( function() {

	function _h( f, c ) {
		return function() {
			var res = f.apply( this, arguments );
			c.apply( this, arguments );
			return res;
		}
	}

	function processErrors( errors, source ) {

		var css = '#shaderReport{ box-sizing: border-box; position: absolute; left: 0; top: 0; \
			right: 0; font-family: monaco, monospace; font-size: 12px; z-index: 1000; \
			background-color: #b70000; color: #ffffff; white-space: normal; \
			text-shadow: 0 -1px 0 rgba(0,0,0,.6); line-height: 1.2em; list-style-type: none; \
			padding: 0; margin: 0; max-height: 300px; overflow: auto; } \
			#shaderReport li{ padding: 10px; border-top: 1px solid rgba( 255, 255, 255, .2 ); \
			border-bottom: 1px solid rgba( 0, 0, 0, .2 ) } \
			#shaderReport li p{ padding: 0; margin: 0 } \
			#shaderReport li:nth-child(odd){ background-color: #c9542b }\
			#shaderReport li p:first-child{ color: #eee }';

		var el = document.createElement( 'style' );
		document.getElementsByTagName( 'head' )[ 0 ].appendChild( el );
		el.textContent = css;

		var report = document.createElement( 'ul' );
		report.setAttribute( 'id', 'shaderReport' );
		document.body.appendChild( report );

		var re = /ERROR: [\d]+:([\d]+): (.+)/gmi; 
		var lines = source.split( '\n' );

		var m;
		while ((m = re.exec( errors )) != null) {
			if (m.index === re.lastIndex) {
				re.lastIndex++;
			}
			var li = document.createElement( 'li' );
			var code = '<p>ERROR "<b>' + m[ 2 ] + '</b>" in line ' + m[ 1 ] + '</p>'
			code += '<p>' + lines[ m[ 1 ] - 1 ].replace( /^[ \t]+/g, '' ) + '</p>';
			li.innerHTML = code;
			report.appendChild( li );
		}
	    
	}

	WebGLRenderingContext.prototype.compileShader = _h( 
		WebGLRenderingContext.prototype.compileShader, 
		function( shader ) {

			if ( !this.getShaderParameter( shader, this.COMPILE_STATUS ) ) {

				var errors = this.getShaderInfoLog( shader );
				var source = this.getShaderSource( shader );

				processErrors( errors, source );

			}
		} 
	);

} )();
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.THREE = global.THREE || {})));
}(this, (function (exports) { 'use strict';

    // Polyfills

    if ( Number.EPSILON === undefined ) {

    	Number.EPSILON = Math.pow( 2, - 52 );

    }

    //

    if ( Math.sign === undefined ) {

    	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

    	Math.sign = function ( x ) {

    		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

    	};

    }

    if ( Function.prototype.name === undefined ) {

    	// Missing in IE9-11.
    	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

    	Object.defineProperty( Function.prototype, 'name', {

    		get: function () {

    			return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

    		}

    	} );

    }

    if ( Object.assign === undefined ) {

    	// Missing in IE.
    	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

    	( function () {

    		Object.assign = function ( target ) {

    			'use strict';

    			if ( target === undefined || target === null ) {

    				throw new TypeError( 'Cannot convert undefined or null to object' );

    			}

    			var output = Object( target );

    			for ( var index = 1; index < arguments.length; index ++ ) {

    				var source = arguments[ index ];

    				if ( source !== undefined && source !== null ) {

    					for ( var nextKey in source ) {

    						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

    							output[ nextKey ] = source[ nextKey ];

    						}

    					}

    				}

    			}

    			return output;

    		};

    	} )();

    }

    /**
     * https://github.com/mrdoob/eventdispatcher.js/
     */

    function EventDispatcher() {}

    Object.assign( EventDispatcher.prototype, {

    	addEventListener: function ( type, listener ) {

    		if ( this._listeners === undefined ) this._listeners = {};

    		var listeners = this._listeners;

    		if ( listeners[ type ] === undefined ) {

    			listeners[ type ] = [];

    		}

    		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

    			listeners[ type ].push( listener );

    		}

    	},

    	hasEventListener: function ( type, listener ) {

    		if ( this._listeners === undefined ) return false;

    		var listeners = this._listeners;

    		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

    			return true;

    		}

    		return false;

    	},

    	removeEventListener: function ( type, listener ) {

    		if ( this._listeners === undefined ) return;

    		var listeners = this._listeners;
    		var listenerArray = listeners[ type ];

    		if ( listenerArray !== undefined ) {

    			var index = listenerArray.indexOf( listener );

    			if ( index !== - 1 ) {

    				listenerArray.splice( index, 1 );

    			}

    		}

    	},

    	dispatchEvent: function ( event ) {

    		if ( this._listeners === undefined ) return;

    		var listeners = this._listeners;
    		var listenerArray = listeners[ event.type ];

    		if ( listenerArray !== undefined ) {

    			event.target = this;

    			var array = [], i = 0;
    			var length = listenerArray.length;

    			for ( i = 0; i < length; i ++ ) {

    				array[ i ] = listenerArray[ i ];

    			}

    			for ( i = 0; i < length; i ++ ) {

    				array[ i ].call( this, event );

    			}

    		}

    	}

    } );

    var REVISION = '81';
    var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
    var CullFaceNone = 0;
    var CullFaceBack = 1;
    var CullFaceFront = 2;
    var CullFaceFrontBack = 3;
    var FrontFaceDirectionCW = 0;
    var FrontFaceDirectionCCW = 1;
    var BasicShadowMap = 0;
    var PCFShadowMap = 1;
    var PCFSoftShadowMap = 2;
    var FrontSide = 0;
    var BackSide = 1;
    var DoubleSide = 2;
    var FlatShading = 1;
    var SmoothShading = 2;
    var NoColors = 0;
    var FaceColors = 1;
    var VertexColors = 2;
    var NoBlending = 0;
    var NormalBlending = 1;
    var AdditiveBlending = 2;
    var SubtractiveBlending = 3;
    var MultiplyBlending = 4;
    var CustomBlending = 5;
    var BlendingMode = {
        NoBlending: NoBlending,
        NormalBlending: NormalBlending,
        AdditiveBlending: AdditiveBlending,
        SubtractiveBlending: SubtractiveBlending,
        MultiplyBlending: MultiplyBlending,
        CustomBlending: CustomBlending
    };
    var AddEquation = 100;
    var SubtractEquation = 101;
    var ReverseSubtractEquation = 102;
    var MinEquation = 103;
    var MaxEquation = 104;
    var ZeroFactor = 200;
    var OneFactor = 201;
    var SrcColorFactor = 202;
    var OneMinusSrcColorFactor = 203;
    var SrcAlphaFactor = 204;
    var OneMinusSrcAlphaFactor = 205;
    var DstAlphaFactor = 206;
    var OneMinusDstAlphaFactor = 207;
    var DstColorFactor = 208;
    var OneMinusDstColorFactor = 209;
    var SrcAlphaSaturateFactor = 210;
    var NeverDepth = 0;
    var AlwaysDepth = 1;
    var LessDepth = 2;
    var LessEqualDepth = 3;
    var EqualDepth = 4;
    var GreaterEqualDepth = 5;
    var GreaterDepth = 6;
    var NotEqualDepth = 7;
    var MultiplyOperation = 0;
    var MixOperation = 1;
    var AddOperation = 2;
    var NoToneMapping = 0;
    var LinearToneMapping = 1;
    var ReinhardToneMapping = 2;
    var Uncharted2ToneMapping = 3;
    var CineonToneMapping = 4;
    var UVMapping = 300;
    var CubeReflectionMapping = 301;
    var CubeRefractionMapping = 302;
    var EquirectangularReflectionMapping = 303;
    var EquirectangularRefractionMapping = 304;
    var SphericalReflectionMapping = 305;
    var CubeUVReflectionMapping = 306;
    var CubeUVRefractionMapping = 307;
    var TextureMapping = {
        UVMapping: UVMapping,
        CubeReflectionMapping: CubeReflectionMapping,
        CubeRefractionMapping: CubeRefractionMapping,
        EquirectangularReflectionMapping: EquirectangularReflectionMapping,
        EquirectangularRefractionMapping: EquirectangularRefractionMapping,
        SphericalReflectionMapping: SphericalReflectionMapping,
        CubeUVReflectionMapping: CubeUVReflectionMapping,
        CubeUVRefractionMapping: CubeUVRefractionMapping
    };
    var RepeatWrapping = 1000;
    var ClampToEdgeWrapping = 1001;
    var MirroredRepeatWrapping = 1002;
    var TextureWrapping = {
        RepeatWrapping: RepeatWrapping,
        ClampToEdgeWrapping: ClampToEdgeWrapping,
        MirroredRepeatWrapping: MirroredRepeatWrapping
    };
    var NearestFilter = 1003;
    var NearestMipMapNearestFilter = 1004;
    var NearestMipMapLinearFilter = 1005;
    var LinearFilter = 1006;
    var LinearMipMapNearestFilter = 1007;
    var LinearMipMapLinearFilter = 1008;
    var TextureFilter = {
        NearestFilter: NearestFilter,
        NearestMipMapNearestFilter: NearestMipMapNearestFilter,
        NearestMipMapLinearFilter: NearestMipMapLinearFilter,
        LinearFilter: LinearFilter,
        LinearMipMapNearestFilter: LinearMipMapNearestFilter,
        LinearMipMapLinearFilter: LinearMipMapLinearFilter
    };
    var UnsignedByteType = 1009;
    var ByteType = 1010;
    var ShortType = 1011;
    var UnsignedShortType = 1012;
    var IntType = 1013;
    var UnsignedIntType = 1014;
    var FloatType = 1015;
    var HalfFloatType = 1016;
    var UnsignedShort4444Type = 1017;
    var UnsignedShort5551Type = 1018;
    var UnsignedShort565Type = 1019;
    var UnsignedInt248Type = 1020;
    var AlphaFormat = 1021;
    var RGBFormat = 1022;
    var RGBAFormat = 1023;
    var LuminanceFormat = 1024;
    var LuminanceAlphaFormat = 1025;
    var RGBEFormat = RGBAFormat;
    var DepthFormat = 1026;
    var DepthStencilFormat = 1027;
    var RGB_S3TC_DXT1_Format = 2001;
    var RGBA_S3TC_DXT1_Format = 2002;
    var RGBA_S3TC_DXT3_Format = 2003;
    var RGBA_S3TC_DXT5_Format = 2004;
    var RGB_PVRTC_4BPPV1_Format = 2100;
    var RGB_PVRTC_2BPPV1_Format = 2101;
    var RGBA_PVRTC_4BPPV1_Format = 2102;
    var RGBA_PVRTC_2BPPV1_Format = 2103;
    var RGB_ETC1_Format = 2151;
    var LoopOnce = 2200;
    var LoopRepeat = 2201;
    var LoopPingPong = 2202;
    var InterpolateDiscrete = 2300;
    var InterpolateLinear = 2301;
    var InterpolateSmooth = 2302;
    var ZeroCurvatureEnding = 2400;
    var ZeroSlopeEnding = 2401;
    var WrapAroundEnding = 2402;
    var TrianglesDrawMode = 0;
    var TriangleStripDrawMode = 1;
    var TriangleFanDrawMode = 2;
    var LinearEncoding = 3000;
    var sRGBEncoding = 3001;
    var GammaEncoding = 3007;
    var RGBEEncoding = 3002;
    var LogLuvEncoding = 3003;
    var RGBM7Encoding = 3004;
    var RGBM16Encoding = 3005;
    var RGBDEncoding = 3006;
    var BasicDepthPacking = 3200;
    var RGBADepthPacking = 3201;

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    exports.Math = {

    	DEG2RAD: Math.PI / 180,
    	RAD2DEG: 180 / Math.PI,

    	generateUUID: function () {

    		// http://www.broofa.com/Tools/Math.uuid.htm

    		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
    		var uuid = new Array( 36 );
    		var rnd = 0, r;

    		return function generateUUID() {

    			for ( var i = 0; i < 36; i ++ ) {

    				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

    					uuid[ i ] = '-';

    				} else if ( i === 14 ) {

    					uuid[ i ] = '4';

    				} else {

    					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
    					r = rnd & 0xf;
    					rnd = rnd >> 4;
    					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

    				}

    			}

    			return uuid.join( '' );

    		};

    	}(),

    	clamp: function ( value, min, max ) {

    		return Math.max( min, Math.min( max, value ) );

    	},

    	// compute euclidian modulo of m % n
    	// https://en.wikipedia.org/wiki/Modulo_operation

    	euclideanModulo: function ( n, m ) {

    		return ( ( n % m ) + m ) % m;

    	},

    	// Linear mapping from range <a1, a2> to range <b1, b2>

    	mapLinear: function ( x, a1, a2, b1, b2 ) {

    		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

    	},

    	// http://en.wikipedia.org/wiki/Smoothstep

    	smoothstep: function ( x, min, max ) {

    		if ( x <= min ) return 0;
    		if ( x >= max ) return 1;

    		x = ( x - min ) / ( max - min );

    		return x * x * ( 3 - 2 * x );

    	},

    	smootherstep: function ( x, min, max ) {

    		if ( x <= min ) return 0;
    		if ( x >= max ) return 1;

    		x = ( x - min ) / ( max - min );

    		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

    	},

    	random16: function () {

    		console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
    		return Math.random();

    	},

    	// Random integer from <low, high> interval

    	randInt: function ( low, high ) {

    		return low + Math.floor( Math.random() * ( high - low + 1 ) );

    	},

    	// Random float from <low, high> interval

    	randFloat: function ( low, high ) {

    		return low + Math.random() * ( high - low );

    	},

    	// Random float from <-range/2, range/2> interval

    	randFloatSpread: function ( range ) {

    		return range * ( 0.5 - Math.random() );

    	},

    	degToRad: function ( degrees ) {

    		return degrees * exports.Math.DEG2RAD;

    	},

    	radToDeg: function ( radians ) {

    		return radians * exports.Math.RAD2DEG;

    	},

    	isPowerOfTwo: function ( value ) {

    		return ( value & ( value - 1 ) ) === 0 && value !== 0;

    	},

    	nearestPowerOfTwo: function ( value ) {

    		return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

    	},

    	nextPowerOfTwo: function ( value ) {

    		value --;
    		value |= value >> 1;
    		value |= value >> 2;
    		value |= value >> 4;
    		value |= value >> 8;
    		value |= value >> 16;
    		value ++;

    		return value;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author philogb / http://blog.thejit.org/
     * @author egraether / http://egraether.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */

    function Vector2( x, y ) {

    	this.x = x || 0;
    	this.y = y || 0;

    }

    Vector2.prototype = {

    	constructor: Vector2,

    	isVector2: true,

    	get width() {

    		return this.x;

    	},

    	set width( value ) {

    		this.x = value;

    	},

    	get height() {

    		return this.y;

    	},

    	set height( value ) {

    		this.y = value;

    	},

    	//

    	set: function ( x, y ) {

    		this.x = x;
    		this.y = y;

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.x = scalar;
    		this.y = scalar;

    		return this;

    	},

    	setX: function ( x ) {

    		this.x = x;

    		return this;

    	},

    	setY: function ( y ) {

    		this.y = y;

    		return this;

    	},

    	setComponent: function ( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	getComponent: function ( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	clone: function () {

    		return new this.constructor( this.x, this.y );

    	},

    	copy: function ( v ) {

    		this.x = v.x;
    		this.y = v.y;

    		return this;

    	},

    	add: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
    			return this.addVectors( v, w );

    		}

    		this.x += v.x;
    		this.y += v.y;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.x += s;
    		this.y += s;

    		return this;

    	},

    	addVectors: function ( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;

    		return this;

    	},

    	addScaledVector: function ( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;

    		return this;

    	},

    	sub: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
    			return this.subVectors( v, w );

    		}

    		this.x -= v.x;
    		this.y -= v.y;

    		return this;

    	},

    	subScalar: function ( s ) {

    		this.x -= s;
    		this.y -= s;

    		return this;

    	},

    	subVectors: function ( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;

    		return this;

    	},

    	multiply: function ( v ) {

    		this.x *= v.x;
    		this.y *= v.y;

    		return this;

    	},

    	multiplyScalar: function ( scalar ) {

    		if ( isFinite( scalar ) ) {

    			this.x *= scalar;
    			this.y *= scalar;

    		} else {

    			this.x = 0;
    			this.y = 0;

    		}

    		return this;

    	},

    	divide: function ( v ) {

    		this.x /= v.x;
    		this.y /= v.y;

    		return this;

    	},

    	divideScalar: function ( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	},

    	min: function ( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );

    		return this;

    	},

    	max: function ( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );

    		return this;

    	},

    	clamp: function ( min, max ) {

    		// This function assumes min < max, if this assumption isn't true it will not operate correctly

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

    		return this;

    	},

    	clampScalar: function () {

    		var min, max;

    		return function clampScalar( minVal, maxVal ) {

    			if ( min === undefined ) {

    				min = new Vector2();
    				max = new Vector2();

    			}

    			min.set( minVal, minVal );
    			max.set( maxVal, maxVal );

    			return this.clamp( min, max );

    		};

    	}(),

    	clampLength: function ( min, max ) {

    		var length = this.length();

    		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

    	},

    	floor: function () {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );

    		return this;

    	},

    	ceil: function () {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );

    		return this;

    	},

    	round: function () {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );

    		return this;

    	},

    	roundToZero: function () {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

    		return this;

    	},

    	negate: function () {

    		this.x = - this.x;
    		this.y = - this.y;

    		return this;

    	},

    	dot: function ( v ) {

    		return this.x * v.x + this.y * v.y;

    	},

    	lengthSq: function () {

    		return this.x * this.x + this.y * this.y;

    	},

    	length: function () {

    		return Math.sqrt( this.x * this.x + this.y * this.y );

    	},

    	lengthManhattan: function() {

    		return Math.abs( this.x ) + Math.abs( this.y );

    	},

    	normalize: function () {

    		return this.divideScalar( this.length() );

    	},

    	angle: function () {

    		// computes the angle in radians with respect to the positive x-axis

    		var angle = Math.atan2( this.y, this.x );

    		if ( angle < 0 ) angle += 2 * Math.PI;

    		return angle;

    	},

    	distanceTo: function ( v ) {

    		return Math.sqrt( this.distanceToSquared( v ) );

    	},

    	distanceToSquared: function ( v ) {

    		var dx = this.x - v.x, dy = this.y - v.y;
    		return dx * dx + dy * dy;

    	},

    	distanceToManhattan: function ( v ) {

    		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

    	},

    	setLength: function ( length ) {

    		return this.multiplyScalar( length / this.length() );

    	},

    	lerp: function ( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;

    		return this;

    	},

    	lerpVectors: function ( v1, v2, alpha ) {

    		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    	},

    	equals: function ( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;

    		return array;

    	},

    	fromAttribute: function ( attribute, index, offset ) {

    		if ( offset === undefined ) offset = 0;

    		index = index * attribute.itemSize + offset;

    		this.x = attribute.array[ index ];
    		this.y = attribute.array[ index + 1 ];

    		return this;

    	},

    	rotateAround: function ( center, angle ) {

    		var c = Math.cos( angle ), s = Math.sin( angle );

    		var x = this.x - center.x;
    		var y = this.y - center.y;

    		this.x = x * c - y * s + center.x;
    		this.y = x * s + y * c + center.y;

    		return this;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     */

    function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

    	Object.defineProperty( this, 'id', { value: TextureIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.sourceFile = '';

    	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
    	this.mipmaps = [];

    	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

    	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
    	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

    	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    	this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

    	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

    	this.format = format !== undefined ? format : RGBAFormat;
    	this.type = type !== undefined ? type : UnsignedByteType;

    	this.offset = new Vector2( 0, 0 );
    	this.repeat = new Vector2( 1, 1 );

    	this.generateMipmaps = true;
    	this.premultiplyAlpha = false;
    	this.flipY = true;
    	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)


    	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
    	//
    	// Also changing the encoding after already used by a Material will not automatically make the Material
    	// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
    	this.encoding = encoding !== undefined ? encoding :  LinearEncoding;

    	this.version = 0;
    	this.onUpdate = null;

    }

    Texture.DEFAULT_IMAGE = undefined;
    Texture.DEFAULT_MAPPING = UVMapping;

    Texture.prototype = {

    	constructor: Texture,

    	isTexture: true,

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.image = source.image;
    		this.mipmaps = source.mipmaps.slice( 0 );

    		this.mapping = source.mapping;

    		this.wrapS = source.wrapS;
    		this.wrapT = source.wrapT;

    		this.magFilter = source.magFilter;
    		this.minFilter = source.minFilter;

    		this.anisotropy = source.anisotropy;

    		this.format = source.format;
    		this.type = source.type;

    		this.offset.copy( source.offset );
    		this.repeat.copy( source.repeat );

    		this.generateMipmaps = source.generateMipmaps;
    		this.premultiplyAlpha = source.premultiplyAlpha;
    		this.flipY = source.flipY;
    		this.unpackAlignment = source.unpackAlignment;
    		this.encoding = source.encoding;

    		return this;

    	},

    	toJSON: function ( meta ) {

    		if ( meta.textures[ this.uuid ] !== undefined ) {

    			return meta.textures[ this.uuid ];

    		}

    		function getDataURL( image ) {

    			var canvas;

    			if ( image.toDataURL !== undefined ) {

    				canvas = image;

    			} else {

    				canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    				canvas.width = image.width;
    				canvas.height = image.height;

    				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

    			}

    			if ( canvas.width > 2048 || canvas.height > 2048 ) {

    				return canvas.toDataURL( 'image/jpeg', 0.6 );

    			} else {

    				return canvas.toDataURL( 'image/png' );

    			}

    		}

    		var output = {
    			metadata: {
    				version: 4.4,
    				type: 'Texture',
    				generator: 'Texture.toJSON'
    			},

    			uuid: this.uuid,
    			name: this.name,

    			mapping: this.mapping,

    			repeat: [ this.repeat.x, this.repeat.y ],
    			offset: [ this.offset.x, this.offset.y ],
    			wrap: [ this.wrapS, this.wrapT ],

    			minFilter: this.minFilter,
    			magFilter: this.magFilter,
    			anisotropy: this.anisotropy,

    			flipY: this.flipY
    		};

    		if ( this.image !== undefined ) {

    			// TODO: Move to THREE.Image

    			var image = this.image;

    			if ( image.uuid === undefined ) {

    				image.uuid = exports.Math.generateUUID(); // UGH

    			}

    			if ( meta.images[ image.uuid ] === undefined ) {

    				meta.images[ image.uuid ] = {
    					uuid: image.uuid,
    					url: getDataURL( image )
    				};

    			}

    			output.image = image.uuid;

    		}

    		meta.textures[ this.uuid ] = output;

    		return output;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	},

    	transformUv: function ( uv ) {

    		if ( this.mapping !== UVMapping )  return;

    		uv.multiply( this.repeat );
    		uv.add( this.offset );

    		if ( uv.x < 0 || uv.x > 1 ) {

    			switch ( this.wrapS ) {

    				case RepeatWrapping:

    					uv.x = uv.x - Math.floor( uv.x );
    					break;

    				case ClampToEdgeWrapping:

    					uv.x = uv.x < 0 ? 0 : 1;
    					break;

    				case MirroredRepeatWrapping:

    					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

    						uv.x = Math.ceil( uv.x ) - uv.x;

    					} else {

    						uv.x = uv.x - Math.floor( uv.x );

    					}
    					break;

    			}

    		}

    		if ( uv.y < 0 || uv.y > 1 ) {

    			switch ( this.wrapT ) {

    				case RepeatWrapping:

    					uv.y = uv.y - Math.floor( uv.y );
    					break;

    				case ClampToEdgeWrapping:

    					uv.y = uv.y < 0 ? 0 : 1;
    					break;

    				case MirroredRepeatWrapping:

    					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

    						uv.y = Math.ceil( uv.y ) - uv.y;

    					} else {

    						uv.y = uv.y - Math.floor( uv.y );

    					}
    					break;

    			}

    		}

    		if ( this.flipY ) {

    			uv.y = 1 - uv.y;

    		}

    	}

    };

    Object.assign( Texture.prototype, EventDispatcher.prototype );

    var count = 0;
    function TextureIdCount() { return count++; };

    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function Vector4( x, y, z, w ) {

    	this.x = x || 0;
    	this.y = y || 0;
    	this.z = z || 0;
    	this.w = ( w !== undefined ) ? w : 1;

    }

    Vector4.prototype = {

    	constructor: Vector4,

    	isVector4: true,

    	set: function ( x, y, z, w ) {

    		this.x = x;
    		this.y = y;
    		this.z = z;
    		this.w = w;

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.x = scalar;
    		this.y = scalar;
    		this.z = scalar;
    		this.w = scalar;

    		return this;

    	},

    	setX: function ( x ) {

    		this.x = x;

    		return this;

    	},

    	setY: function ( y ) {

    		this.y = y;

    		return this;

    	},

    	setZ: function ( z ) {

    		this.z = z;

    		return this;

    	},

    	setW: function ( w ) {

    		this.w = w;

    		return this;

    	},

    	setComponent: function ( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			case 2: this.z = value; break;
    			case 3: this.w = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	getComponent: function ( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			case 2: return this.z;
    			case 3: return this.w;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	clone: function () {

    		return new this.constructor( this.x, this.y, this.z, this.w );

    	},

    	copy: function ( v ) {

    		this.x = v.x;
    		this.y = v.y;
    		this.z = v.z;
    		this.w = ( v.w !== undefined ) ? v.w : 1;

    		return this;

    	},

    	add: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
    			return this.addVectors( v, w );

    		}

    		this.x += v.x;
    		this.y += v.y;
    		this.z += v.z;
    		this.w += v.w;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.x += s;
    		this.y += s;
    		this.z += s;
    		this.w += s;

    		return this;

    	},

    	addVectors: function ( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;
    		this.z = a.z + b.z;
    		this.w = a.w + b.w;

    		return this;

    	},

    	addScaledVector: function ( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;
    		this.z += v.z * s;
    		this.w += v.w * s;

    		return this;

    	},

    	sub: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
    			return this.subVectors( v, w );

    		}

    		this.x -= v.x;
    		this.y -= v.y;
    		this.z -= v.z;
    		this.w -= v.w;

    		return this;

    	},

    	subScalar: function ( s ) {

    		this.x -= s;
    		this.y -= s;
    		this.z -= s;
    		this.w -= s;

    		return this;

    	},

    	subVectors: function ( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;
    		this.z = a.z - b.z;
    		this.w = a.w - b.w;

    		return this;

    	},

    	multiplyScalar: function ( scalar ) {

    		if ( isFinite( scalar ) ) {

    			this.x *= scalar;
    			this.y *= scalar;
    			this.z *= scalar;
    			this.w *= scalar;

    		} else {

    			this.x = 0;
    			this.y = 0;
    			this.z = 0;
    			this.w = 0;

    		}

    		return this;

    	},

    	applyMatrix4: function ( m ) {

    		var x = this.x, y = this.y, z = this.z, w = this.w;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
    		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
    		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
    		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

    		return this;

    	},

    	divideScalar: function ( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	},

    	setAxisAngleFromQuaternion: function ( q ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

    		// q is assumed to be normalized

    		this.w = 2 * Math.acos( q.w );

    		var s = Math.sqrt( 1 - q.w * q.w );

    		if ( s < 0.0001 ) {

    			 this.x = 1;
    			 this.y = 0;
    			 this.z = 0;

    		} else {

    			 this.x = q.x / s;
    			 this.y = q.y / s;
    			 this.z = q.z / s;

    		}

    		return this;

    	},

    	setAxisAngleFromRotationMatrix: function ( m ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		var angle, x, y, z,		// variables for result
    			epsilon = 0.01,		// margin to allow for rounding errors
    			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

    			te = m.elements,

    			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
    			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
    			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
    		     ( Math.abs( m13 - m31 ) < epsilon ) &&
    		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

    			// singularity found
    			// first check for identity matrix which must have +1 for all terms
    			// in leading diagonal and zero in other terms

    			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
    			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
    			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
    			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

    				// this singularity is identity matrix so angle = 0

    				this.set( 1, 0, 0, 0 );

    				return this; // zero angle, arbitrary axis

    			}

    			// otherwise this singularity is angle = 180

    			angle = Math.PI;

    			var xx = ( m11 + 1 ) / 2;
    			var yy = ( m22 + 1 ) / 2;
    			var zz = ( m33 + 1 ) / 2;
    			var xy = ( m12 + m21 ) / 4;
    			var xz = ( m13 + m31 ) / 4;
    			var yz = ( m23 + m32 ) / 4;

    			if ( ( xx > yy ) && ( xx > zz ) ) {

    				// m11 is the largest diagonal term

    				if ( xx < epsilon ) {

    					x = 0;
    					y = 0.707106781;
    					z = 0.707106781;

    				} else {

    					x = Math.sqrt( xx );
    					y = xy / x;
    					z = xz / x;

    				}

    			} else if ( yy > zz ) {

    				// m22 is the largest diagonal term

    				if ( yy < epsilon ) {

    					x = 0.707106781;
    					y = 0;
    					z = 0.707106781;

    				} else {

    					y = Math.sqrt( yy );
    					x = xy / y;
    					z = yz / y;

    				}

    			} else {

    				// m33 is the largest diagonal term so base result on this

    				if ( zz < epsilon ) {

    					x = 0.707106781;
    					y = 0.707106781;
    					z = 0;

    				} else {

    					z = Math.sqrt( zz );
    					x = xz / z;
    					y = yz / z;

    				}

    			}

    			this.set( x, y, z, angle );

    			return this; // return 180 deg rotation

    		}

    		// as we have reached here there are no singularities so we can handle normally

    		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
    		                   ( m13 - m31 ) * ( m13 - m31 ) +
    		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

    		if ( Math.abs( s ) < 0.001 ) s = 1;

    		// prevent divide by zero, should not happen if matrix is orthogonal and should be
    		// caught by singularity test above, but I've left it in just in case

    		this.x = ( m32 - m23 ) / s;
    		this.y = ( m13 - m31 ) / s;
    		this.z = ( m21 - m12 ) / s;
    		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

    		return this;

    	},

    	min: function ( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );
    		this.z = Math.min( this.z, v.z );
    		this.w = Math.min( this.w, v.w );

    		return this;

    	},

    	max: function ( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );
    		this.z = Math.max( this.z, v.z );
    		this.w = Math.max( this.w, v.w );

    		return this;

    	},

    	clamp: function ( min, max ) {

    		// This function assumes min < max, if this assumption isn't true it will not operate correctly

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
    		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
    		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

    		return this;

    	},

    	clampScalar: function () {

    		var min, max;

    		return function clampScalar( minVal, maxVal ) {

    			if ( min === undefined ) {

    				min = new Vector4();
    				max = new Vector4();

    			}

    			min.set( minVal, minVal, minVal, minVal );
    			max.set( maxVal, maxVal, maxVal, maxVal );

    			return this.clamp( min, max );

    		};

    	}(),

    	floor: function () {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );
    		this.z = Math.floor( this.z );
    		this.w = Math.floor( this.w );

    		return this;

    	},

    	ceil: function () {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );
    		this.z = Math.ceil( this.z );
    		this.w = Math.ceil( this.w );

    		return this;

    	},

    	round: function () {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );
    		this.z = Math.round( this.z );
    		this.w = Math.round( this.w );

    		return this;

    	},

    	roundToZero: function () {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
    		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

    		return this;

    	},

    	negate: function () {

    		this.x = - this.x;
    		this.y = - this.y;
    		this.z = - this.z;
    		this.w = - this.w;

    		return this;

    	},

    	dot: function ( v ) {

    		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

    	},

    	lengthSq: function () {

    		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

    	},

    	length: function () {

    		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

    	},

    	lengthManhattan: function () {

    		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

    	},

    	normalize: function () {

    		return this.divideScalar( this.length() );

    	},

    	setLength: function ( length ) {

    		return this.multiplyScalar( length / this.length() );

    	},

    	lerp: function ( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;
    		this.z += ( v.z - this.z ) * alpha;
    		this.w += ( v.w - this.w ) * alpha;

    		return this;

    	},

    	lerpVectors: function ( v1, v2, alpha ) {

    		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    	},

    	equals: function ( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];
    		this.z = array[ offset + 2 ];
    		this.w = array[ offset + 3 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;
    		array[ offset + 2 ] = this.z;
    		array[ offset + 3 ] = this.w;

    		return array;

    	},

    	fromAttribute: function ( attribute, index, offset ) {

    		if ( offset === undefined ) offset = 0;

    		index = index * attribute.itemSize + offset;

    		this.x = attribute.array[ index ];
    		this.y = attribute.array[ index + 1 ];
    		this.z = attribute.array[ index + 2 ];
    		this.w = attribute.array[ index + 3 ];

    		return this;

    	}

    };

    /**
     * @author szimek / https://github.com/szimek/
     * @author alteredq / http://alteredqualia.com/
     * @author Marius Kintel / https://github.com/kintel
     */

    /*
     In options, we can specify:
     * Texture parameters for an auto-generated target texture
     * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
    */
    function WebGLRenderTarget( width, height, options ) {

    	this.uuid = exports.Math.generateUUID();

    	this.width = width;
    	this.height = height;

    	this.scissor = new Vector4( 0, 0, width, height );
    	this.scissorTest = false;

    	this.viewport = new Vector4( 0, 0, width, height );

    	options = options || {};

    	if ( options.minFilter === undefined ) options.minFilter = LinearFilter;

    	this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

    	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
    	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

    }

    Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {

    	isWebGLRenderTarget: true,

    	setSize: function ( width, height ) {

    		if ( this.width !== width || this.height !== height ) {

    			this.width = width;
    			this.height = height;

    			this.dispose();

    		}

    		this.viewport.set( 0, 0, width, height );
    		this.scissor.set( 0, 0, width, height );

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.width = source.width;
    		this.height = source.height;

    		this.viewport.copy( source.viewport );

    		this.texture = source.texture.clone();

    		this.depthBuffer = source.depthBuffer;
    		this.stencilBuffer = source.stencilBuffer;
    		this.depthTexture = source.depthTexture;

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com
     */

    function WebGLRenderTargetCube( width, height, options ) {

    	WebGLRenderTarget.call( this, width, height, options );

    	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
    	this.activeMipMapLevel = 0;

    }

    WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
    WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

    WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */

    function Quaternion( x, y, z, w ) {

    	this._x = x || 0;
    	this._y = y || 0;
    	this._z = z || 0;
    	this._w = ( w !== undefined ) ? w : 1;

    }

    Quaternion.prototype = {

    	constructor: Quaternion,

    	get x () {

    		return this._x;

    	},

    	set x ( value ) {

    		this._x = value;
    		this.onChangeCallback();

    	},

    	get y () {

    		return this._y;

    	},

    	set y ( value ) {

    		this._y = value;
    		this.onChangeCallback();

    	},

    	get z () {

    		return this._z;

    	},

    	set z ( value ) {

    		this._z = value;
    		this.onChangeCallback();

    	},

    	get w () {

    		return this._w;

    	},

    	set w ( value ) {

    		this._w = value;
    		this.onChangeCallback();

    	},

    	set: function ( x, y, z, w ) {

    		this._x = x;
    		this._y = y;
    		this._z = z;
    		this._w = w;

    		this.onChangeCallback();

    		return this;

    	},

    	clone: function () {

    		return new this.constructor( this._x, this._y, this._z, this._w );

    	},

    	copy: function ( quaternion ) {

    		this._x = quaternion.x;
    		this._y = quaternion.y;
    		this._z = quaternion.z;
    		this._w = quaternion.w;

    		this.onChangeCallback();

    		return this;

    	},

    	setFromEuler: function ( euler, update ) {

    		if ( (euler && euler.isEuler) === false ) {

    			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    		}

    		// http://www.mathworks.com/matlabcentral/fileexchange/
    		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    		//	content/SpinCalc.m

    		var c1 = Math.cos( euler._x / 2 );
    		var c2 = Math.cos( euler._y / 2 );
    		var c3 = Math.cos( euler._z / 2 );
    		var s1 = Math.sin( euler._x / 2 );
    		var s2 = Math.sin( euler._y / 2 );
    		var s3 = Math.sin( euler._z / 2 );

    		var order = euler.order;

    		if ( order === 'XYZ' ) {

    			this._x = s1 * c2 * c3 + c1 * s2 * s3;
    			this._y = c1 * s2 * c3 - s1 * c2 * s3;
    			this._z = c1 * c2 * s3 + s1 * s2 * c3;
    			this._w = c1 * c2 * c3 - s1 * s2 * s3;

    		} else if ( order === 'YXZ' ) {

    			this._x = s1 * c2 * c3 + c1 * s2 * s3;
    			this._y = c1 * s2 * c3 - s1 * c2 * s3;
    			this._z = c1 * c2 * s3 - s1 * s2 * c3;
    			this._w = c1 * c2 * c3 + s1 * s2 * s3;

    		} else if ( order === 'ZXY' ) {

    			this._x = s1 * c2 * c3 - c1 * s2 * s3;
    			this._y = c1 * s2 * c3 + s1 * c2 * s3;
    			this._z = c1 * c2 * s3 + s1 * s2 * c3;
    			this._w = c1 * c2 * c3 - s1 * s2 * s3;

    		} else if ( order === 'ZYX' ) {

    			this._x = s1 * c2 * c3 - c1 * s2 * s3;
    			this._y = c1 * s2 * c3 + s1 * c2 * s3;
    			this._z = c1 * c2 * s3 - s1 * s2 * c3;
    			this._w = c1 * c2 * c3 + s1 * s2 * s3;

    		} else if ( order === 'YZX' ) {

    			this._x = s1 * c2 * c3 + c1 * s2 * s3;
    			this._y = c1 * s2 * c3 + s1 * c2 * s3;
    			this._z = c1 * c2 * s3 - s1 * s2 * c3;
    			this._w = c1 * c2 * c3 - s1 * s2 * s3;

    		} else if ( order === 'XZY' ) {

    			this._x = s1 * c2 * c3 - c1 * s2 * s3;
    			this._y = c1 * s2 * c3 - s1 * c2 * s3;
    			this._z = c1 * c2 * s3 + s1 * s2 * c3;
    			this._w = c1 * c2 * c3 + s1 * s2 * s3;

    		}

    		if ( update !== false ) this.onChangeCallback();

    		return this;

    	},

    	setFromAxisAngle: function ( axis, angle ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

    		// assumes axis is normalized

    		var halfAngle = angle / 2, s = Math.sin( halfAngle );

    		this._x = axis.x * s;
    		this._y = axis.y * s;
    		this._z = axis.z * s;
    		this._w = Math.cos( halfAngle );

    		this.onChangeCallback();

    		return this;

    	},

    	setFromRotationMatrix: function ( m ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		var te = m.elements,

    			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
    			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
    			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

    			trace = m11 + m22 + m33,
    			s;

    		if ( trace > 0 ) {

    			s = 0.5 / Math.sqrt( trace + 1.0 );

    			this._w = 0.25 / s;
    			this._x = ( m32 - m23 ) * s;
    			this._y = ( m13 - m31 ) * s;
    			this._z = ( m21 - m12 ) * s;

    		} else if ( m11 > m22 && m11 > m33 ) {

    			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

    			this._w = ( m32 - m23 ) / s;
    			this._x = 0.25 * s;
    			this._y = ( m12 + m21 ) / s;
    			this._z = ( m13 + m31 ) / s;

    		} else if ( m22 > m33 ) {

    			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

    			this._w = ( m13 - m31 ) / s;
    			this._x = ( m12 + m21 ) / s;
    			this._y = 0.25 * s;
    			this._z = ( m23 + m32 ) / s;

    		} else {

    			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

    			this._w = ( m21 - m12 ) / s;
    			this._x = ( m13 + m31 ) / s;
    			this._y = ( m23 + m32 ) / s;
    			this._z = 0.25 * s;

    		}

    		this.onChangeCallback();

    		return this;

    	},

    	setFromUnitVectors: function () {

    		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

    		// assumes direction vectors vFrom and vTo are normalized

    		var v1, r;

    		var EPS = 0.000001;

    		return function setFromUnitVectors( vFrom, vTo ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			r = vFrom.dot( vTo ) + 1;

    			if ( r < EPS ) {

    				r = 0;

    				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

    					v1.set( - vFrom.y, vFrom.x, 0 );

    				} else {

    					v1.set( 0, - vFrom.z, vFrom.y );

    				}

    			} else {

    				v1.crossVectors( vFrom, vTo );

    			}

    			this._x = v1.x;
    			this._y = v1.y;
    			this._z = v1.z;
    			this._w = r;

    			return this.normalize();

    		};

    	}(),

    	inverse: function () {

    		return this.conjugate().normalize();

    	},

    	conjugate: function () {

    		this._x *= - 1;
    		this._y *= - 1;
    		this._z *= - 1;

    		this.onChangeCallback();

    		return this;

    	},

    	dot: function ( v ) {

    		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

    	},

    	lengthSq: function () {

    		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

    	},

    	length: function () {

    		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

    	},

    	normalize: function () {

    		var l = this.length();

    		if ( l === 0 ) {

    			this._x = 0;
    			this._y = 0;
    			this._z = 0;
    			this._w = 1;

    		} else {

    			l = 1 / l;

    			this._x = this._x * l;
    			this._y = this._y * l;
    			this._z = this._z * l;
    			this._w = this._w * l;

    		}

    		this.onChangeCallback();

    		return this;

    	},

    	multiply: function ( q, p ) {

    		if ( p !== undefined ) {

    			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
    			return this.multiplyQuaternions( q, p );

    		}

    		return this.multiplyQuaternions( this, q );

    	},

    	premultiply: function ( q ) {

    		return this.multiplyQuaternions( q, this );

    	},

    	multiplyQuaternions: function ( a, b ) {

    		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

    		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    		this.onChangeCallback();

    		return this;

    	},

    	slerp: function ( qb, t ) {

    		if ( t === 0 ) return this;
    		if ( t === 1 ) return this.copy( qb );

    		var x = this._x, y = this._y, z = this._z, w = this._w;

    		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    		if ( cosHalfTheta < 0 ) {

    			this._w = - qb._w;
    			this._x = - qb._x;
    			this._y = - qb._y;
    			this._z = - qb._z;

    			cosHalfTheta = - cosHalfTheta;

    		} else {

    			this.copy( qb );

    		}

    		if ( cosHalfTheta >= 1.0 ) {

    			this._w = w;
    			this._x = x;
    			this._y = y;
    			this._z = z;

    			return this;

    		}

    		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

    		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

    			this._w = 0.5 * ( w + this._w );
    			this._x = 0.5 * ( x + this._x );
    			this._y = 0.5 * ( y + this._y );
    			this._z = 0.5 * ( z + this._z );

    			return this;

    		}

    		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
    		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    		this._w = ( w * ratioA + this._w * ratioB );
    		this._x = ( x * ratioA + this._x * ratioB );
    		this._y = ( y * ratioA + this._y * ratioB );
    		this._z = ( z * ratioA + this._z * ratioB );

    		this.onChangeCallback();

    		return this;

    	},

    	equals: function ( quaternion ) {

    		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this._x = array[ offset ];
    		this._y = array[ offset + 1 ];
    		this._z = array[ offset + 2 ];
    		this._w = array[ offset + 3 ];

    		this.onChangeCallback();

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this._x;
    		array[ offset + 1 ] = this._y;
    		array[ offset + 2 ] = this._z;
    		array[ offset + 3 ] = this._w;

    		return array;

    	},

    	onChange: function ( callback ) {

    		this.onChangeCallback = callback;

    		return this;

    	},

    	onChangeCallback: function () {}

    };

    Object.assign( Quaternion, {

    	slerp: function( qa, qb, qm, t ) {

    		return qm.copy( qa ).slerp( qb, t );

    	},

    	slerpFlat: function(
    			dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

    		// fuzz-free, array-based Quaternion SLERP operation

    		var x0 = src0[ srcOffset0 + 0 ],
    			y0 = src0[ srcOffset0 + 1 ],
    			z0 = src0[ srcOffset0 + 2 ],
    			w0 = src0[ srcOffset0 + 3 ],

    			x1 = src1[ srcOffset1 + 0 ],
    			y1 = src1[ srcOffset1 + 1 ],
    			z1 = src1[ srcOffset1 + 2 ],
    			w1 = src1[ srcOffset1 + 3 ];

    		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

    			var s = 1 - t,

    				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

    				dir = ( cos >= 0 ? 1 : - 1 ),
    				sqrSin = 1 - cos * cos;

    			// Skip the Slerp for tiny steps to avoid numeric problems:
    			if ( sqrSin > Number.EPSILON ) {

    				var sin = Math.sqrt( sqrSin ),
    					len = Math.atan2( sin, cos * dir );

    				s = Math.sin( s * len ) / sin;
    				t = Math.sin( t * len ) / sin;

    			}

    			var tDir = t * dir;

    			x0 = x0 * s + x1 * tDir;
    			y0 = y0 * s + y1 * tDir;
    			z0 = z0 * s + z1 * tDir;
    			w0 = w0 * s + w1 * tDir;

    			// Normalize in case we just did a lerp:
    			if ( s === 1 - t ) {

    				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

    				x0 *= f;
    				y0 *= f;
    				z0 *= f;
    				w0 *= f;

    			}

    		}

    		dst[ dstOffset ] = x0;
    		dst[ dstOffset + 1 ] = y0;
    		dst[ dstOffset + 2 ] = z0;
    		dst[ dstOffset + 3 ] = w0;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author *kile / http://kile.stravaganza.org/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function Vector3( x, y, z ) {

    	this.x = x || 0;
    	this.y = y || 0;
    	this.z = z || 0;

    }

    Vector3.prototype = {

    	constructor: Vector3,

    	isVector3: true,

    	set: function ( x, y, z ) {

    		this.x = x;
    		this.y = y;
    		this.z = z;

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.x = scalar;
    		this.y = scalar;
    		this.z = scalar;

    		return this;

    	},

    	setX: function ( x ) {

    		this.x = x;

    		return this;

    	},

    	setY: function ( y ) {

    		this.y = y;

    		return this;

    	},

    	setZ: function ( z ) {

    		this.z = z;

    		return this;

    	},

    	setComponent: function ( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			case 2: this.z = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	getComponent: function ( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			case 2: return this.z;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	clone: function () {

    		return new this.constructor( this.x, this.y, this.z );

    	},

    	copy: function ( v ) {

    		this.x = v.x;
    		this.y = v.y;
    		this.z = v.z;

    		return this;

    	},

    	add: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
    			return this.addVectors( v, w );

    		}

    		this.x += v.x;
    		this.y += v.y;
    		this.z += v.z;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.x += s;
    		this.y += s;
    		this.z += s;

    		return this;

    	},

    	addVectors: function ( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;
    		this.z = a.z + b.z;

    		return this;

    	},

    	addScaledVector: function ( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;
    		this.z += v.z * s;

    		return this;

    	},

    	sub: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
    			return this.subVectors( v, w );

    		}

    		this.x -= v.x;
    		this.y -= v.y;
    		this.z -= v.z;

    		return this;

    	},

    	subScalar: function ( s ) {

    		this.x -= s;
    		this.y -= s;
    		this.z -= s;

    		return this;

    	},

    	subVectors: function ( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;
    		this.z = a.z - b.z;

    		return this;

    	},

    	multiply: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
    			return this.multiplyVectors( v, w );

    		}

    		this.x *= v.x;
    		this.y *= v.y;
    		this.z *= v.z;

    		return this;

    	},

    	multiplyScalar: function ( scalar ) {

    		if ( isFinite( scalar ) ) {

    			this.x *= scalar;
    			this.y *= scalar;
    			this.z *= scalar;

    		} else {

    			this.x = 0;
    			this.y = 0;
    			this.z = 0;

    		}

    		return this;

    	},

    	multiplyVectors: function ( a, b ) {

    		this.x = a.x * b.x;
    		this.y = a.y * b.y;
    		this.z = a.z * b.z;

    		return this;

    	},

    	applyEuler: function () {

    		var quaternion;

    		return function applyEuler( euler ) {

    			if ( (euler && euler.isEuler) === false ) {

    				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

    			}

    			if ( quaternion === undefined ) quaternion = new Quaternion();

    			return this.applyQuaternion( quaternion.setFromEuler( euler ) );

    		};

    	}(),

    	applyAxisAngle: function () {

    		var quaternion;

    		return function applyAxisAngle( axis, angle ) {

    			if ( quaternion === undefined ) quaternion = new Quaternion();

    			return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

    		};

    	}(),

    	applyMatrix3: function ( m ) {

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
    		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
    		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

    		return this;

    	},

    	applyMatrix4: function ( m ) {

    		// input: THREE.Matrix4 affine matrix

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
    		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
    		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

    		return this;

    	},

    	applyProjection: function ( m ) {

    		// input: THREE.Matrix4 projection matrix

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;
    		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

    		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
    		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
    		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

    		return this;

    	},

    	applyQuaternion: function ( q ) {

    		var x = this.x, y = this.y, z = this.z;
    		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

    		// calculate quat * vector

    		var ix =  qw * x + qy * z - qz * y;
    		var iy =  qw * y + qz * x - qx * z;
    		var iz =  qw * z + qx * y - qy * x;
    		var iw = - qx * x - qy * y - qz * z;

    		// calculate result * inverse quat

    		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    		return this;

    	},

    	project: function () {

    		var matrix;

    		return function project( camera ) {

    			if ( matrix === undefined ) matrix = new Matrix4();

    			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
    			return this.applyProjection( matrix );

    		};

    	}(),

    	unproject: function () {

    		var matrix;

    		return function unproject( camera ) {

    			if ( matrix === undefined ) matrix = new Matrix4();

    			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
    			return this.applyProjection( matrix );

    		};

    	}(),

    	transformDirection: function ( m ) {

    		// input: THREE.Matrix4 affine matrix
    		// vector interpreted as a direction

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
    		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
    		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

    		return this.normalize();

    	},

    	divide: function ( v ) {

    		this.x /= v.x;
    		this.y /= v.y;
    		this.z /= v.z;

    		return this;

    	},

    	divideScalar: function ( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	},

    	min: function ( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );
    		this.z = Math.min( this.z, v.z );

    		return this;

    	},

    	max: function ( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );
    		this.z = Math.max( this.z, v.z );

    		return this;

    	},

    	clamp: function ( min, max ) {

    		// This function assumes min < max, if this assumption isn't true it will not operate correctly

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
    		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

    		return this;

    	},

    	clampScalar: function () {

    		var min, max;

    		return function clampScalar( minVal, maxVal ) {

    			if ( min === undefined ) {

    				min = new Vector3();
    				max = new Vector3();

    			}

    			min.set( minVal, minVal, minVal );
    			max.set( maxVal, maxVal, maxVal );

    			return this.clamp( min, max );

    		};

    	}(),

    	clampLength: function ( min, max ) {

    		var length = this.length();

    		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

    	},

    	floor: function () {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );
    		this.z = Math.floor( this.z );

    		return this;

    	},

    	ceil: function () {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );
    		this.z = Math.ceil( this.z );

    		return this;

    	},

    	round: function () {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );
    		this.z = Math.round( this.z );

    		return this;

    	},

    	roundToZero: function () {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

    		return this;

    	},

    	negate: function () {

    		this.x = - this.x;
    		this.y = - this.y;
    		this.z = - this.z;

    		return this;

    	},

    	dot: function ( v ) {

    		return this.x * v.x + this.y * v.y + this.z * v.z;

    	},

    	lengthSq: function () {

    		return this.x * this.x + this.y * this.y + this.z * this.z;

    	},

    	length: function () {

    		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

    	},

    	lengthManhattan: function () {

    		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

    	},

    	normalize: function () {

    		return this.divideScalar( this.length() );

    	},

    	setLength: function ( length ) {

    		return this.multiplyScalar( length / this.length() );

    	},

    	lerp: function ( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;
    		this.z += ( v.z - this.z ) * alpha;

    		return this;

    	},

    	lerpVectors: function ( v1, v2, alpha ) {

    		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    	},

    	cross: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
    			return this.crossVectors( v, w );

    		}

    		var x = this.x, y = this.y, z = this.z;

    		this.x = y * v.z - z * v.y;
    		this.y = z * v.x - x * v.z;
    		this.z = x * v.y - y * v.x;

    		return this;

    	},

    	crossVectors: function ( a, b ) {

    		var ax = a.x, ay = a.y, az = a.z;
    		var bx = b.x, by = b.y, bz = b.z;

    		this.x = ay * bz - az * by;
    		this.y = az * bx - ax * bz;
    		this.z = ax * by - ay * bx;

    		return this;

    	},

    	projectOnVector: function ( vector ) {

    		var scalar = vector.dot( this ) / vector.lengthSq();

    		return this.copy( vector ).multiplyScalar( scalar );

    	},

    	projectOnPlane: function () {

    		var v1;

    		return function projectOnPlane( planeNormal ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			v1.copy( this ).projectOnVector( planeNormal );

    			return this.sub( v1 );

    		};

    	}(),

    	reflect: function () {

    		// reflect incident vector off plane orthogonal to normal
    		// normal is assumed to have unit length

    		var v1;

    		return function reflect( normal ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

    		};

    	}(),

    	angleTo: function ( v ) {

    		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

    		// clamp, to handle numerical problems

    		return Math.acos( exports.Math.clamp( theta, - 1, 1 ) );

    	},

    	distanceTo: function ( v ) {

    		return Math.sqrt( this.distanceToSquared( v ) );

    	},

    	distanceToSquared: function ( v ) {

    		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

    		return dx * dx + dy * dy + dz * dz;

    	},

    	distanceToManhattan: function ( v ) {

    		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

    	},

    	setFromSpherical: function( s ) {

    		var sinPhiRadius = Math.sin( s.phi ) * s.radius;

    		this.x = sinPhiRadius * Math.sin( s.theta );
    		this.y = Math.cos( s.phi ) * s.radius;
    		this.z = sinPhiRadius * Math.cos( s.theta );

    		return this;

    	},

    	setFromMatrixPosition: function ( m ) {

    		return this.setFromMatrixColumn( m, 3 );

    	},

    	setFromMatrixScale: function ( m ) {

    		var sx = this.setFromMatrixColumn( m, 0 ).length();
    		var sy = this.setFromMatrixColumn( m, 1 ).length();
    		var sz = this.setFromMatrixColumn( m, 2 ).length();

    		this.x = sx;
    		this.y = sy;
    		this.z = sz;

    		return this;

    	},

    	setFromMatrixColumn: function ( m, index ) {

    		if ( typeof m === 'number' ) {

    			console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );
    			var temp = m
    			m = index;
    			index = temp;

    		}

    		return this.fromArray( m.elements, index * 4 );

    	},

    	equals: function ( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];
    		this.z = array[ offset + 2 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;
    		array[ offset + 2 ] = this.z;

    		return array;

    	},

    	fromAttribute: function ( attribute, index, offset ) {

    		if ( offset === undefined ) offset = 0;

    		index = index * attribute.itemSize + offset;

    		this.x = attribute.array[ index ];
    		this.y = attribute.array[ index + 1 ];
    		this.z = attribute.array[ index + 2 ];

    		return this;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author jordi_ros / http://plattsoft.com
     * @author D1plo1d / http://github.com/D1plo1d
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author timknip / http://www.floorplanner.com/
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */

    function Matrix4() {

    	this.elements = new Float32Array( [

    		1, 0, 0, 0,
    		0, 1, 0, 0,
    		0, 0, 1, 0,
    		0, 0, 0, 1

    	] );

    	if ( arguments.length > 0 ) {

    		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

    	}

    }

    Matrix4.prototype = {

    	constructor: Matrix4,

    	isMatrix4: true,

    	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

    		var te = this.elements;

    		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
    		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
    		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
    		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

    		return this;

    	},

    	identity: function () {

    		this.set(

    			1, 0, 0, 0,
    			0, 1, 0, 0,
    			0, 0, 1, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	clone: function () {

    		return new Matrix4().fromArray( this.elements );

    	},

    	copy: function ( m ) {

    		this.elements.set( m.elements );

    		return this;

    	},

    	copyPosition: function ( m ) {

    		var te = this.elements;
    		var me = m.elements;

    		te[ 12 ] = me[ 12 ];
    		te[ 13 ] = me[ 13 ];
    		te[ 14 ] = me[ 14 ];

    		return this;

    	},

    	extractBasis: function ( xAxis, yAxis, zAxis ) {

    		xAxis.setFromMatrixColumn( this, 0 );
    		yAxis.setFromMatrixColumn( this, 1 );
    		zAxis.setFromMatrixColumn( this, 2 );

    		return this;

    	},

    	makeBasis: function ( xAxis, yAxis, zAxis ) {

    		this.set(
    			xAxis.x, yAxis.x, zAxis.x, 0,
    			xAxis.y, yAxis.y, zAxis.y, 0,
    			xAxis.z, yAxis.z, zAxis.z, 0,
    			0,       0,       0,       1
    		);

    		return this;

    	},

    	extractRotation: function () {

    		var v1;

    		return function extractRotation( m ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			var te = this.elements;
    			var me = m.elements;

    			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
    			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
    			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

    			te[ 0 ] = me[ 0 ] * scaleX;
    			te[ 1 ] = me[ 1 ] * scaleX;
    			te[ 2 ] = me[ 2 ] * scaleX;

    			te[ 4 ] = me[ 4 ] * scaleY;
    			te[ 5 ] = me[ 5 ] * scaleY;
    			te[ 6 ] = me[ 6 ] * scaleY;

    			te[ 8 ] = me[ 8 ] * scaleZ;
    			te[ 9 ] = me[ 9 ] * scaleZ;
    			te[ 10 ] = me[ 10 ] * scaleZ;

    			return this;

    		};

    	}(),

    	makeRotationFromEuler: function ( euler ) {

    		if ( (euler && euler.isEuler) === false ) {

    			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    		}

    		var te = this.elements;

    		var x = euler.x, y = euler.y, z = euler.z;
    		var a = Math.cos( x ), b = Math.sin( x );
    		var c = Math.cos( y ), d = Math.sin( y );
    		var e = Math.cos( z ), f = Math.sin( z );

    		if ( euler.order === 'XYZ' ) {

    			var ae = a * e, af = a * f, be = b * e, bf = b * f;

    			te[ 0 ] = c * e;
    			te[ 4 ] = - c * f;
    			te[ 8 ] = d;

    			te[ 1 ] = af + be * d;
    			te[ 5 ] = ae - bf * d;
    			te[ 9 ] = - b * c;

    			te[ 2 ] = bf - ae * d;
    			te[ 6 ] = be + af * d;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'YXZ' ) {

    			var ce = c * e, cf = c * f, de = d * e, df = d * f;

    			te[ 0 ] = ce + df * b;
    			te[ 4 ] = de * b - cf;
    			te[ 8 ] = a * d;

    			te[ 1 ] = a * f;
    			te[ 5 ] = a * e;
    			te[ 9 ] = - b;

    			te[ 2 ] = cf * b - de;
    			te[ 6 ] = df + ce * b;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'ZXY' ) {

    			var ce = c * e, cf = c * f, de = d * e, df = d * f;

    			te[ 0 ] = ce - df * b;
    			te[ 4 ] = - a * f;
    			te[ 8 ] = de + cf * b;

    			te[ 1 ] = cf + de * b;
    			te[ 5 ] = a * e;
    			te[ 9 ] = df - ce * b;

    			te[ 2 ] = - a * d;
    			te[ 6 ] = b;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'ZYX' ) {

    			var ae = a * e, af = a * f, be = b * e, bf = b * f;

    			te[ 0 ] = c * e;
    			te[ 4 ] = be * d - af;
    			te[ 8 ] = ae * d + bf;

    			te[ 1 ] = c * f;
    			te[ 5 ] = bf * d + ae;
    			te[ 9 ] = af * d - be;

    			te[ 2 ] = - d;
    			te[ 6 ] = b * c;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'YZX' ) {

    			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

    			te[ 0 ] = c * e;
    			te[ 4 ] = bd - ac * f;
    			te[ 8 ] = bc * f + ad;

    			te[ 1 ] = f;
    			te[ 5 ] = a * e;
    			te[ 9 ] = - b * e;

    			te[ 2 ] = - d * e;
    			te[ 6 ] = ad * f + bc;
    			te[ 10 ] = ac - bd * f;

    		} else if ( euler.order === 'XZY' ) {

    			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

    			te[ 0 ] = c * e;
    			te[ 4 ] = - f;
    			te[ 8 ] = d * e;

    			te[ 1 ] = ac * f + bd;
    			te[ 5 ] = a * e;
    			te[ 9 ] = ad * f - bc;

    			te[ 2 ] = bc * f - ad;
    			te[ 6 ] = b * e;
    			te[ 10 ] = bd * f + ac;

    		}

    		// last column
    		te[ 3 ] = 0;
    		te[ 7 ] = 0;
    		te[ 11 ] = 0;

    		// bottom row
    		te[ 12 ] = 0;
    		te[ 13 ] = 0;
    		te[ 14 ] = 0;
    		te[ 15 ] = 1;

    		return this;

    	},

    	makeRotationFromQuaternion: function ( q ) {

    		var te = this.elements;

    		var x = q.x, y = q.y, z = q.z, w = q.w;
    		var x2 = x + x, y2 = y + y, z2 = z + z;
    		var xx = x * x2, xy = x * y2, xz = x * z2;
    		var yy = y * y2, yz = y * z2, zz = z * z2;
    		var wx = w * x2, wy = w * y2, wz = w * z2;

    		te[ 0 ] = 1 - ( yy + zz );
    		te[ 4 ] = xy - wz;
    		te[ 8 ] = xz + wy;

    		te[ 1 ] = xy + wz;
    		te[ 5 ] = 1 - ( xx + zz );
    		te[ 9 ] = yz - wx;

    		te[ 2 ] = xz - wy;
    		te[ 6 ] = yz + wx;
    		te[ 10 ] = 1 - ( xx + yy );

    		// last column
    		te[ 3 ] = 0;
    		te[ 7 ] = 0;
    		te[ 11 ] = 0;

    		// bottom row
    		te[ 12 ] = 0;
    		te[ 13 ] = 0;
    		te[ 14 ] = 0;
    		te[ 15 ] = 1;

    		return this;

    	},

    	lookAt: function () {

    		var x, y, z;

    		return function lookAt( eye, target, up ) {

    			if ( x === undefined ) {

    				x = new Vector3();
    				y = new Vector3();
    				z = new Vector3();

    			}

    			var te = this.elements;

    			z.subVectors( eye, target ).normalize();

    			if ( z.lengthSq() === 0 ) {

    				z.z = 1;

    			}

    			x.crossVectors( up, z ).normalize();

    			if ( x.lengthSq() === 0 ) {

    				z.z += 0.0001;
    				x.crossVectors( up, z ).normalize();

    			}

    			y.crossVectors( z, x );


    			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
    			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
    			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

    			return this;

    		};

    	}(),

    	multiply: function ( m, n ) {

    		if ( n !== undefined ) {

    			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
    			return this.multiplyMatrices( m, n );

    		}

    		return this.multiplyMatrices( this, m );

    	},

    	premultiply: function ( m ) {

    		return this.multiplyMatrices( m, this );

    	},

    	multiplyMatrices: function ( a, b ) {

    		var ae = a.elements;
    		var be = b.elements;
    		var te = this.elements;

    		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
    		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
    		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
    		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

    		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
    		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
    		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
    		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

    		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

    		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

    		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

    		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

    		return this;

    	},

    	multiplyToArray: function ( a, b, r ) {

    		var te = this.elements;

    		this.multiplyMatrices( a, b );

    		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
    		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
    		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
    		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

    		return this;

    	},

    	multiplyScalar: function ( s ) {

    		var te = this.elements;

    		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
    		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
    		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
    		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

    		return this;

    	},

    	applyToVector3Array: function () {

    		var v1;

    		return function applyToVector3Array( array, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = array.length;

    			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

    				v1.fromArray( array, j );
    				v1.applyMatrix4( this );
    				v1.toArray( array, j );

    			}

    			return array;

    		};

    	}(),

    	applyToBuffer: function () {

    		var v1;

    		return function applyToBuffer( buffer, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = buffer.length / buffer.itemSize;

    			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

    				v1.x = buffer.getX( j );
    				v1.y = buffer.getY( j );
    				v1.z = buffer.getZ( j );

    				v1.applyMatrix4( this );

    				buffer.setXYZ( v1.x, v1.y, v1.z );

    			}

    			return buffer;

    		};

    	}(),

    	determinant: function () {

    		var te = this.elements;

    		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
    		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
    		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
    		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

    		//TODO: make this more efficient
    		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    		return (
    			n41 * (
    				+ n14 * n23 * n32
    				 - n13 * n24 * n32
    				 - n14 * n22 * n33
    				 + n12 * n24 * n33
    				 + n13 * n22 * n34
    				 - n12 * n23 * n34
    			) +
    			n42 * (
    				+ n11 * n23 * n34
    				 - n11 * n24 * n33
    				 + n14 * n21 * n33
    				 - n13 * n21 * n34
    				 + n13 * n24 * n31
    				 - n14 * n23 * n31
    			) +
    			n43 * (
    				+ n11 * n24 * n32
    				 - n11 * n22 * n34
    				 - n14 * n21 * n32
    				 + n12 * n21 * n34
    				 + n14 * n22 * n31
    				 - n12 * n24 * n31
    			) +
    			n44 * (
    				- n13 * n22 * n31
    				 - n11 * n23 * n32
    				 + n11 * n22 * n33
    				 + n13 * n21 * n32
    				 - n12 * n21 * n33
    				 + n12 * n23 * n31
    			)

    		);

    	},

    	transpose: function () {

    		var te = this.elements;
    		var tmp;

    		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
    		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
    		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

    		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
    		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
    		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

    		return this;

    	},

    	flattenToArrayOffset: function ( array, offset ) {

    		console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
    				"- just use .toArray instead." );

    		return this.toArray( array, offset );

    	},

    	getPosition: function () {

    		var v1;

    		return function getPosition() {

    			if ( v1 === undefined ) v1 = new Vector3();
    			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

    			return v1.setFromMatrixColumn( this, 3 );

    		};

    	}(),

    	setPosition: function ( v ) {

    		var te = this.elements;

    		te[ 12 ] = v.x;
    		te[ 13 ] = v.y;
    		te[ 14 ] = v.z;

    		return this;

    	},

    	getInverse: function ( m, throwOnDegenerate ) {

    		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    		var te = this.elements,
    			me = m.elements,

    			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
    			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
    			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
    			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

    			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
    			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
    			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
    			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

    		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

    		if ( det === 0 ) {

    			var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

    			if ( throwOnDegenerate === true ) {

    				throw new Error( msg );

    			} else {

    				console.warn( msg );

    			}

    			return this.identity();

    		}

    		var detInv = 1 / det;

    		te[ 0 ] = t11 * detInv;
    		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
    		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
    		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

    		te[ 4 ] = t12 * detInv;
    		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
    		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
    		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

    		te[ 8 ] = t13 * detInv;
    		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
    		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
    		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

    		te[ 12 ] = t14 * detInv;
    		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
    		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
    		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

    		return this;

    	},

    	scale: function ( v ) {

    		var te = this.elements;
    		var x = v.x, y = v.y, z = v.z;

    		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
    		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
    		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
    		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

    		return this;

    	},

    	getMaxScaleOnAxis: function () {

    		var te = this.elements;

    		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
    		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
    		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

    		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

    	},

    	makeTranslation: function ( x, y, z ) {

    		this.set(

    			1, 0, 0, x,
    			0, 1, 0, y,
    			0, 0, 1, z,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	makeRotationX: function ( theta ) {

    		var c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			1, 0,  0, 0,
    			0, c, - s, 0,
    			0, s,  c, 0,
    			0, 0,  0, 1

    		);

    		return this;

    	},

    	makeRotationY: function ( theta ) {

    		var c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			 c, 0, s, 0,
    			 0, 1, 0, 0,
    			- s, 0, c, 0,
    			 0, 0, 0, 1

    		);

    		return this;

    	},

    	makeRotationZ: function ( theta ) {

    		var c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			c, - s, 0, 0,
    			s,  c, 0, 0,
    			0,  0, 1, 0,
    			0,  0, 0, 1

    		);

    		return this;

    	},

    	makeRotationAxis: function ( axis, angle ) {

    		// Based on http://www.gamedev.net/reference/articles/article1199.asp

    		var c = Math.cos( angle );
    		var s = Math.sin( angle );
    		var t = 1 - c;
    		var x = axis.x, y = axis.y, z = axis.z;
    		var tx = t * x, ty = t * y;

    		this.set(

    			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
    			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
    			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
    			0, 0, 0, 1

    		);

    		 return this;

    	},

    	makeScale: function ( x, y, z ) {

    		this.set(

    			x, 0, 0, 0,
    			0, y, 0, 0,
    			0, 0, z, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	compose: function ( position, quaternion, scale ) {

    		this.makeRotationFromQuaternion( quaternion );
    		this.scale( scale );
    		this.setPosition( position );

    		return this;

    	},

    	decompose: function () {

    		var vector, matrix;

    		return function decompose( position, quaternion, scale ) {

    			if ( vector === undefined ) {

    				vector = new Vector3();
    				matrix = new Matrix4();

    			}

    			var te = this.elements;

    			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
    			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
    			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

    			// if determine is negative, we need to invert one scale
    			var det = this.determinant();
    			if ( det < 0 ) {

    				sx = - sx;

    			}

    			position.x = te[ 12 ];
    			position.y = te[ 13 ];
    			position.z = te[ 14 ];

    			// scale the rotation part

    			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

    			var invSX = 1 / sx;
    			var invSY = 1 / sy;
    			var invSZ = 1 / sz;

    			matrix.elements[ 0 ] *= invSX;
    			matrix.elements[ 1 ] *= invSX;
    			matrix.elements[ 2 ] *= invSX;

    			matrix.elements[ 4 ] *= invSY;
    			matrix.elements[ 5 ] *= invSY;
    			matrix.elements[ 6 ] *= invSY;

    			matrix.elements[ 8 ] *= invSZ;
    			matrix.elements[ 9 ] *= invSZ;
    			matrix.elements[ 10 ] *= invSZ;

    			quaternion.setFromRotationMatrix( matrix );

    			scale.x = sx;
    			scale.y = sy;
    			scale.z = sz;

    			return this;

    		};

    	}(),

    	makeFrustum: function ( left, right, bottom, top, near, far ) {

    		var te = this.elements;
    		var x = 2 * near / ( right - left );
    		var y = 2 * near / ( top - bottom );

    		var a = ( right + left ) / ( right - left );
    		var b = ( top + bottom ) / ( top - bottom );
    		var c = - ( far + near ) / ( far - near );
    		var d = - 2 * far * near / ( far - near );

    		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
    		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
    		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
    		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

    		return this;

    	},

    	makePerspective: function ( fov, aspect, near, far ) {

    		var ymax = near * Math.tan( exports.Math.DEG2RAD * fov * 0.5 );
    		var ymin = - ymax;
    		var xmin = ymin * aspect;
    		var xmax = ymax * aspect;

    		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

    	},

    	makeOrthographic: function ( left, right, top, bottom, near, far ) {

    		var te = this.elements;
    		var w = 1.0 / ( right - left );
    		var h = 1.0 / ( top - bottom );
    		var p = 1.0 / ( far - near );

    		var x = ( right + left ) * w;
    		var y = ( top + bottom ) * h;
    		var z = ( far + near ) * p;

    		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
    		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
    		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
    		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

    		return this;

    	},

    	equals: function ( matrix ) {

    		var te = this.elements;
    		var me = matrix.elements;

    		for ( var i = 0; i < 16; i ++ ) {

    			if ( te[ i ] !== me[ i ] ) return false;

    		}

    		return true;

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		for( var i = 0; i < 16; i ++ ) {

    			this.elements[ i ] = array[ i + offset ];

    		}

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		var te = this.elements;

    		array[ offset ] = te[ 0 ];
    		array[ offset + 1 ] = te[ 1 ];
    		array[ offset + 2 ] = te[ 2 ];
    		array[ offset + 3 ] = te[ 3 ];

    		array[ offset + 4 ] = te[ 4 ];
    		array[ offset + 5 ] = te[ 5 ];
    		array[ offset + 6 ] = te[ 6 ];
    		array[ offset + 7 ] = te[ 7 ];

    		array[ offset + 8 ]  = te[ 8 ];
    		array[ offset + 9 ]  = te[ 9 ];
    		array[ offset + 10 ] = te[ 10 ];
    		array[ offset + 11 ] = te[ 11 ];

    		array[ offset + 12 ] = te[ 12 ];
    		array[ offset + 13 ] = te[ 13 ];
    		array[ offset + 14 ] = te[ 14 ];
    		array[ offset + 15 ] = te[ 15 ];

    		return array;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

    	images = images !== undefined ? images : [];
    	mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

    	Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    	this.flipY = false;

    }

    CubeTexture.prototype = Object.create( Texture.prototype );
    CubeTexture.prototype.constructor = CubeTexture;

    CubeTexture.prototype.isCubeTexture = true;

    Object.defineProperty( CubeTexture.prototype, 'images', {

    	get: function () {

    		return this.image;

    	},

    	set: function ( value ) {

    		this.image = value;

    	}

    } );

    var emptyTexture = new Texture();
    var emptyCubeTexture = new CubeTexture();

    // --- Base for inner nodes (including the root) ---

    function UniformContainer() {

    	this.seq = [];
    	this.map = {};

    }

    // --- Utilities ---

    // Array Caches (provide typed arrays for temporary by size)

    var arrayCacheF32 = [];
    var arrayCacheI32 = [];

    // Flattening for arrays of vectors and matrices

    function flatten( array, nBlocks, blockSize ) {

    	var firstElem = array[ 0 ];

    	if ( firstElem <= 0 || firstElem > 0 ) return array;
    	// unoptimized: ! isNaN( firstElem )
    	// see http://jacksondunstan.com/articles/983

    	var n = nBlocks * blockSize,
    		r = arrayCacheF32[ n ];

    	if ( r === undefined ) {

    		r = new Float32Array( n );
    		arrayCacheF32[ n ] = r;

    	}

    	if ( nBlocks !== 0 ) {

    		firstElem.toArray( r, 0 );

    		for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

    			offset += blockSize;
    			array[ i ].toArray( r, offset );

    		}

    	}

    	return r;

    }

    // Texture unit allocation

    function allocTexUnits( renderer, n ) {

    	var r = arrayCacheI32[ n ];

    	if ( r === undefined ) {

    		r = new Int32Array( n );
    		arrayCacheI32[ n ] = r;

    	}

    	for ( var i = 0; i !== n; ++ i )
    		r[ i ] = renderer.allocTextureUnit();

    	return r;

    }

    // --- Setters ---

    // Note: Defining these methods externally, because they come in a bunch
    // and this way their names minify.

    // Single scalar

    function setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }
    function setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }

    // Single float vector (from flat array or THREE.VectorN)

    function setValue2fv( gl, v ) {

    	if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
    	else gl.uniform2f( this.addr, v.x, v.y );

    }

    function setValue3fv( gl, v ) {

    	if ( v.x !== undefined )
    		gl.uniform3f( this.addr, v.x, v.y, v.z );
    	else if ( v.r !== undefined )
    		gl.uniform3f( this.addr, v.r, v.g, v.b );
    	else
    		gl.uniform3fv( this.addr, v );

    }

    function setValue4fv( gl, v ) {

    	if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
    	else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

    }

    // Single matrix (from flat array or MatrixN)

    function setValue2fm( gl, v ) {

    	gl.uniformMatrix2fv( this.addr, false, v.elements || v );

    }

    function setValue3fm( gl, v ) {

    	gl.uniformMatrix3fv( this.addr, false, v.elements || v );

    }

    function setValue4fm( gl, v ) {

    	gl.uniformMatrix4fv( this.addr, false, v.elements || v );

    }

    // Single texture (2D / Cube)

    function setValueT1( gl, v, renderer ) {

    	var unit = renderer.allocTextureUnit();
    	gl.uniform1i( this.addr, unit );
    	renderer.setTexture2D( v || emptyTexture, unit );

    }

    function setValueT6( gl, v, renderer ) {

    	var unit = renderer.allocTextureUnit();
    	gl.uniform1i( this.addr, unit );
    	renderer.setTextureCube( v || emptyCubeTexture, unit );

    }

    // Integer / Boolean vectors or arrays thereof (always flat arrays)

    function setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }
    function setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }
    function setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }

    // Helper to pick the right setter for the singular case

    function getSingularSetter( type ) {

    	switch ( type ) {

    		case 0x1406: return setValue1f; // FLOAT
    		case 0x8b50: return setValue2fv; // _VEC2
    		case 0x8b51: return setValue3fv; // _VEC3
    		case 0x8b52: return setValue4fv; // _VEC4

    		case 0x8b5a: return setValue2fm; // _MAT2
    		case 0x8b5b: return setValue3fm; // _MAT3
    		case 0x8b5c: return setValue4fm; // _MAT4

    		case 0x8b5e: return setValueT1; // SAMPLER_2D
    		case 0x8b60: return setValueT6; // SAMPLER_CUBE

    		case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
    		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
    		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
    		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

    	}

    }

    // Array of scalars

    function setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }
    function setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }

    // Array of vectors (flat or from THREE classes)

    function setValueV2a( gl, v ) {

    	gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

    }

    function setValueV3a( gl, v ) {

    	gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

    }

    function setValueV4a( gl, v ) {

    	gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

    }

    // Array of matrices (flat or from THREE clases)

    function setValueM2a( gl, v ) {

    	gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

    }

    function setValueM3a( gl, v ) {

    	gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

    }

    function setValueM4a( gl, v ) {

    	gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

    }

    // Array of textures (2D / Cube)

    function setValueT1a( gl, v, renderer ) {

    	var n = v.length,
    		units = allocTexUnits( renderer, n );

    	gl.uniform1iv( this.addr, units );

    	for ( var i = 0; i !== n; ++ i ) {

    		renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

    	}

    }

    function setValueT6a( gl, v, renderer ) {

    	var n = v.length,
    		units = allocTexUnits( renderer, n );

    	gl.uniform1iv( this.addr, units );

    	for ( var i = 0; i !== n; ++ i ) {

    		renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

    	}

    }

    // Helper to pick the right setter for a pure (bottom-level) array

    function getPureArraySetter( type ) {

    	switch ( type ) {

    		case 0x1406: return setValue1fv; // FLOAT
    		case 0x8b50: return setValueV2a; // _VEC2
    		case 0x8b51: return setValueV3a; // _VEC3
    		case 0x8b52: return setValueV4a; // _VEC4

    		case 0x8b5a: return setValueM2a; // _MAT2
    		case 0x8b5b: return setValueM3a; // _MAT3
    		case 0x8b5c: return setValueM4a; // _MAT4

    		case 0x8b5e: return setValueT1a; // SAMPLER_2D
    		case 0x8b60: return setValueT6a; // SAMPLER_CUBE

    		case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
    		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
    		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
    		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

    	}

    }

    // --- Uniform Classes ---

    function SingleUniform( id, activeInfo, addr ) {

    	this.id = id;
    	this.addr = addr;
    	this.setValue = getSingularSetter( activeInfo.type );

    	// this.path = activeInfo.name; // DEBUG

    }

    function PureArrayUniform( id, activeInfo, addr ) {

    	this.id = id;
    	this.addr = addr;
    	this.size = activeInfo.size;
    	this.setValue = getPureArraySetter( activeInfo.type );

    	// this.path = activeInfo.name; // DEBUG

    }

    function StructuredUniform( id ) {

    	this.id = id;

    	UniformContainer.call( this ); // mix-in

    }

    StructuredUniform.prototype.setValue = function( gl, value ) {

    	// Note: Don't need an extra 'renderer' parameter, since samplers
    	// are not allowed in structured uniforms.

    	var seq = this.seq;

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var u = seq[ i ];
    		u.setValue( gl, value[ u.id ] );

    	}

    };

    // --- Top-level ---

    // Parser - builds up the property tree from the path strings

    var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

    // extracts
    // 	- the identifier (member name or array index)
    //  - followed by an optional right bracket (found when array index)
    //  - followed by an optional left bracket or dot (type of subscript)
    //
    // Note: These portions can be read in a non-overlapping fashion and
    // allow straightforward parsing of the hierarchy that WebGL encodes
    // in the uniform names.

    function addUniform( container, uniformObject ) {

    	container.seq.push( uniformObject );
    	container.map[ uniformObject.id ] = uniformObject;

    }

    function parseUniform( activeInfo, addr, container ) {

    	var path = activeInfo.name,
    		pathLength = path.length;

    	// reset RegExp object, because of the early exit of a previous run
    	RePathPart.lastIndex = 0;

    	for (; ;) {

    		var match = RePathPart.exec( path ),
    			matchEnd = RePathPart.lastIndex,

    			id = match[ 1 ],
    			idIsIndex = match[ 2 ] === ']',
    			subscript = match[ 3 ];

    		if ( idIsIndex ) id = id | 0; // convert to integer

    		if ( subscript === undefined ||
    				subscript === '[' && matchEnd + 2 === pathLength ) {
    			// bare name or "pure" bottom-level array "[0]" suffix

    			addUniform( container, subscript === undefined ?
    					new SingleUniform( id, activeInfo, addr ) :
    					new PureArrayUniform( id, activeInfo, addr ) );

    			break;

    		} else {
    			// step into inner node / create it in case it doesn't exist

    			var map = container.map,
    				next = map[ id ];

    			if ( next === undefined ) {

    				next = new StructuredUniform( id );
    				addUniform( container, next );

    			}

    			container = next;

    		}

    	}

    }

    // Root Container

    function WebGLUniforms( gl, program, renderer ) {

    	UniformContainer.call( this );

    	this.renderer = renderer;

    	var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

    	for ( var i = 0; i !== n; ++ i ) {

    		var info = gl.getActiveUniform( program, i ),
    			path = info.name,
    			addr = gl.getUniformLocation( program, path );

    		parseUniform( info, addr, this );

    	}

    }

    WebGLUniforms.prototype.setValue = function( gl, name, value ) {

    	var u = this.map[ name ];

    	if ( u !== undefined ) u.setValue( gl, value, this.renderer );

    };

    WebGLUniforms.prototype.set = function( gl, object, name ) {

    	var u = this.map[ name ];

    	if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );

    };

    WebGLUniforms.prototype.setOptional = function( gl, object, name ) {

    	var v = object[ name ];

    	if ( v !== undefined ) this.setValue( gl, name, v );

    };


    // Static interface

    WebGLUniforms.upload = function( gl, seq, values, renderer ) {

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var u = seq[ i ],
    			v = values[ u.id ];

    		if ( v.needsUpdate !== false ) {
    			// note: always updating when .needsUpdate is undefined

    			u.setValue( gl, v.value, renderer );

    		}

    	}

    };

    WebGLUniforms.seqWithValue = function( seq, values ) {

    	var r = [];

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var u = seq[ i ];
    		if ( u.id in values ) r.push( u );

    	}

    	return r;

    };

    WebGLUniforms.splitDynamic = function( seq, values ) {

    	var r = null,
    		n = seq.length,
    		w = 0;

    	for ( var i = 0; i !== n; ++ i ) {

    		var u = seq[ i ],
    			v = values[ u.id ];

    		if ( v && v.dynamic === true ) {

    			if ( r === null ) r = [];
    			r.push( u );

    		} else {

    			// in-place compact 'seq', removing the matches
    			if ( w < i ) seq[ w ] = u;
    			++ w;

    		}

    	}

    	if ( w < n ) seq.length = w;

    	return r;

    };

    WebGLUniforms.evalDynamic = function( seq, values, object, material, camera ) {

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var v = values[ seq[ i ].id ],
    			f = v.onUpdateCallback;

    		if ( f !== undefined ) f.call( v, object, material, camera );

    	}

    };

    /**
     * Uniform Utilities
     */

    exports.UniformsUtils = {

    	merge: function ( uniforms ) {

    		var merged = {};

    		for ( var u = 0; u < uniforms.length; u ++ ) {

    			var tmp = this.clone( uniforms[ u ] );

    			for ( var p in tmp ) {

    				merged[ p ] = tmp[ p ];

    			}

    		}

    		return merged;

    	},

    	clone: function ( uniforms_src ) {

    		var uniforms_dst = {};

    		for ( var u in uniforms_src ) {

    			uniforms_dst[ u ] = {};

    			for ( var p in uniforms_src[ u ] ) {

    				var parameter_src = uniforms_src[ u ][ p ];

    				if ( (parameter_src && parameter_src.isColor) ||
    					 (parameter_src && parameter_src.isVector2) ||
    					 (parameter_src && parameter_src.isVector3) ||
    					 (parameter_src && parameter_src.isVector4) ||
    					 (parameter_src && parameter_src.isMatrix3) ||
    					 (parameter_src && parameter_src.isMatrix4) ||
    					 (parameter_src && parameter_src.isTexture) ) {

    					uniforms_dst[ u ][ p ] = parameter_src.clone();

    				} else if ( Array.isArray( parameter_src ) ) {

    					uniforms_dst[ u ][ p ] = parameter_src.slice();

    				} else {

    					uniforms_dst[ u ][ p ] = parameter_src;

    				}

    			}

    		}

    		return uniforms_dst;

    	}

    };

    var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

    var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

    var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

    var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

    var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

    var begin_vertex = "\nvec3 transformed = vec3( position );\n";

    var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

    var bsdfs = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

    var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

    var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n#endif\n";

    var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

    var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

    var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

    var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

    var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

    var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

    var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

    var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n";

    var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

    var defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

    var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

    var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

    var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

    var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

    var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

    var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";

    var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

    var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

    var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

    var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

    var fog_fragment = "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

    var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

    var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

    var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

    var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

    var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#include <normal_flip>\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#include <normal_flip>\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

    var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

    var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

    var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

    var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

    var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

    var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";

    var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

    var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

    var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";

    var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

    var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

    var map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

    var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";

    var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n";

    var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

    var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

    var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

    var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

    var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";

    var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

    var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";

    var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

    var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

    var project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";

    var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";

    var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

    var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

    var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

    var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

    var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

    var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

    var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

    var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";

    var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

    var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

    var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

    var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

    var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

    var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

    var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";

    var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";

    var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

    var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

    var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

    var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";

    var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

    var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

    var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

    var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

    var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";

    var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";

    var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

    var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

    var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

    var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n";

    var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var normal_frag = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n";

    var normal_vert = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

    var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n";

    var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var ShaderChunk = {
    	alphamap_fragment: alphamap_fragment,
    	alphamap_pars_fragment: alphamap_pars_fragment,
    	alphatest_fragment: alphatest_fragment,
    	aomap_fragment: aomap_fragment,
    	aomap_pars_fragment: aomap_pars_fragment,
    	begin_vertex: begin_vertex,
    	beginnormal_vertex: beginnormal_vertex,
    	bsdfs: bsdfs,
    	bumpmap_pars_fragment: bumpmap_pars_fragment,
    	clipping_planes_fragment: clipping_planes_fragment,
    	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
    	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
    	clipping_planes_vertex: clipping_planes_vertex,
    	color_fragment: color_fragment,
    	color_pars_fragment: color_pars_fragment,
    	color_pars_vertex: color_pars_vertex,
    	color_vertex: color_vertex,
    	common: common,
    	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
    	defaultnormal_vertex: defaultnormal_vertex,
    	displacementmap_pars_vertex: displacementmap_pars_vertex,
    	displacementmap_vertex: displacementmap_vertex,
    	emissivemap_fragment: emissivemap_fragment,
    	emissivemap_pars_fragment: emissivemap_pars_fragment,
    	encodings_fragment: encodings_fragment,
    	encodings_pars_fragment: encodings_pars_fragment,
    	envmap_fragment: envmap_fragment,
    	envmap_pars_fragment: envmap_pars_fragment,
    	envmap_pars_vertex: envmap_pars_vertex,
    	envmap_vertex: envmap_vertex,
    	fog_fragment: fog_fragment,
    	fog_pars_fragment: fog_pars_fragment,
    	lightmap_fragment: lightmap_fragment,
    	lightmap_pars_fragment: lightmap_pars_fragment,
    	lights_lambert_vertex: lights_lambert_vertex,
    	lights_pars: lights_pars,
    	lights_phong_fragment: lights_phong_fragment,
    	lights_phong_pars_fragment: lights_phong_pars_fragment,
    	lights_physical_fragment: lights_physical_fragment,
    	lights_physical_pars_fragment: lights_physical_pars_fragment,
    	lights_template: lights_template,
    	logdepthbuf_fragment: logdepthbuf_fragment,
    	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
    	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
    	logdepthbuf_vertex: logdepthbuf_vertex,
    	map_fragment: map_fragment,
    	map_pars_fragment: map_pars_fragment,
    	map_particle_fragment: map_particle_fragment,
    	map_particle_pars_fragment: map_particle_pars_fragment,
    	metalnessmap_fragment: metalnessmap_fragment,
    	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
    	morphnormal_vertex: morphnormal_vertex,
    	morphtarget_pars_vertex: morphtarget_pars_vertex,
    	morphtarget_vertex: morphtarget_vertex,
    	normal_flip: normal_flip,
    	normal_fragment: normal_fragment,
    	normalmap_pars_fragment: normalmap_pars_fragment,
    	packing: packing,
    	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
    	project_vertex: project_vertex,
    	roughnessmap_fragment: roughnessmap_fragment,
    	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
    	shadowmap_pars_fragment: shadowmap_pars_fragment,
    	shadowmap_pars_vertex: shadowmap_pars_vertex,
    	shadowmap_vertex: shadowmap_vertex,
    	shadowmask_pars_fragment: shadowmask_pars_fragment,
    	skinbase_vertex: skinbase_vertex,
    	skinning_pars_vertex: skinning_pars_vertex,
    	skinning_vertex: skinning_vertex,
    	skinnormal_vertex: skinnormal_vertex,
    	specularmap_fragment: specularmap_fragment,
    	specularmap_pars_fragment: specularmap_pars_fragment,
    	tonemapping_fragment: tonemapping_fragment,
    	tonemapping_pars_fragment: tonemapping_pars_fragment,
    	uv_pars_fragment: uv_pars_fragment,
    	uv_pars_vertex: uv_pars_vertex,
    	uv_vertex: uv_vertex,
    	uv2_pars_fragment: uv2_pars_fragment,
    	uv2_pars_vertex: uv2_pars_vertex,
    	uv2_vertex: uv2_vertex,
    	worldpos_vertex: worldpos_vertex,

    	cube_frag: cube_frag,
    	cube_vert: cube_vert,
    	depth_frag: depth_frag,
    	depth_vert: depth_vert,
    	distanceRGBA_frag: distanceRGBA_frag,
    	distanceRGBA_vert: distanceRGBA_vert,
    	equirect_frag: equirect_frag,
    	equirect_vert: equirect_vert,
    	linedashed_frag: linedashed_frag,
    	linedashed_vert: linedashed_vert,
    	meshbasic_frag: meshbasic_frag,
    	meshbasic_vert: meshbasic_vert,
    	meshlambert_frag: meshlambert_frag,
    	meshlambert_vert: meshlambert_vert,
    	meshphong_frag: meshphong_frag,
    	meshphong_vert: meshphong_vert,
    	meshphysical_frag: meshphysical_frag,
    	meshphysical_vert: meshphysical_vert,
    	normal_frag: normal_frag,
    	normal_vert: normal_vert,
    	points_frag: points_frag,
    	points_vert: points_vert,
    	shadow_frag: shadow_frag,
    	shadow_vert: shadow_vert
    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Color( r, g, b ) {

    	if ( g === undefined && b === undefined ) {

    		// r is THREE.Color, hex or string
    		return this.set( r );

    	}

    	return this.setRGB( r, g, b );

    }

    Color.prototype = {

    	constructor: Color,

    	isColor: true,

    	r: 1, g: 1, b: 1,

    	set: function ( value ) {

    		if ( (value && value.isColor) ) {

    			this.copy( value );

    		} else if ( typeof value === 'number' ) {

    			this.setHex( value );

    		} else if ( typeof value === 'string' ) {

    			this.setStyle( value );

    		}

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.r = scalar;
    		this.g = scalar;
    		this.b = scalar;

    	},

    	setHex: function ( hex ) {

    		hex = Math.floor( hex );

    		this.r = ( hex >> 16 & 255 ) / 255;
    		this.g = ( hex >> 8 & 255 ) / 255;
    		this.b = ( hex & 255 ) / 255;

    		return this;

    	},

    	setRGB: function ( r, g, b ) {

    		this.r = r;
    		this.g = g;
    		this.b = b;

    		return this;

    	},

    	setHSL: function () {

    		function hue2rgb( p, q, t ) {

    			if ( t < 0 ) t += 1;
    			if ( t > 1 ) t -= 1;
    			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
    			if ( t < 1 / 2 ) return q;
    			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
    			return p;

    		}

    		return function setHSL( h, s, l ) {

    			// h,s,l ranges are in 0.0 - 1.0
    			h = exports.Math.euclideanModulo( h, 1 );
    			s = exports.Math.clamp( s, 0, 1 );
    			l = exports.Math.clamp( l, 0, 1 );

    			if ( s === 0 ) {

    				this.r = this.g = this.b = l;

    			} else {

    				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
    				var q = ( 2 * l ) - p;

    				this.r = hue2rgb( q, p, h + 1 / 3 );
    				this.g = hue2rgb( q, p, h );
    				this.b = hue2rgb( q, p, h - 1 / 3 );

    			}

    			return this;

    		};

    	}(),

    	setStyle: function ( style ) {

    		function handleAlpha( string ) {

    			if ( string === undefined ) return;

    			if ( parseFloat( string ) < 1 ) {

    				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

    			}

    		}


    		var m;

    		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

    			// rgb / hsl

    			var color;
    			var name = m[ 1 ];
    			var components = m[ 2 ];

    			switch ( name ) {

    				case 'rgb':
    				case 'rgba':

    					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

    						// rgb(255,0,0) rgba(255,0,0,0.5)
    						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
    						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
    						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

    						handleAlpha( color[ 5 ] );

    						return this;

    					}

    					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

    						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
    						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
    						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
    						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

    						handleAlpha( color[ 5 ] );

    						return this;

    					}

    					break;

    				case 'hsl':
    				case 'hsla':

    					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

    						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
    						var h = parseFloat( color[ 1 ] ) / 360;
    						var s = parseInt( color[ 2 ], 10 ) / 100;
    						var l = parseInt( color[ 3 ], 10 ) / 100;

    						handleAlpha( color[ 5 ] );

    						return this.setHSL( h, s, l );

    					}

    					break;

    			}

    		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

    			// hex color

    			var hex = m[ 1 ];
    			var size = hex.length;

    			if ( size === 3 ) {

    				// #ff0
    				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
    				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
    				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

    				return this;

    			} else if ( size === 6 ) {

    				// #ff0000
    				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
    				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
    				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

    				return this;

    			}

    		}

    		if ( style && style.length > 0 ) {

    			// color keywords
    			var hex = exports.ColorKeywords[ style ];

    			if ( hex !== undefined ) {

    				// red
    				this.setHex( hex );

    			} else {

    				// unknown color
    				console.warn( 'THREE.Color: Unknown color ' + style );

    			}

    		}

    		return this;

    	},

    	clone: function () {

    		return new this.constructor( this.r, this.g, this.b );

    	},

    	copy: function ( color ) {

    		this.r = color.r;
    		this.g = color.g;
    		this.b = color.b;

    		return this;

    	},

    	copyGammaToLinear: function ( color, gammaFactor ) {

    		if ( gammaFactor === undefined ) gammaFactor = 2.0;

    		this.r = Math.pow( color.r, gammaFactor );
    		this.g = Math.pow( color.g, gammaFactor );
    		this.b = Math.pow( color.b, gammaFactor );

    		return this;

    	},

    	copyLinearToGamma: function ( color, gammaFactor ) {

    		if ( gammaFactor === undefined ) gammaFactor = 2.0;

    		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

    		this.r = Math.pow( color.r, safeInverse );
    		this.g = Math.pow( color.g, safeInverse );
    		this.b = Math.pow( color.b, safeInverse );

    		return this;

    	},

    	convertGammaToLinear: function () {

    		var r = this.r, g = this.g, b = this.b;

    		this.r = r * r;
    		this.g = g * g;
    		this.b = b * b;

    		return this;

    	},

    	convertLinearToGamma: function () {

    		this.r = Math.sqrt( this.r );
    		this.g = Math.sqrt( this.g );
    		this.b = Math.sqrt( this.b );

    		return this;

    	},

    	getHex: function () {

    		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

    	},

    	getHexString: function () {

    		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

    	},

    	getHSL: function ( optionalTarget ) {

    		// h,s,l ranges are in 0.0 - 1.0

    		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

    		var r = this.r, g = this.g, b = this.b;

    		var max = Math.max( r, g, b );
    		var min = Math.min( r, g, b );

    		var hue, saturation;
    		var lightness = ( min + max ) / 2.0;

    		if ( min === max ) {

    			hue = 0;
    			saturation = 0;

    		} else {

    			var delta = max - min;

    			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

    			switch ( max ) {

    				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
    				case g: hue = ( b - r ) / delta + 2; break;
    				case b: hue = ( r - g ) / delta + 4; break;

    			}

    			hue /= 6;

    		}

    		hsl.h = hue;
    		hsl.s = saturation;
    		hsl.l = lightness;

    		return hsl;

    	},

    	getStyle: function () {

    		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

    	},

    	offsetHSL: function ( h, s, l ) {

    		var hsl = this.getHSL();

    		hsl.h += h; hsl.s += s; hsl.l += l;

    		this.setHSL( hsl.h, hsl.s, hsl.l );

    		return this;

    	},

    	add: function ( color ) {

    		this.r += color.r;
    		this.g += color.g;
    		this.b += color.b;

    		return this;

    	},

    	addColors: function ( color1, color2 ) {

    		this.r = color1.r + color2.r;
    		this.g = color1.g + color2.g;
    		this.b = color1.b + color2.b;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.r += s;
    		this.g += s;
    		this.b += s;

    		return this;

    	},

    	sub: function( color ) {

    		this.r = Math.max( 0, this.r - color.r );
    		this.g = Math.max( 0, this.g - color.g );
    		this.b = Math.max( 0, this.b - color.b );

    		return this;

    	},

    	multiply: function ( color ) {

    		this.r *= color.r;
    		this.g *= color.g;
    		this.b *= color.b;

    		return this;

    	},

    	multiplyScalar: function ( s ) {

    		this.r *= s;
    		this.g *= s;
    		this.b *= s;

    		return this;

    	},

    	lerp: function ( color, alpha ) {

    		this.r += ( color.r - this.r ) * alpha;
    		this.g += ( color.g - this.g ) * alpha;
    		this.b += ( color.b - this.b ) * alpha;

    		return this;

    	},

    	equals: function ( c ) {

    		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.r = array[ offset ];
    		this.g = array[ offset + 1 ];
    		this.b = array[ offset + 2 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.r;
    		array[ offset + 1 ] = this.g;
    		array[ offset + 2 ] = this.b;

    		return array;

    	},

    	toJSON: function () {

    		return this.getHex();

    	}

    };

    exports.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
    'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
    'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
    'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
    'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
    'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
    'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

    /**
     * Uniforms library for shared webgl shaders
     */

    var UniformsLib = {

    	common: {

    		diffuse: { value: new Color( 0xeeeeee ) },
    		opacity: { value: 1.0 },

    		map: { value: null },
    		offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },

    		specularMap: { value: null },
    		alphaMap: { value: null },

    		envMap: { value: null },
    		flipEnvMap: { value: - 1 },
    		reflectivity: { value: 1.0 },
    		refractionRatio: { value: 0.98 }

    	},

    	aomap: {

    		aoMap: { value: null },
    		aoMapIntensity: { value: 1 }

    	},

    	lightmap: {

    		lightMap: { value: null },
    		lightMapIntensity: { value: 1 }

    	},

    	emissivemap: {

    		emissiveMap: { value: null }

    	},

    	bumpmap: {

    		bumpMap: { value: null },
    		bumpScale: { value: 1 }

    	},

    	normalmap: {

    		normalMap: { value: null },
    		normalScale: { value: new Vector2( 1, 1 ) }

    	},

    	displacementmap: {

    		displacementMap: { value: null },
    		displacementScale: { value: 1 },
    		displacementBias: { value: 0 }

    	},

    	roughnessmap: {

    		roughnessMap: { value: null }

    	},

    	metalnessmap: {

    		metalnessMap: { value: null }

    	},

    	fog: {

    		fogDensity: { value: 0.00025 },
    		fogNear: { value: 1 },
    		fogFar: { value: 2000 },
    		fogColor: { value: new Color( 0xffffff ) }

    	},

    	lights: {

    		ambientLightColor: { value: [] },

    		directionalLights: { value: [], properties: {
    			direction: {},
    			color: {},

    			shadow: {},
    			shadowBias: {},
    			shadowRadius: {},
    			shadowMapSize: {}
    		} },

    		directionalShadowMap: { value: [] },
    		directionalShadowMatrix: { value: [] },

    		spotLights: { value: [], properties: {
    			color: {},
    			position: {},
    			direction: {},
    			distance: {},
    			coneCos: {},
    			penumbraCos: {},
    			decay: {},

    			shadow: {},
    			shadowBias: {},
    			shadowRadius: {},
    			shadowMapSize: {}
    		} },

    		spotShadowMap: { value: [] },
    		spotShadowMatrix: { value: [] },

    		pointLights: { value: [], properties: {
    			color: {},
    			position: {},
    			decay: {},
    			distance: {},

    			shadow: {},
    			shadowBias: {},
    			shadowRadius: {},
    			shadowMapSize: {}
    		} },

    		pointShadowMap: { value: [] },
    		pointShadowMatrix: { value: [] },

    		hemisphereLights: { value: [], properties: {
    			direction: {},
    			skyColor: {},
    			groundColor: {}
    		} }

    	},

    	points: {

    		diffuse: { value: new Color( 0xeeeeee ) },
    		opacity: { value: 1.0 },
    		size: { value: 1.0 },
    		scale: { value: 1.0 },
    		map: { value: null },
    		offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     */

    var ShaderLib = {

    	basic: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.fog

    		] ),

    		vertexShader: ShaderChunk.meshbasic_vert,
    		fragmentShader: ShaderChunk.meshbasic_frag

    	},

    	lambert: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.fog,
    			UniformsLib.lights,

    			{
    				emissive : { value: new Color( 0x000000 ) }
    			}

    		] ),

    		vertexShader: ShaderChunk.meshlambert_vert,
    		fragmentShader: ShaderChunk.meshlambert_frag

    	},

    	phong: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.bumpmap,
    			UniformsLib.normalmap,
    			UniformsLib.displacementmap,
    			UniformsLib.fog,
    			UniformsLib.lights,

    			{
    				emissive : { value: new Color( 0x000000 ) },
    				specular : { value: new Color( 0x111111 ) },
    				shininess: { value: 30 }
    			}

    		] ),

    		vertexShader: ShaderChunk.meshphong_vert,
    		fragmentShader: ShaderChunk.meshphong_frag

    	},

    	standard: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.bumpmap,
    			UniformsLib.normalmap,
    			UniformsLib.displacementmap,
    			UniformsLib.roughnessmap,
    			UniformsLib.metalnessmap,
    			UniformsLib.fog,
    			UniformsLib.lights,

    			{
    				emissive : { value: new Color( 0x000000 ) },
    				roughness: { value: 0.5 },
    				metalness: { value: 0 },
    				envMapIntensity : { value: 1 }, // temporary
    			}

    		] ),

    		vertexShader: ShaderChunk.meshphysical_vert,
    		fragmentShader: ShaderChunk.meshphysical_frag

    	},

    	points: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.points,
    			UniformsLib.fog

    		] ),

    		vertexShader: ShaderChunk.points_vert,
    		fragmentShader: ShaderChunk.points_frag

    	},

    	dashed: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.fog,

    			{
    				scale    : { value: 1 },
    				dashSize : { value: 1 },
    				totalSize: { value: 2 }
    			}

    		] ),

    		vertexShader: ShaderChunk.linedashed_vert,
    		fragmentShader: ShaderChunk.linedashed_frag

    	},

    	depth: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.displacementmap

    		] ),

    		vertexShader: ShaderChunk.depth_vert,
    		fragmentShader: ShaderChunk.depth_frag

    	},

    	normal: {

    		uniforms: {

    			opacity : { value: 1.0 }

    		},

    		vertexShader: ShaderChunk.normal_vert,
    		fragmentShader: ShaderChunk.normal_frag

    	},

    	/* -------------------------------------------------------------------------
    	//	Cube map shader
    	 ------------------------------------------------------------------------- */

    	cube: {

    		uniforms: {
    			tCube: { value: null },
    			tFlip: { value: - 1 },
    			opacity: { value: 1.0 }
    		},

    		vertexShader: ShaderChunk.cube_vert,
    		fragmentShader: ShaderChunk.cube_frag

    	},

    	/* -------------------------------------------------------------------------
    	//	Cube map shader
    	 ------------------------------------------------------------------------- */

    	equirect: {

    		uniforms: {
    			tEquirect: { value: null },
    			tFlip: { value: - 1 }
    		},

    		vertexShader: ShaderChunk.equirect_vert,
    		fragmentShader: ShaderChunk.equirect_frag

    	},

    	distanceRGBA: {

    		uniforms: {

    			lightPos: { value: new Vector3() }

    		},

    		vertexShader: ShaderChunk.distanceRGBA_vert,
    		fragmentShader: ShaderChunk.distanceRGBA_frag

    	}

    };

    ShaderLib.physical = {

    	uniforms: exports.UniformsUtils.merge( [

    		ShaderLib.standard.uniforms,

    		{
    			clearCoat: { value: 0 },
    			clearCoatRoughness: { value: 0 }
    		}

    	] ),

    	vertexShader: ShaderChunk.meshphysical_vert,
    	fragmentShader: ShaderChunk.meshphysical_frag

    };

    /**
     * @author bhouston / http://clara.io
     */

    function Box2( min, max ) {

    	this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
    	this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

    }

    Box2.prototype = {

    	constructor: Box2,

    	set: function ( min, max ) {

    		this.min.copy( min );
    		this.max.copy( max );

    		return this;

    	},

    	setFromPoints: function ( points ) {

    		this.makeEmpty();

    		for ( var i = 0, il = points.length; i < il; i ++ ) {

    			this.expandByPoint( points[ i ] );

    		}

    		return this;

    	},

    	setFromCenterAndSize: function () {

    		var v1 = new Vector2();

    		return function setFromCenterAndSize( center, size ) {

    			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
    			this.min.copy( center ).sub( halfSize );
    			this.max.copy( center ).add( halfSize );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( box ) {

    		this.min.copy( box.min );
    		this.max.copy( box.max );

    		return this;

    	},

    	makeEmpty: function () {

    		this.min.x = this.min.y = + Infinity;
    		this.max.x = this.max.y = - Infinity;

    		return this;

    	},

    	isEmpty: function () {

    		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

    	},

    	getCenter: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector2();
    		return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    	},

    	getSize: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector2();
    		return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );

    	},

    	expandByPoint: function ( point ) {

    		this.min.min( point );
    		this.max.max( point );

    		return this;

    	},

    	expandByVector: function ( vector ) {

    		this.min.sub( vector );
    		this.max.add( vector );

    		return this;

    	},

    	expandByScalar: function ( scalar ) {

    		this.min.addScalar( - scalar );
    		this.max.addScalar( scalar );

    		return this;

    	},

    	containsPoint: function ( point ) {

    		if ( point.x < this.min.x || point.x > this.max.x ||
    		     point.y < this.min.y || point.y > this.max.y ) {

    			return false;

    		}

    		return true;

    	},

    	containsBox: function ( box ) {

    		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
    		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

    			return true;

    		}

    		return false;

    	},

    	getParameter: function ( point, optionalTarget ) {

    		// This can potentially have a divide by zero if the box
    		// has a size dimension of 0.

    		var result = optionalTarget || new Vector2();

    		return result.set(
    			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
    			( point.y - this.min.y ) / ( this.max.y - this.min.y )
    		);

    	},

    	intersectsBox: function ( box ) {

    		// using 6 splitting planes to rule out intersections.

    		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
    		     box.max.y < this.min.y || box.min.y > this.max.y ) {

    			return false;

    		}

    		return true;

    	},

    	clampPoint: function ( point, optionalTarget ) {

    		var result = optionalTarget || new Vector2();
    		return result.copy( point ).clamp( this.min, this.max );

    	},

    	distanceToPoint: function () {

    		var v1 = new Vector2();

    		return function distanceToPoint( point ) {

    			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
    			return clampedPoint.sub( point ).length();

    		};

    	}(),

    	intersect: function ( box ) {

    		this.min.max( box.min );
    		this.max.min( box.max );

    		return this;

    	},

    	union: function ( box ) {

    		this.min.min( box.min );
    		this.max.max( box.max );

    		return this;

    	},

    	translate: function ( offset ) {

    		this.min.add( offset );
    		this.max.add( offset );

    		return this;

    	},

    	equals: function ( box ) {

    		return box.min.equals( this.min ) && box.max.equals( this.max );

    	}

    };

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function LensFlarePlugin( renderer, flares ) {

    	var gl = renderer.context;
    	var state = renderer.state;

    	var vertexBuffer, elementBuffer;
    	var shader, program, attributes, uniforms;

    	var tempTexture, occlusionTexture;

    	function init() {

    		var vertices = new Float32Array( [
    			- 1, - 1,  0, 0,
    			 1, - 1,  1, 0,
    			 1,  1,  1, 1,
    			- 1,  1,  0, 1
    		] );

    		var faces = new Uint16Array( [
    			0, 1, 2,
    			0, 2, 3
    		] );

    		// buffers

    		vertexBuffer     = gl.createBuffer();
    		elementBuffer    = gl.createBuffer();

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    		// textures

    		tempTexture      = gl.createTexture();
    		occlusionTexture = gl.createTexture();

    		state.bindTexture( gl.TEXTURE_2D, tempTexture );
    		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
    		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    		shader = {

    			vertexShader: [

    				"uniform lowp int renderType;",

    				"uniform vec3 screenPosition;",
    				"uniform vec2 scale;",
    				"uniform float rotation;",

    				"uniform sampler2D occlusionMap;",

    				"attribute vec2 position;",
    				"attribute vec2 uv;",

    				"varying vec2 vUV;",
    				"varying float vVisibility;",

    				"void main() {",

    					"vUV = uv;",

    					"vec2 pos = position;",

    					"if ( renderType == 2 ) {",

    						"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

    						"vVisibility =        visibility.r / 9.0;",
    						"vVisibility *= 1.0 - visibility.g / 9.0;",
    						"vVisibility *=       visibility.b / 9.0;",
    						"vVisibility *= 1.0 - visibility.a / 9.0;",

    						"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
    						"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

    					"}",

    					"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

    				"}"

    			].join( "\n" ),

    			fragmentShader: [

    				"uniform lowp int renderType;",

    				"uniform sampler2D map;",
    				"uniform float opacity;",
    				"uniform vec3 color;",

    				"varying vec2 vUV;",
    				"varying float vVisibility;",

    				"void main() {",

    					// pink square

    					"if ( renderType == 0 ) {",

    						"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

    					// restore

    					"} else if ( renderType == 1 ) {",

    						"gl_FragColor = texture2D( map, vUV );",

    					// flare

    					"} else {",

    						"vec4 texture = texture2D( map, vUV );",
    						"texture.a *= opacity * vVisibility;",
    						"gl_FragColor = texture;",
    						"gl_FragColor.rgb *= color;",

    					"}",

    				"}"

    			].join( "\n" )

    		};

    		program = createProgram( shader );

    		attributes = {
    			vertex: gl.getAttribLocation ( program, "position" ),
    			uv:     gl.getAttribLocation ( program, "uv" )
    		};

    		uniforms = {
    			renderType:     gl.getUniformLocation( program, "renderType" ),
    			map:            gl.getUniformLocation( program, "map" ),
    			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
    			opacity:        gl.getUniformLocation( program, "opacity" ),
    			color:          gl.getUniformLocation( program, "color" ),
    			scale:          gl.getUniformLocation( program, "scale" ),
    			rotation:       gl.getUniformLocation( program, "rotation" ),
    			screenPosition: gl.getUniformLocation( program, "screenPosition" )
    		};

    	}

    	/*
    	 * Render lens flares
    	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
    	 *         reads these back and calculates occlusion.
    	 */

    	this.render = function ( scene, camera, viewport ) {

    		if ( flares.length === 0 ) return;

    		var tempPosition = new Vector3();

    		var invAspect = viewport.w / viewport.z,
    			halfViewportWidth = viewport.z * 0.5,
    			halfViewportHeight = viewport.w * 0.5;

    		var size = 16 / viewport.w,
    			scale = new Vector2( size * invAspect, size );

    		var screenPosition = new Vector3( 1, 1, 0 ),
    			screenPositionPixels = new Vector2( 1, 1 );

    		var validArea = new Box2();

    		validArea.min.set( 0, 0 );
    		validArea.max.set( viewport.z - 16, viewport.w - 16 );

    		if ( program === undefined ) {

    			init();

    		}

    		gl.useProgram( program );

    		state.initAttributes();
    		state.enableAttribute( attributes.vertex );
    		state.enableAttribute( attributes.uv );
    		state.disableUnusedAttributes();

    		// loop through all lens flares to update their occlusion and positions
    		// setup gl and common used attribs/uniforms

    		gl.uniform1i( uniforms.occlusionMap, 0 );
    		gl.uniform1i( uniforms.map, 1 );

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
    		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    		state.disable( gl.CULL_FACE );
    		state.setDepthWrite( false );

    		for ( var i = 0, l = flares.length; i < l; i ++ ) {

    			size = 16 / viewport.w;
    			scale.set( size * invAspect, size );

    			// calc object screen position

    			var flare = flares[ i ];

    			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

    			tempPosition.applyMatrix4( camera.matrixWorldInverse );
    			tempPosition.applyProjection( camera.projectionMatrix );

    			// setup arrays for gl programs

    			screenPosition.copy( tempPosition );

    			// horizontal and vertical coordinate of the lower left corner of the pixels to copy

    			screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
    			screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

    			// screen cull

    			if ( validArea.containsPoint( screenPositionPixels ) === true ) {

    				// save current RGB to temp texture

    				state.activeTexture( gl.TEXTURE0 );
    				state.bindTexture( gl.TEXTURE_2D, null );
    				state.activeTexture( gl.TEXTURE1 );
    				state.bindTexture( gl.TEXTURE_2D, tempTexture );
    				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


    				// render pink quad

    				gl.uniform1i( uniforms.renderType, 0 );
    				gl.uniform2f( uniforms.scale, scale.x, scale.y );
    				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

    				state.disable( gl.BLEND );
    				state.enable( gl.DEPTH_TEST );

    				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


    				// copy result to occlusionMap

    				state.activeTexture( gl.TEXTURE0 );
    				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
    				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


    				// restore graphics

    				gl.uniform1i( uniforms.renderType, 1 );
    				state.disable( gl.DEPTH_TEST );

    				state.activeTexture( gl.TEXTURE1 );
    				state.bindTexture( gl.TEXTURE_2D, tempTexture );
    				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


    				// update object positions

    				flare.positionScreen.copy( screenPosition );

    				if ( flare.customUpdateCallback ) {

    					flare.customUpdateCallback( flare );

    				} else {

    					flare.updateLensFlares();

    				}

    				// render flares

    				gl.uniform1i( uniforms.renderType, 2 );
    				state.enable( gl.BLEND );

    				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

    					var sprite = flare.lensFlares[ j ];

    					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

    						screenPosition.x = sprite.x;
    						screenPosition.y = sprite.y;
    						screenPosition.z = sprite.z;

    						size = sprite.size * sprite.scale / viewport.w;

    						scale.x = size * invAspect;
    						scale.y = size;

    						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
    						gl.uniform2f( uniforms.scale, scale.x, scale.y );
    						gl.uniform1f( uniforms.rotation, sprite.rotation );

    						gl.uniform1f( uniforms.opacity, sprite.opacity );
    						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

    						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
    						renderer.setTexture2D( sprite.texture, 1 );

    						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    					}

    				}

    			}

    		}

    		// restore gl

    		state.enable( gl.CULL_FACE );
    		state.enable( gl.DEPTH_TEST );
    		state.setDepthWrite( true );

    		renderer.resetGLState();

    	};

    	function createProgram( shader ) {

    		var program = gl.createProgram();

    		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
    		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

    		var prefix = "precision " + renderer.getPrecision() + " float;\n";

    		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
    		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

    		gl.compileShader( fragmentShader );
    		gl.compileShader( vertexShader );

    		gl.attachShader( program, fragmentShader );
    		gl.attachShader( program, vertexShader );

    		gl.linkProgram( program );

    		return program;

    	}

    }

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function SpritePlugin( renderer, sprites ) {

    	var gl = renderer.context;
    	var state = renderer.state;

    	var vertexBuffer, elementBuffer;
    	var program, attributes, uniforms;

    	var texture;

    	// decompose matrixWorld

    	var spritePosition = new Vector3();
    	var spriteRotation = new Quaternion();
    	var spriteScale = new Vector3();

    	function init() {

    		var vertices = new Float32Array( [
    			- 0.5, - 0.5,  0, 0,
    			  0.5, - 0.5,  1, 0,
    			  0.5,   0.5,  1, 1,
    			- 0.5,   0.5,  0, 1
    		] );

    		var faces = new Uint16Array( [
    			0, 1, 2,
    			0, 2, 3
    		] );

    		vertexBuffer  = gl.createBuffer();
    		elementBuffer = gl.createBuffer();

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    		program = createProgram();

    		attributes = {
    			position:			gl.getAttribLocation ( program, 'position' ),
    			uv:					gl.getAttribLocation ( program, 'uv' )
    		};

    		uniforms = {
    			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
    			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

    			rotation:			gl.getUniformLocation( program, 'rotation' ),
    			scale:				gl.getUniformLocation( program, 'scale' ),

    			color:				gl.getUniformLocation( program, 'color' ),
    			map:				gl.getUniformLocation( program, 'map' ),
    			opacity:			gl.getUniformLocation( program, 'opacity' ),

    			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
    			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

    			fogType:			gl.getUniformLocation( program, 'fogType' ),
    			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
    			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
    			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
    			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

    			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
    		};

    		var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    		canvas.width = 8;
    		canvas.height = 8;

    		var context = canvas.getContext( '2d' );
    		context.fillStyle = 'white';
    		context.fillRect( 0, 0, 8, 8 );

    		texture = new Texture( canvas );
    		texture.needsUpdate = true;

    	}

    	this.render = function ( scene, camera ) {

    		if ( sprites.length === 0 ) return;

    		// setup gl

    		if ( program === undefined ) {

    			init();

    		}

    		gl.useProgram( program );

    		state.initAttributes();
    		state.enableAttribute( attributes.position );
    		state.enableAttribute( attributes.uv );
    		state.disableUnusedAttributes();

    		state.disable( gl.CULL_FACE );
    		state.enable( gl.BLEND );

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
    		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

    		state.activeTexture( gl.TEXTURE0 );
    		gl.uniform1i( uniforms.map, 0 );

    		var oldFogType = 0;
    		var sceneFogType = 0;
    		var fog = scene.fog;

    		if ( fog ) {

    			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

    			if ( (fog && fog.isFog) ) {

    				gl.uniform1f( uniforms.fogNear, fog.near );
    				gl.uniform1f( uniforms.fogFar, fog.far );

    				gl.uniform1i( uniforms.fogType, 1 );
    				oldFogType = 1;
    				sceneFogType = 1;

    			} else if ( (fog && fog.isFogExp2) ) {

    				gl.uniform1f( uniforms.fogDensity, fog.density );

    				gl.uniform1i( uniforms.fogType, 2 );
    				oldFogType = 2;
    				sceneFogType = 2;

    			}

    		} else {

    			gl.uniform1i( uniforms.fogType, 0 );
    			oldFogType = 0;
    			sceneFogType = 0;

    		}


    		// update positions and sort

    		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

    			var sprite = sprites[ i ];

    			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
    			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

    		}

    		sprites.sort( painterSortStable );

    		// render all sprites

    		var scale = [];

    		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

    			var sprite = sprites[ i ];
    			var material = sprite.material;

    			if ( material.visible === false ) continue;

    			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
    			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

    			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

    			scale[ 0 ] = spriteScale.x;
    			scale[ 1 ] = spriteScale.y;

    			var fogType = 0;

    			if ( scene.fog && material.fog ) {

    				fogType = sceneFogType;

    			}

    			if ( oldFogType !== fogType ) {

    				gl.uniform1i( uniforms.fogType, fogType );
    				oldFogType = fogType;

    			}

    			if ( material.map !== null ) {

    				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
    				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

    			} else {

    				gl.uniform2f( uniforms.uvOffset, 0, 0 );
    				gl.uniform2f( uniforms.uvScale, 1, 1 );

    			}

    			gl.uniform1f( uniforms.opacity, material.opacity );
    			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

    			gl.uniform1f( uniforms.rotation, material.rotation );
    			gl.uniform2fv( uniforms.scale, scale );

    			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
    			state.setDepthTest( material.depthTest );
    			state.setDepthWrite( material.depthWrite );

    			if ( material.map ) {

    				renderer.setTexture2D( material.map, 0 );

    			} else {

    				renderer.setTexture2D( texture, 0 );

    			}

    			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    		}

    		// restore gl

    		state.enable( gl.CULL_FACE );

    		renderer.resetGLState();

    	};

    	function createProgram() {

    		var program = gl.createProgram();

    		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
    		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

    		gl.shaderSource( vertexShader, [

    			'precision ' + renderer.getPrecision() + ' float;',

    			'uniform mat4 modelViewMatrix;',
    			'uniform mat4 projectionMatrix;',
    			'uniform float rotation;',
    			'uniform vec2 scale;',
    			'uniform vec2 uvOffset;',
    			'uniform vec2 uvScale;',

    			'attribute vec2 position;',
    			'attribute vec2 uv;',

    			'varying vec2 vUV;',

    			'void main() {',

    				'vUV = uvOffset + uv * uvScale;',

    				'vec2 alignedPosition = position * scale;',

    				'vec2 rotatedPosition;',
    				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
    				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

    				'vec4 finalPosition;',

    				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
    				'finalPosition.xy += rotatedPosition;',
    				'finalPosition = projectionMatrix * finalPosition;',

    				'gl_Position = finalPosition;',

    			'}'

    		].join( '\n' ) );

    		gl.shaderSource( fragmentShader, [

    			'precision ' + renderer.getPrecision() + ' float;',

    			'uniform vec3 color;',
    			'uniform sampler2D map;',
    			'uniform float opacity;',

    			'uniform int fogType;',
    			'uniform vec3 fogColor;',
    			'uniform float fogDensity;',
    			'uniform float fogNear;',
    			'uniform float fogFar;',
    			'uniform float alphaTest;',

    			'varying vec2 vUV;',

    			'void main() {',

    				'vec4 texture = texture2D( map, vUV );',

    				'if ( texture.a < alphaTest ) discard;',

    				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

    				'if ( fogType > 0 ) {',

    					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
    					'float fogFactor = 0.0;',

    					'if ( fogType == 1 ) {',

    						'fogFactor = smoothstep( fogNear, fogFar, depth );',

    					'} else {',

    						'const float LOG2 = 1.442695;',
    						'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
    						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

    					'}',

    					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

    				'}',

    			'}'

    		].join( '\n' ) );

    		gl.compileShader( vertexShader );
    		gl.compileShader( fragmentShader );

    		gl.attachShader( program, vertexShader );
    		gl.attachShader( program, fragmentShader );

    		gl.linkProgram( program );

    		return program;

    	}

    	function painterSortStable( a, b ) {

    		if ( a.renderOrder !== b.renderOrder ) {

    			return a.renderOrder - b.renderOrder;

    		} else if ( a.z !== b.z ) {

    			return b.z - a.z;

    		} else {

    			return b.id - a.id;

    		}

    	}

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Material() {

    	Object.defineProperty( this, 'id', { value: MaterialIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'Material';

    	this.fog = true;
    	this.lights = true;

    	this.blending = NormalBlending;
    	this.side = FrontSide;
    	this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
    	this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

    	this.opacity = 1;
    	this.transparent = false;

    	this.blendSrc = SrcAlphaFactor;
    	this.blendDst = OneMinusSrcAlphaFactor;
    	this.blendEquation = AddEquation;
    	this.blendSrcAlpha = null;
    	this.blendDstAlpha = null;
    	this.blendEquationAlpha = null;

    	this.depthFunc = LessEqualDepth;
    	this.depthTest = true;
    	this.depthWrite = true;

    	this.clippingPlanes = null;
    	this.clipShadows = false;

    	this.colorWrite = true;

    	this.precision = null; // override the renderer's default precision for this material

    	this.polygonOffset = false;
    	this.polygonOffsetFactor = 0;
    	this.polygonOffsetUnits = 0;

    	this.alphaTest = 0;
    	this.premultipliedAlpha = false;

    	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

    	this.visible = true;

    	this._needsUpdate = true;

    }

    Material.prototype = {

    	constructor: Material,

    	isMaterial: true,

    	get needsUpdate() {

    		return this._needsUpdate;

    	},

    	set needsUpdate( value ) {

    		if ( value === true ) this.update();
    		this._needsUpdate = value;

    	},

    	setValues: function ( values ) {

    		if ( values === undefined ) return;

    		for ( var key in values ) {

    			var newValue = values[ key ];

    			if ( newValue === undefined ) {

    				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
    				continue;

    			}

    			var currentValue = this[ key ];

    			if ( currentValue === undefined ) {

    				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
    				continue;

    			}

    			if ( (currentValue && currentValue.isColor) ) {

    				currentValue.set( newValue );

    			} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {

    				currentValue.copy( newValue );

    			} else if ( key === 'overdraw' ) {

    				// ensure overdraw is backwards-compatible with legacy boolean type
    				this[ key ] = Number( newValue );

    			} else {

    				this[ key ] = newValue;

    			}

    		}

    	},

    	toJSON: function ( meta ) {

    		var isRoot = meta === undefined;

    		if ( isRoot ) {

    			meta = {
    				textures: {},
    				images: {}
    			};

    		}

    		var data = {
    			metadata: {
    				version: 4.4,
    				type: 'Material',
    				generator: 'Material.toJSON'
    			}
    		};

    		// standard Material serialization
    		data.uuid = this.uuid;
    		data.type = this.type;

    		if ( this.name !== '' ) data.name = this.name;

    		if ( (this.color && this.color.isColor) ) data.color = this.color.getHex();

    		if ( this.roughness !== undefined ) data.roughness = this.roughness;
    		if ( this.metalness !== undefined ) data.metalness = this.metalness;

    		if ( (this.emissive && this.emissive.isColor) ) data.emissive = this.emissive.getHex();
    		if ( (this.specular && this.specular.isColor) ) data.specular = this.specular.getHex();
    		if ( this.shininess !== undefined ) data.shininess = this.shininess;

    		if ( (this.map && this.map.isTexture) ) data.map = this.map.toJSON( meta ).uuid;
    		if ( (this.alphaMap && this.alphaMap.isTexture) ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
    		if ( (this.lightMap && this.lightMap.isTexture) ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
    		if ( (this.bumpMap && this.bumpMap.isTexture) ) {

    			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
    			data.bumpScale = this.bumpScale;

    		}
    		if ( (this.normalMap && this.normalMap.isTexture) ) {

    			data.normalMap = this.normalMap.toJSON( meta ).uuid;
    			data.normalScale = this.normalScale.toArray();

    		}
    		if ( (this.displacementMap && this.displacementMap.isTexture) ) {

    			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
    			data.displacementScale = this.displacementScale;
    			data.displacementBias = this.displacementBias;

    		}
    		if ( (this.roughnessMap && this.roughnessMap.isTexture) ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
    		if ( (this.metalnessMap && this.metalnessMap.isTexture) ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

    		if ( (this.emissiveMap && this.emissiveMap.isTexture) ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
    		if ( (this.specularMap && this.specularMap.isTexture) ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

    		if ( (this.envMap && this.envMap.isTexture) ) {

    			data.envMap = this.envMap.toJSON( meta ).uuid;
    			data.reflectivity = this.reflectivity; // Scale behind envMap

    		}

    		if ( this.size !== undefined ) data.size = this.size;
    		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

    		if ( this.blending !== NormalBlending ) data.blending = this.blending;
    		if ( this.shading !== SmoothShading ) data.shading = this.shading;
    		if ( this.side !== FrontSide ) data.side = this.side;
    		if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

    		if ( this.opacity < 1 ) data.opacity = this.opacity;
    		if ( this.transparent === true ) data.transparent = this.transparent;

    		data.depthFunc = this.depthFunc;
    		data.depthTest = this.depthTest;
    		data.depthWrite = this.depthWrite;

    		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
    		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
    		if ( this.wireframe === true ) data.wireframe = this.wireframe;
    		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
    		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
    		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

    		data.skinning = this.skinning;
    		data.morphTargets = this.morphTargets;

    		// TODO: Copied from Object3D.toJSON

    		function extractFromCache( cache ) {

    			var values = [];

    			for ( var key in cache ) {

    				var data = cache[ key ];
    				delete data.metadata;
    				values.push( data );

    			}

    			return values;

    		}

    		if ( isRoot ) {

    			var textures = extractFromCache( meta.textures );
    			var images = extractFromCache( meta.images );

    			if ( textures.length > 0 ) data.textures = textures;
    			if ( images.length > 0 ) data.images = images;

    		}

    		return data;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.name = source.name;

    		this.fog = source.fog;
    		this.lights = source.lights;

    		this.blending = source.blending;
    		this.side = source.side;
    		this.shading = source.shading;
    		this.vertexColors = source.vertexColors;

    		this.opacity = source.opacity;
    		this.transparent = source.transparent;

    		this.blendSrc = source.blendSrc;
    		this.blendDst = source.blendDst;
    		this.blendEquation = source.blendEquation;
    		this.blendSrcAlpha = source.blendSrcAlpha;
    		this.blendDstAlpha = source.blendDstAlpha;
    		this.blendEquationAlpha = source.blendEquationAlpha;

    		this.depthFunc = source.depthFunc;
    		this.depthTest = source.depthTest;
    		this.depthWrite = source.depthWrite;

    		this.colorWrite = source.colorWrite;

    		this.precision = source.precision;

    		this.polygonOffset = source.polygonOffset;
    		this.polygonOffsetFactor = source.polygonOffsetFactor;
    		this.polygonOffsetUnits = source.polygonOffsetUnits;

    		this.alphaTest = source.alphaTest;

    		this.premultipliedAlpha = source.premultipliedAlpha;

    		this.overdraw = source.overdraw;

    		this.visible = source.visible;
    		this.clipShadows = source.clipShadows;

    		var srcPlanes = source.clippingPlanes,
    			dstPlanes = null;

    		if ( srcPlanes !== null ) {

    			var n = srcPlanes.length;
    			dstPlanes = new Array( n );

    			for ( var i = 0; i !== n; ++ i )
    				dstPlanes[ i ] = srcPlanes[ i ].clone();

    		}

    		this.clippingPlanes = dstPlanes;

    		return this;

    	},

    	update: function () {

    		this.dispatchEvent( { type: 'update' } );

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    };

    Object.assign( Material.prototype, EventDispatcher.prototype );

    var count$1 = 0;
    function MaterialIdCount() { return count$1++; };

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  defines: { "label" : "value" },
     *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
     *
     *  fragmentShader: <string>,
     *  vertexShader: <string>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  lights: <bool>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function ShaderMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'ShaderMaterial';

    	this.defines = {};
    	this.uniforms = {};

    	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
    	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

    	this.linewidth = 1;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;

    	this.fog = false; // set to use scene fog
    	this.lights = false; // set to use scene lights
    	this.clipping = false; // set to use user-defined clipping planes

    	this.skinning = false; // set to use skinning attribute streams
    	this.morphTargets = false; // set to use morph targets
    	this.morphNormals = false; // set to use morph normals

    	this.extensions = {
    		derivatives: false, // set to use derivatives
    		fragDepth: false, // set to use fragment depth values
    		drawBuffers: false, // set to use draw buffers
    		shaderTextureLOD: false // set to use shader texture LOD
    	};

    	// When rendered geometry doesn't include these attributes but the material does,
    	// use these default values in WebGL. This avoids errors when buffer data is missing.
    	this.defaultAttributeValues = {
    		'color': [ 1, 1, 1 ],
    		'uv': [ 0, 0 ],
    		'uv2': [ 0, 0 ]
    	};

    	this.index0AttributeName = undefined;

    	if ( parameters !== undefined ) {

    		if ( parameters.attributes !== undefined ) {

    			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

    		}

    		this.setValues( parameters );

    	}

    }

    ShaderMaterial.prototype = Object.create( Material.prototype );
    ShaderMaterial.prototype.constructor = ShaderMaterial;

    ShaderMaterial.prototype.isShaderMaterial = true;

    ShaderMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.fragmentShader = source.fragmentShader;
    	this.vertexShader = source.vertexShader;

    	this.uniforms = exports.UniformsUtils.clone( source.uniforms );

    	this.defines = source.defines;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;

    	this.lights = source.lights;
    	this.clipping = source.clipping;

    	this.skinning = source.skinning;

    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	this.extensions = source.extensions;

    	return this;

    };

    ShaderMaterial.prototype.toJSON = function ( meta ) {

    	var data = Material.prototype.toJSON.call( this, meta );

    	data.uniforms = this.uniforms;
    	data.vertexShader = this.vertexShader;
    	data.fragmentShader = this.fragmentShader;

    	return data;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author bhouston / https://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     * }
     */

    function MeshDepthMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshDepthMaterial';

    	this.depthPacking = BasicDepthPacking;

    	this.skinning = false;
    	this.morphTargets = false;

    	this.map = null;

    	this.alphaMap = null;

    	this.displacementMap = null;
    	this.displacementScale = 1;
    	this.displacementBias = 0;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;

    	this.fog = false;
    	this.lights = false;

    	this.setValues( parameters );

    }

    MeshDepthMaterial.prototype = Object.create( Material.prototype );
    MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

    MeshDepthMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.depthPacking = source.depthPacking;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;

    	this.map = source.map;

    	this.alphaMap = source.alphaMap;

    	this.displacementMap = source.displacementMap;
    	this.displacementScale = source.displacementScale;
    	this.displacementBias = source.displacementBias;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;

    	return this;

    };

    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */

    function Box3( min, max ) {

    	this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
    	this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

    }

    Box3.prototype = {

    	constructor: Box3,

    	isBox3: true,

    	set: function ( min, max ) {

    		this.min.copy( min );
    		this.max.copy( max );

    		return this;

    	},

    	setFromArray: function ( array ) {

    		var minX = + Infinity;
    		var minY = + Infinity;
    		var minZ = + Infinity;

    		var maxX = - Infinity;
    		var maxY = - Infinity;
    		var maxZ = - Infinity;

    		for ( var i = 0, l = array.length; i < l; i += 3 ) {

    			var x = array[ i ];
    			var y = array[ i + 1 ];
    			var z = array[ i + 2 ];

    			if ( x < minX ) minX = x;
    			if ( y < minY ) minY = y;
    			if ( z < minZ ) minZ = z;

    			if ( x > maxX ) maxX = x;
    			if ( y > maxY ) maxY = y;
    			if ( z > maxZ ) maxZ = z;

    		}

    		this.min.set( minX, minY, minZ );
    		this.max.set( maxX, maxY, maxZ );

    	},

    	setFromPoints: function ( points ) {

    		this.makeEmpty();

    		for ( var i = 0, il = points.length; i < il; i ++ ) {

    			this.expandByPoint( points[ i ] );

    		}

    		return this;

    	},

    	setFromCenterAndSize: function () {

    		var v1 = new Vector3();

    		return function setFromCenterAndSize( center, size ) {

    			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

    			this.min.copy( center ).sub( halfSize );
    			this.max.copy( center ).add( halfSize );

    			return this;

    		};

    	}(),

    	setFromObject: function () {

    		// Computes the world-axis-aligned bounding box of an object (including its children),
    		// accounting for both the object's, and children's, world transforms

    		var v1 = new Vector3();

    		return function setFromObject( object ) {

    			var scope = this;

    			object.updateMatrixWorld( true );

    			this.makeEmpty();

    			object.traverse( function ( node ) {

    				var geometry = node.geometry;

    				if ( geometry !== undefined ) {

    					if ( (geometry && geometry.isGeometry) ) {

    						var vertices = geometry.vertices;

    						for ( var i = 0, il = vertices.length; i < il; i ++ ) {

    							v1.copy( vertices[ i ] );
    							v1.applyMatrix4( node.matrixWorld );

    							scope.expandByPoint( v1 );

    						}

    					} else if ( (geometry && geometry.isBufferGeometry) ) {

    						var attribute = geometry.attributes.position;

    						if ( attribute !== undefined ) {

    							var array, offset, stride;

    							if ( (attribute && attribute.isInterleavedBufferAttribute) ) {

    								array = attribute.data.array;
    								offset = attribute.offset;
    								stride = attribute.data.stride;

    							} else {

    								array = attribute.array;
    								offset = 0;
    								stride = 3;

    							}

    							for ( var i = offset, il = array.length; i < il; i += stride ) {

    								v1.fromArray( array, i );
    								v1.applyMatrix4( node.matrixWorld );

    								scope.expandByPoint( v1 );

    							}

    						}

    					}

    				}

    			} );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( box ) {

    		this.min.copy( box.min );
    		this.max.copy( box.max );

    		return this;

    	},

    	makeEmpty: function () {

    		this.min.x = this.min.y = this.min.z = + Infinity;
    		this.max.x = this.max.y = this.max.z = - Infinity;

    		return this;

    	},

    	isEmpty: function () {

    		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

    	},

    	getCenter: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    	},

    	getSize: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

    	},

    	expandByPoint: function ( point ) {

    		this.min.min( point );
    		this.max.max( point );

    		return this;

    	},

    	expandByVector: function ( vector ) {

    		this.min.sub( vector );
    		this.max.add( vector );

    		return this;

    	},

    	expandByScalar: function ( scalar ) {

    		this.min.addScalar( - scalar );
    		this.max.addScalar( scalar );

    		return this;

    	},

    	containsPoint: function ( point ) {

    		if ( point.x < this.min.x || point.x > this.max.x ||
    				 point.y < this.min.y || point.y > this.max.y ||
    				 point.z < this.min.z || point.z > this.max.z ) {

    			return false;

    		}

    		return true;

    	},

    	containsBox: function ( box ) {

    		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
    			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
    			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

    			return true;

    		}

    		return false;

    	},

    	getParameter: function ( point, optionalTarget ) {

    		// This can potentially have a divide by zero if the box
    		// has a size dimension of 0.

    		var result = optionalTarget || new Vector3();

    		return result.set(
    			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
    			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
    			( point.z - this.min.z ) / ( this.max.z - this.min.z )
    		);

    	},

    	intersectsBox: function ( box ) {

    		// using 6 splitting planes to rule out intersections.

    		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
    				 box.max.y < this.min.y || box.min.y > this.max.y ||
    				 box.max.z < this.min.z || box.min.z > this.max.z ) {

    			return false;

    		}

    		return true;

    	},

    	intersectsSphere: ( function () {

    		var closestPoint;

    		return function intersectsSphere( sphere ) {

    			if ( closestPoint === undefined ) closestPoint = new Vector3();

    			// Find the point on the AABB closest to the sphere center.
    			this.clampPoint( sphere.center, closestPoint );

    			// If that point is inside the sphere, the AABB and sphere intersect.
    			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

    		};

    	} )(),

    	intersectsPlane: function ( plane ) {

    		// We compute the minimum and maximum dot product values. If those values
    		// are on the same side (back or front) of the plane, then there is no intersection.

    		var min, max;

    		if ( plane.normal.x > 0 ) {

    			min = plane.normal.x * this.min.x;
    			max = plane.normal.x * this.max.x;

    		} else {

    			min = plane.normal.x * this.max.x;
    			max = plane.normal.x * this.min.x;

    		}

    		if ( plane.normal.y > 0 ) {

    			min += plane.normal.y * this.min.y;
    			max += plane.normal.y * this.max.y;

    		} else {

    			min += plane.normal.y * this.max.y;
    			max += plane.normal.y * this.min.y;

    		}

    		if ( plane.normal.z > 0 ) {

    			min += plane.normal.z * this.min.z;
    			max += plane.normal.z * this.max.z;

    		} else {

    			min += plane.normal.z * this.max.z;
    			max += plane.normal.z * this.min.z;

    		}

    		return ( min <= plane.constant && max >= plane.constant );

    	},

    	clampPoint: function ( point, optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.copy( point ).clamp( this.min, this.max );

    	},

    	distanceToPoint: function () {

    		var v1 = new Vector3();

    		return function distanceToPoint( point ) {

    			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
    			return clampedPoint.sub( point ).length();

    		};

    	}(),

    	getBoundingSphere: function () {

    		var v1 = new Vector3();

    		return function getBoundingSphere( optionalTarget ) {

    			var result = optionalTarget || new Sphere();

    			this.getCenter( result.center );

    			result.radius = this.size( v1 ).length() * 0.5;

    			return result;

    		};

    	}(),

    	intersect: function ( box ) {

    		this.min.max( box.min );
    		this.max.min( box.max );

    		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
    		if( this.isEmpty() ) this.makeEmpty();

    		return this;

    	},

    	union: function ( box ) {

    		this.min.min( box.min );
    		this.max.max( box.max );

    		return this;

    	},

    	applyMatrix4: function () {

    		var points = [
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3()
    		];

    		return function applyMatrix4( matrix ) {

    			// transform of empty box is an empty box.
    			if( this.isEmpty() ) return this;

    			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
    			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
    			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
    			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
    			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
    			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
    			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
    			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
    			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

    			this.setFromPoints( points );

    			return this;

    		};

    	}(),

    	translate: function ( offset ) {

    		this.min.add( offset );
    		this.max.add( offset );

    		return this;

    	},

    	equals: function ( box ) {

    		return box.min.equals( this.min ) && box.max.equals( this.max );

    	}

    };

    /**
     * @author bhouston / http://clara.io
     * @author mrdoob / http://mrdoob.com/
     */

    function Sphere( center, radius ) {

    	this.center = ( center !== undefined ) ? center : new Vector3();
    	this.radius = ( radius !== undefined ) ? radius : 0;

    }

    Sphere.prototype = {

    	constructor: Sphere,

    	set: function ( center, radius ) {

    		this.center.copy( center );
    		this.radius = radius;

    		return this;

    	},

    	setFromPoints: function () {

    		var box = new Box3();

    		return function setFromPoints( points, optionalCenter ) {

    			var center = this.center;

    			if ( optionalCenter !== undefined ) {

    				center.copy( optionalCenter );

    			} else {

    				box.setFromPoints( points ).getCenter( center );

    			}

    			var maxRadiusSq = 0;

    			for ( var i = 0, il = points.length; i < il; i ++ ) {

    				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

    			}

    			this.radius = Math.sqrt( maxRadiusSq );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( sphere ) {

    		this.center.copy( sphere.center );
    		this.radius = sphere.radius;

    		return this;

    	},

    	empty: function () {

    		return ( this.radius <= 0 );

    	},

    	containsPoint: function ( point ) {

    		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

    	},

    	distanceToPoint: function ( point ) {

    		return ( point.distanceTo( this.center ) - this.radius );

    	},

    	intersectsSphere: function ( sphere ) {

    		var radiusSum = this.radius + sphere.radius;

    		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

    	},

    	intersectsBox: function ( box ) {

    		return box.intersectsSphere( this );

    	},

    	intersectsPlane: function ( plane ) {

    		// We use the following equation to compute the signed distance from
    		// the center of the sphere to the plane.
    		//
    		// distance = q * n - d
    		//
    		// If this distance is greater than the radius of the sphere,
    		// then there is no intersection.

    		return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;

    	},

    	clampPoint: function ( point, optionalTarget ) {

    		var deltaLengthSq = this.center.distanceToSquared( point );

    		var result = optionalTarget || new Vector3();

    		result.copy( point );

    		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

    			result.sub( this.center ).normalize();
    			result.multiplyScalar( this.radius ).add( this.center );

    		}

    		return result;

    	},

    	getBoundingBox: function ( optionalTarget ) {

    		var box = optionalTarget || new Box3();

    		box.set( this.center, this.center );
    		box.expandByScalar( this.radius );

    		return box;

    	},

    	applyMatrix4: function ( matrix ) {

    		this.center.applyMatrix4( matrix );
    		this.radius = this.radius * matrix.getMaxScaleOnAxis();

    		return this;

    	},

    	translate: function ( offset ) {

    		this.center.add( offset );

    		return this;

    	},

    	equals: function ( sphere ) {

    		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     * @author tschw
     */

    function Matrix3() {

    	this.elements = new Float32Array( [

    		1, 0, 0,
    		0, 1, 0,
    		0, 0, 1

    	] );

    	if ( arguments.length > 0 ) {

    		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

    	}

    }

    Matrix3.prototype = {

    	constructor: Matrix3,

    	isMatrix3: true,

    	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

    		var te = this.elements;

    		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
    		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
    		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

    		return this;

    	},

    	identity: function () {

    		this.set(

    			1, 0, 0,
    			0, 1, 0,
    			0, 0, 1

    		);

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().fromArray( this.elements );

    	},

    	copy: function ( m ) {

    		var me = m.elements;

    		this.set(

    			me[ 0 ], me[ 3 ], me[ 6 ],
    			me[ 1 ], me[ 4 ], me[ 7 ],
    			me[ 2 ], me[ 5 ], me[ 8 ]

    		);

    		return this;

    	},

    	setFromMatrix4: function( m ) {

    		var me = m.elements;

    		this.set(

    			me[ 0 ], me[ 4 ], me[  8 ],
    			me[ 1 ], me[ 5 ], me[  9 ],
    			me[ 2 ], me[ 6 ], me[ 10 ]

    		);

    		return this;

    	},

    	applyToVector3Array: function () {

    		var v1;

    		return function applyToVector3Array( array, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = array.length;

    			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

    				v1.fromArray( array, j );
    				v1.applyMatrix3( this );
    				v1.toArray( array, j );

    			}

    			return array;

    		};

    	}(),

    	applyToBuffer: function () {

    		var v1;

    		return function applyToBuffer( buffer, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = buffer.length / buffer.itemSize;

    			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

    				v1.x = buffer.getX( j );
    				v1.y = buffer.getY( j );
    				v1.z = buffer.getZ( j );

    				v1.applyMatrix3( this );

    				buffer.setXYZ( v1.x, v1.y, v1.z );

    			}

    			return buffer;

    		};

    	}(),

    	multiplyScalar: function ( s ) {

    		var te = this.elements;

    		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
    		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
    		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

    		return this;

    	},

    	determinant: function () {

    		var te = this.elements;

    		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
    			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
    			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

    		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

    	},

    	getInverse: function ( matrix, throwOnDegenerate ) {

    		if ( (matrix && matrix.isMatrix4) ) {

    			console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );

    		}

    		var me = matrix.elements,
    			te = this.elements,

    			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
    			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
    			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

    			t11 = n33 * n22 - n32 * n23,
    			t12 = n32 * n13 - n33 * n12,
    			t13 = n23 * n12 - n22 * n13,

    			det = n11 * t11 + n21 * t12 + n31 * t13;

    		if ( det === 0 ) {

    			var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

    			if ( throwOnDegenerate === true ) {

    				throw new Error( msg );

    			} else {

    				console.warn( msg );

    			}

    			return this.identity();
    		}

    		var detInv = 1 / det;

    		te[ 0 ] = t11 * detInv;
    		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
    		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

    		te[ 3 ] = t12 * detInv;
    		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
    		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

    		te[ 6 ] = t13 * detInv;
    		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
    		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

    		return this;

    	},

    	transpose: function () {

    		var tmp, m = this.elements;

    		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
    		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
    		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

    		return this;

    	},

    	flattenToArrayOffset: function ( array, offset ) {

    		console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
    				"- just use .toArray instead." );

    		return this.toArray( array, offset );

    	},

    	getNormalMatrix: function ( matrix4 ) {

    		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

    	},

    	transposeIntoArray: function ( r ) {

    		var m = this.elements;

    		r[ 0 ] = m[ 0 ];
    		r[ 1 ] = m[ 3 ];
    		r[ 2 ] = m[ 6 ];
    		r[ 3 ] = m[ 1 ];
    		r[ 4 ] = m[ 4 ];
    		r[ 5 ] = m[ 7 ];
    		r[ 6 ] = m[ 2 ];
    		r[ 7 ] = m[ 5 ];
    		r[ 8 ] = m[ 8 ];

    		return this;

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		for( var i = 0; i < 9; i ++ ) {

    			this.elements[ i ] = array[ i + offset ];

    		}

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		var te = this.elements;

    		array[ offset ] = te[ 0 ];
    		array[ offset + 1 ] = te[ 1 ];
    		array[ offset + 2 ] = te[ 2 ];

    		array[ offset + 3 ] = te[ 3 ];
    		array[ offset + 4 ] = te[ 4 ];
    		array[ offset + 5 ] = te[ 5 ];

    		array[ offset + 6 ] = te[ 6 ];
    		array[ offset + 7 ] = te[ 7 ];
    		array[ offset + 8 ]  = te[ 8 ];

    		return array;

    	}

    };

    /**
     * @author bhouston / http://clara.io
     */

    function Plane( normal, constant ) {

    	this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
    	this.constant = ( constant !== undefined ) ? constant : 0;

    }

    Plane.prototype = {

    	constructor: Plane,

    	set: function ( normal, constant ) {

    		this.normal.copy( normal );
    		this.constant = constant;

    		return this;

    	},

    	setComponents: function ( x, y, z, w ) {

    		this.normal.set( x, y, z );
    		this.constant = w;

    		return this;

    	},

    	setFromNormalAndCoplanarPoint: function ( normal, point ) {

    		this.normal.copy( normal );
    		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

    		return this;

    	},

    	setFromCoplanarPoints: function () {

    		var v1 = new Vector3();
    		var v2 = new Vector3();

    		return function setFromCoplanarPoints( a, b, c ) {

    			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

    			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

    			this.setFromNormalAndCoplanarPoint( normal, a );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( plane ) {

    		this.normal.copy( plane.normal );
    		this.constant = plane.constant;

    		return this;

    	},

    	normalize: function () {

    		// Note: will lead to a divide by zero if the plane is invalid.

    		var inverseNormalLength = 1.0 / this.normal.length();
    		this.normal.multiplyScalar( inverseNormalLength );
    		this.constant *= inverseNormalLength;

    		return this;

    	},

    	negate: function () {

    		this.constant *= - 1;
    		this.normal.negate();

    		return this;

    	},

    	distanceToPoint: function ( point ) {

    		return this.normal.dot( point ) + this.constant;

    	},

    	distanceToSphere: function ( sphere ) {

    		return this.distanceToPoint( sphere.center ) - sphere.radius;

    	},

    	projectPoint: function ( point, optionalTarget ) {

    		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

    	},

    	orthoPoint: function ( point, optionalTarget ) {

    		var perpendicularMagnitude = this.distanceToPoint( point );

    		var result = optionalTarget || new Vector3();
    		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

    	},

    	intersectLine: function () {

    		var v1 = new Vector3();

    		return function intersectLine( line, optionalTarget ) {

    			var result = optionalTarget || new Vector3();

    			var direction = line.delta( v1 );

    			var denominator = this.normal.dot( direction );

    			if ( denominator === 0 ) {

    				// line is coplanar, return origin
    				if ( this.distanceToPoint( line.start ) === 0 ) {

    					return result.copy( line.start );

    				}

    				// Unsure if this is the correct method to handle this case.
    				return undefined;

    			}

    			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

    			if ( t < 0 || t > 1 ) {

    				return undefined;

    			}

    			return result.copy( direction ).multiplyScalar( t ).add( line.start );

    		};

    	}(),

    	intersectsLine: function ( line ) {

    		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

    		var startSign = this.distanceToPoint( line.start );
    		var endSign = this.distanceToPoint( line.end );

    		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

    	},

    	intersectsBox: function ( box ) {

    		return box.intersectsPlane( this );

    	},

    	intersectsSphere: function ( sphere ) {

    		return sphere.intersectsPlane( this );

    	},

    	coplanarPoint: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.copy( this.normal ).multiplyScalar( - this.constant );

    	},

    	applyMatrix4: function () {

    		var v1 = new Vector3();
    		var m1 = new Matrix3();

    		return function applyMatrix4( matrix, optionalNormalMatrix ) {

    			var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

    			// transform normal based on theory here:
    			// http://www.songho.ca/opengl/gl_normaltransform.html
    			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
    			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

    			// recalculate constant (like in setFromNormalAndCoplanarPoint)
    			this.constant = - referencePoint.dot( normal );

    			return this;

    		};

    	}(),

    	translate: function ( offset ) {

    		this.constant = this.constant - offset.dot( this.normal );

    		return this;

    	},

    	equals: function ( plane ) {

    		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author bhouston / http://clara.io
     */

    function Frustum( p0, p1, p2, p3, p4, p5 ) {

    	this.planes = [

    		( p0 !== undefined ) ? p0 : new Plane(),
    		( p1 !== undefined ) ? p1 : new Plane(),
    		( p2 !== undefined ) ? p2 : new Plane(),
    		( p3 !== undefined ) ? p3 : new Plane(),
    		( p4 !== undefined ) ? p4 : new Plane(),
    		( p5 !== undefined ) ? p5 : new Plane()

    	];

    }

    Frustum.prototype = {

    	constructor: Frustum,

    	set: function ( p0, p1, p2, p3, p4, p5 ) {

    		var planes = this.planes;

    		planes[ 0 ].copy( p0 );
    		planes[ 1 ].copy( p1 );
    		planes[ 2 ].copy( p2 );
    		planes[ 3 ].copy( p3 );
    		planes[ 4 ].copy( p4 );
    		planes[ 5 ].copy( p5 );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( frustum ) {

    		var planes = this.planes;

    		for ( var i = 0; i < 6; i ++ ) {

    			planes[ i ].copy( frustum.planes[ i ] );

    		}

    		return this;

    	},

    	setFromMatrix: function ( m ) {

    		var planes = this.planes;
    		var me = m.elements;
    		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
    		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
    		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
    		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

    		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
    		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
    		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
    		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
    		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
    		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

    		return this;

    	},

    	intersectsObject: function () {

    		var sphere = new Sphere();

    		return function intersectsObject( object ) {

    			var geometry = object.geometry;

    			if ( geometry.boundingSphere === null )
    				geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere )
    				.applyMatrix4( object.matrixWorld );

    			return this.intersectsSphere( sphere );

    		};

    	}(),

    	intersectsSprite: function () {

    		var sphere = new Sphere();

    		return function intersectsSprite( sprite ) {

    			sphere.center.set( 0, 0, 0 );
    			sphere.radius = 0.7071067811865476;
    			sphere.applyMatrix4( sprite.matrixWorld );

    			return this.intersectsSphere( sphere );

    		};

    	}(),

    	intersectsSphere: function ( sphere ) {

    		var planes = this.planes;
    		var center = sphere.center;
    		var negRadius = - sphere.radius;

    		for ( var i = 0; i < 6; i ++ ) {

    			var distance = planes[ i ].distanceToPoint( center );

    			if ( distance < negRadius ) {

    				return false;

    			}

    		}

    		return true;

    	},

    	intersectsBox: function () {

    		var p1 = new Vector3(),
    			p2 = new Vector3();

    		return function intersectsBox( box ) {

    			var planes = this.planes;

    			for ( var i = 0; i < 6 ; i ++ ) {

    				var plane = planes[ i ];

    				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
    				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
    				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
    				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
    				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
    				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

    				var d1 = plane.distanceToPoint( p1 );
    				var d2 = plane.distanceToPoint( p2 );

    				// if both outside plane, no intersection

    				if ( d1 < 0 && d2 < 0 ) {

    					return false;

    				}

    			}

    			return true;

    		};

    	}(),


    	containsPoint: function ( point ) {

    		var planes = this.planes;

    		for ( var i = 0; i < 6; i ++ ) {

    			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

    				return false;

    			}

    		}

    		return true;

    	}

    };

    function WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {

    	var _gl = _renderer.context,
    	_state = _renderer.state,
    	_frustum = new Frustum(),
    	_projScreenMatrix = new Matrix4(),

    	_lightShadows = _lights.shadows,

    	_shadowMapSize = new Vector2(),
    	_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),

    	_lookTarget = new Vector3(),
    	_lightPositionWorld = new Vector3(),

    	_renderList = [],

    	_MorphingFlag = 1,
    	_SkinningFlag = 2,

    	_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

    	_depthMaterials = new Array( _NumberOfMaterialVariants ),
    	_distanceMaterials = new Array( _NumberOfMaterialVariants ),

    	_materialCache = {};

    	var cubeDirections = [
    		new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
    		new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
    	];

    	var cubeUps = [
    		new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
    		new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
    	];

    	var cube2DViewPorts = [
    		new Vector4(), new Vector4(), new Vector4(),
    		new Vector4(), new Vector4(), new Vector4()
    	];

    	// init

    	var depthMaterialTemplate = new MeshDepthMaterial();
    	depthMaterialTemplate.depthPacking = RGBADepthPacking;
    	depthMaterialTemplate.clipping = true;

    	var distanceShader = ShaderLib[ "distanceRGBA" ];
    	var distanceUniforms = exports.UniformsUtils.clone( distanceShader.uniforms );

    	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

    		var useMorphing = ( i & _MorphingFlag ) !== 0;
    		var useSkinning = ( i & _SkinningFlag ) !== 0;

    		var depthMaterial = depthMaterialTemplate.clone();
    		depthMaterial.morphTargets = useMorphing;
    		depthMaterial.skinning = useSkinning;

    		_depthMaterials[ i ] = depthMaterial;

    		var distanceMaterial = new ShaderMaterial( {
    			defines: {
    				'USE_SHADOWMAP': ''
    			},
    			uniforms: distanceUniforms,
    			vertexShader: distanceShader.vertexShader,
    			fragmentShader: distanceShader.fragmentShader,
    			morphTargets: useMorphing,
    			skinning: useSkinning,
    			clipping: true
    		} );

    		_distanceMaterials[ i ] = distanceMaterial;

    	}

    	//

    	var scope = this;

    	this.enabled = false;

    	this.autoUpdate = true;
    	this.needsUpdate = false;

    	this.type = PCFShadowMap;

    	this.renderReverseSided = true;
    	this.renderSingleSided = true;

    	this.render = function ( scene, camera ) {

    		if ( scope.enabled === false ) return;
    		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

    		if ( _lightShadows.length === 0 ) return;

    		// Set GL state for depth map.
    		_state.clearColor( 1, 1, 1, 1 );
    		_state.disable( _gl.BLEND );
    		_state.setDepthTest( true );
    		_state.setScissorTest( false );

    		// render depth map

    		var faceCount, isPointLight;

    		for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {

    			var light = _lightShadows[ i ];
    			var shadow = light.shadow;

    			if ( shadow === undefined ) {

    				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
    				continue;

    			}

    			var shadowCamera = shadow.camera;

    			_shadowMapSize.copy( shadow.mapSize );
    			_shadowMapSize.min( _maxShadowMapSize );

    			if ( (light && light.isPointLight) ) {

    				faceCount = 6;
    				isPointLight = true;

    				var vpWidth = _shadowMapSize.x;
    				var vpHeight = _shadowMapSize.y;

    				// These viewports map a cube-map onto a 2D texture with the
    				// following orientation:
    				//
    				//  xzXZ
    				//   y Y
    				//
    				// X - Positive x direction
    				// x - Negative x direction
    				// Y - Positive y direction
    				// y - Negative y direction
    				// Z - Positive z direction
    				// z - Negative z direction

    				// positive X
    				cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
    				// negative X
    				cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
    				// positive Z
    				cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
    				// negative Z
    				cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
    				// positive Y
    				cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
    				// negative Y
    				cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

    				_shadowMapSize.x *= 4.0;
    				_shadowMapSize.y *= 2.0;

    			} else {

    				faceCount = 1;
    				isPointLight = false;

    			}

    			if ( shadow.map === null ) {

    				var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

    				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

    				shadowCamera.updateProjectionMatrix();

    			}

    			if ( (shadow && shadow.isSpotLightShadow) ) {

    				shadow.update( light );

    			}

    			var shadowMap = shadow.map;
    			var shadowMatrix = shadow.matrix;

    			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
    			shadowCamera.position.copy( _lightPositionWorld );

    			_renderer.setRenderTarget( shadowMap );
    			_renderer.clear();

    			// render shadow map for each cube face (if omni-directional) or
    			// run a single pass if not

    			for ( var face = 0; face < faceCount; face ++ ) {

    				if ( isPointLight ) {

    					_lookTarget.copy( shadowCamera.position );
    					_lookTarget.add( cubeDirections[ face ] );
    					shadowCamera.up.copy( cubeUps[ face ] );
    					shadowCamera.lookAt( _lookTarget );

    					var vpDimensions = cube2DViewPorts[ face ];
    					_state.viewport( vpDimensions );

    				} else {

    					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
    					shadowCamera.lookAt( _lookTarget );

    				}

    				shadowCamera.updateMatrixWorld();
    				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

    				// compute shadow matrix

    				shadowMatrix.set(
    					0.5, 0.0, 0.0, 0.5,
    					0.0, 0.5, 0.0, 0.5,
    					0.0, 0.0, 0.5, 0.5,
    					0.0, 0.0, 0.0, 1.0
    				);

    				shadowMatrix.multiply( shadowCamera.projectionMatrix );
    				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

    				// update camera matrices and frustum

    				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
    				_frustum.setFromMatrix( _projScreenMatrix );

    				// set object matrices & frustum culling

    				_renderList.length = 0;

    				projectObject( scene, camera, shadowCamera );

    				// render shadow map
    				// render regular objects

    				for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

    					var object = _renderList[ j ];
    					var geometry = _objects.update( object );
    					var material = object.material;

    					if ( (material && material.isMultiMaterial) ) {

    						var groups = geometry.groups;
    						var materials = material.materials;

    						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

    							var group = groups[ k ];
    							var groupMaterial = materials[ group.materialIndex ];

    							if ( groupMaterial.visible === true ) {

    								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
    								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

    							}

    						}

    					} else {

    						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
    						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

    					}

    				}

    			}

    		}

    		// Restore GL state.
    		var clearColor = _renderer.getClearColor(),
    		clearAlpha = _renderer.getClearAlpha();
    		_renderer.setClearColor( clearColor, clearAlpha );

    		scope.needsUpdate = false;

    	};

    	function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

    		var geometry = object.geometry;

    		var result = null;

    		var materialVariants = _depthMaterials;
    		var customMaterial = object.customDepthMaterial;

    		if ( isPointLight ) {

    			materialVariants = _distanceMaterials;
    			customMaterial = object.customDistanceMaterial;

    		}

    		if ( ! customMaterial ) {

    			var useMorphing = false;

    			if ( material.morphTargets ) {

    				if ( (geometry && geometry.isBufferGeometry) ) {

    					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

    				} else if ( (geometry && geometry.isGeometry) ) {

    					useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

    				}

    			}

    			var useSkinning = object.isSkinnedMesh && material.skinning;

    			var variantIndex = 0;

    			if ( useMorphing ) variantIndex |= _MorphingFlag;
    			if ( useSkinning ) variantIndex |= _SkinningFlag;

    			result = materialVariants[ variantIndex ];

    		} else {

    			result = customMaterial;

    		}

    		if ( _renderer.localClippingEnabled &&
    			 material.clipShadows === true &&
    				material.clippingPlanes.length !== 0 ) {

    			// in this case we need a unique material instance reflecting the
    			// appropriate state

    			var keyA = result.uuid, keyB = material.uuid;

    			var materialsForVariant = _materialCache[ keyA ];

    			if ( materialsForVariant === undefined ) {

    				materialsForVariant = {};
    				_materialCache[ keyA ] = materialsForVariant;

    			}

    			var cachedMaterial = materialsForVariant[ keyB ];

    			if ( cachedMaterial === undefined ) {

    				cachedMaterial = result.clone();
    				materialsForVariant[ keyB ] = cachedMaterial;

    			}

    			result = cachedMaterial;

    		}

    		result.visible = material.visible;
    		result.wireframe = material.wireframe;

    		var side = material.side;

    		if ( scope.renderSingleSided && side == DoubleSide ) {

    			side = FrontSide;

    		}

    		if ( scope.renderReverseSided ) {

    			if ( side === FrontSide ) side = BackSide;
    			else if ( side === BackSide ) side = FrontSide;

    		}

    		result.side = side;

    		result.clipShadows = material.clipShadows;
    		result.clippingPlanes = material.clippingPlanes;

    		result.wireframeLinewidth = material.wireframeLinewidth;
    		result.linewidth = material.linewidth;

    		if ( isPointLight && result.uniforms.lightPos !== undefined ) {

    			result.uniforms.lightPos.value.copy( lightPositionWorld );

    		}

    		return result;

    	}

    	function projectObject( object, camera, shadowCamera ) {

    		if ( object.visible === false ) return;

    		var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

    		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

    			if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

    				var material = object.material;

    				if ( material.visible === true ) {

    					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
    					_renderList.push( object );

    				}

    			}

    		}

    		var children = object.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			projectObject( children[ i ], camera, shadowCamera );

    		}

    	}

    }

    /**
     * @author bhouston / http://clara.io
     */

    function Ray( origin, direction ) {

    	this.origin = ( origin !== undefined ) ? origin : new Vector3();
    	this.direction = ( direction !== undefined ) ? direction : new Vector3();

    }

    Ray.prototype = {

    	constructor: Ray,

    	set: function ( origin, direction ) {

    		this.origin.copy( origin );
    		this.direction.copy( direction );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( ray ) {

    		this.origin.copy( ray.origin );
    		this.direction.copy( ray.direction );

    		return this;

    	},

    	at: function ( t, optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

    	},

    	lookAt: function ( v ) {

    		this.direction.copy( v ).sub( this.origin ).normalize();

    		return this;

    	},

    	recast: function () {

    		var v1 = new Vector3();

    		return function recast( t ) {

    			this.origin.copy( this.at( t, v1 ) );

    			return this;

    		};

    	}(),

    	closestPointToPoint: function ( point, optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		result.subVectors( point, this.origin );
    		var directionDistance = result.dot( this.direction );

    		if ( directionDistance < 0 ) {

    			return result.copy( this.origin );

    		}

    		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    	},

    	distanceToPoint: function ( point ) {

    		return Math.sqrt( this.distanceSqToPoint( point ) );

    	},

    	distanceSqToPoint: function () {

    		var v1 = new Vector3();

    		return function distanceSqToPoint( point ) {

    			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

    			// point behind the ray

    			if ( directionDistance < 0 ) {

    				return this.origin.distanceToSquared( point );

    			}

    			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    			return v1.distanceToSquared( point );

    		};

    	}(),

    	distanceSqToSegment: function () {

    		var segCenter = new Vector3();
    		var segDir = new Vector3();
    		var diff = new Vector3();

    		return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

    			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
    			// It returns the min distance between the ray and the segment
    			// defined by v0 and v1
    			// It can also set two optional targets :
    			// - The closest point on the ray
    			// - The closest point on the segment

    			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
    			segDir.copy( v1 ).sub( v0 ).normalize();
    			diff.copy( this.origin ).sub( segCenter );

    			var segExtent = v0.distanceTo( v1 ) * 0.5;
    			var a01 = - this.direction.dot( segDir );
    			var b0 = diff.dot( this.direction );
    			var b1 = - diff.dot( segDir );
    			var c = diff.lengthSq();
    			var det = Math.abs( 1 - a01 * a01 );
    			var s0, s1, sqrDist, extDet;

    			if ( det > 0 ) {

    				// The ray and segment are not parallel.

    				s0 = a01 * b1 - b0;
    				s1 = a01 * b0 - b1;
    				extDet = segExtent * det;

    				if ( s0 >= 0 ) {

    					if ( s1 >= - extDet ) {

    						if ( s1 <= extDet ) {

    							// region 0
    							// Minimum at interior points of ray and segment.

    							var invDet = 1 / det;
    							s0 *= invDet;
    							s1 *= invDet;
    							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

    						} else {

    							// region 1

    							s1 = segExtent;
    							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
    							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    						}

    					} else {

    						// region 5

    						s1 = - segExtent;
    						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
    						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    					}

    				} else {

    					if ( s1 <= - extDet ) {

    						// region 4

    						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
    						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
    						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    					} else if ( s1 <= extDet ) {

    						// region 3

    						s0 = 0;
    						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
    						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

    					} else {

    						// region 2

    						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
    						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
    						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    					}

    				}

    			} else {

    				// Ray and segment are parallel.

    				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
    				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
    				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    			}

    			if ( optionalPointOnRay ) {

    				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

    			}

    			if ( optionalPointOnSegment ) {

    				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

    			}

    			return sqrDist;

    		};

    	}(),

    	intersectSphere: function () {

    		var v1 = new Vector3();

    		return function intersectSphere( sphere, optionalTarget ) {

    			v1.subVectors( sphere.center, this.origin );
    			var tca = v1.dot( this.direction );
    			var d2 = v1.dot( v1 ) - tca * tca;
    			var radius2 = sphere.radius * sphere.radius;

    			if ( d2 > radius2 ) return null;

    			var thc = Math.sqrt( radius2 - d2 );

    			// t0 = first intersect point - entrance on front of sphere
    			var t0 = tca - thc;

    			// t1 = second intersect point - exit point on back of sphere
    			var t1 = tca + thc;

    			// test to see if both t0 and t1 are behind the ray - if so, return null
    			if ( t0 < 0 && t1 < 0 ) return null;

    			// test to see if t0 is behind the ray:
    			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
    			// in order to always return an intersect point that is in front of the ray.
    			if ( t0 < 0 ) return this.at( t1, optionalTarget );

    			// else t0 is in front of the ray, so return the first collision point scaled by t0
    			return this.at( t0, optionalTarget );

    		};

    	}(),

    	intersectsSphere: function ( sphere ) {

    		return this.distanceToPoint( sphere.center ) <= sphere.radius;

    	},

    	distanceToPlane: function ( plane ) {

    		var denominator = plane.normal.dot( this.direction );

    		if ( denominator === 0 ) {

    			// line is coplanar, return origin
    			if ( plane.distanceToPoint( this.origin ) === 0 ) {

    				return 0;

    			}

    			// Null is preferable to undefined since undefined means.... it is undefined

    			return null;

    		}

    		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

    		// Return if the ray never intersects the plane

    		return t >= 0 ? t :  null;

    	},

    	intersectPlane: function ( plane, optionalTarget ) {

    		var t = this.distanceToPlane( plane );

    		if ( t === null ) {

    			return null;

    		}

    		return this.at( t, optionalTarget );

    	},



    	intersectsPlane: function ( plane ) {

    		// check if the ray lies on the plane first

    		var distToPoint = plane.distanceToPoint( this.origin );

    		if ( distToPoint === 0 ) {

    			return true;

    		}

    		var denominator = plane.normal.dot( this.direction );

    		if ( denominator * distToPoint < 0 ) {

    			return true;

    		}

    		// ray origin is behind the plane (and is pointing behind it)

    		return false;

    	},

    	intersectBox: function ( box, optionalTarget ) {

    		var tmin, tmax, tymin, tymax, tzmin, tzmax;

    		var invdirx = 1 / this.direction.x,
    			invdiry = 1 / this.direction.y,
    			invdirz = 1 / this.direction.z;

    		var origin = this.origin;

    		if ( invdirx >= 0 ) {

    			tmin = ( box.min.x - origin.x ) * invdirx;
    			tmax = ( box.max.x - origin.x ) * invdirx;

    		} else {

    			tmin = ( box.max.x - origin.x ) * invdirx;
    			tmax = ( box.min.x - origin.x ) * invdirx;

    		}

    		if ( invdiry >= 0 ) {

    			tymin = ( box.min.y - origin.y ) * invdiry;
    			tymax = ( box.max.y - origin.y ) * invdiry;

    		} else {

    			tymin = ( box.max.y - origin.y ) * invdiry;
    			tymax = ( box.min.y - origin.y ) * invdiry;

    		}

    		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

    		// These lines also handle the case where tmin or tmax is NaN
    		// (result of 0 * Infinity). x !== x returns true if x is NaN

    		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

    		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

    		if ( invdirz >= 0 ) {

    			tzmin = ( box.min.z - origin.z ) * invdirz;
    			tzmax = ( box.max.z - origin.z ) * invdirz;

    		} else {

    			tzmin = ( box.max.z - origin.z ) * invdirz;
    			tzmax = ( box.min.z - origin.z ) * invdirz;

    		}

    		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

    		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

    		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

    		//return point closest to the ray (positive side)

    		if ( tmax < 0 ) return null;

    		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

    	},

    	intersectsBox: ( function () {

    		var v = new Vector3();

    		return function intersectsBox( box ) {

    			return this.intersectBox( box, v ) !== null;

    		};

    	} )(),

    	intersectTriangle: function () {

    		// Compute the offset origin, edges, and normal.
    		var diff = new Vector3();
    		var edge1 = new Vector3();
    		var edge2 = new Vector3();
    		var normal = new Vector3();

    		return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

    			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

    			edge1.subVectors( b, a );
    			edge2.subVectors( c, a );
    			normal.crossVectors( edge1, edge2 );

    			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
    			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
    			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
    			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
    			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
    			var DdN = this.direction.dot( normal );
    			var sign;

    			if ( DdN > 0 ) {

    				if ( backfaceCulling ) return null;
    				sign = 1;

    			} else if ( DdN < 0 ) {

    				sign = - 1;
    				DdN = - DdN;

    			} else {

    				return null;

    			}

    			diff.subVectors( this.origin, a );
    			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

    			// b1 < 0, no intersection
    			if ( DdQxE2 < 0 ) {

    				return null;

    			}

    			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

    			// b2 < 0, no intersection
    			if ( DdE1xQ < 0 ) {

    				return null;

    			}

    			// b1+b2 > 1, no intersection
    			if ( DdQxE2 + DdE1xQ > DdN ) {

    				return null;

    			}

    			// Line intersects triangle, check if ray does.
    			var QdN = - sign * diff.dot( normal );

    			// t < 0, no intersection
    			if ( QdN < 0 ) {

    				return null;

    			}

    			// Ray intersects triangle.
    			return this.at( QdN / DdN, optionalTarget );

    		};

    	}(),

    	applyMatrix4: function ( matrix4 ) {

    		this.direction.add( this.origin ).applyMatrix4( matrix4 );
    		this.origin.applyMatrix4( matrix4 );
    		this.direction.sub( this.origin );
    		this.direction.normalize();

    		return this;

    	},

    	equals: function ( ray ) {

    		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */

    function Euler( x, y, z, order ) {

    	this._x = x || 0;
    	this._y = y || 0;
    	this._z = z || 0;
    	this._order = order || Euler.DefaultOrder;

    }

    Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

    Euler.DefaultOrder = 'XYZ';

    Euler.prototype = {

    	constructor: Euler,

    	isEuler: true,

    	get x () {

    		return this._x;

    	},

    	set x ( value ) {

    		this._x = value;
    		this.onChangeCallback();

    	},

    	get y () {

    		return this._y;

    	},

    	set y ( value ) {

    		this._y = value;
    		this.onChangeCallback();

    	},

    	get z () {

    		return this._z;

    	},

    	set z ( value ) {

    		this._z = value;
    		this.onChangeCallback();

    	},

    	get order () {

    		return this._order;

    	},

    	set order ( value ) {

    		this._order = value;
    		this.onChangeCallback();

    	},

    	set: function ( x, y, z, order ) {

    		this._x = x;
    		this._y = y;
    		this._z = z;
    		this._order = order || this._order;

    		this.onChangeCallback();

    		return this;

    	},

    	clone: function () {

    		return new this.constructor( this._x, this._y, this._z, this._order );

    	},

    	copy: function ( euler ) {

    		this._x = euler._x;
    		this._y = euler._y;
    		this._z = euler._z;
    		this._order = euler._order;

    		this.onChangeCallback();

    		return this;

    	},

    	setFromRotationMatrix: function ( m, order, update ) {

    		var clamp = exports.Math.clamp;

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		var te = m.elements;
    		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
    		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
    		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    		order = order || this._order;

    		if ( order === 'XYZ' ) {

    			this._y = Math.asin( clamp( m13, - 1, 1 ) );

    			if ( Math.abs( m13 ) < 0.99999 ) {

    				this._x = Math.atan2( - m23, m33 );
    				this._z = Math.atan2( - m12, m11 );

    			} else {

    				this._x = Math.atan2( m32, m22 );
    				this._z = 0;

    			}

    		} else if ( order === 'YXZ' ) {

    			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

    			if ( Math.abs( m23 ) < 0.99999 ) {

    				this._y = Math.atan2( m13, m33 );
    				this._z = Math.atan2( m21, m22 );

    			} else {

    				this._y = Math.atan2( - m31, m11 );
    				this._z = 0;

    			}

    		} else if ( order === 'ZXY' ) {

    			this._x = Math.asin( clamp( m32, - 1, 1 ) );

    			if ( Math.abs( m32 ) < 0.99999 ) {

    				this._y = Math.atan2( - m31, m33 );
    				this._z = Math.atan2( - m12, m22 );

    			} else {

    				this._y = 0;
    				this._z = Math.atan2( m21, m11 );

    			}

    		} else if ( order === 'ZYX' ) {

    			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

    			if ( Math.abs( m31 ) < 0.99999 ) {

    				this._x = Math.atan2( m32, m33 );
    				this._z = Math.atan2( m21, m11 );

    			} else {

    				this._x = 0;
    				this._z = Math.atan2( - m12, m22 );

    			}

    		} else if ( order === 'YZX' ) {

    			this._z = Math.asin( clamp( m21, - 1, 1 ) );

    			if ( Math.abs( m21 ) < 0.99999 ) {

    				this._x = Math.atan2( - m23, m22 );
    				this._y = Math.atan2( - m31, m11 );

    			} else {

    				this._x = 0;
    				this._y = Math.atan2( m13, m33 );

    			}

    		} else if ( order === 'XZY' ) {

    			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

    			if ( Math.abs( m12 ) < 0.99999 ) {

    				this._x = Math.atan2( m32, m22 );
    				this._y = Math.atan2( m13, m11 );

    			} else {

    				this._x = Math.atan2( - m23, m33 );
    				this._y = 0;

    			}

    		} else {

    			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

    		}

    		this._order = order;

    		if ( update !== false ) this.onChangeCallback();

    		return this;

    	},

    	setFromQuaternion: function () {

    		var matrix;

    		return function setFromQuaternion( q, order, update ) {

    			if ( matrix === undefined ) matrix = new Matrix4();

    			matrix.makeRotationFromQuaternion( q );

    			return this.setFromRotationMatrix( matrix, order, update );

    		};

    	}(),

    	setFromVector3: function ( v, order ) {

    		return this.set( v.x, v.y, v.z, order || this._order );

    	},

    	reorder: function () {

    		// WARNING: this discards revolution information -bhouston

    		var q = new Quaternion();

    		return function reorder( newOrder ) {

    			q.setFromEuler( this );

    			return this.setFromQuaternion( q, newOrder );

    		};

    	}(),

    	equals: function ( euler ) {

    		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

    	},

    	fromArray: function ( array ) {

    		this._x = array[ 0 ];
    		this._y = array[ 1 ];
    		this._z = array[ 2 ];
    		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

    		this.onChangeCallback();

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this._x;
    		array[ offset + 1 ] = this._y;
    		array[ offset + 2 ] = this._z;
    		array[ offset + 3 ] = this._order;

    		return array;

    	},

    	toVector3: function ( optionalResult ) {

    		if ( optionalResult ) {

    			return optionalResult.set( this._x, this._y, this._z );

    		} else {

    			return new Vector3( this._x, this._y, this._z );

    		}

    	},

    	onChange: function ( callback ) {

    		this.onChangeCallback = callback;

    		return this;

    	},

    	onChangeCallback: function () {}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Layers() {

    	this.mask = 1;

    }

    Layers.prototype = {

    	constructor: Layers,

    	set: function ( channel ) {

    		this.mask = 1 << channel;

    	},

    	enable: function ( channel ) {

    		this.mask |= 1 << channel;

    	},

    	toggle: function ( channel ) {

    		this.mask ^= 1 << channel;

    	},

    	disable: function ( channel ) {

    		this.mask &= ~ ( 1 << channel );

    	},

    	test: function ( layers ) {

    		return ( this.mask & layers.mask ) !== 0;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author elephantatwork / www.elephantatwork.ch
     */

    function Object3D() {

    	Object.defineProperty( this, 'id', { value: Object3DIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'Object3D';

    	this.parent = null;
    	this.children = [];

    	this.up = Object3D.DefaultUp.clone();

    	var position = new Vector3();
    	var rotation = new Euler();
    	var quaternion = new Quaternion();
    	var scale = new Vector3( 1, 1, 1 );

    	function onRotationChange() {

    		quaternion.setFromEuler( rotation, false );

    	}

    	function onQuaternionChange() {

    		rotation.setFromQuaternion( quaternion, undefined, false );

    	}

    	rotation.onChange( onRotationChange );
    	quaternion.onChange( onQuaternionChange );

    	Object.defineProperties( this, {
    		position: {
    			enumerable: true,
    			value: position
    		},
    		rotation: {
    			enumerable: true,
    			value: rotation
    		},
    		quaternion: {
    			enumerable: true,
    			value: quaternion
    		},
    		scale: {
    			enumerable: true,
    			value: scale
    		},
    		modelViewMatrix: {
    			value: new Matrix4()
    		},
    		normalMatrix: {
    			value: new Matrix3()
    		}
    	} );

    	this.matrix = new Matrix4();
    	this.matrixWorld = new Matrix4();

    	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    	this.matrixWorldNeedsUpdate = false;

    	this.layers = new Layers();
    	this.visible = true;

    	this.castShadow = false;
    	this.receiveShadow = false;

    	this.frustumCulled = true;
    	this.renderOrder = 0;

    	this.userData = {};

    	this.onBeforeRender = null;

    }

    Object3D.DefaultUp = new Vector3( 0, 1, 0 );
    Object3D.DefaultMatrixAutoUpdate = true;

    Object.assign( Object3D.prototype, EventDispatcher.prototype, {

    	isObject3D: true,

    	applyMatrix: function ( matrix ) {

    		this.matrix.multiplyMatrices( matrix, this.matrix );

    		this.matrix.decompose( this.position, this.quaternion, this.scale );

    	},

    	setRotationFromAxisAngle: function ( axis, angle ) {

    		// assumes axis is normalized

    		this.quaternion.setFromAxisAngle( axis, angle );

    	},

    	setRotationFromEuler: function ( euler ) {

    		this.quaternion.setFromEuler( euler, true );

    	},

    	setRotationFromMatrix: function ( m ) {

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		this.quaternion.setFromRotationMatrix( m );

    	},

    	setRotationFromQuaternion: function ( q ) {

    		// assumes q is normalized

    		this.quaternion.copy( q );

    	},

    	rotateOnAxis: function () {

    		// rotate object on axis in object space
    		// axis is assumed to be normalized

    		var q1 = new Quaternion();

    		return function rotateOnAxis( axis, angle ) {

    			q1.setFromAxisAngle( axis, angle );

    			this.quaternion.multiply( q1 );

    			return this;

    		};

    	}(),

    	rotateX: function () {

    		var v1 = new Vector3( 1, 0, 0 );

    		return function rotateX( angle ) {

    			return this.rotateOnAxis( v1, angle );

    		};

    	}(),

    	rotateY: function () {

    		var v1 = new Vector3( 0, 1, 0 );

    		return function rotateY( angle ) {

    			return this.rotateOnAxis( v1, angle );

    		};

    	}(),

    	rotateZ: function () {

    		var v1 = new Vector3( 0, 0, 1 );

    		return function rotateZ( angle ) {

    			return this.rotateOnAxis( v1, angle );

    		};

    	}(),

    	translateOnAxis: function () {

    		// translate object by distance along axis in object space
    		// axis is assumed to be normalized

    		var v1 = new Vector3();

    		return function translateOnAxis( axis, distance ) {

    			v1.copy( axis ).applyQuaternion( this.quaternion );

    			this.position.add( v1.multiplyScalar( distance ) );

    			return this;

    		};

    	}(),

    	translateX: function () {

    		var v1 = new Vector3( 1, 0, 0 );

    		return function translateX( distance ) {

    			return this.translateOnAxis( v1, distance );

    		};

    	}(),

    	translateY: function () {

    		var v1 = new Vector3( 0, 1, 0 );

    		return function translateY( distance ) {

    			return this.translateOnAxis( v1, distance );

    		};

    	}(),

    	translateZ: function () {

    		var v1 = new Vector3( 0, 0, 1 );

    		return function translateZ( distance ) {

    			return this.translateOnAxis( v1, distance );

    		};

    	}(),

    	localToWorld: function ( vector ) {

    		return vector.applyMatrix4( this.matrixWorld );

    	},

    	worldToLocal: function () {

    		var m1 = new Matrix4();

    		return function worldToLocal( vector ) {

    			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

    		};

    	}(),

    	lookAt: function () {

    		// This routine does not support objects with rotated and/or translated parent(s)

    		var m1 = new Matrix4();

    		return function lookAt( vector ) {

    			m1.lookAt( vector, this.position, this.up );

    			this.quaternion.setFromRotationMatrix( m1 );

    		};

    	}(),

    	add: function ( object ) {

    		if ( arguments.length > 1 ) {

    			for ( var i = 0; i < arguments.length; i ++ ) {

    				this.add( arguments[ i ] );

    			}

    			return this;

    		}

    		if ( object === this ) {

    			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
    			return this;

    		}

    		if ( (object && object.isObject3D) ) {

    			if ( object.parent !== null ) {

    				object.parent.remove( object );

    			}

    			object.parent = this;
    			object.dispatchEvent( { type: 'added' } );

    			this.children.push( object );

    		} else {

    			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

    		}

    		return this;

    	},

    	remove: function ( object ) {

    		if ( arguments.length > 1 ) {

    			for ( var i = 0; i < arguments.length; i ++ ) {

    				this.remove( arguments[ i ] );

    			}

    		}

    		var index = this.children.indexOf( object );

    		if ( index !== - 1 ) {

    			object.parent = null;

    			object.dispatchEvent( { type: 'removed' } );

    			this.children.splice( index, 1 );

    		}

    	},

    	getObjectById: function ( id ) {

    		return this.getObjectByProperty( 'id', id );

    	},

    	getObjectByName: function ( name ) {

    		return this.getObjectByProperty( 'name', name );

    	},

    	getObjectByProperty: function ( name, value ) {

    		if ( this[ name ] === value ) return this;

    		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

    			var child = this.children[ i ];
    			var object = child.getObjectByProperty( name, value );

    			if ( object !== undefined ) {

    				return object;

    			}

    		}

    		return undefined;

    	},

    	getWorldPosition: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		this.updateMatrixWorld( true );

    		return result.setFromMatrixPosition( this.matrixWorld );

    	},

    	getWorldQuaternion: function () {

    		var position = new Vector3();
    		var scale = new Vector3();

    		return function getWorldQuaternion( optionalTarget ) {

    			var result = optionalTarget || new Quaternion();

    			this.updateMatrixWorld( true );

    			this.matrixWorld.decompose( position, result, scale );

    			return result;

    		};

    	}(),

    	getWorldRotation: function () {

    		var quaternion = new Quaternion();

    		return function getWorldRotation( optionalTarget ) {

    			var result = optionalTarget || new Euler();

    			this.getWorldQuaternion( quaternion );

    			return result.setFromQuaternion( quaternion, this.rotation.order, false );

    		};

    	}(),

    	getWorldScale: function () {

    		var position = new Vector3();
    		var quaternion = new Quaternion();

    		return function getWorldScale( optionalTarget ) {

    			var result = optionalTarget || new Vector3();

    			this.updateMatrixWorld( true );

    			this.matrixWorld.decompose( position, quaternion, result );

    			return result;

    		};

    	}(),

    	getWorldDirection: function () {

    		var quaternion = new Quaternion();

    		return function getWorldDirection( optionalTarget ) {

    			var result = optionalTarget || new Vector3();

    			this.getWorldQuaternion( quaternion );

    			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

    		};

    	}(),

    	raycast: function () {},

    	traverse: function ( callback ) {

    		callback( this );

    		var children = this.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			children[ i ].traverse( callback );

    		}

    	},

    	traverseVisible: function ( callback ) {

    		if ( this.visible === false ) return;

    		callback( this );

    		var children = this.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			children[ i ].traverseVisible( callback );

    		}

    	},

    	traverseAncestors: function ( callback ) {

    		var parent = this.parent;

    		if ( parent !== null ) {

    			callback( parent );

    			parent.traverseAncestors( callback );

    		}

    	},

    	updateMatrix: function () {

    		this.matrix.compose( this.position, this.quaternion, this.scale );

    		this.matrixWorldNeedsUpdate = true;

    	},

    	updateMatrixWorld: function ( force ) {

    		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

    		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

    			if ( this.parent === null ) {

    				this.matrixWorld.copy( this.matrix );

    			} else {

    				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

    			}

    			this.matrixWorldNeedsUpdate = false;

    			force = true;

    		}

    		// update children

    		var children = this.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			children[ i ].updateMatrixWorld( force );

    		}

    	},

    	toJSON: function ( meta ) {

    		// meta is '' when called from JSON.stringify
    		var isRootObject = ( meta === undefined || meta === '' );

    		var output = {};

    		// meta is a hash used to collect geometries, materials.
    		// not providing it implies that this is the root object
    		// being serialized.
    		if ( isRootObject ) {

    			// initialize meta obj
    			meta = {
    				geometries: {},
    				materials: {},
    				textures: {},
    				images: {}
    			};

    			output.metadata = {
    				version: 4.4,
    				type: 'Object',
    				generator: 'Object3D.toJSON'
    			};

    		}

    		// standard Object3D serialization

    		var object = {};

    		object.uuid = this.uuid;
    		object.type = this.type;

    		if ( this.name !== '' ) object.name = this.name;
    		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
    		if ( this.castShadow === true ) object.castShadow = true;
    		if ( this.receiveShadow === true ) object.receiveShadow = true;
    		if ( this.visible === false ) object.visible = false;

    		object.matrix = this.matrix.toArray();

    		//

    		if ( this.geometry !== undefined ) {

    			if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

    				meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

    			}

    			object.geometry = this.geometry.uuid;

    		}

    		if ( this.material !== undefined ) {

    			if ( meta.materials[ this.material.uuid ] === undefined ) {

    				meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

    			}

    			object.material = this.material.uuid;

    		}

    		//

    		if ( this.children.length > 0 ) {

    			object.children = [];

    			for ( var i = 0; i < this.children.length; i ++ ) {

    				object.children.push( this.children[ i ].toJSON( meta ).object );

    			}

    		}

    		if ( isRootObject ) {

    			var geometries = extractFromCache( meta.geometries );
    			var materials = extractFromCache( meta.materials );
    			var textures = extractFromCache( meta.textures );
    			var images = extractFromCache( meta.images );

    			if ( geometries.length > 0 ) output.geometries = geometries;
    			if ( materials.length > 0 ) output.materials = materials;
    			if ( textures.length > 0 ) output.textures = textures;
    			if ( images.length > 0 ) output.images = images;

    		}

    		output.object = object;

    		return output;

    		// extract data from the cache hash
    		// remove metadata on each item
    		// and return as array
    		function extractFromCache( cache ) {

    			var values = [];
    			for ( var key in cache ) {

    				var data = cache[ key ];
    				delete data.metadata;
    				values.push( data );

    			}
    			return values;

    		}

    	},

    	clone: function ( recursive ) {

    		return new this.constructor().copy( this, recursive );

    	},

    	copy: function ( source, recursive ) {

    		if ( recursive === undefined ) recursive = true;

    		this.name = source.name;

    		this.up.copy( source.up );

    		this.position.copy( source.position );
    		this.quaternion.copy( source.quaternion );
    		this.scale.copy( source.scale );

    		this.matrix.copy( source.matrix );
    		this.matrixWorld.copy( source.matrixWorld );

    		this.matrixAutoUpdate = source.matrixAutoUpdate;
    		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

    		this.visible = source.visible;

    		this.castShadow = source.castShadow;
    		this.receiveShadow = source.receiveShadow;

    		this.frustumCulled = source.frustumCulled;
    		this.renderOrder = source.renderOrder;

    		this.userData = JSON.parse( JSON.stringify( source.userData ) );

    		if ( recursive === true ) {

    			for ( var i = 0; i < source.children.length; i ++ ) {

    				var child = source.children[ i ];
    				this.add( child.clone() );

    			}

    		}

    		return this;

    	}

    } );

    var count$2 = 0;
    function Object3DIdCount() { return count$2++; };

    /**
     * @author bhouston / http://clara.io
     */

    function Line3( start, end ) {

    	this.start = ( start !== undefined ) ? start : new Vector3();
    	this.end = ( end !== undefined ) ? end : new Vector3();

    }

    Line3.prototype = {

    	constructor: Line3,

    	set: function ( start, end ) {

    		this.start.copy( start );
    		this.end.copy( end );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( line ) {

    		this.start.copy( line.start );
    		this.end.copy( line.end );

    		return this;

    	},

    	getCenter: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

    	},

    	delta: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.subVectors( this.end, this.start );

    	},

    	distanceSq: function () {

    		return this.start.distanceToSquared( this.end );

    	},

    	distance: function () {

    		return this.start.distanceTo( this.end );

    	},

    	at: function ( t, optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		return this.delta( result ).multiplyScalar( t ).add( this.start );

    	},

    	closestPointToPointParameter: function () {

    		var startP = new Vector3();
    		var startEnd = new Vector3();

    		return function closestPointToPointParameter( point, clampToLine ) {

    			startP.subVectors( point, this.start );
    			startEnd.subVectors( this.end, this.start );

    			var startEnd2 = startEnd.dot( startEnd );
    			var startEnd_startP = startEnd.dot( startP );

    			var t = startEnd_startP / startEnd2;

    			if ( clampToLine ) {

    				t = exports.Math.clamp( t, 0, 1 );

    			}

    			return t;

    		};

    	}(),

    	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

    		var t = this.closestPointToPointParameter( point, clampToLine );

    		var result = optionalTarget || new Vector3();

    		return this.delta( result ).multiplyScalar( t ).add( this.start );

    	},

    	applyMatrix4: function ( matrix ) {

    		this.start.applyMatrix4( matrix );
    		this.end.applyMatrix4( matrix );

    		return this;

    	},

    	equals: function ( line ) {

    		return line.start.equals( this.start ) && line.end.equals( this.end );

    	}

    };

    /**
     * @author bhouston / http://clara.io
     * @author mrdoob / http://mrdoob.com/
     */

    function Triangle( a, b, c ) {

    	this.a = ( a !== undefined ) ? a : new Vector3();
    	this.b = ( b !== undefined ) ? b : new Vector3();
    	this.c = ( c !== undefined ) ? c : new Vector3();

    }

    Triangle.normal = function () {

    	var v0 = new Vector3();

    	return function normal( a, b, c, optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		result.subVectors( c, b );
    		v0.subVectors( a, b );
    		result.cross( v0 );

    		var resultLengthSq = result.lengthSq();
    		if ( resultLengthSq > 0 ) {

    			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

    		}

    		return result.set( 0, 0, 0 );

    	};

    }();

    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    Triangle.barycoordFromPoint = function () {

    	var v0 = new Vector3();
    	var v1 = new Vector3();
    	var v2 = new Vector3();

    	return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

    		v0.subVectors( c, a );
    		v1.subVectors( b, a );
    		v2.subVectors( point, a );

    		var dot00 = v0.dot( v0 );
    		var dot01 = v0.dot( v1 );
    		var dot02 = v0.dot( v2 );
    		var dot11 = v1.dot( v1 );
    		var dot12 = v1.dot( v2 );

    		var denom = ( dot00 * dot11 - dot01 * dot01 );

    		var result = optionalTarget || new Vector3();

    		// collinear or singular triangle
    		if ( denom === 0 ) {

    			// arbitrary location outside of triangle?
    			// not sure if this is the best idea, maybe should be returning undefined
    			return result.set( - 2, - 1, - 1 );

    		}

    		var invDenom = 1 / denom;
    		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
    		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

    		// barycentric coordinates must always sum to 1
    		return result.set( 1 - u - v, v, u );

    	};

    }();

    Triangle.containsPoint = function () {

    	var v1 = new Vector3();

    	return function containsPoint( point, a, b, c ) {

    		var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );

    		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

    	};

    }();

    Triangle.prototype = {

    	constructor: Triangle,

    	set: function ( a, b, c ) {

    		this.a.copy( a );
    		this.b.copy( b );
    		this.c.copy( c );

    		return this;

    	},

    	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

    		this.a.copy( points[ i0 ] );
    		this.b.copy( points[ i1 ] );
    		this.c.copy( points[ i2 ] );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( triangle ) {

    		this.a.copy( triangle.a );
    		this.b.copy( triangle.b );
    		this.c.copy( triangle.c );

    		return this;

    	},

    	area: function () {

    		var v0 = new Vector3();
    		var v1 = new Vector3();

    		return function area() {

    			v0.subVectors( this.c, this.b );
    			v1.subVectors( this.a, this.b );

    			return v0.cross( v1 ).length() * 0.5;

    		};

    	}(),

    	midpoint: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

    	},

    	normal: function ( optionalTarget ) {

    		return Triangle.normal( this.a, this.b, this.c, optionalTarget );

    	},

    	plane: function ( optionalTarget ) {

    		var result = optionalTarget || new Plane();

    		return result.setFromCoplanarPoints( this.a, this.b, this.c );

    	},

    	barycoordFromPoint: function ( point, optionalTarget ) {

    		return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

    	},

    	containsPoint: function ( point ) {

    		return Triangle.containsPoint( point, this.a, this.b, this.c );

    	},

    	closestPointToPoint: function () {

    		var plane, edgeList, projectedPoint, closestPoint;

    		return function closestPointToPoint( point, optionalTarget ) {

    			if ( plane === undefined ) {

    				plane = new Plane();
    				edgeList = [ new Line3(), new Line3(), new Line3() ];
    				projectedPoint = new Vector3();
    				closestPoint = new Vector3();

    			}

    			var result = optionalTarget || new Vector3();
    			var minDistance = Infinity;

    			// project the point onto the plane of the triangle

    			plane.setFromCoplanarPoints( this.a, this.b, this.c );
    			plane.projectPoint( point, projectedPoint );

    			// check if the projection lies within the triangle

    			if( this.containsPoint( projectedPoint ) === true ) {

    				// if so, this is the closest point

    				result.copy( projectedPoint );

    			} else {

    				// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

    				edgeList[ 0 ].set( this.a, this.b );
    				edgeList[ 1 ].set( this.b, this.c );
    				edgeList[ 2 ].set( this.c, this.a );

    				for( var i = 0; i < edgeList.length; i ++ ) {

    					edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

    					var distance = projectedPoint.distanceToSquared( closestPoint );

    					if( distance < minDistance ) {

    						minDistance = distance;

    						result.copy( closestPoint );

    					}

    				}

    			}

    			return result;

    		};

    	}(),

    	equals: function ( triangle ) {

    		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Face3( a, b, c, normal, color, materialIndex ) {

    	this.a = a;
    	this.b = b;
    	this.c = c;

    	this.normal = (normal && normal.isVector3) ? normal : new Vector3();
    	this.vertexNormals = Array.isArray( normal ) ? normal : [];

    	this.color = (color && color.isColor) ? color : new Color();
    	this.vertexColors = Array.isArray( color ) ? color : [];

    	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

    }

    Face3.prototype = {

    	constructor: Face3,

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.a = source.a;
    		this.b = source.b;
    		this.c = source.c;

    		this.normal.copy( source.normal );
    		this.color.copy( source.color );

    		this.materialIndex = source.materialIndex;

    		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

    			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

    		}

    		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

    			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

    		}

    		return this;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  shading: THREE.SmoothShading,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>
     * }
     */

    function MeshBasicMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshBasicMaterial';

    	this.color = new Color( 0xffffff ); // emissive

    	this.map = null;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.specularMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.combine = MultiplyOperation;
    	this.reflectivity = 1;
    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;

    	this.lights = false;

    	this.setValues( parameters );

    }

    MeshBasicMaterial.prototype = Object.create( Material.prototype );
    MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

    MeshBasicMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.map = source.map;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.specularMap = source.specularMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.combine = source.combine;
    	this.reflectivity = source.reflectivity;
    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function BufferAttribute( array, itemSize, normalized ) {

    	if ( Array.isArray( array ) ) {

    		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

    	}

    	this.uuid = exports.Math.generateUUID();

    	this.array = array;
    	this.itemSize = itemSize;
    	this.count = array !== undefined ? array.length / itemSize : 0;
    	this.normalized = normalized === true;

    	this.dynamic = false;
    	this.updateRange = { offset: 0, count: - 1 };

    	this.version = 0;

    }

    BufferAttribute.prototype = {

    	constructor: BufferAttribute,

    	isBufferAttribute: true,

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	},

    	setDynamic: function ( value ) {

    		this.dynamic = value;

    		return this;

    	},

    	copy: function ( source ) {

    		this.array = new source.array.constructor( source.array );
    		this.itemSize = source.itemSize;
    		this.count = source.count;
    		this.normalized = source.normalized;

    		this.dynamic = source.dynamic;

    		return this;

    	},

    	copyAt: function ( index1, attribute, index2 ) {

    		index1 *= this.itemSize;
    		index2 *= attribute.itemSize;

    		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

    			this.array[ index1 + i ] = attribute.array[ index2 + i ];

    		}

    		return this;

    	},

    	copyArray: function ( array ) {

    		this.array.set( array );

    		return this;

    	},

    	copyColorsArray: function ( colors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = colors.length; i < l; i ++ ) {

    			var color = colors[ i ];

    			if ( color === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
    				color = new Color();

    			}

    			array[ offset ++ ] = color.r;
    			array[ offset ++ ] = color.g;
    			array[ offset ++ ] = color.b;

    		}

    		return this;

    	},

    	copyIndicesArray: function ( indices ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = indices.length; i < l; i ++ ) {

    			var index = indices[ i ];

    			array[ offset ++ ] = index.a;
    			array[ offset ++ ] = index.b;
    			array[ offset ++ ] = index.c;

    		}

    		return this;

    	},

    	copyVector2sArray: function ( vectors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

    			var vector = vectors[ i ];

    			if ( vector === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
    				vector = new Vector2();

    			}

    			array[ offset ++ ] = vector.x;
    			array[ offset ++ ] = vector.y;

    		}

    		return this;

    	},

    	copyVector3sArray: function ( vectors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

    			var vector = vectors[ i ];

    			if ( vector === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
    				vector = new Vector3();

    			}

    			array[ offset ++ ] = vector.x;
    			array[ offset ++ ] = vector.y;
    			array[ offset ++ ] = vector.z;

    		}

    		return this;

    	},

    	copyVector4sArray: function ( vectors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

    			var vector = vectors[ i ];

    			if ( vector === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
    				vector = new Vector4();

    			}

    			array[ offset ++ ] = vector.x;
    			array[ offset ++ ] = vector.y;
    			array[ offset ++ ] = vector.z;
    			array[ offset ++ ] = vector.w;

    		}

    		return this;

    	},

    	set: function ( value, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.array.set( value, offset );

    		return this;

    	},

    	getX: function ( index ) {

    		return this.array[ index * this.itemSize ];

    	},

    	setX: function ( index, x ) {

    		this.array[ index * this.itemSize ] = x;

    		return this;

    	},

    	getY: function ( index ) {

    		return this.array[ index * this.itemSize + 1 ];

    	},

    	setY: function ( index, y ) {

    		this.array[ index * this.itemSize + 1 ] = y;

    		return this;

    	},

    	getZ: function ( index ) {

    		return this.array[ index * this.itemSize + 2 ];

    	},

    	setZ: function ( index, z ) {

    		this.array[ index * this.itemSize + 2 ] = z;

    		return this;

    	},

    	getW: function ( index ) {

    		return this.array[ index * this.itemSize + 3 ];

    	},

    	setW: function ( index, w ) {

    		this.array[ index * this.itemSize + 3 ] = w;

    		return this;

    	},

    	setXY: function ( index, x, y ) {

    		index *= this.itemSize;

    		this.array[ index + 0 ] = x;
    		this.array[ index + 1 ] = y;

    		return this;

    	},

    	setXYZ: function ( index, x, y, z ) {

    		index *= this.itemSize;

    		this.array[ index + 0 ] = x;
    		this.array[ index + 1 ] = y;
    		this.array[ index + 2 ] = z;

    		return this;

    	},

    	setXYZW: function ( index, x, y, z, w ) {

    		index *= this.itemSize;

    		this.array[ index + 0 ] = x;
    		this.array[ index + 1 ] = y;
    		this.array[ index + 2 ] = z;
    		this.array[ index + 3 ] = w;

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	}

    };

    //

    function Int8Attribute( array, itemSize ) {

    	return new BufferAttribute( new Int8Array( array ), itemSize );

    }

    function Uint8Attribute( array, itemSize ) {

    	return new BufferAttribute( new Uint8Array( array ), itemSize );

    }

    function Uint8ClampedAttribute( array, itemSize ) {

    	return new BufferAttribute( new Uint8ClampedArray( array ), itemSize );

    }

    function Int16Attribute( array, itemSize ) {

    	return new BufferAttribute( new Int16Array( array ), itemSize );

    }

    function Uint16Attribute( array, itemSize ) {

    	return new BufferAttribute( new Uint16Array( array ), itemSize );

    }

    function Int32Attribute( array, itemSize ) {

    	return new BufferAttribute( new Int32Array( array ), itemSize );

    }

    function Uint32Attribute( array, itemSize ) {

    	return new BufferAttribute( new Uint32Array( array ), itemSize );

    }

    function Float32Attribute( array, itemSize ) {

    	return new BufferAttribute( new Float32Array( array ), itemSize );

    }

    function Float64Attribute( array, itemSize ) {

    	return new BufferAttribute( new Float64Array( array ), itemSize );

    }

    // Deprecated

    function DynamicBufferAttribute( array, itemSize ) {

    	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
    	return new BufferAttribute( array, itemSize ).setDynamic( true );

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author kile / http://kile.stravaganza.org/
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author bhouston / http://clara.io
     */

    function Geometry() {

    	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'Geometry';

    	this.vertices = [];
    	this.colors = [];
    	this.faces = [];
    	this.faceVertexUvs = [ [] ];

    	this.morphTargets = [];
    	this.morphNormals = [];

    	this.skinWeights = [];
    	this.skinIndices = [];

    	this.lineDistances = [];

    	this.boundingBox = null;
    	this.boundingSphere = null;

    	// update flags

    	this.elementsNeedUpdate = false;
    	this.verticesNeedUpdate = false;
    	this.uvsNeedUpdate = false;
    	this.normalsNeedUpdate = false;
    	this.colorsNeedUpdate = false;
    	this.lineDistancesNeedUpdate = false;
    	this.groupsNeedUpdate = false;

    }

    Object.assign( Geometry.prototype, EventDispatcher.prototype, {

    	isGeometry: true,

    	applyMatrix: function ( matrix ) {

    		var normalMatrix = new Matrix3().getNormalMatrix( matrix );

    		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

    			var vertex = this.vertices[ i ];
    			vertex.applyMatrix4( matrix );

    		}

    		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

    			var face = this.faces[ i ];
    			face.normal.applyMatrix3( normalMatrix ).normalize();

    			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

    				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

    			}

    		}

    		if ( this.boundingBox !== null ) {

    			this.computeBoundingBox();

    		}

    		if ( this.boundingSphere !== null ) {

    			this.computeBoundingSphere();

    		}

    		this.verticesNeedUpdate = true;
    		this.normalsNeedUpdate = true;

    		return this;

    	},

    	rotateX: function () {

    		// rotate geometry around world x-axis

    		var m1;

    		return function rotateX( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationX( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateY: function () {

    		// rotate geometry around world y-axis

    		var m1;

    		return function rotateY( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationY( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateZ: function () {

    		// rotate geometry around world z-axis

    		var m1;

    		return function rotateZ( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationZ( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	translate: function () {

    		// translate geometry

    		var m1;

    		return function translate( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeTranslation( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	scale: function () {

    		// scale geometry

    		var m1;

    		return function scale( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeScale( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	lookAt: function () {

    		var obj;

    		return function lookAt( vector ) {

    			if ( obj === undefined ) obj = new Object3D();

    			obj.lookAt( vector );

    			obj.updateMatrix();

    			this.applyMatrix( obj.matrix );

    		};

    	}(),

    	fromBufferGeometry: function ( geometry ) {

    		var scope = this;

    		var indices = geometry.index !== null ? geometry.index.array : undefined;
    		var attributes = geometry.attributes;

    		var positions = attributes.position.array;
    		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
    		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
    		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
    		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

    		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

    		var tempNormals = [];
    		var tempUVs = [];
    		var tempUVs2 = [];

    		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

    			scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

    			if ( normals !== undefined ) {

    				tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

    			}

    			if ( colors !== undefined ) {

    				scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

    			}

    			if ( uvs !== undefined ) {

    				tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

    			}

    			if ( uvs2 !== undefined ) {

    				tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

    			}

    		}

    		function addFace( a, b, c, materialIndex ) {

    			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
    			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

    			var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

    			scope.faces.push( face );

    			if ( uvs !== undefined ) {

    				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

    			}

    			if ( uvs2 !== undefined ) {

    				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

    			}

    		}

    		if ( indices !== undefined ) {

    			var groups = geometry.groups;

    			if ( groups.length > 0 ) {

    				for ( var i = 0; i < groups.length; i ++ ) {

    					var group = groups[ i ];

    					var start = group.start;
    					var count = group.count;

    					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

    						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );

    					}

    				}

    			} else {

    				for ( var i = 0; i < indices.length; i += 3 ) {

    					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

    				}

    			}

    		} else {

    			for ( var i = 0; i < positions.length / 3; i += 3 ) {

    				addFace( i, i + 1, i + 2 );

    			}

    		}

    		this.computeFaceNormals();

    		if ( geometry.boundingBox !== null ) {

    			this.boundingBox = geometry.boundingBox.clone();

    		}

    		if ( geometry.boundingSphere !== null ) {

    			this.boundingSphere = geometry.boundingSphere.clone();

    		}

    		return this;

    	},

    	center: function () {

    		this.computeBoundingBox();

    		var offset = this.boundingBox.getCenter().negate();

    		this.translate( offset.x, offset.y, offset.z );

    		return offset;

    	},

    	normalize: function () {

    		this.computeBoundingSphere();

    		var center = this.boundingSphere.center;
    		var radius = this.boundingSphere.radius;

    		var s = radius === 0 ? 1 : 1.0 / radius;

    		var matrix = new Matrix4();
    		matrix.set(
    			s, 0, 0, - s * center.x,
    			0, s, 0, - s * center.y,
    			0, 0, s, - s * center.z,
    			0, 0, 0, 1
    		);

    		this.applyMatrix( matrix );

    		return this;

    	},

    	computeFaceNormals: function () {

    		var cb = new Vector3(), ab = new Vector3();

    		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			var face = this.faces[ f ];

    			var vA = this.vertices[ face.a ];
    			var vB = this.vertices[ face.b ];
    			var vC = this.vertices[ face.c ];

    			cb.subVectors( vC, vB );
    			ab.subVectors( vA, vB );
    			cb.cross( ab );

    			cb.normalize();

    			face.normal.copy( cb );

    		}

    	},

    	computeVertexNormals: function ( areaWeighted ) {

    		if ( areaWeighted === undefined ) areaWeighted = true;

    		var v, vl, f, fl, face, vertices;

    		vertices = new Array( this.vertices.length );

    		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

    			vertices[ v ] = new Vector3();

    		}

    		if ( areaWeighted ) {

    			// vertex normals weighted by triangle areas
    			// http://www.iquilezles.org/www/articles/normals/normals.htm

    			var vA, vB, vC;
    			var cb = new Vector3(), ab = new Vector3();

    			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    				face = this.faces[ f ];

    				vA = this.vertices[ face.a ];
    				vB = this.vertices[ face.b ];
    				vC = this.vertices[ face.c ];

    				cb.subVectors( vC, vB );
    				ab.subVectors( vA, vB );
    				cb.cross( ab );

    				vertices[ face.a ].add( cb );
    				vertices[ face.b ].add( cb );
    				vertices[ face.c ].add( cb );

    			}

    		} else {

    			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    				face = this.faces[ f ];

    				vertices[ face.a ].add( face.normal );
    				vertices[ face.b ].add( face.normal );
    				vertices[ face.c ].add( face.normal );

    			}

    		}

    		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

    			vertices[ v ].normalize();

    		}

    		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			face = this.faces[ f ];

    			var vertexNormals = face.vertexNormals;

    			if ( vertexNormals.length === 3 ) {

    				vertexNormals[ 0 ].copy( vertices[ face.a ] );
    				vertexNormals[ 1 ].copy( vertices[ face.b ] );
    				vertexNormals[ 2 ].copy( vertices[ face.c ] );

    			} else {

    				vertexNormals[ 0 ] = vertices[ face.a ].clone();
    				vertexNormals[ 1 ] = vertices[ face.b ].clone();
    				vertexNormals[ 2 ] = vertices[ face.c ].clone();

    			}

    		}

    		if ( this.faces.length > 0 ) {

    			this.normalsNeedUpdate = true;

    		}

    	},

    	computeMorphNormals: function () {

    		var i, il, f, fl, face;

    		// save original normals
    		// - create temp variables on first access
    		//   otherwise just copy (for faster repeated calls)

    		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			face = this.faces[ f ];

    			if ( ! face.__originalFaceNormal ) {

    				face.__originalFaceNormal = face.normal.clone();

    			} else {

    				face.__originalFaceNormal.copy( face.normal );

    			}

    			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

    			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

    				if ( ! face.__originalVertexNormals[ i ] ) {

    					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

    				} else {

    					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

    				}

    			}

    		}

    		// use temp geometry to compute face and vertex normals for each morph

    		var tmpGeo = new Geometry();
    		tmpGeo.faces = this.faces;

    		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

    			// create on first access

    			if ( ! this.morphNormals[ i ] ) {

    				this.morphNormals[ i ] = {};
    				this.morphNormals[ i ].faceNormals = [];
    				this.morphNormals[ i ].vertexNormals = [];

    				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
    				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

    				var faceNormal, vertexNormals;

    				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    					faceNormal = new Vector3();
    					vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

    					dstNormalsFace.push( faceNormal );
    					dstNormalsVertex.push( vertexNormals );

    				}

    			}

    			var morphNormals = this.morphNormals[ i ];

    			// set vertices to morph target

    			tmpGeo.vertices = this.morphTargets[ i ].vertices;

    			// compute morph normals

    			tmpGeo.computeFaceNormals();
    			tmpGeo.computeVertexNormals();

    			// store morph normals

    			var faceNormal, vertexNormals;

    			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    				face = this.faces[ f ];

    				faceNormal = morphNormals.faceNormals[ f ];
    				vertexNormals = morphNormals.vertexNormals[ f ];

    				faceNormal.copy( face.normal );

    				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
    				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
    				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

    			}

    		}

    		// restore original normals

    		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			face = this.faces[ f ];

    			face.normal = face.__originalFaceNormal;
    			face.vertexNormals = face.__originalVertexNormals;

    		}

    	},

    	computeTangents: function () {

    		console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

    	},

    	computeLineDistances: function () {

    		var d = 0;
    		var vertices = this.vertices;

    		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

    			if ( i > 0 ) {

    				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

    			}

    			this.lineDistances[ i ] = d;

    		}

    	},

    	computeBoundingBox: function () {

    		if ( this.boundingBox === null ) {

    			this.boundingBox = new Box3();

    		}

    		this.boundingBox.setFromPoints( this.vertices );

    	},

    	computeBoundingSphere: function () {

    		if ( this.boundingSphere === null ) {

    			this.boundingSphere = new Sphere();

    		}

    		this.boundingSphere.setFromPoints( this.vertices );

    	},

    	merge: function ( geometry, matrix, materialIndexOffset ) {

    		if ( (geometry && geometry.isGeometry) === false ) {

    			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
    			return;

    		}

    		var normalMatrix,
    		vertexOffset = this.vertices.length,
    		vertices1 = this.vertices,
    		vertices2 = geometry.vertices,
    		faces1 = this.faces,
    		faces2 = geometry.faces,
    		uvs1 = this.faceVertexUvs[ 0 ],
    		uvs2 = geometry.faceVertexUvs[ 0 ],
    		colors1 = this.colors,
    		colors2 = geometry.colors;

    		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

    		if ( matrix !== undefined ) {

    			normalMatrix = new Matrix3().getNormalMatrix( matrix );

    		}

    		// vertices

    		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

    			var vertex = vertices2[ i ];

    			var vertexCopy = vertex.clone();

    			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

    			vertices1.push( vertexCopy );

    		}

    		// colors

    		for ( var i = 0, il = colors2.length; i < il; i ++ ) {

    			colors1.push( colors2[ i ].clone() );

    		}

    		// faces

    		for ( i = 0, il = faces2.length; i < il; i ++ ) {

    			var face = faces2[ i ], faceCopy, normal, color,
    			faceVertexNormals = face.vertexNormals,
    			faceVertexColors = face.vertexColors;

    			faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
    			faceCopy.normal.copy( face.normal );

    			if ( normalMatrix !== undefined ) {

    				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

    			}

    			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

    				normal = faceVertexNormals[ j ].clone();

    				if ( normalMatrix !== undefined ) {

    					normal.applyMatrix3( normalMatrix ).normalize();

    				}

    				faceCopy.vertexNormals.push( normal );

    			}

    			faceCopy.color.copy( face.color );

    			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

    				color = faceVertexColors[ j ];
    				faceCopy.vertexColors.push( color.clone() );

    			}

    			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

    			faces1.push( faceCopy );

    		}

    		// uvs

    		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

    			var uv = uvs2[ i ], uvCopy = [];

    			if ( uv === undefined ) {

    				continue;

    			}

    			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

    				uvCopy.push( uv[ j ].clone() );

    			}

    			uvs1.push( uvCopy );

    		}

    	},

    	mergeMesh: function ( mesh ) {

    		if ( (mesh && mesh.isMesh) === false ) {

    			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
    			return;

    		}

    		mesh.matrixAutoUpdate && mesh.updateMatrix();

    		this.merge( mesh.geometry, mesh.matrix );

    	},

    	/*
    	 * Checks for duplicate vertices with hashmap.
    	 * Duplicated vertices are removed
    	 * and faces' vertices are updated.
    	 */

    	mergeVertices: function () {

    		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
    		var unique = [], changes = [];

    		var v, key;
    		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
    		var precision = Math.pow( 10, precisionPoints );
    		var i, il, face;
    		var indices, j, jl;

    		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

    			v = this.vertices[ i ];
    			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

    			if ( verticesMap[ key ] === undefined ) {

    				verticesMap[ key ] = i;
    				unique.push( this.vertices[ i ] );
    				changes[ i ] = unique.length - 1;

    			} else {

    				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
    				changes[ i ] = changes[ verticesMap[ key ] ];

    			}

    		}


    		// if faces are completely degenerate after merging vertices, we
    		// have to remove them from the geometry.
    		var faceIndicesToRemove = [];

    		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

    			face = this.faces[ i ];

    			face.a = changes[ face.a ];
    			face.b = changes[ face.b ];
    			face.c = changes[ face.c ];

    			indices = [ face.a, face.b, face.c ];

    			var dupIndex = - 1;

    			// if any duplicate vertices are found in a Face3
    			// we have to remove the face as nothing can be saved
    			for ( var n = 0; n < 3; n ++ ) {

    				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

    					dupIndex = n;
    					faceIndicesToRemove.push( i );
    					break;

    				}

    			}

    		}

    		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

    			var idx = faceIndicesToRemove[ i ];

    			this.faces.splice( idx, 1 );

    			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

    				this.faceVertexUvs[ j ].splice( idx, 1 );

    			}

    		}

    		// Use unique set of vertices

    		var diff = this.vertices.length - unique.length;
    		this.vertices = unique;
    		return diff;

    	},

    	sortFacesByMaterialIndex: function () {

    		var faces = this.faces;
    		var length = faces.length;

    		// tag faces

    		for ( var i = 0; i < length; i ++ ) {

    			faces[ i ]._id = i;

    		}

    		// sort faces

    		function materialIndexSort( a, b ) {

    			return a.materialIndex - b.materialIndex;

    		}

    		faces.sort( materialIndexSort );

    		// sort uvs

    		var uvs1 = this.faceVertexUvs[ 0 ];
    		var uvs2 = this.faceVertexUvs[ 1 ];

    		var newUvs1, newUvs2;

    		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
    		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

    		for ( var i = 0; i < length; i ++ ) {

    			var id = faces[ i ]._id;

    			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
    			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

    		}

    		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
    		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

    	},

    	toJSON: function () {

    		var data = {
    			metadata: {
    				version: 4.4,
    				type: 'Geometry',
    				generator: 'Geometry.toJSON'
    			}
    		};

    		// standard Geometry serialization

    		data.uuid = this.uuid;
    		data.type = this.type;
    		if ( this.name !== '' ) data.name = this.name;

    		if ( this.parameters !== undefined ) {

    			var parameters = this.parameters;

    			for ( var key in parameters ) {

    				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

    			}

    			return data;

    		}

    		var vertices = [];

    		for ( var i = 0; i < this.vertices.length; i ++ ) {

    			var vertex = this.vertices[ i ];
    			vertices.push( vertex.x, vertex.y, vertex.z );

    		}

    		var faces = [];
    		var normals = [];
    		var normalsHash = {};
    		var colors = [];
    		var colorsHash = {};
    		var uvs = [];
    		var uvsHash = {};

    		for ( var i = 0; i < this.faces.length; i ++ ) {

    			var face = this.faces[ i ];

    			var hasMaterial = true;
    			var hasFaceUv = false; // deprecated
    			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
    			var hasFaceNormal = face.normal.length() > 0;
    			var hasFaceVertexNormal = face.vertexNormals.length > 0;
    			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
    			var hasFaceVertexColor = face.vertexColors.length > 0;

    			var faceType = 0;

    			faceType = setBit( faceType, 0, 0 ); // isQuad
    			faceType = setBit( faceType, 1, hasMaterial );
    			faceType = setBit( faceType, 2, hasFaceUv );
    			faceType = setBit( faceType, 3, hasFaceVertexUv );
    			faceType = setBit( faceType, 4, hasFaceNormal );
    			faceType = setBit( faceType, 5, hasFaceVertexNormal );
    			faceType = setBit( faceType, 6, hasFaceColor );
    			faceType = setBit( faceType, 7, hasFaceVertexColor );

    			faces.push( faceType );
    			faces.push( face.a, face.b, face.c );
    			faces.push( face.materialIndex );

    			if ( hasFaceVertexUv ) {

    				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

    				faces.push(
    					getUvIndex( faceVertexUvs[ 0 ] ),
    					getUvIndex( faceVertexUvs[ 1 ] ),
    					getUvIndex( faceVertexUvs[ 2 ] )
    				);

    			}

    			if ( hasFaceNormal ) {

    				faces.push( getNormalIndex( face.normal ) );

    			}

    			if ( hasFaceVertexNormal ) {

    				var vertexNormals = face.vertexNormals;

    				faces.push(
    					getNormalIndex( vertexNormals[ 0 ] ),
    					getNormalIndex( vertexNormals[ 1 ] ),
    					getNormalIndex( vertexNormals[ 2 ] )
    				);

    			}

    			if ( hasFaceColor ) {

    				faces.push( getColorIndex( face.color ) );

    			}

    			if ( hasFaceVertexColor ) {

    				var vertexColors = face.vertexColors;

    				faces.push(
    					getColorIndex( vertexColors[ 0 ] ),
    					getColorIndex( vertexColors[ 1 ] ),
    					getColorIndex( vertexColors[ 2 ] )
    				);

    			}

    		}

    		function setBit( value, position, enabled ) {

    			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

    		}

    		function getNormalIndex( normal ) {

    			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

    			if ( normalsHash[ hash ] !== undefined ) {

    				return normalsHash[ hash ];

    			}

    			normalsHash[ hash ] = normals.length / 3;
    			normals.push( normal.x, normal.y, normal.z );

    			return normalsHash[ hash ];

    		}

    		function getColorIndex( color ) {

    			var hash = color.r.toString() + color.g.toString() + color.b.toString();

    			if ( colorsHash[ hash ] !== undefined ) {

    				return colorsHash[ hash ];

    			}

    			colorsHash[ hash ] = colors.length;
    			colors.push( color.getHex() );

    			return colorsHash[ hash ];

    		}

    		function getUvIndex( uv ) {

    			var hash = uv.x.toString() + uv.y.toString();

    			if ( uvsHash[ hash ] !== undefined ) {

    				return uvsHash[ hash ];

    			}

    			uvsHash[ hash ] = uvs.length / 2;
    			uvs.push( uv.x, uv.y );

    			return uvsHash[ hash ];

    		}

    		data.data = {};

    		data.data.vertices = vertices;
    		data.data.normals = normals;
    		if ( colors.length > 0 ) data.data.colors = colors;
    		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
    		data.data.faces = faces;

    		return data;

    	},

    	clone: function () {

    		/*
    		// Handle primitives

    		var parameters = this.parameters;

    		if ( parameters !== undefined ) {

    			var values = [];

    			for ( var key in parameters ) {

    				values.push( parameters[ key ] );

    			}

    			var geometry = Object.create( this.constructor.prototype );
    			this.constructor.apply( geometry, values );
    			return geometry;

    		}

    		return new this.constructor().copy( this );
    		*/

    		return new Geometry().copy( this );

    	},

    	copy: function ( source ) {

    		this.vertices = [];
    		this.faces = [];
    		this.faceVertexUvs = [ [] ];
    		this.colors = [];

    		var vertices = source.vertices;

    		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

    			this.vertices.push( vertices[ i ].clone() );

    		}

    		var colors = source.colors;

    		for ( var i = 0, il = colors.length; i < il; i ++ ) {

    			this.colors.push( colors[ i ].clone() );

    		}

    		var faces = source.faces;

    		for ( var i = 0, il = faces.length; i < il; i ++ ) {

    			this.faces.push( faces[ i ].clone() );

    		}

    		for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

    			var faceVertexUvs = source.faceVertexUvs[ i ];

    			if ( this.faceVertexUvs[ i ] === undefined ) {

    				this.faceVertexUvs[ i ] = [];

    			}

    			for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

    				var uvs = faceVertexUvs[ j ], uvsCopy = [];

    				for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

    					var uv = uvs[ k ];

    					uvsCopy.push( uv.clone() );

    				}

    				this.faceVertexUvs[ i ].push( uvsCopy );

    			}

    		}

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    var count$3 = 0;
    function GeometryIdCount() { return count$3++; };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function DirectGeometry() {

    	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'DirectGeometry';

    	this.indices = [];
    	this.vertices = [];
    	this.normals = [];
    	this.colors = [];
    	this.uvs = [];
    	this.uvs2 = [];

    	this.groups = [];

    	this.morphTargets = {};

    	this.skinWeights = [];
    	this.skinIndices = [];

    	// this.lineDistances = [];

    	this.boundingBox = null;
    	this.boundingSphere = null;

    	// update flags

    	this.verticesNeedUpdate = false;
    	this.normalsNeedUpdate = false;
    	this.colorsNeedUpdate = false;
    	this.uvsNeedUpdate = false;
    	this.groupsNeedUpdate = false;

    }

    Object.assign( DirectGeometry.prototype, EventDispatcher.prototype, {

    	computeBoundingBox: Geometry.prototype.computeBoundingBox,
    	computeBoundingSphere: Geometry.prototype.computeBoundingSphere,

    	computeFaceNormals: function () {

    		console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

    	},

    	computeVertexNormals: function () {

    		console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

    	},

    	computeGroups: function ( geometry ) {

    		var group;
    		var groups = [];
    		var materialIndex;

    		var faces = geometry.faces;

    		for ( var i = 0; i < faces.length; i ++ ) {

    			var face = faces[ i ];

    			// materials

    			if ( face.materialIndex !== materialIndex ) {

    				materialIndex = face.materialIndex;

    				if ( group !== undefined ) {

    					group.count = ( i * 3 ) - group.start;
    					groups.push( group );

    				}

    				group = {
    					start: i * 3,
    					materialIndex: materialIndex
    				};

    			}

    		}

    		if ( group !== undefined ) {

    			group.count = ( i * 3 ) - group.start;
    			groups.push( group );

    		}

    		this.groups = groups;

    	},

    	fromGeometry: function ( geometry ) {

    		var faces = geometry.faces;
    		var vertices = geometry.vertices;
    		var faceVertexUvs = geometry.faceVertexUvs;

    		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
    		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

    		// morphs

    		var morphTargets = geometry.morphTargets;
    		var morphTargetsLength = morphTargets.length;

    		var morphTargetsPosition;

    		if ( morphTargetsLength > 0 ) {

    			morphTargetsPosition = [];

    			for ( var i = 0; i < morphTargetsLength; i ++ ) {

    				morphTargetsPosition[ i ] = [];

    			}

    			this.morphTargets.position = morphTargetsPosition;

    		}

    		var morphNormals = geometry.morphNormals;
    		var morphNormalsLength = morphNormals.length;

    		var morphTargetsNormal;

    		if ( morphNormalsLength > 0 ) {

    			morphTargetsNormal = [];

    			for ( var i = 0; i < morphNormalsLength; i ++ ) {

    				morphTargetsNormal[ i ] = [];

    			}

    			this.morphTargets.normal = morphTargetsNormal;

    		}

    		// skins

    		var skinIndices = geometry.skinIndices;
    		var skinWeights = geometry.skinWeights;

    		var hasSkinIndices = skinIndices.length === vertices.length;
    		var hasSkinWeights = skinWeights.length === vertices.length;

    		//

    		for ( var i = 0; i < faces.length; i ++ ) {

    			var face = faces[ i ];

    			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

    			var vertexNormals = face.vertexNormals;

    			if ( vertexNormals.length === 3 ) {

    				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

    			} else {

    				var normal = face.normal;

    				this.normals.push( normal, normal, normal );

    			}

    			var vertexColors = face.vertexColors;

    			if ( vertexColors.length === 3 ) {

    				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

    			} else {

    				var color = face.color;

    				this.colors.push( color, color, color );

    			}

    			if ( hasFaceVertexUv === true ) {

    				var vertexUvs = faceVertexUvs[ 0 ][ i ];

    				if ( vertexUvs !== undefined ) {

    					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

    				} else {

    					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

    					this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

    				}

    			}

    			if ( hasFaceVertexUv2 === true ) {

    				var vertexUvs = faceVertexUvs[ 1 ][ i ];

    				if ( vertexUvs !== undefined ) {

    					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

    				} else {

    					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

    					this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

    				}

    			}

    			// morphs

    			for ( var j = 0; j < morphTargetsLength; j ++ ) {

    				var morphTarget = morphTargets[ j ].vertices;

    				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

    			}

    			for ( var j = 0; j < morphNormalsLength; j ++ ) {

    				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

    				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

    			}

    			// skins

    			if ( hasSkinIndices ) {

    				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

    			}

    			if ( hasSkinWeights ) {

    				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

    			}

    		}

    		this.computeGroups( geometry );

    		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
    		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function BufferGeometry() {

    	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'BufferGeometry';

    	this.index = null;
    	this.attributes = {};

    	this.morphAttributes = {};

    	this.groups = [];

    	this.boundingBox = null;
    	this.boundingSphere = null;

    	this.drawRange = { start: 0, count: Infinity };

    }

    Object.assign( BufferGeometry.prototype, EventDispatcher.prototype, {

    	isBufferGeometry: true,

    	getIndex: function () {

    		return this.index;

    	},

    	setIndex: function ( index ) {

    		this.index = index;

    	},

    	addAttribute: function ( name, attribute ) {

    		if ( (attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false ) {

    			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

    			this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

    			return;

    		}

    		if ( name === 'index' ) {

    			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
    			this.setIndex( attribute );

    			return;

    		}

    		this.attributes[ name ] = attribute;

    		return this;

    	},

    	getAttribute: function ( name ) {

    		return this.attributes[ name ];

    	},

    	removeAttribute: function ( name ) {

    		delete this.attributes[ name ];

    		return this;

    	},

    	addGroup: function ( start, count, materialIndex ) {

    		this.groups.push( {

    			start: start,
    			count: count,
    			materialIndex: materialIndex !== undefined ? materialIndex : 0

    		} );

    	},

    	clearGroups: function () {

    		this.groups = [];

    	},

    	setDrawRange: function ( start, count ) {

    		this.drawRange.start = start;
    		this.drawRange.count = count;

    	},

    	applyMatrix: function ( matrix ) {

    		var position = this.attributes.position;

    		if ( position !== undefined ) {

    			matrix.applyToVector3Array( position.array );
    			position.needsUpdate = true;

    		}

    		var normal = this.attributes.normal;

    		if ( normal !== undefined ) {

    			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

    			normalMatrix.applyToVector3Array( normal.array );
    			normal.needsUpdate = true;

    		}

    		if ( this.boundingBox !== null ) {

    			this.computeBoundingBox();

    		}

    		if ( this.boundingSphere !== null ) {

    			this.computeBoundingSphere();

    		}

    		return this;

    	},

    	rotateX: function () {

    		// rotate geometry around world x-axis

    		var m1;

    		return function rotateX( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationX( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateY: function () {

    		// rotate geometry around world y-axis

    		var m1;

    		return function rotateY( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationY( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateZ: function () {

    		// rotate geometry around world z-axis

    		var m1;

    		return function rotateZ( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationZ( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	translate: function () {

    		// translate geometry

    		var m1;

    		return function translate( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeTranslation( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	scale: function () {

    		// scale geometry

    		var m1;

    		return function scale( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeScale( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	lookAt: function () {

    		var obj;

    		return function lookAt( vector ) {

    			if ( obj === undefined ) obj = new Object3D();

    			obj.lookAt( vector );

    			obj.updateMatrix();

    			this.applyMatrix( obj.matrix );

    		};

    	}(),

    	center: function () {

    		this.computeBoundingBox();

    		var offset = this.boundingBox.getCenter().negate();

    		this.translate( offset.x, offset.y, offset.z );

    		return offset;

    	},

    	setFromObject: function ( object ) {

    		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

    		var geometry = object.geometry;

    		if ( (object && object.isPoints) || (object && object.isLine) ) {

    			var positions = new Float32Attribute( geometry.vertices.length * 3, 3 );
    			var colors = new Float32Attribute( geometry.colors.length * 3, 3 );

    			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
    			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

    			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

    				var lineDistances = new Float32Attribute( geometry.lineDistances.length, 1 );

    				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

    			}

    			if ( geometry.boundingSphere !== null ) {

    				this.boundingSphere = geometry.boundingSphere.clone();

    			}

    			if ( geometry.boundingBox !== null ) {

    				this.boundingBox = geometry.boundingBox.clone();

    			}

    		} else if ( (object && object.isMesh) ) {

    			if ( (geometry && geometry.isGeometry) ) {

    				this.fromGeometry( geometry );

    			}

    		}

    		return this;

    	},

    	updateFromObject: function ( object ) {

    		var geometry = object.geometry;

    		if ( (object && object.isMesh) ) {

    			var direct = geometry.__directGeometry;

    			if ( geometry.elementsNeedUpdate === true ) {

    				direct = undefined;
    				geometry.elementsNeedUpdate = false;

    			}

    			if ( direct === undefined ) {

    				return this.fromGeometry( geometry );

    			}

    			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
    			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
    			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
    			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
    			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

    			geometry.verticesNeedUpdate = false;
    			geometry.normalsNeedUpdate = false;
    			geometry.colorsNeedUpdate = false;
    			geometry.uvsNeedUpdate = false;
    			geometry.groupsNeedUpdate = false;

    			geometry = direct;

    		}

    		var attribute;

    		if ( geometry.verticesNeedUpdate === true ) {

    			attribute = this.attributes.position;

    			if ( attribute !== undefined ) {

    				attribute.copyVector3sArray( geometry.vertices );
    				attribute.needsUpdate = true;

    			}

    			geometry.verticesNeedUpdate = false;

    		}

    		if ( geometry.normalsNeedUpdate === true ) {

    			attribute = this.attributes.normal;

    			if ( attribute !== undefined ) {

    				attribute.copyVector3sArray( geometry.normals );
    				attribute.needsUpdate = true;

    			}

    			geometry.normalsNeedUpdate = false;

    		}

    		if ( geometry.colorsNeedUpdate === true ) {

    			attribute = this.attributes.color;

    			if ( attribute !== undefined ) {

    				attribute.copyColorsArray( geometry.colors );
    				attribute.needsUpdate = true;

    			}

    			geometry.colorsNeedUpdate = false;

    		}

    		if ( geometry.uvsNeedUpdate ) {

    			attribute = this.attributes.uv;

    			if ( attribute !== undefined ) {

    				attribute.copyVector2sArray( geometry.uvs );
    				attribute.needsUpdate = true;

    			}

    			geometry.uvsNeedUpdate = false;

    		}

    		if ( geometry.lineDistancesNeedUpdate ) {

    			attribute = this.attributes.lineDistance;

    			if ( attribute !== undefined ) {

    				attribute.copyArray( geometry.lineDistances );
    				attribute.needsUpdate = true;

    			}

    			geometry.lineDistancesNeedUpdate = false;

    		}

    		if ( geometry.groupsNeedUpdate ) {

    			geometry.computeGroups( object.geometry );
    			this.groups = geometry.groups;

    			geometry.groupsNeedUpdate = false;

    		}

    		return this;

    	},

    	fromGeometry: function ( geometry ) {

    		geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

    		return this.fromDirectGeometry( geometry.__directGeometry );

    	},

    	fromDirectGeometry: function ( geometry ) {

    		var positions = new Float32Array( geometry.vertices.length * 3 );
    		this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

    		if ( geometry.normals.length > 0 ) {

    			var normals = new Float32Array( geometry.normals.length * 3 );
    			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

    		}

    		if ( geometry.colors.length > 0 ) {

    			var colors = new Float32Array( geometry.colors.length * 3 );
    			this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

    		}

    		if ( geometry.uvs.length > 0 ) {

    			var uvs = new Float32Array( geometry.uvs.length * 2 );
    			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

    		}

    		if ( geometry.uvs2.length > 0 ) {

    			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
    			this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

    		}

    		if ( geometry.indices.length > 0 ) {

    			var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
    			var indices = new TypeArray( geometry.indices.length * 3 );
    			this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

    		}

    		// groups

    		this.groups = geometry.groups;

    		// morphs

    		for ( var name in geometry.morphTargets ) {

    			var array = [];
    			var morphTargets = geometry.morphTargets[ name ];

    			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

    				var morphTarget = morphTargets[ i ];

    				var attribute = new Float32Attribute( morphTarget.length * 3, 3 );

    				array.push( attribute.copyVector3sArray( morphTarget ) );

    			}

    			this.morphAttributes[ name ] = array;

    		}

    		// skinning

    		if ( geometry.skinIndices.length > 0 ) {

    			var skinIndices = new Float32Attribute( geometry.skinIndices.length * 4, 4 );
    			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

    		}

    		if ( geometry.skinWeights.length > 0 ) {

    			var skinWeights = new Float32Attribute( geometry.skinWeights.length * 4, 4 );
    			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

    		}

    		//

    		if ( geometry.boundingSphere !== null ) {

    			this.boundingSphere = geometry.boundingSphere.clone();

    		}

    		if ( geometry.boundingBox !== null ) {

    			this.boundingBox = geometry.boundingBox.clone();

    		}

    		return this;

    	},

    	computeBoundingBox: function () {

    		if ( this.boundingBox === null ) {

    			this.boundingBox = new Box3();

    		}

    		var positions = this.attributes.position.array;

    		if ( positions !== undefined ) {

    			this.boundingBox.setFromArray( positions );

    		} else {

    			this.boundingBox.makeEmpty();

    		}

    		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

    			console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

    		}

    	},

    	computeBoundingSphere: function () {

    		var box = new Box3();
    		var vector = new Vector3();

    		return function computeBoundingSphere() {

    			if ( this.boundingSphere === null ) {

    				this.boundingSphere = new Sphere();

    			}

    			var positions = this.attributes.position;

    			if ( positions ) {

    				var array = positions.array;
    				var center = this.boundingSphere.center;

    				box.setFromArray( array );
    				box.getCenter( center );

    				// hoping to find a boundingSphere with a radius smaller than the
    				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

    				var maxRadiusSq = 0;

    				for ( var i = 0, il = array.length; i < il; i += 3 ) {

    					vector.fromArray( array, i );
    					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

    				}

    				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

    				if ( isNaN( this.boundingSphere.radius ) ) {

    					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

    				}

    			}

    		};

    	}(),

    	computeFaceNormals: function () {

    		// backwards compatibility

    	},

    	computeVertexNormals: function () {

    		var index = this.index;
    		var attributes = this.attributes;
    		var groups = this.groups;

    		if ( attributes.position ) {

    			var positions = attributes.position.array;

    			if ( attributes.normal === undefined ) {

    				this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

    			} else {

    				// reset existing normals to zero

    				var array = attributes.normal.array;

    				for ( var i = 0, il = array.length; i < il; i ++ ) {

    					array[ i ] = 0;

    				}

    			}

    			var normals = attributes.normal.array;

    			var vA, vB, vC,

    			pA = new Vector3(),
    			pB = new Vector3(),
    			pC = new Vector3(),

    			cb = new Vector3(),
    			ab = new Vector3();

    			// indexed elements

    			if ( index ) {

    				var indices = index.array;

    				if ( groups.length === 0 ) {

    					this.addGroup( 0, indices.length );

    				}

    				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

    					var group = groups[ j ];

    					var start = group.start;
    					var count = group.count;

    					for ( var i = start, il = start + count; i < il; i += 3 ) {

    						vA = indices[ i + 0 ] * 3;
    						vB = indices[ i + 1 ] * 3;
    						vC = indices[ i + 2 ] * 3;

    						pA.fromArray( positions, vA );
    						pB.fromArray( positions, vB );
    						pC.fromArray( positions, vC );

    						cb.subVectors( pC, pB );
    						ab.subVectors( pA, pB );
    						cb.cross( ab );

    						normals[ vA ] += cb.x;
    						normals[ vA + 1 ] += cb.y;
    						normals[ vA + 2 ] += cb.z;

    						normals[ vB ] += cb.x;
    						normals[ vB + 1 ] += cb.y;
    						normals[ vB + 2 ] += cb.z;

    						normals[ vC ] += cb.x;
    						normals[ vC + 1 ] += cb.y;
    						normals[ vC + 2 ] += cb.z;

    					}

    				}

    			} else {

    				// non-indexed elements (unconnected triangle soup)

    				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

    					pA.fromArray( positions, i );
    					pB.fromArray( positions, i + 3 );
    					pC.fromArray( positions, i + 6 );

    					cb.subVectors( pC, pB );
    					ab.subVectors( pA, pB );
    					cb.cross( ab );

    					normals[ i ] = cb.x;
    					normals[ i + 1 ] = cb.y;
    					normals[ i + 2 ] = cb.z;

    					normals[ i + 3 ] = cb.x;
    					normals[ i + 4 ] = cb.y;
    					normals[ i + 5 ] = cb.z;

    					normals[ i + 6 ] = cb.x;
    					normals[ i + 7 ] = cb.y;
    					normals[ i + 8 ] = cb.z;

    				}

    			}

    			this.normalizeNormals();

    			attributes.normal.needsUpdate = true;

    		}

    	},

    	merge: function ( geometry, offset ) {

    		if ( (geometry && geometry.isBufferGeometry) === false ) {

    			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
    			return;

    		}

    		if ( offset === undefined ) offset = 0;

    		var attributes = this.attributes;

    		for ( var key in attributes ) {

    			if ( geometry.attributes[ key ] === undefined ) continue;

    			var attribute1 = attributes[ key ];
    			var attributeArray1 = attribute1.array;

    			var attribute2 = geometry.attributes[ key ];
    			var attributeArray2 = attribute2.array;

    			var attributeSize = attribute2.itemSize;

    			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

    				attributeArray1[ j ] = attributeArray2[ i ];

    			}

    		}

    		return this;

    	},

    	normalizeNormals: function () {

    		var normals = this.attributes.normal.array;

    		var x, y, z, n;

    		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

    			x = normals[ i ];
    			y = normals[ i + 1 ];
    			z = normals[ i + 2 ];

    			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

    			normals[ i ] *= n;
    			normals[ i + 1 ] *= n;
    			normals[ i + 2 ] *= n;

    		}

    	},

    	toNonIndexed: function () {

    		if ( this.index === null ) {

    			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
    			return this;

    		}

    		var geometry2 = new BufferGeometry();

    		var indices = this.index.array;
    		var attributes = this.attributes;

    		for ( var name in attributes ) {

    			var attribute = attributes[ name ];

    			var array = attribute.array;
    			var itemSize = attribute.itemSize;

    			var array2 = new array.constructor( indices.length * itemSize );

    			var index = 0, index2 = 0;

    			for ( var i = 0, l = indices.length; i < l; i ++ ) {

    				index = indices[ i ] * itemSize;

    				for ( var j = 0; j < itemSize; j ++ ) {

    					array2[ index2 ++ ] = array[ index ++ ];

    				}

    			}

    			geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

    		}

    		return geometry2;

    	},

    	toJSON: function () {

    		var data = {
    			metadata: {
    				version: 4.4,
    				type: 'BufferGeometry',
    				generator: 'BufferGeometry.toJSON'
    			}
    		};

    		// standard BufferGeometry serialization

    		data.uuid = this.uuid;
    		data.type = this.type;
    		if ( this.name !== '' ) data.name = this.name;

    		if ( this.parameters !== undefined ) {

    			var parameters = this.parameters;

    			for ( var key in parameters ) {

    				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

    			}

    			return data;

    		}

    		data.data = { attributes: {} };

    		var index = this.index;

    		if ( index !== null ) {

    			var array = Array.prototype.slice.call( index.array );

    			data.data.index = {
    				type: index.array.constructor.name,
    				array: array
    			};

    		}

    		var attributes = this.attributes;

    		for ( var key in attributes ) {

    			var attribute = attributes[ key ];

    			var array = Array.prototype.slice.call( attribute.array );

    			data.data.attributes[ key ] = {
    				itemSize: attribute.itemSize,
    				type: attribute.array.constructor.name,
    				array: array,
    				normalized: attribute.normalized
    			};

    		}

    		var groups = this.groups;

    		if ( groups.length > 0 ) {

    			data.data.groups = JSON.parse( JSON.stringify( groups ) );

    		}

    		var boundingSphere = this.boundingSphere;

    		if ( boundingSphere !== null ) {

    			data.data.boundingSphere = {
    				center: boundingSphere.center.toArray(),
    				radius: boundingSphere.radius
    			};

    		}

    		return data;

    	},

    	clone: function () {

    		/*
    		// Handle primitives

    		var parameters = this.parameters;

    		if ( parameters !== undefined ) {

    			var values = [];

    			for ( var key in parameters ) {

    				values.push( parameters[ key ] );

    			}

    			var geometry = Object.create( this.constructor.prototype );
    			this.constructor.apply( geometry, values );
    			return geometry;

    		}

    		return new this.constructor().copy( this );
    		*/

    		return new BufferGeometry().copy( this );

    	},

    	copy: function ( source ) {

    		var index = source.index;

    		if ( index !== null ) {

    			this.setIndex( index.clone() );

    		}

    		var attributes = source.attributes;

    		for ( var name in attributes ) {

    			var attribute = attributes[ name ];
    			this.addAttribute( name, attribute.clone() );

    		}

    		var groups = source.groups;

    		for ( var i = 0, l = groups.length; i < l; i ++ ) {

    			var group = groups[ i ];
    			this.addGroup( group.start, group.count, group.materialIndex );

    		}

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    BufferGeometry.MaxIndex = 65535;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author jonobr1 / http://jonobr1.com/
     */

    function Mesh( geometry, material ) {

    	Object3D.call( this );

    	this.type = 'Mesh';

    	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    	this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

    	this.drawMode = TrianglesDrawMode;

    	this.updateMorphTargets();

    }

    Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Mesh,

    	isMesh: true,

    	setDrawMode: function ( value ) {

    		this.drawMode = value;

    	},

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.drawMode = source.drawMode;

    		return this;

    	},

    	updateMorphTargets: function () {

    		var morphTargets = this.geometry.morphTargets;

    		if ( morphTargets !== undefined && morphTargets.length > 0 ) {

    			this.morphTargetInfluences = [];
    			this.morphTargetDictionary = {};

    			for ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {

    				this.morphTargetInfluences.push( 0 );
    				this.morphTargetDictionary[ morphTargets[ m ].name ] = m;

    			}

    		}

    	},

    	raycast: ( function () {

    		var inverseMatrix = new Matrix4();
    		var ray = new Ray();
    		var sphere = new Sphere();

    		var vA = new Vector3();
    		var vB = new Vector3();
    		var vC = new Vector3();

    		var tempA = new Vector3();
    		var tempB = new Vector3();
    		var tempC = new Vector3();

    		var uvA = new Vector2();
    		var uvB = new Vector2();
    		var uvC = new Vector2();

    		var barycoord = new Vector3();

    		var intersectionPoint = new Vector3();
    		var intersectionPointWorld = new Vector3();

    		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

    			Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

    			uv1.multiplyScalar( barycoord.x );
    			uv2.multiplyScalar( barycoord.y );
    			uv3.multiplyScalar( barycoord.z );

    			uv1.add( uv2 ).add( uv3 );

    			return uv1.clone();

    		}

    		function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {

    			var intersect;
    			var material = object.material;

    			if ( material.side === BackSide ) {

    				intersect = ray.intersectTriangle( pC, pB, pA, true, point );

    			} else {

    				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

    			}

    			if ( intersect === null ) return null;

    			intersectionPointWorld.copy( point );
    			intersectionPointWorld.applyMatrix4( object.matrixWorld );

    			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

    			if ( distance < raycaster.near || distance > raycaster.far ) return null;

    			return {
    				distance: distance,
    				point: intersectionPointWorld.clone(),
    				object: object
    			};

    		}

    		function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

    			vA.fromArray( positions, a * 3 );
    			vB.fromArray( positions, b * 3 );
    			vC.fromArray( positions, c * 3 );

    			var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

    			if ( intersection ) {

    				if ( uvs ) {

    					uvA.fromArray( uvs, a * 2 );
    					uvB.fromArray( uvs, b * 2 );
    					uvC.fromArray( uvs, c * 2 );

    					intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

    				}

    				intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
    				intersection.faceIndex = a;

    			}

    			return intersection;

    		}

    		return function raycast( raycaster, intersects ) {

    			var geometry = this.geometry;
    			var material = this.material;
    			var matrixWorld = this.matrixWorld;

    			if ( material === undefined ) return;

    			// Checking boundingSphere distance to ray

    			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere );
    			sphere.applyMatrix4( matrixWorld );

    			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

    			//

    			inverseMatrix.getInverse( matrixWorld );
    			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    			// Check boundingBox before continuing

    			if ( geometry.boundingBox !== null ) {

    				if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

    			}

    			var uvs, intersection;

    			if ( (geometry && geometry.isBufferGeometry) ) {

    				var a, b, c;
    				var index = geometry.index;
    				var attributes = geometry.attributes;
    				var positions = attributes.position.array;

    				if ( attributes.uv !== undefined ) {

    					uvs = attributes.uv.array;

    				}

    				if ( index !== null ) {

    					var indices = index.array;

    					for ( var i = 0, l = indices.length; i < l; i += 3 ) {

    						a = indices[ i ];
    						b = indices[ i + 1 ];
    						c = indices[ i + 2 ];

    						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

    						if ( intersection ) {

    							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
    							intersects.push( intersection );

    						}

    					}

    				} else {


    					for ( var i = 0, l = positions.length; i < l; i += 9 ) {

    						a = i / 3;
    						b = a + 1;
    						c = a + 2;

    						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

    						if ( intersection ) {

    							intersection.index = a; // triangle number in positions buffer semantics
    							intersects.push( intersection );

    						}

    					}

    				}

    			} else if ( (geometry && geometry.isGeometry) ) {

    				var fvA, fvB, fvC;
    				var isFaceMaterial = (material && material.isMultiMaterial);
    				var materials = isFaceMaterial === true ? material.materials : null;

    				var vertices = geometry.vertices;
    				var faces = geometry.faces;
    				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
    				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

    				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

    					var face = faces[ f ];
    					var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

    					if ( faceMaterial === undefined ) continue;

    					fvA = vertices[ face.a ];
    					fvB = vertices[ face.b ];
    					fvC = vertices[ face.c ];

    					if ( faceMaterial.morphTargets === true ) {

    						var morphTargets = geometry.morphTargets;
    						var morphInfluences = this.morphTargetInfluences;

    						vA.set( 0, 0, 0 );
    						vB.set( 0, 0, 0 );
    						vC.set( 0, 0, 0 );

    						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

    							var influence = morphInfluences[ t ];

    							if ( influence === 0 ) continue;

    							var targets = morphTargets[ t ].vertices;

    							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
    							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
    							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

    						}

    						vA.add( fvA );
    						vB.add( fvB );
    						vC.add( fvC );

    						fvA = vA;
    						fvB = vB;
    						fvC = vC;

    					}

    					intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

    					if ( intersection ) {

    						if ( uvs ) {

    							var uvs_f = uvs[ f ];
    							uvA.copy( uvs_f[ 0 ] );
    							uvB.copy( uvs_f[ 1 ] );
    							uvC.copy( uvs_f[ 2 ] );

    							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

    						}

    						intersection.face = face;
    						intersection.faceIndex = f;
    						intersects.push( intersection );

    					}

    				}

    			}

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.geometry, this.material ).copy( this );

    	}

    } );

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

    	BufferGeometry.call( this );

    	this.type = 'BoxBufferGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		depth: depth,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		depthSegments: depthSegments
    	};

    	var scope = this;

    	// segments
    	widthSegments = Math.floor( widthSegments ) || 1;
    	heightSegments = Math.floor( heightSegments ) || 1;
    	depthSegments = Math.floor( depthSegments ) || 1;

    	// these are used to calculate buffer length
    	var vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );
    	var indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );

    	// buffers
    	var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
    	var vertices = new Float32Array( vertexCount * 3 );
    	var normals = new Float32Array( vertexCount * 3 );
    	var uvs = new Float32Array( vertexCount * 2 );

    	// offset variables
    	var vertexBufferOffset = 0;
    	var uvBufferOffset = 0;
    	var indexBufferOffset = 0;
    	var numberOfVertices = 0;

    	// group variables
    	var groupStart = 0;

    	// build each side of the box geometry
    	buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
    	buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
    	buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
    	buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
    	buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
    	buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz

    	// build geometry
    	this.setIndex( new BufferAttribute( indices, 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    	// helper functions

    	function calculateVertexCount( w, h, d ) {

    		var vertices = 0;

    		// calculate the amount of vertices for each side (plane)
    		vertices += (w + 1) * (h + 1) * 2; // xy
    		vertices += (w + 1) * (d + 1) * 2; // xz
    		vertices += (d + 1) * (h + 1) * 2; // zy

    		return vertices;

    	}

    	function calculateIndexCount( w, h, d ) {

    		var index = 0;

    		// calculate the amount of squares for each side
    		index += w * h * 2; // xy
    		index += w * d * 2; // xz
    		index += d * h * 2; // zy

    		return index * 6; // two triangles per square => six vertices per square

    	}

    	function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

    		var segmentWidth	= width / gridX;
    		var segmentHeight = height / gridY;

    		var widthHalf = width / 2;
    		var heightHalf = height / 2;
    		var depthHalf = depth / 2;

    		var gridX1 = gridX + 1;
    		var gridY1 = gridY + 1;

    		var vertexCounter = 0;
    		var groupCount = 0;

    		var vector = new Vector3();

    		// generate vertices, normals and uvs

    		for ( var iy = 0; iy < gridY1; iy ++ ) {

    			var y = iy * segmentHeight - heightHalf;

    			for ( var ix = 0; ix < gridX1; ix ++ ) {

    				var x = ix * segmentWidth - widthHalf;

    				// set values to correct vector component
    				vector[ u ] = x * udir;
    				vector[ v ] = y * vdir;
    				vector[ w ] = depthHalf;

    				// now apply vector to vertex buffer
    				vertices[ vertexBufferOffset ] = vector.x;
    				vertices[ vertexBufferOffset + 1 ] = vector.y;
    				vertices[ vertexBufferOffset + 2 ] = vector.z;

    				// set values to correct vector component
    				vector[ u ] = 0;
    				vector[ v ] = 0;
    				vector[ w ] = depth > 0 ? 1 : - 1;

    				// now apply vector to normal buffer
    				normals[ vertexBufferOffset ] = vector.x;
    				normals[ vertexBufferOffset + 1 ] = vector.y;
    				normals[ vertexBufferOffset + 2 ] = vector.z;

    				// uvs
    				uvs[ uvBufferOffset ] = ix / gridX;
    				uvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );

    				// update offsets and counters
    				vertexBufferOffset += 3;
    				uvBufferOffset += 2;
    				vertexCounter += 1;

    			}

    		}

    		// 1. you need three indices to draw a single face
    		// 2. a single segment consists of two faces
    		// 3. so we need to generate six (2*3) indices per segment

    		for ( iy = 0; iy < gridY; iy ++ ) {

    			for ( ix = 0; ix < gridX; ix ++ ) {

    				// indices
    				var a = numberOfVertices + ix + gridX1 * iy;
    				var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
    				var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
    				var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

    				// face one
    				indices[ indexBufferOffset ] = a;
    				indices[ indexBufferOffset + 1 ] = b;
    				indices[ indexBufferOffset + 2 ] = d;

    				// face two
    				indices[ indexBufferOffset + 3 ] = b;
    				indices[ indexBufferOffset + 4 ] = c;
    				indices[ indexBufferOffset + 5 ] = d;

    				// update offsets and counters
    				indexBufferOffset += 6;
    				groupCount += 6;

    			}

    		}

    		// add a group to the geometry. this will ensure multi material support
    		scope.addGroup( groupStart, groupCount, materialIndex );

    		// calculate new start value for groups
    		groupStart += groupCount;

    		// update total number of vertices
    		numberOfVertices += vertexCounter;

    	}

    }

    BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
     */

    function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

    	BufferGeometry.call( this );

    	this.type = 'PlaneBufferGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments
    	};

    	var width_half = width / 2;
    	var height_half = height / 2;

    	var gridX = Math.floor( widthSegments ) || 1;
    	var gridY = Math.floor( heightSegments ) || 1;

    	var gridX1 = gridX + 1;
    	var gridY1 = gridY + 1;

    	var segment_width = width / gridX;
    	var segment_height = height / gridY;

    	var vertices = new Float32Array( gridX1 * gridY1 * 3 );
    	var normals = new Float32Array( gridX1 * gridY1 * 3 );
    	var uvs = new Float32Array( gridX1 * gridY1 * 2 );

    	var offset = 0;
    	var offset2 = 0;

    	for ( var iy = 0; iy < gridY1; iy ++ ) {

    		var y = iy * segment_height - height_half;

    		for ( var ix = 0; ix < gridX1; ix ++ ) {

    			var x = ix * segment_width - width_half;

    			vertices[ offset ] = x;
    			vertices[ offset + 1 ] = - y;

    			normals[ offset + 2 ] = 1;

    			uvs[ offset2 ] = ix / gridX;
    			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

    			offset += 3;
    			offset2 += 2;

    		}

    	}

    	offset = 0;

    	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

    	for ( var iy = 0; iy < gridY; iy ++ ) {

    		for ( var ix = 0; ix < gridX; ix ++ ) {

    			var a = ix + gridX1 * iy;
    			var b = ix + gridX1 * ( iy + 1 );
    			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
    			var d = ( ix + 1 ) + gridX1 * iy;

    			indices[ offset ] = a;
    			indices[ offset + 1 ] = b;
    			indices[ offset + 2 ] = d;

    			indices[ offset + 3 ] = b;
    			indices[ offset + 4 ] = c;
    			indices[ offset + 5 ] = d;

    			offset += 6;

    		}

    	}

    	this.setIndex( new BufferAttribute( indices, 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    }

    PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author WestLangley / http://github.com/WestLangley
    */

    function Camera() {

    	Object3D.call( this );

    	this.type = 'Camera';

    	this.matrixWorldInverse = new Matrix4();
    	this.projectionMatrix = new Matrix4();

    }

    Camera.prototype = Object.create( Object3D.prototype );
    Camera.prototype.constructor = Camera;

    Camera.prototype.isCamera = true;

    Camera.prototype.getWorldDirection = function () {

    	var quaternion = new Quaternion();

    	return function getWorldDirection( optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		this.getWorldQuaternion( quaternion );

    		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

    	};

    }();

    Camera.prototype.lookAt = function () {

    	// This routine does not support cameras with rotated and/or translated parent(s)

    	var m1 = new Matrix4();

    	return function lookAt( vector ) {

    		m1.lookAt( this.position, vector, this.up );

    		this.quaternion.setFromRotationMatrix( m1 );

    	};

    }();

    Camera.prototype.clone = function () {

    	return new this.constructor().copy( this );

    };

    Camera.prototype.copy = function ( source ) {

    	Object3D.prototype.copy.call( this, source );

    	this.matrixWorldInverse.copy( source.matrixWorldInverse );
    	this.projectionMatrix.copy( source.projectionMatrix );

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author greggman / http://games.greggman.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author tschw
     */

    function PerspectiveCamera( fov, aspect, near, far ) {

    	Camera.call( this );

    	this.type = 'PerspectiveCamera';

    	this.fov = fov !== undefined ? fov : 50;
    	this.zoom = 1;

    	this.near = near !== undefined ? near : 0.1;
    	this.far = far !== undefined ? far : 2000;
    	this.focus = 10;

    	this.aspect = aspect !== undefined ? aspect : 1;
    	this.view = null;

    	this.filmGauge = 35;	// width of the film (default in millimeters)
    	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

    	this.updateProjectionMatrix();

    }

    PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

    	constructor: PerspectiveCamera,

    	isPerspectiveCamera: true,

    	copy: function ( source ) {

    		Camera.prototype.copy.call( this, source );

    		this.fov = source.fov;
    		this.zoom = source.zoom;

    		this.near = source.near;
    		this.far = source.far;
    		this.focus = source.focus;

    		this.aspect = source.aspect;
    		this.view = source.view === null ? null : Object.assign( {}, source.view );

    		this.filmGauge = source.filmGauge;
    		this.filmOffset = source.filmOffset;

    		return this;

    	},

    	/**
    	 * Sets the FOV by focal length in respect to the current .filmGauge.
    	 *
    	 * The default film gauge is 35, so that the focal length can be specified for
    	 * a 35mm (full frame) camera.
    	 *
    	 * Values for focal length and film gauge must have the same unit.
    	 */
    	setFocalLength: function ( focalLength ) {

    		// see http://www.bobatkins.com/photography/technical/field_of_view.html
    		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

    		this.fov = exports.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
    		this.updateProjectionMatrix();

    	},

    	/**
    	 * Calculates the focal length from the current .fov and .filmGauge.
    	 */
    	getFocalLength: function () {

    		var vExtentSlope = Math.tan( exports.Math.DEG2RAD * 0.5 * this.fov );

    		return 0.5 * this.getFilmHeight() / vExtentSlope;

    	},

    	getEffectiveFOV: function () {

    		return exports.Math.RAD2DEG * 2 * Math.atan(
    				Math.tan( exports.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

    	},

    	getFilmWidth: function () {

    		// film not completely covered in portrait format (aspect < 1)
    		return this.filmGauge * Math.min( this.aspect, 1 );

    	},

    	getFilmHeight: function () {

    		// film not completely covered in landscape format (aspect > 1)
    		return this.filmGauge / Math.max( this.aspect, 1 );

    	},

    	/**
    	 * Sets an offset in a larger frustum. This is useful for multi-window or
    	 * multi-monitor/multi-machine setups.
    	 *
    	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
    	 * the monitors are in grid like this
    	 *
    	 *   +---+---+---+
    	 *   | A | B | C |
    	 *   +---+---+---+
    	 *   | D | E | F |
    	 *   +---+---+---+
    	 *
    	 * then for each monitor you would call it like this
    	 *
    	 *   var w = 1920;
    	 *   var h = 1080;
    	 *   var fullWidth = w * 3;
    	 *   var fullHeight = h * 2;
    	 *
    	 *   --A--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
    	 *   --B--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
    	 *   --C--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
    	 *   --D--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
    	 *   --E--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
    	 *   --F--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
    	 *
    	 *   Note there is no reason monitors have to be the same size or in a grid.
    	 */
    	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

    		this.aspect = fullWidth / fullHeight;

    		this.view = {
    			fullWidth: fullWidth,
    			fullHeight: fullHeight,
    			offsetX: x,
    			offsetY: y,
    			width: width,
    			height: height
    		};

    		this.updateProjectionMatrix();

    	},

    	clearViewOffset: function() {

    		this.view = null;
    		this.updateProjectionMatrix();

    	},

    	updateProjectionMatrix: function () {

    		var near = this.near,
    			top = near * Math.tan(
    					exports.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
    			height = 2 * top,
    			width = this.aspect * height,
    			left = - 0.5 * width,
    			view = this.view;

    		if ( view !== null ) {

    			var fullWidth = view.fullWidth,
    				fullHeight = view.fullHeight;

    			left += view.offsetX * width / fullWidth;
    			top -= view.offsetY * height / fullHeight;
    			width *= view.width / fullWidth;
    			height *= view.height / fullHeight;

    		}

    		var skew = this.filmOffset;
    		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

    		this.projectionMatrix.makeFrustum(
    				left, left + width, top - height, top, near, this.far );

    	},

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.fov = this.fov;
    		data.object.zoom = this.zoom;

    		data.object.near = this.near;
    		data.object.far = this.far;
    		data.object.focus = this.focus;

    		data.object.aspect = this.aspect;

    		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

    		data.object.filmGauge = this.filmGauge;
    		data.object.filmOffset = this.filmOffset;

    		return data;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author arose / http://github.com/arose
     */

    function OrthographicCamera( left, right, top, bottom, near, far ) {

    	Camera.call( this );

    	this.type = 'OrthographicCamera';

    	this.zoom = 1;
    	this.view = null;

    	this.left = left;
    	this.right = right;
    	this.top = top;
    	this.bottom = bottom;

    	this.near = ( near !== undefined ) ? near : 0.1;
    	this.far = ( far !== undefined ) ? far : 2000;

    	this.updateProjectionMatrix();

    }

    OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

    	constructor: OrthographicCamera,

    	isOrthographicCamera: true,

    	copy: function ( source ) {

    		Camera.prototype.copy.call( this, source );

    		this.left = source.left;
    		this.right = source.right;
    		this.top = source.top;
    		this.bottom = source.bottom;
    		this.near = source.near;
    		this.far = source.far;

    		this.zoom = source.zoom;
    		this.view = source.view === null ? null : Object.assign( {}, source.view );

    		return this;

    	},

    	setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {

    		this.view = {
    			fullWidth: fullWidth,
    			fullHeight: fullHeight,
    			offsetX: x,
    			offsetY: y,
    			width: width,
    			height: height
    		};

    		this.updateProjectionMatrix();

    	},

    	clearViewOffset: function() {

    		this.view = null;
    		this.updateProjectionMatrix();

    	},

    	updateProjectionMatrix: function () {

    		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
    		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
    		var cx = ( this.right + this.left ) / 2;
    		var cy = ( this.top + this.bottom ) / 2;

    		var left = cx - dx;
    		var right = cx + dx;
    		var top = cy + dy;
    		var bottom = cy - dy;

    		if ( this.view !== null ) {

    			var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
    			var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
    			var scaleW = ( this.right - this.left ) / this.view.width;
    			var scaleH = ( this.top - this.bottom ) / this.view.height;

    			left += scaleW * ( this.view.offsetX / zoomW );
    			right = left + scaleW * ( this.view.width / zoomW );
    			top -= scaleH * ( this.view.offsetY / zoomH );
    			bottom = top - scaleH * ( this.view.height / zoomH );

    		}

    		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

    	},

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.zoom = this.zoom;
    		data.object.left = this.left;
    		data.object.right = this.right;
    		data.object.top = this.top;
    		data.object.bottom = this.bottom;
    		data.object.near = this.near;
    		data.object.far = this.far;

    		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

    		return data;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {

    	var mode;

    	function setMode( value ) {

    		mode = value;

    	}

    	var type, size;

    	function setIndex( index ) {

    		if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

    			type = gl.UNSIGNED_INT;
    			size = 4;

    		} else {

    			type = gl.UNSIGNED_SHORT;
    			size = 2;

    		}

    	}

    	function render( start, count ) {

    		gl.drawElements( mode, count, type, start * size );

    		infoRender.calls ++;
    		infoRender.vertices += count;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

    	}

    	function renderInstances( geometry, start, count ) {

    		var extension = extensions.get( 'ANGLE_instanced_arrays' );

    		if ( extension === null ) {

    			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
    			return;

    		}

    		extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );

    		infoRender.calls ++;
    		infoRender.vertices += count * geometry.maxInstancedCount;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

    	}

    	return {

    		setMode: setMode,
    		setIndex: setIndex,
    		render: render,
    		renderInstances: renderInstances

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLBufferRenderer( gl, extensions, infoRender ) {

    	var mode;

    	function setMode( value ) {

    		mode = value;

    	}

    	function render( start, count ) {

    		gl.drawArrays( mode, start, count );

    		infoRender.calls ++;
    		infoRender.vertices += count;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

    	}

    	function renderInstances( geometry ) {

    		var extension = extensions.get( 'ANGLE_instanced_arrays' );

    		if ( extension === null ) {

    			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
    			return;

    		}

    		var position = geometry.attributes.position;

    		var count = 0;

    		if ( (position && position.isInterleavedBufferAttribute) ) {

    			count = position.data.count;

    			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

    		} else {

    			count = position.count;

    			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

    		}

    		infoRender.calls ++;
    		infoRender.vertices += count * geometry.maxInstancedCount;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

    	}

    	return {
    		setMode: setMode,
    		render: render,
    		renderInstances: renderInstances
    	};

    }

    function WebGLLights() {

    	var lights = {};

    	return {

    		get: function ( light ) {

    			if ( lights[ light.id ] !== undefined ) {

    				return lights[ light.id ];

    			}

    			var uniforms;

    			switch ( light.type ) {

    				case 'DirectionalLight':
    					uniforms = {
    						direction: new Vector3(),
    						color: new Color(),

    						shadow: false,
    						shadowBias: 0,
    						shadowRadius: 1,
    						shadowMapSize: new Vector2()
    					};
    					break;

    				case 'SpotLight':
    					uniforms = {
    						position: new Vector3(),
    						direction: new Vector3(),
    						color: new Color(),
    						distance: 0,
    						coneCos: 0,
    						penumbraCos: 0,
    						decay: 0,

    						shadow: false,
    						shadowBias: 0,
    						shadowRadius: 1,
    						shadowMapSize: new Vector2()
    					};
    					break;

    				case 'PointLight':
    					uniforms = {
    						position: new Vector3(),
    						color: new Color(),
    						distance: 0,
    						decay: 0,

    						shadow: false,
    						shadowBias: 0,
    						shadowRadius: 1,
    						shadowMapSize: new Vector2()
    					};
    					break;

    				case 'HemisphereLight':
    					uniforms = {
    						direction: new Vector3(),
    						skyColor: new Color(),
    						groundColor: new Color()
    					};
    					break;

    			}

    			lights[ light.id ] = uniforms;

    			return uniforms;

    		}

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function addLineNumbers( string ) {

    	var lines = string.split( '\n' );

    	for ( var i = 0; i < lines.length; i ++ ) {

    		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

    	}

    	return lines.join( '\n' );

    }

    function WebGLShader( gl, type, string ) {

    	var shader = gl.createShader( type );

    	gl.shaderSource( shader, string );
    	gl.compileShader( shader );

    	if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

    		console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

    	}

    	if ( gl.getShaderInfoLog( shader ) !== '' ) {

    		console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

    	}

    	// --enable-privileged-webgl-extension
    	// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

    	return shader;

    }

    var programIdCount = 0;

    function getEncodingComponents( encoding ) {

    	switch ( encoding ) {

    		case LinearEncoding:
    			return [ 'Linear','( value )' ];
    		case sRGBEncoding:
    			return [ 'sRGB','( value )' ];
    		case RGBEEncoding:
    			return [ 'RGBE','( value )' ];
    		case RGBM7Encoding:
    			return [ 'RGBM','( value, 7.0 )' ];
    		case RGBM16Encoding:
    			return [ 'RGBM','( value, 16.0 )' ];
    		case RGBDEncoding:
    			return [ 'RGBD','( value, 256.0 )' ];
    		case GammaEncoding:
    			return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
    		default:
    			throw new Error( 'unsupported encoding: ' + encoding );

    	}

    }

    function getTexelDecodingFunction( functionName, encoding ) {

    	var components = getEncodingComponents( encoding );
    	return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";

    }

    function getTexelEncodingFunction( functionName, encoding ) {

    	var components = getEncodingComponents( encoding );
    	return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";

    }

    function getToneMappingFunction( functionName, toneMapping ) {

    	var toneMappingName;

    	switch ( toneMapping ) {

    		case LinearToneMapping:
    			toneMappingName = "Linear";
    			break;

    		case ReinhardToneMapping:
    			toneMappingName = "Reinhard";
    			break;

    		case Uncharted2ToneMapping:
    			toneMappingName = "Uncharted2";
    			break;

    		case CineonToneMapping:
    			toneMappingName = "OptimizedCineon";
    			break;

    		default:
    			throw new Error( 'unsupported toneMapping: ' + toneMapping );

    	}

    	return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

    }

    function generateExtensions( extensions, parameters, rendererExtensions ) {

    	extensions = extensions || {};

    	var chunks = [
    		( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
    		( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
    		( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
    		( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',
    	];

    	return chunks.filter( filterEmptyLine ).join( '\n' );

    }

    function generateDefines( defines ) {

    	var chunks = [];

    	for ( var name in defines ) {

    		var value = defines[ name ];

    		if ( value === false ) continue;

    		chunks.push( '#define ' + name + ' ' + value );

    	}

    	return chunks.join( '\n' );

    }

    function fetchAttributeLocations( gl, program, identifiers ) {

    	var attributes = {};

    	var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

    	for ( var i = 0; i < n; i ++ ) {

    		var info = gl.getActiveAttrib( program, i );
    		var name = info.name;

    		// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

    		attributes[ name ] = gl.getAttribLocation( program, name );

    	}

    	return attributes;

    }

    function filterEmptyLine( string ) {

    	return string !== '';

    }

    function replaceLightNums( string, parameters ) {

    	return string
    		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
    		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
    		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
    		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

    }

    function parseIncludes( string ) {

    	var pattern = /#include +<([\w\d.]+)>/g;

    	function replace( match, include ) {

    		var replace = ShaderChunk[ include ];

    		if ( replace === undefined ) {

    			throw new Error( 'Can not resolve #include <' + include + '>' );

    		}

    		return parseIncludes( replace );

    	}

    	return string.replace( pattern, replace );

    }

    function unrollLoops( string ) {

    	var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

    	function replace( match, start, end, snippet ) {

    		var unroll = '';

    		for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

    			unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

    		}

    		return unroll;

    	}

    	return string.replace( pattern, replace );

    }

    function WebGLProgram( renderer, code, material, parameters ) {

    	var gl = renderer.context;

    	var extensions = material.extensions;
    	var defines = material.defines;

    	var vertexShader = material.__webglShader.vertexShader;
    	var fragmentShader = material.__webglShader.fragmentShader;

    	var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

    	if ( parameters.shadowMapType === PCFShadowMap ) {

    		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

    	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

    		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

    	}

    	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    	var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

    	if ( parameters.envMap ) {

    		switch ( material.envMap.mapping ) {

    			case CubeReflectionMapping:
    			case CubeRefractionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    				break;

    			case CubeUVReflectionMapping:
    			case CubeUVRefractionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
    				break;

    			case EquirectangularReflectionMapping:
    			case EquirectangularRefractionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
    				break;

    			case SphericalReflectionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
    				break;

    		}

    		switch ( material.envMap.mapping ) {

    			case CubeRefractionMapping:
    			case EquirectangularRefractionMapping:
    				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
    				break;

    		}

    		switch ( material.combine ) {

    			case MultiplyOperation:
    				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
    				break;

    			case MixOperation:
    				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
    				break;

    			case AddOperation:
    				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
    				break;

    		}

    	}

    	var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

    	// console.log( 'building new program ' );

    	//

    	var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );

    	var customDefines = generateDefines( defines );

    	//

    	var program = gl.createProgram();

    	var prefixVertex, prefixFragment;

    	if ( material.isRawShaderMaterial ) {

    		prefixVertex = [

    			customDefines,

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    		prefixFragment = [

    			customExtensions,
    			customDefines,

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    	} else {

    		prefixVertex = [

    			'precision ' + parameters.precision + ' float;',
    			'precision ' + parameters.precision + ' int;',

    			'#define SHADER_NAME ' + material.__webglShader.name,

    			customDefines,

    			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

    			'#define GAMMA_FACTOR ' + gammaFactorDefine,

    			'#define MAX_BONES ' + parameters.maxBones,

    			parameters.map ? '#define USE_MAP' : '',
    			parameters.envMap ? '#define USE_ENVMAP' : '',
    			parameters.envMap ? '#define ' + envMapModeDefine : '',
    			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
    			parameters.aoMap ? '#define USE_AOMAP' : '',
    			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
    			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
    			parameters.normalMap ? '#define USE_NORMALMAP' : '',
    			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
    			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
    			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
    			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
    			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
    			parameters.vertexColors ? '#define USE_COLOR' : '',

    			parameters.flatShading ? '#define FLAT_SHADED' : '',

    			parameters.skinning ? '#define USE_SKINNING' : '',
    			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

    			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
    			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
    			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
    			parameters.flipSided ? '#define FLIP_SIDED' : '',

    			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

    			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
    			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

    			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

    			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
    			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

    			'uniform mat4 modelMatrix;',
    			'uniform mat4 modelViewMatrix;',
    			'uniform mat4 projectionMatrix;',
    			'uniform mat4 viewMatrix;',
    			'uniform mat3 normalMatrix;',
    			'uniform vec3 cameraPosition;',

    			'attribute vec3 position;',
    			'attribute vec3 normal;',
    			'attribute vec2 uv;',

    			'#ifdef USE_COLOR',

    			'	attribute vec3 color;',

    			'#endif',

    			'#ifdef USE_MORPHTARGETS',

    			'	attribute vec3 morphTarget0;',
    			'	attribute vec3 morphTarget1;',
    			'	attribute vec3 morphTarget2;',
    			'	attribute vec3 morphTarget3;',

    			'	#ifdef USE_MORPHNORMALS',

    			'		attribute vec3 morphNormal0;',
    			'		attribute vec3 morphNormal1;',
    			'		attribute vec3 morphNormal2;',
    			'		attribute vec3 morphNormal3;',

    			'	#else',

    			'		attribute vec3 morphTarget4;',
    			'		attribute vec3 morphTarget5;',
    			'		attribute vec3 morphTarget6;',
    			'		attribute vec3 morphTarget7;',

    			'	#endif',

    			'#endif',

    			'#ifdef USE_SKINNING',

    			'	attribute vec4 skinIndex;',
    			'	attribute vec4 skinWeight;',

    			'#endif',

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    		prefixFragment = [

    			customExtensions,

    			'precision ' + parameters.precision + ' float;',
    			'precision ' + parameters.precision + ' int;',

    			'#define SHADER_NAME ' + material.__webglShader.name,

    			customDefines,

    			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

    			'#define GAMMA_FACTOR ' + gammaFactorDefine,

    			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
    			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

    			parameters.map ? '#define USE_MAP' : '',
    			parameters.envMap ? '#define USE_ENVMAP' : '',
    			parameters.envMap ? '#define ' + envMapTypeDefine : '',
    			parameters.envMap ? '#define ' + envMapModeDefine : '',
    			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
    			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
    			parameters.aoMap ? '#define USE_AOMAP' : '',
    			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
    			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
    			parameters.normalMap ? '#define USE_NORMALMAP' : '',
    			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
    			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
    			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
    			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
    			parameters.vertexColors ? '#define USE_COLOR' : '',

    			parameters.flatShading ? '#define FLAT_SHADED' : '',

    			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
    			parameters.flipSided ? '#define FLIP_SIDED' : '',

    			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

    			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
    			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

    			parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

    			parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

    			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
    			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

    			parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

    			'uniform mat4 viewMatrix;',
    			'uniform vec3 cameraPosition;',

    			( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
    			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
    			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',

    			( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
    			parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
    			parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
    			parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
    			parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',

    			parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    	}

    	vertexShader = parseIncludes( vertexShader, parameters );
    	vertexShader = replaceLightNums( vertexShader, parameters );

    	fragmentShader = parseIncludes( fragmentShader, parameters );
    	fragmentShader = replaceLightNums( fragmentShader, parameters );

    	if ( ! material.isShaderMaterial ) {

    		vertexShader = unrollLoops( vertexShader );
    		fragmentShader = unrollLoops( fragmentShader );

    	}

    	var vertexGlsl = prefixVertex + vertexShader;
    	var fragmentGlsl = prefixFragment + fragmentShader;

    	// console.log( '*VERTEX*', vertexGlsl );
    	// console.log( '*FRAGMENT*', fragmentGlsl );

    	var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
    	var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

    	gl.attachShader( program, glVertexShader );
    	gl.attachShader( program, glFragmentShader );

    	// Force a particular attribute to index 0.

    	if ( material.index0AttributeName !== undefined ) {

    		gl.bindAttribLocation( program, 0, material.index0AttributeName );

    	} else if ( parameters.morphTargets === true ) {

    		// programs with morphTargets displace position out of attribute 0
    		gl.bindAttribLocation( program, 0, 'position' );

    	}

    	gl.linkProgram( program );

    	var programLog = gl.getProgramInfoLog( program );
    	var vertexLog = gl.getShaderInfoLog( glVertexShader );
    	var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

    	var runnable = true;
    	var haveDiagnostics = true;

    	// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
    	// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

    	if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

    		runnable = false;

    		console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

    	} else if ( programLog !== '' ) {

    		console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

    	} else if ( vertexLog === '' || fragmentLog === '' ) {

    		haveDiagnostics = false;

    	}

    	if ( haveDiagnostics ) {

    		this.diagnostics = {

    			runnable: runnable,
    			material: material,

    			programLog: programLog,

    			vertexShader: {

    				log: vertexLog,
    				prefix: prefixVertex

    			},

    			fragmentShader: {

    				log: fragmentLog,
    				prefix: prefixFragment

    			}

    		};

    	}

    	// clean up

    	gl.deleteShader( glVertexShader );
    	gl.deleteShader( glFragmentShader );

    	// set up caching for uniform locations

    	var cachedUniforms;

    	this.getUniforms = function() {

    		if ( cachedUniforms === undefined ) {

    			cachedUniforms =
    					new WebGLUniforms( gl, program, renderer );

    		}

    		return cachedUniforms;

    	};

    	// set up caching for attribute locations

    	var cachedAttributes;

    	this.getAttributes = function() {

    		if ( cachedAttributes === undefined ) {

    			cachedAttributes = fetchAttributeLocations( gl, program );

    		}

    		return cachedAttributes;

    	};

    	// free resource

    	this.destroy = function() {

    		gl.deleteProgram( program );
    		this.program = undefined;

    	};

    	// DEPRECATED

    	Object.defineProperties( this, {

    		uniforms: {
    			get: function() {

    				console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
    				return this.getUniforms();

    			}
    		},

    		attributes: {
    			get: function() {

    				console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
    				return this.getAttributes();

    			}
    		}

    	} );


    	//

    	this.id = programIdCount ++;
    	this.code = code;
    	this.usedTimes = 1;
    	this.program = program;
    	this.vertexShader = glVertexShader;
    	this.fragmentShader = glFragmentShader;

    	return this;

    }

    function WebGLPrograms( renderer, capabilities ) {

    	var programs = [];

    	var shaderIDs = {
    		MeshDepthMaterial: 'depth',
    		MeshNormalMaterial: 'normal',
    		MeshBasicMaterial: 'basic',
    		MeshLambertMaterial: 'lambert',
    		MeshPhongMaterial: 'phong',
    		MeshStandardMaterial: 'physical',
    		MeshPhysicalMaterial: 'physical',
    		LineBasicMaterial: 'basic',
    		LineDashedMaterial: 'dashed',
    		PointsMaterial: 'points'
    	};

    	var parameterNames = [
    		"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
    		"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
    		"roughnessMap", "metalnessMap",
    		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
    		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
    		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
    		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
    		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
    		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
    		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "depthPacking"
    	];


    	function allocateBones( object ) {

    		if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

    			return 1024;

    		} else {

    			// default for when object is not specified
    			// ( for example when prebuilding shader to be used with multiple objects )
    			//
    			//  - leave some extra space for other uniforms
    			//  - limit here is ANGLE's 254 max uniform vectors
    			//    (up to 54 should be safe)

    			var nVertexUniforms = capabilities.maxVertexUniforms;
    			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

    			var maxBones = nVertexMatrices;

    			if ( object !== undefined && (object && object.isSkinnedMesh) ) {

    				maxBones = Math.min( object.skeleton.bones.length, maxBones );

    				if ( maxBones < object.skeleton.bones.length ) {

    					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

    				}

    			}

    			return maxBones;

    		}

    	}

    	function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

    		var encoding;

    		if ( ! map ) {

    			encoding = LinearEncoding;

    		} else if ( (map && map.isTexture) ) {

    			encoding = map.encoding;

    		} else if ( (map && map.isWebGLRenderTarget) ) {

    			console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
    			encoding = map.texture.encoding;

    		}

    		// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
    		if ( encoding === LinearEncoding && gammaOverrideLinear ) {

    			encoding = GammaEncoding;

    		}

    		return encoding;

    	}

    	this.getParameters = function ( material, lights, fog, nClipPlanes, object ) {

    		var shaderID = shaderIDs[ material.type ];

    		// heuristics to create shader parameters according to lights in the scene
    		// (not to blow over maxLights budget)

    		var maxBones = allocateBones( object );
    		var precision = renderer.getPrecision();

    		if ( material.precision !== null ) {

    			precision = capabilities.getMaxPrecision( material.precision );

    			if ( precision !== material.precision ) {

    				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

    			}

    		}

    		var currentRenderTarget = renderer.getCurrentRenderTarget();

    		var parameters = {

    			shaderID: shaderID,

    			precision: precision,
    			supportsVertexTextures: capabilities.vertexTextures,
    			outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
    			map: !! material.map,
    			mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
    			envMap: !! material.envMap,
    			envMapMode: material.envMap && material.envMap.mapping,
    			envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
    			envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
    			lightMap: !! material.lightMap,
    			aoMap: !! material.aoMap,
    			emissiveMap: !! material.emissiveMap,
    			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
    			bumpMap: !! material.bumpMap,
    			normalMap: !! material.normalMap,
    			displacementMap: !! material.displacementMap,
    			roughnessMap: !! material.roughnessMap,
    			metalnessMap: !! material.metalnessMap,
    			specularMap: !! material.specularMap,
    			alphaMap: !! material.alphaMap,

    			combine: material.combine,

    			vertexColors: material.vertexColors,

    			fog: !! fog,
    			useFog: material.fog,
    			fogExp: (fog && fog.isFogExp2),

    			flatShading: material.shading === FlatShading,

    			sizeAttenuation: material.sizeAttenuation,
    			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

    			skinning: material.skinning,
    			maxBones: maxBones,
    			useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

    			morphTargets: material.morphTargets,
    			morphNormals: material.morphNormals,
    			maxMorphTargets: renderer.maxMorphTargets,
    			maxMorphNormals: renderer.maxMorphNormals,

    			numDirLights: lights.directional.length,
    			numPointLights: lights.point.length,
    			numSpotLights: lights.spot.length,
    			numHemiLights: lights.hemi.length,

    			numClippingPlanes: nClipPlanes,

    			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
    			shadowMapType: renderer.shadowMap.type,

    			toneMapping: renderer.toneMapping,
    			physicallyCorrectLights: renderer.physicallyCorrectLights,

    			premultipliedAlpha: material.premultipliedAlpha,

    			alphaTest: material.alphaTest,
    			doubleSided: material.side === DoubleSide,
    			flipSided: material.side === BackSide,

    			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

    		};

    		return parameters;

    	};

    	this.getProgramCode = function ( material, parameters ) {

    		var array = [];

    		if ( parameters.shaderID ) {

    			array.push( parameters.shaderID );

    		} else {

    			array.push( material.fragmentShader );
    			array.push( material.vertexShader );

    		}

    		if ( material.defines !== undefined ) {

    			for ( var name in material.defines ) {

    				array.push( name );
    				array.push( material.defines[ name ] );

    			}

    		}

    		for ( var i = 0; i < parameterNames.length; i ++ ) {

    			array.push( parameters[ parameterNames[ i ] ] );

    		}

    		return array.join();

    	};

    	this.acquireProgram = function ( material, parameters, code ) {

    		var program;

    		// Check if code has been already compiled
    		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

    			var programInfo = programs[ p ];

    			if ( programInfo.code === code ) {

    				program = programInfo;
    				++ program.usedTimes;

    				break;

    			}

    		}

    		if ( program === undefined ) {

    			program = new WebGLProgram( renderer, code, material, parameters );
    			programs.push( program );

    		}

    		return program;

    	};

    	this.releaseProgram = function( program ) {

    		if ( -- program.usedTimes === 0 ) {

    			// Remove from unordered set
    			var i = programs.indexOf( program );
    			programs[ i ] = programs[ programs.length - 1 ];
    			programs.pop();

    			// Free WebGL resources
    			program.destroy();

    		}

    	};

    	// Exposed for resource monitoring & error feedback via renderer.info:
    	this.programs = programs;

    }

    function WebGLGeometries( gl, properties, info ) {

    	var geometries = {};

    	function onGeometryDispose( event ) {

    		var geometry = event.target;
    		var buffergeometry = geometries[ geometry.id ];

    		if ( buffergeometry.index !== null ) {

    			deleteAttribute( buffergeometry.index );

    		}

    		deleteAttributes( buffergeometry.attributes );

    		geometry.removeEventListener( 'dispose', onGeometryDispose );

    		delete geometries[ geometry.id ];

    		// TODO

    		var property = properties.get( geometry );

    		if ( property.wireframe ) {

    			deleteAttribute( property.wireframe );

    		}

    		properties.delete( geometry );

    		var bufferproperty = properties.get( buffergeometry );

    		if ( bufferproperty.wireframe ) {

    			deleteAttribute( bufferproperty.wireframe );

    		}

    		properties.delete( buffergeometry );

    		//

    		info.memory.geometries --;

    	}

    	function getAttributeBuffer( attribute ) {

    		if ( attribute.isInterleavedBufferAttribute ) {

    			return properties.get( attribute.data ).__webglBuffer;

    		}

    		return properties.get( attribute ).__webglBuffer;

    	}

    	function deleteAttribute( attribute ) {

    		var buffer = getAttributeBuffer( attribute );

    		if ( buffer !== undefined ) {

    			gl.deleteBuffer( buffer );
    			removeAttributeBuffer( attribute );

    		}

    	}

    	function deleteAttributes( attributes ) {

    		for ( var name in attributes ) {

    			deleteAttribute( attributes[ name ] );

    		}

    	}

    	function removeAttributeBuffer( attribute ) {

    		if ( attribute.isInterleavedBufferAttribute ) {

    			properties.delete( attribute.data );

    		} else {

    			properties.delete( attribute );

    		}

    	}

    	return {

    		get: function ( object ) {

    			var geometry = object.geometry;

    			if ( geometries[ geometry.id ] !== undefined ) {

    				return geometries[ geometry.id ];

    			}

    			geometry.addEventListener( 'dispose', onGeometryDispose );

    			var buffergeometry;

    			if ( geometry.isBufferGeometry ) {

    				buffergeometry = geometry;

    			} else if ( geometry.isGeometry ) {

    				if ( geometry._bufferGeometry === undefined ) {

    					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

    				}

    				buffergeometry = geometry._bufferGeometry;

    			}

    			geometries[ geometry.id ] = buffergeometry;

    			info.memory.geometries ++;

    			return buffergeometry;

    		}

    	};

    }

    function WebGLObjects( gl, properties, info ) {

    	var geometries = new WebGLGeometries( gl, properties, info );

    	//

    	function update( object ) {

    		// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

    		var geometry = geometries.get( object );

    		if ( object.geometry.isGeometry ) {

    			geometry.updateFromObject( object );

    		}

    		var index = geometry.index;
    		var attributes = geometry.attributes;

    		if ( index !== null ) {

    			updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

    		}

    		for ( var name in attributes ) {

    			updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

    		}

    		// morph targets

    		var morphAttributes = geometry.morphAttributes;

    		for ( var name in morphAttributes ) {

    			var array = morphAttributes[ name ];

    			for ( var i = 0, l = array.length; i < l; i ++ ) {

    				updateAttribute( array[ i ], gl.ARRAY_BUFFER );

    			}

    		}

    		return geometry;

    	}

    	function updateAttribute( attribute, bufferType ) {

    		var data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;

    		var attributeProperties = properties.get( data );

    		if ( attributeProperties.__webglBuffer === undefined ) {

    			createBuffer( attributeProperties, data, bufferType );

    		} else if ( attributeProperties.version !== data.version ) {

    			updateBuffer( attributeProperties, data, bufferType );

    		}

    	}

    	function createBuffer( attributeProperties, data, bufferType ) {

    		attributeProperties.__webglBuffer = gl.createBuffer();
    		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

    		var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

    		gl.bufferData( bufferType, data.array, usage );

    		attributeProperties.version = data.version;

    	}

    	function updateBuffer( attributeProperties, data, bufferType ) {

    		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

    		if ( data.dynamic === false || data.updateRange.count === - 1 ) {

    			// Not using update ranges

    			gl.bufferSubData( bufferType, 0, data.array );

    		} else if ( data.updateRange.count === 0 ) {

    			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

    		} else {

    			gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
    							  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

    			data.updateRange.count = 0; // reset range

    		}

    		attributeProperties.version = data.version;

    	}

    	function getAttributeBuffer( attribute ) {

    		if ( attribute.isInterleavedBufferAttribute ) {

    			return properties.get( attribute.data ).__webglBuffer;

    		}

    		return properties.get( attribute ).__webglBuffer;

    	}

    	function getWireframeAttribute( geometry ) {

    		var property = properties.get( geometry );

    		if ( property.wireframe !== undefined ) {

    			return property.wireframe;

    		}

    		var indices = [];

    		var index = geometry.index;
    		var attributes = geometry.attributes;
    		var position = attributes.position;

    		// console.time( 'wireframe' );

    		if ( index !== null ) {

    			var edges = {};
    			var array = index.array;

    			for ( var i = 0, l = array.length; i < l; i += 3 ) {

    				var a = array[ i + 0 ];
    				var b = array[ i + 1 ];
    				var c = array[ i + 2 ];

    				indices.push( a, b, b, c, c, a );

    			}

    		} else {

    			var array = attributes.position.array;

    			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

    				var a = i + 0;
    				var b = i + 1;
    				var c = i + 2;

    				indices.push( a, b, b, c, c, a );

    			}

    		}

    		// console.timeEnd( 'wireframe' );

    		var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
    		var attribute = new BufferAttribute( new TypeArray( indices ), 1 );

    		updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

    		property.wireframe = attribute;

    		return attribute;

    	}

    	return {

    		getAttributeBuffer: getAttributeBuffer,
    		getWireframeAttribute: getWireframeAttribute,

    		update: update

    	};

    }

    function WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {

    	var _infoMemory = info.memory;
    	var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );

    	//

    	function clampToMaxSize( image, maxSize ) {

    		if ( image.width > maxSize || image.height > maxSize ) {

    			// Warning: Scaling through the canvas will only work with images that use
    			// premultiplied alpha.

    			var scale = maxSize / Math.max( image.width, image.height );

    			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    			canvas.width = Math.floor( image.width * scale );
    			canvas.height = Math.floor( image.height * scale );

    			var context = canvas.getContext( '2d' );
    			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

    			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

    			return canvas;

    		}

    		return image;

    	}

    	function isPowerOfTwo( image ) {

    		return exports.Math.isPowerOfTwo( image.width ) && exports.Math.isPowerOfTwo( image.height );

    	}

    	function makePowerOfTwo( image ) {

    		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

    			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    			canvas.width = exports.Math.nearestPowerOfTwo( image.width );
    			canvas.height = exports.Math.nearestPowerOfTwo( image.height );

    			var context = canvas.getContext( '2d' );
    			context.drawImage( image, 0, 0, canvas.width, canvas.height );

    			console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

    			return canvas;

    		}

    		return image;

    	}

    	function textureNeedsPowerOfTwo( texture ) {

    		if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) return true;
    		if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) return true;

    		return false;

    	}

    	// Fallback filters for non-power-of-2 textures

    	function filterFallback( f ) {

    		if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

    			return _gl.NEAREST;

    		}

    		return _gl.LINEAR;

    	}

    	//

    	function onTextureDispose( event ) {

    		var texture = event.target;

    		texture.removeEventListener( 'dispose', onTextureDispose );

    		deallocateTexture( texture );

    		_infoMemory.textures --;


    	}

    	function onRenderTargetDispose( event ) {

    		var renderTarget = event.target;

    		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

    		deallocateRenderTarget( renderTarget );

    		_infoMemory.textures --;

    	}

    	//

    	function deallocateTexture( texture ) {

    		var textureProperties = properties.get( texture );

    		if ( texture.image && textureProperties.__image__webglTextureCube ) {

    			// cube texture

    			_gl.deleteTexture( textureProperties.__image__webglTextureCube );

    		} else {

    			// 2D texture

    			if ( textureProperties.__webglInit === undefined ) return;

    			_gl.deleteTexture( textureProperties.__webglTexture );

    		}

    		// remove all webgl properties
    		properties.delete( texture );

    	}

    	function deallocateRenderTarget( renderTarget ) {

    		var renderTargetProperties = properties.get( renderTarget );
    		var textureProperties = properties.get( renderTarget.texture );

    		if ( ! renderTarget ) return;

    		if ( textureProperties.__webglTexture !== undefined ) {

    			_gl.deleteTexture( textureProperties.__webglTexture );

    		}

    		if ( renderTarget.depthTexture ) {

    			renderTarget.depthTexture.dispose();

    		}

    		if ( (renderTarget && renderTarget.isWebGLRenderTargetCube) ) {

    			for ( var i = 0; i < 6; i ++ ) {

    				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
    				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

    			}

    		} else {

    			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
    			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

    		}

    		properties.delete( renderTarget.texture );
    		properties.delete( renderTarget );

    	}

    	//



    	function setTexture2D( texture, slot ) {

    		var textureProperties = properties.get( texture );

    		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

    			var image = texture.image;

    			if ( image === undefined ) {

    				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

    			} else if ( image.complete === false ) {

    				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

    			} else {

    				uploadTexture( textureProperties, texture, slot );
    				return;

    			}

    		}

    		state.activeTexture( _gl.TEXTURE0 + slot );
    		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    	}

    	function setTextureCube( texture, slot ) {

    		var textureProperties = properties.get( texture );

    		if ( texture.image.length === 6 ) {

    			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

    				if ( ! textureProperties.__image__webglTextureCube ) {

    					texture.addEventListener( 'dispose', onTextureDispose );

    					textureProperties.__image__webglTextureCube = _gl.createTexture();

    					_infoMemory.textures ++;

    				}

    				state.activeTexture( _gl.TEXTURE0 + slot );
    				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

    				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

    				var isCompressed = (texture && texture.isCompressedTexture);
    				var isDataTexture = (texture.image[ 0 ] && texture.image[ 0 ].isDataTexture);

    				var cubeImage = [];

    				for ( var i = 0; i < 6; i ++ ) {

    					if ( ! isCompressed && ! isDataTexture ) {

    						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

    					} else {

    						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

    					}

    				}

    				var image = cubeImage[ 0 ],
    				isPowerOfTwoImage = isPowerOfTwo( image ),
    				glFormat = paramThreeToGL( texture.format ),
    				glType = paramThreeToGL( texture.type );

    				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

    				for ( var i = 0; i < 6; i ++ ) {

    					if ( ! isCompressed ) {

    						if ( isDataTexture ) {

    							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

    						} else {

    							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

    						}

    					} else {

    						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

    						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

    							mipmap = mipmaps[ j ];

    							if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

    								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

    									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

    								} else {

    									console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );

    								}

    							} else {

    								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    							}

    						}

    					}

    				}

    				if ( texture.generateMipmaps && isPowerOfTwoImage ) {

    					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

    				}

    				textureProperties.__version = texture.version;

    				if ( texture.onUpdate ) texture.onUpdate( texture );

    			} else {

    				state.activeTexture( _gl.TEXTURE0 + slot );
    				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

    			}

    		}

    	}

    	function setTextureCubeDynamic( texture, slot ) {

    		state.activeTexture( _gl.TEXTURE0 + slot );
    		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

    	}

    	function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

    		var extension;

    		if ( isPowerOfTwoImage ) {

    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

    			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
    			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

    		} else {

    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

    			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

    				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

    			}

    			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
    			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

    			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

    				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

    			}

    		}

    		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

    		if ( extension ) {

    			if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
    			if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

    			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

    				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
    				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

    			}

    		}

    	}

    	function uploadTexture( textureProperties, texture, slot ) {

    		if ( textureProperties.__webglInit === undefined ) {

    			textureProperties.__webglInit = true;

    			texture.addEventListener( 'dispose', onTextureDispose );

    			textureProperties.__webglTexture = _gl.createTexture();

    			_infoMemory.textures ++;

    		}

    		state.activeTexture( _gl.TEXTURE0 + slot );
    		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
    		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
    		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

    		var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

    		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

    			image = makePowerOfTwo( image );

    		}

    		var isPowerOfTwoImage = isPowerOfTwo( image ),
    		glFormat = paramThreeToGL( texture.format ),
    		glType = paramThreeToGL( texture.type );

    		setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

    		var mipmap, mipmaps = texture.mipmaps;

    		if ( (texture && texture.isDepthTexture) ) {

    			// populate depth texture with dummy data

    			var internalFormat = _gl.DEPTH_COMPONENT;

    			if ( texture.type === FloatType ) {

    				if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
    				internalFormat = _gl.DEPTH_COMPONENT32F;

    			} else if ( _isWebGL2 ) {

    				// WebGL 2.0 requires signed internalformat for glTexImage2D
    				internalFormat = _gl.DEPTH_COMPONENT16;

    			}

    			// Depth stencil textures need the DEPTH_STENCIL internal format
    			// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
    			if ( texture.format === DepthStencilFormat ) {

    				internalFormat = _gl.DEPTH_STENCIL;

    			}

    			state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

    		} else if ( (texture && texture.isDataTexture) ) {

    			// use manually created mipmaps if available
    			// if there are no manual mipmaps
    			// set 0 level mipmap and then use GL to generate other mipmap levels

    			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

    				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

    					mipmap = mipmaps[ i ];
    					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    				}

    				texture.generateMipmaps = false;

    			} else {

    				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

    			}

    		} else if ( (texture && texture.isCompressedTexture) ) {

    			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

    				mipmap = mipmaps[ i ];

    				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

    					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

    						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

    					} else {

    						console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

    					}

    				} else {

    					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    				}

    			}

    		} else {

    			// regular Texture (image, video, canvas)

    			// use manually created mipmaps if available
    			// if there are no manual mipmaps
    			// set 0 level mipmap and then use GL to generate other mipmap levels

    			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

    				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

    					mipmap = mipmaps[ i ];
    					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

    				}

    				texture.generateMipmaps = false;

    			} else {

    				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

    			}

    		}

    		if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );

    		textureProperties.__version = texture.version;

    		if ( texture.onUpdate ) texture.onUpdate( texture );

    	}

    	// Render targets

    	// Setup storage for target texture and bind it to correct framebuffer
    	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

    		var glFormat = paramThreeToGL( renderTarget.texture.format );
    		var glType = paramThreeToGL( renderTarget.texture.type );
    		state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
    		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

    	}

    	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
    	function setupRenderBufferStorage( renderbuffer, renderTarget ) {

    		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

    		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

    			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
    			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

    			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
    			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    		} else {

    			// FIXME: We don't support !depth !stencil
    			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

    		}

    		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

    	}

    	// Setup resources for a Depth Texture for a FBO (needs an extension)
    	function setupDepthTexture( framebuffer, renderTarget ) {

    		var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );
    		if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');

    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

    		if ( !( (renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture) ) ) {

    			throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

    		}

    		// upload an empty depth texture with framebuffer size
    		if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
    				renderTarget.depthTexture.image.width !== renderTarget.width ||
    				renderTarget.depthTexture.image.height !== renderTarget.height ) {
    			renderTarget.depthTexture.image.width = renderTarget.width;
    			renderTarget.depthTexture.image.height = renderTarget.height;
    			renderTarget.depthTexture.needsUpdate = true;
    		}

    		setTexture2D( renderTarget.depthTexture, 0 );

    		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

    		if ( renderTarget.depthTexture.format === DepthFormat ) {

    			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

    		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

    			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

    		} else {

    			throw new Error('Unknown depthTexture format')

    		}

    	}

    	// Setup GL resources for a non-texture depth buffer
    	function setupDepthRenderbuffer( renderTarget ) {

    		var renderTargetProperties = properties.get( renderTarget );

    		var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );

    		if ( renderTarget.depthTexture ) {

    			if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');

    			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

    		} else {

    			if ( isCube ) {

    				renderTargetProperties.__webglDepthbuffer = [];

    				for ( var i = 0; i < 6; i ++ ) {

    					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
    					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
    					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

    				}

    			} else {

    				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
    				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
    				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

    			}

    		}

    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

    	}

    	// Set up GL resources for the render target
    	function setupRenderTarget( renderTarget ) {

    		var renderTargetProperties = properties.get( renderTarget );
    		var textureProperties = properties.get( renderTarget.texture );

    		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

    		textureProperties.__webglTexture = _gl.createTexture();

    		_infoMemory.textures ++;

    		var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );
    		var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

    		// Setup framebuffer

    		if ( isCube ) {

    			renderTargetProperties.__webglFramebuffer = [];

    			for ( var i = 0; i < 6; i ++ ) {

    				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

    			}

    		} else {

    			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

    		}

    		// Setup color buffer

    		if ( isCube ) {

    			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
    			setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

    			for ( var i = 0; i < 6; i ++ ) {

    				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

    			}

    			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
    			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

    		} else {

    			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
    			setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
    			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

    			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
    			state.bindTexture( _gl.TEXTURE_2D, null );

    		}

    		// Setup depth and stencil buffers

    		if ( renderTarget.depthBuffer ) {

    			setupDepthRenderbuffer( renderTarget );

    		}

    	}

    	function updateRenderTargetMipmap( renderTarget ) {

    		var texture = renderTarget.texture;

    		if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
    				texture.minFilter !== NearestFilter &&
    				texture.minFilter !== LinearFilter ) {

    			var target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
    			var webglTexture = properties.get( texture ).__webglTexture;

    			state.bindTexture( target, webglTexture );
    			_gl.generateMipmap( target );
    			state.bindTexture( target, null );

    		}

    	}

    	this.setTexture2D = setTexture2D;
    	this.setTextureCube = setTextureCube;
    	this.setTextureCubeDynamic = setTextureCubeDynamic;
    	this.setupRenderTarget = setupRenderTarget;
    	this.updateRenderTargetMipmap = updateRenderTargetMipmap;

    }

    /**
     * @author fordacious / fordacious.github.io
     */

    function WebGLProperties() {

    	var properties = {};

    	return {

    		get: function ( object ) {

    			var uuid = object.uuid;
    			var map = properties[ uuid ];

    			if ( map === undefined ) {

    				map = {};
    				properties[ uuid ] = map;

    			}

    			return map;

    		},

    		delete: function ( object ) {

    			delete properties[ object.uuid ];

    		},

    		clear: function () {

    			properties = {};

    		}

    	};

    }

    function WebGLState( gl, extensions, paramThreeToGL ) {

    	function ColorBuffer() {

    		var locked = false;

    		var color = new Vector4();
    		var currentColorMask = null;
    		var currentColorClear = new Vector4();

    		return {

    			setMask: function ( colorMask ) {

    				if ( currentColorMask !== colorMask && ! locked ) {

    					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
    					currentColorMask = colorMask;

    				}

    			},

    			setLocked: function ( lock ) {

    				locked = lock;

    			},

    			setClear: function ( r, g, b, a ) {

    				color.set( r, g, b, a );

    				if ( currentColorClear.equals( color ) === false ) {

    					gl.clearColor( r, g, b, a );
    					currentColorClear.copy( color );

    				}

    			},

    			reset: function () {

    				locked = false;

    				currentColorMask = null;
    				currentColorClear.set( 0, 0, 0, 1 );

    			}

    		};

    	}

    	function DepthBuffer() {

    		var locked = false;

    		var currentDepthMask = null;
    		var currentDepthFunc = null;
    		var currentDepthClear = null;

    		return {

    			setTest: function ( depthTest ) {

    				if ( depthTest ) {

    					enable( gl.DEPTH_TEST );

    				} else {

    					disable( gl.DEPTH_TEST );

    				}

    			},

    			setMask: function ( depthMask ) {

    				if ( currentDepthMask !== depthMask && ! locked ) {

    					gl.depthMask( depthMask );
    					currentDepthMask = depthMask;

    				}

    			},

    			setFunc: function ( depthFunc ) {

    				if ( currentDepthFunc !== depthFunc ) {

    					if ( depthFunc ) {

    						switch ( depthFunc ) {

    							case NeverDepth:

    								gl.depthFunc( gl.NEVER );
    								break;

    							case AlwaysDepth:

    								gl.depthFunc( gl.ALWAYS );
    								break;

    							case LessDepth:

    								gl.depthFunc( gl.LESS );
    								break;

    							case LessEqualDepth:

    								gl.depthFunc( gl.LEQUAL );
    								break;

    							case EqualDepth:

    								gl.depthFunc( gl.EQUAL );
    								break;

    							case GreaterEqualDepth:

    								gl.depthFunc( gl.GEQUAL );
    								break;

    							case GreaterDepth:

    								gl.depthFunc( gl.GREATER );
    								break;

    							case NotEqualDepth:

    								gl.depthFunc( gl.NOTEQUAL );
    								break;

    							default:

    								gl.depthFunc( gl.LEQUAL );

    						}

    					} else {

    						gl.depthFunc( gl.LEQUAL );

    					}

    					currentDepthFunc = depthFunc;

    				}

    			},

    			setLocked: function ( lock ) {

    				locked = lock;

    			},

    			setClear: function ( depth ) {

    				if ( currentDepthClear !== depth ) {

    					gl.clearDepth( depth );
    					currentDepthClear = depth;

    				}

    			},

    			reset: function () {

    				locked = false;

    				currentDepthMask = null;
    				currentDepthFunc = null;
    				currentDepthClear = null;

    			}

    		};

    	}

    	function StencilBuffer() {

    		var locked = false;

    		var currentStencilMask = null;
    		var currentStencilFunc = null;
    		var currentStencilRef = null;
    		var currentStencilFuncMask = null;
    		var currentStencilFail  = null;
    		var currentStencilZFail = null;
    		var currentStencilZPass = null;
    		var currentStencilClear = null;

    		return {

    			setTest: function ( stencilTest ) {

    				if ( stencilTest ) {

    					enable( gl.STENCIL_TEST );

    				} else {

    					disable( gl.STENCIL_TEST );

    				}

    			},

    			setMask: function ( stencilMask ) {

    				if ( currentStencilMask !== stencilMask && ! locked ) {

    					gl.stencilMask( stencilMask );
    					currentStencilMask = stencilMask;

    				}

    			},

    			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

    				if ( currentStencilFunc !== stencilFunc ||
    				     currentStencilRef 	!== stencilRef 	||
    				     currentStencilFuncMask !== stencilMask ) {

    					gl.stencilFunc( stencilFunc,  stencilRef, stencilMask );

    					currentStencilFunc = stencilFunc;
    					currentStencilRef  = stencilRef;
    					currentStencilFuncMask = stencilMask;

    				}

    			},

    			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

    				if ( currentStencilFail	 !== stencilFail 	||
    				     currentStencilZFail !== stencilZFail ||
    				     currentStencilZPass !== stencilZPass ) {

    					gl.stencilOp( stencilFail,  stencilZFail, stencilZPass );

    					currentStencilFail  = stencilFail;
    					currentStencilZFail = stencilZFail;
    					currentStencilZPass = stencilZPass;

    				}

    			},

    			setLocked: function ( lock ) {

    				locked = lock;

    			},

    			setClear: function ( stencil ) {

    				if ( currentStencilClear !== stencil ) {

    					gl.clearStencil( stencil );
    					currentStencilClear = stencil;

    				}

    			},

    			reset: function () {

    				locked = false;

    				currentStencilMask = null;
    				currentStencilFunc = null;
    				currentStencilRef = null;
    				currentStencilFuncMask = null;
    				currentStencilFail = null;
    				currentStencilZFail = null;
    				currentStencilZPass = null;
    				currentStencilClear = null;

    			}

    		};

    	}

    	//

    	var colorBuffer = new ColorBuffer();
    	var depthBuffer = new DepthBuffer();
    	var stencilBuffer = new StencilBuffer();

    	var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
    	var newAttributes = new Uint8Array( maxVertexAttributes );
    	var enabledAttributes = new Uint8Array( maxVertexAttributes );
    	var attributeDivisors = new Uint8Array( maxVertexAttributes );

    	var capabilities = {};

    	var compressedTextureFormats = null;

    	var currentBlending = null;
    	var currentBlendEquation = null;
    	var currentBlendSrc = null;
    	var currentBlendDst = null;
    	var currentBlendEquationAlpha = null;
    	var currentBlendSrcAlpha = null;
    	var currentBlendDstAlpha = null;
    	var currentPremultipledAlpha = false;

    	var currentFlipSided = null;
    	var currentCullFace = null;

    	var currentLineWidth = null;

    	var currentPolygonOffsetFactor = null;
    	var currentPolygonOffsetUnits = null;

    	var currentScissorTest = null;

    	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

    	var currentTextureSlot = null;
    	var currentBoundTextures = {};

    	var currentScissor = new Vector4();
    	var currentViewport = new Vector4();

    	function createTexture( type, target, count ) {

    		var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
    		var texture = gl.createTexture();

    		gl.bindTexture( type, texture );
    		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
    		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

    		for ( var i = 0; i < count; i ++ ) {

    			gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

    		}

    		return texture;

    	}

    	var emptyTextures = {};
    	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
    	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

    	//

    	function init() {

    		clearColor( 0, 0, 0, 1 );
    		clearDepth( 1 );
    		clearStencil( 0 );

    		enable( gl.DEPTH_TEST );
    		setDepthFunc( LessEqualDepth );

    		setFlipSided( false );
    		setCullFace( CullFaceBack );
    		enable( gl.CULL_FACE );

    		enable( gl.BLEND );
    		setBlending( NormalBlending );

    	}

    	function initAttributes() {

    		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

    			newAttributes[ i ] = 0;

    		}

    	}

    	function enableAttribute( attribute ) {

    		newAttributes[ attribute ] = 1;

    		if ( enabledAttributes[ attribute ] === 0 ) {

    			gl.enableVertexAttribArray( attribute );
    			enabledAttributes[ attribute ] = 1;

    		}

    		if ( attributeDivisors[ attribute ] !== 0 ) {

    			var extension = extensions.get( 'ANGLE_instanced_arrays' );

    			extension.vertexAttribDivisorANGLE( attribute, 0 );
    			attributeDivisors[ attribute ] = 0;

    		}

    	}

    	function enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {

    		newAttributes[ attribute ] = 1;

    		if ( enabledAttributes[ attribute ] === 0 ) {

    			gl.enableVertexAttribArray( attribute );
    			enabledAttributes[ attribute ] = 1;

    		}

    		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

    			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
    			attributeDivisors[ attribute ] = meshPerAttribute;

    		}

    	}

    	function disableUnusedAttributes() {

    		for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

    			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

    				gl.disableVertexAttribArray( i );
    				enabledAttributes[ i ] = 0;

    			}

    		}

    	}

    	function enable( id ) {

    		if ( capabilities[ id ] !== true ) {

    			gl.enable( id );
    			capabilities[ id ] = true;

    		}

    	}

    	function disable( id ) {

    		if ( capabilities[ id ] !== false ) {

    			gl.disable( id );
    			capabilities[ id ] = false;

    		}

    	}

    	function getCompressedTextureFormats() {

    		if ( compressedTextureFormats === null ) {

    			compressedTextureFormats = [];

    			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
    			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
    			     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

    				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

    				for ( var i = 0; i < formats.length; i ++ ) {

    					compressedTextureFormats.push( formats[ i ] );

    				}

    			}

    		}

    		return compressedTextureFormats;

    	}

    	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

    		if ( blending !== NoBlending ) {

    			enable( gl.BLEND );

    		} else {

    			disable( gl.BLEND );
    			currentBlending = blending; // no blending, that is
    			return;

    		}

    		if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

    			if ( blending === AdditiveBlending ) {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

    				} else {

    					gl.blendEquation( gl.FUNC_ADD );
    					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

    				}

    			} else if ( blending === SubtractiveBlending ) {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

    				} else {

    					gl.blendEquation( gl.FUNC_ADD );
    					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

    				}

    			} else if ( blending === MultiplyBlending ) {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

    				} else {

    					gl.blendEquation( gl.FUNC_ADD );
    					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

    				}

    			} else {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

    				} else {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

    				}

    			}

    			currentBlending = blending;
    			currentPremultipledAlpha = premultipliedAlpha;

    		}

    		if ( blending === CustomBlending ) {

    			blendEquationAlpha = blendEquationAlpha || blendEquation;
    			blendSrcAlpha = blendSrcAlpha || blendSrc;
    			blendDstAlpha = blendDstAlpha || blendDst;

    			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

    				gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

    				currentBlendEquation = blendEquation;
    				currentBlendEquationAlpha = blendEquationAlpha;

    			}

    			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

    				gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

    				currentBlendSrc = blendSrc;
    				currentBlendDst = blendDst;
    				currentBlendSrcAlpha = blendSrcAlpha;
    				currentBlendDstAlpha = blendDstAlpha;

    			}

    		} else {

    			currentBlendEquation = null;
    			currentBlendSrc = null;
    			currentBlendDst = null;
    			currentBlendEquationAlpha = null;
    			currentBlendSrcAlpha = null;
    			currentBlendDstAlpha = null;

    		}

    	}

    	// TODO Deprecate

    	function setColorWrite( colorWrite ) {

    		colorBuffer.setMask( colorWrite );

    	}

    	function setDepthTest( depthTest ) {

    		depthBuffer.setTest( depthTest );

    	}

    	function setDepthWrite( depthWrite ) {

    		depthBuffer.setMask( depthWrite );

    	}

    	function setDepthFunc( depthFunc ) {

    		depthBuffer.setFunc( depthFunc );

    	}

    	function setStencilTest( stencilTest ) {

    		stencilBuffer.setTest( stencilTest );

    	}

    	function setStencilWrite( stencilWrite ) {

    		stencilBuffer.setMask( stencilWrite );

    	}

    	function setStencilFunc( stencilFunc, stencilRef, stencilMask ) {

    		stencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );

    	}

    	function setStencilOp( stencilFail, stencilZFail, stencilZPass ) {

    		stencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );

    	}

    	//

    	function setFlipSided( flipSided ) {

    		if ( currentFlipSided !== flipSided ) {

    			if ( flipSided ) {

    				gl.frontFace( gl.CW );

    			} else {

    				gl.frontFace( gl.CCW );

    			}

    			currentFlipSided = flipSided;

    		}

    	}

    	function setCullFace( cullFace ) {

    		if ( cullFace !== CullFaceNone ) {

    			enable( gl.CULL_FACE );

    			if ( cullFace !== currentCullFace ) {

    				if ( cullFace === CullFaceBack ) {

    					gl.cullFace( gl.BACK );

    				} else if ( cullFace === CullFaceFront ) {

    					gl.cullFace( gl.FRONT );

    				} else {

    					gl.cullFace( gl.FRONT_AND_BACK );

    				}

    			}

    		} else {

    			disable( gl.CULL_FACE );

    		}

    		currentCullFace = cullFace;

    	}

    	function setLineWidth( width ) {

    		if ( width !== currentLineWidth ) {

    			gl.lineWidth( width );

    			currentLineWidth = width;

    		}

    	}

    	function setPolygonOffset( polygonOffset, factor, units ) {

    		if ( polygonOffset ) {

    			enable( gl.POLYGON_OFFSET_FILL );

    			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

    				gl.polygonOffset( factor, units );

    				currentPolygonOffsetFactor = factor;
    				currentPolygonOffsetUnits = units;

    			}

    		} else {

    			disable( gl.POLYGON_OFFSET_FILL );

    		}

    	}

    	function getScissorTest() {

    		return currentScissorTest;

    	}

    	function setScissorTest( scissorTest ) {

    		currentScissorTest = scissorTest;

    		if ( scissorTest ) {

    			enable( gl.SCISSOR_TEST );

    		} else {

    			disable( gl.SCISSOR_TEST );

    		}

    	}

    	// texture

    	function activeTexture( webglSlot ) {

    		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

    		if ( currentTextureSlot !== webglSlot ) {

    			gl.activeTexture( webglSlot );
    			currentTextureSlot = webglSlot;

    		}

    	}

    	function bindTexture( webglType, webglTexture ) {

    		if ( currentTextureSlot === null ) {

    			activeTexture();

    		}

    		var boundTexture = currentBoundTextures[ currentTextureSlot ];

    		if ( boundTexture === undefined ) {

    			boundTexture = { type: undefined, texture: undefined };
    			currentBoundTextures[ currentTextureSlot ] = boundTexture;

    		}

    		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

    			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

    			boundTexture.type = webglType;
    			boundTexture.texture = webglTexture;

    		}

    	}

    	function compressedTexImage2D() {

    		try {

    			gl.compressedTexImage2D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( error );

    		}

    	}

    	function texImage2D() {

    		try {

    			gl.texImage2D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( error );

    		}

    	}

    	// TODO Deprecate

    	function clearColor( r, g, b, a ) {

    		colorBuffer.setClear( r, g, b, a );

    	}

    	function clearDepth( depth ) {

    		depthBuffer.setClear( depth );

    	}

    	function clearStencil( stencil ) {

    		stencilBuffer.setClear( stencil );

    	}

    	//

    	function scissor( scissor ) {

    		if ( currentScissor.equals( scissor ) === false ) {

    			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
    			currentScissor.copy( scissor );

    		}

    	}

    	function viewport( viewport ) {

    		if ( currentViewport.equals( viewport ) === false ) {

    			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
    			currentViewport.copy( viewport );

    		}

    	}

    	//

    	function reset() {

    		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

    			if ( enabledAttributes[ i ] === 1 ) {

    				gl.disableVertexAttribArray( i );
    				enabledAttributes[ i ] = 0;

    			}

    		}

    		capabilities = {};

    		compressedTextureFormats = null;

    		currentTextureSlot = null;
    		currentBoundTextures = {};

    		currentBlending = null;

    		currentFlipSided = null;
    		currentCullFace = null;

    		colorBuffer.reset();
    		depthBuffer.reset();
    		stencilBuffer.reset();

    	}

    	return {

    		buffers: {
    			color: colorBuffer,
    			depth: depthBuffer,
    			stencil: stencilBuffer
    		},

    		init: init,
    		initAttributes: initAttributes,
    		enableAttribute: enableAttribute,
    		enableAttributeAndDivisor: enableAttributeAndDivisor,
    		disableUnusedAttributes: disableUnusedAttributes,
    		enable: enable,
    		disable: disable,
    		getCompressedTextureFormats: getCompressedTextureFormats,

    		setBlending: setBlending,

    		setColorWrite: setColorWrite,
    		setDepthTest: setDepthTest,
    		setDepthWrite: setDepthWrite,
    		setDepthFunc: setDepthFunc,
    		setStencilTest: setStencilTest,
    		setStencilWrite: setStencilWrite,
    		setStencilFunc: setStencilFunc,
    		setStencilOp: setStencilOp,

    		setFlipSided: setFlipSided,
    		setCullFace: setCullFace,

    		setLineWidth: setLineWidth,
    		setPolygonOffset: setPolygonOffset,

    		getScissorTest: getScissorTest,
    		setScissorTest: setScissorTest,

    		activeTexture: activeTexture,
    		bindTexture: bindTexture,
    		compressedTexImage2D: compressedTexImage2D,
    		texImage2D: texImage2D,

    		clearColor: clearColor,
    		clearDepth: clearDepth,
    		clearStencil: clearStencil,

    		scissor: scissor,
    		viewport: viewport,

    		reset: reset

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLCapabilities( gl, extensions, parameters ) {

    	var maxAnisotropy;

    	function getMaxAnisotropy() {

    		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

    		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

    		if ( extension !== null ) {

    			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

    		} else {

    			maxAnisotropy = 0;

    		}

    		return maxAnisotropy;

    	}

    	function getMaxPrecision( precision ) {

    		if ( precision === 'highp' ) {

    			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
    			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

    				return 'highp';

    			}

    			precision = 'mediump';

    		}

    		if ( precision === 'mediump' ) {

    			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
    			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

    				return 'mediump';

    			}

    		}

    		return 'lowp';

    	}

    	var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
    	var maxPrecision = getMaxPrecision( precision );

    	if ( maxPrecision !== precision ) {

    		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
    		precision = maxPrecision;

    	}

    	var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );

    	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
    	var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
    	var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
    	var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

    	var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
    	var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
    	var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
    	var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

    	var vertexTextures = maxVertexTextures > 0;
    	var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
    	var floatVertexTextures = vertexTextures && floatFragmentTextures;

    	return {

    		getMaxAnisotropy: getMaxAnisotropy,
    		getMaxPrecision: getMaxPrecision,

    		precision: precision,
    		logarithmicDepthBuffer: logarithmicDepthBuffer,

    		maxTextures: maxTextures,
    		maxVertexTextures: maxVertexTextures,
    		maxTextureSize: maxTextureSize,
    		maxCubemapSize: maxCubemapSize,

    		maxAttributes: maxAttributes,
    		maxVertexUniforms: maxVertexUniforms,
    		maxVaryings: maxVaryings,
    		maxFragmentUniforms: maxFragmentUniforms,

    		vertexTextures: vertexTextures,
    		floatFragmentTextures: floatFragmentTextures,
    		floatVertexTextures: floatVertexTextures

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLExtensions( gl ) {

    	var extensions = {};

    	return {

    		get: function ( name ) {

    			if ( extensions[ name ] !== undefined ) {

    				return extensions[ name ];

    			}

    			var extension;

    			switch ( name ) {

    				case 'WEBGL_depth_texture':
    					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
    					break;

    				case 'EXT_texture_filter_anisotropic':
    					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
    					break;

    				case 'WEBGL_compressed_texture_s3tc':
    					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
    					break;

    				case 'WEBGL_compressed_texture_pvrtc':
    					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
    					break;

    				case 'WEBGL_compressed_texture_etc1':
    					extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
    					break;

    				default:
    					extension = gl.getExtension( name );

    			}

    			if ( extension === null ) {

    				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

    			}

    			extensions[ name ] = extension;

    			return extension;

    		}

    	};

    }

    function WebGLClipping() {

    	var scope = this,

    		globalState = null,
    		numGlobalPlanes = 0,
    		localClippingEnabled = false,
    		renderingShadows = false,

    		plane = new Plane(),
    		viewNormalMatrix = new Matrix3(),

    		uniform = { value: null, needsUpdate: false };

    	this.uniform = uniform;
    	this.numPlanes = 0;

    	this.init = function( planes, enableLocalClipping, camera ) {

    		var enabled =
    			planes.length !== 0 ||
    			enableLocalClipping ||
    			// enable state of previous frame - the clipping code has to
    			// run another frame in order to reset the state:
    			numGlobalPlanes !== 0 ||
    			localClippingEnabled;

    		localClippingEnabled = enableLocalClipping;

    		globalState = projectPlanes( planes, camera, 0 );
    		numGlobalPlanes = planes.length;

    		return enabled;

    	};

    	this.beginShadows = function() {

    		renderingShadows = true;
    		projectPlanes( null );

    	};

    	this.endShadows = function() {

    		renderingShadows = false;
    		resetGlobalState();

    	};

    	this.setState = function( planes, clipShadows, camera, cache, fromCache ) {

    		if ( ! localClippingEnabled ||
    				planes === null || planes.length === 0 ||
    				renderingShadows && ! clipShadows ) {
    			// there's no local clipping

    			if ( renderingShadows ) {
    				// there's no global clipping

    				projectPlanes( null );

    			} else {

    				resetGlobalState();
    			}

    		} else {

    			var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
    				lGlobal = nGlobal * 4,

    				dstArray = cache.clippingState || null;

    			uniform.value = dstArray; // ensure unique state

    			dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

    			for ( var i = 0; i !== lGlobal; ++ i ) {

    				dstArray[ i ] = globalState[ i ];

    			}

    			cache.clippingState = dstArray;
    			this.numPlanes += nGlobal;

    		}


    	};

    	function resetGlobalState() {

    		if ( uniform.value !== globalState ) {

    			uniform.value = globalState;
    			uniform.needsUpdate = numGlobalPlanes > 0;

    		}

    		scope.numPlanes = numGlobalPlanes;

    	}

    	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

    		var nPlanes = planes !== null ? planes.length : 0,
    			dstArray = null;

    		if ( nPlanes !== 0 ) {

    			dstArray = uniform.value;

    			if ( skipTransform !== true || dstArray === null ) {

    				var flatSize = dstOffset + nPlanes * 4,
    					viewMatrix = camera.matrixWorldInverse;

    				viewNormalMatrix.getNormalMatrix( viewMatrix );

    				if ( dstArray === null || dstArray.length < flatSize ) {

    					dstArray = new Float32Array( flatSize );

    				}

    				for ( var i = 0, i4 = dstOffset;
    									i !== nPlanes; ++ i, i4 += 4 ) {

    					plane.copy( planes[ i ] ).
    							applyMatrix4( viewMatrix, viewNormalMatrix );

    					plane.normal.toArray( dstArray, i4 );
    					dstArray[ i4 + 3 ] = plane.constant;

    				}

    			}

    			uniform.value = dstArray;
    			uniform.needsUpdate = true;

    		}

    		scope.numPlanes = nPlanes;
    		return dstArray;

    	}

    }

    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     * @author tschw
     */

    function WebGLRenderer( parameters ) {

    	console.log( 'THREE.WebGLRenderer', REVISION );

    	parameters = parameters || {};

    	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
    	_context = parameters.context !== undefined ? parameters.context : null,

    	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
    	_depth = parameters.depth !== undefined ? parameters.depth : true,
    	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
    	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
    	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
    	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

    	var lights = [];

    	var opaqueObjects = [];
    	var opaqueObjectsLastIndex = - 1;
    	var transparentObjects = [];
    	var transparentObjectsLastIndex = - 1;

    	var morphInfluences = new Float32Array( 8 );

    	var sprites = [];
    	var lensFlares = [];

    	// public properties

    	this.domElement = _canvas;
    	this.context = null;

    	// clearing

    	this.autoClear = true;
    	this.autoClearColor = true;
    	this.autoClearDepth = true;
    	this.autoClearStencil = true;

    	// scene graph

    	this.sortObjects = true;

    	// user-defined clipping

    	this.clippingPlanes = [];
    	this.localClippingEnabled = false;

    	// physically based shading

    	this.gammaFactor = 2.0;	// for backwards compatibility
    	this.gammaInput = false;
    	this.gammaOutput = false;

    	// physical lights

    	this.physicallyCorrectLights = false;

    	// tone mapping

    	this.toneMapping = LinearToneMapping;
    	this.toneMappingExposure = 1.0;
    	this.toneMappingWhitePoint = 1.0;

    	// morphs

    	this.maxMorphTargets = 8;
    	this.maxMorphNormals = 4;

    	// internal properties

    	var _this = this,

    	// internal state cache

    	_currentProgram = null,
    	_currentRenderTarget = null,
    	_currentFramebuffer = null,
    	_currentMaterialId = - 1,
    	_currentGeometryProgram = '',
    	_currentCamera = null,

    	_currentScissor = new Vector4(),
    	_currentScissorTest = null,

    	_currentViewport = new Vector4(),

    	//

    	_usedTextureUnits = 0,

    	//

    	_clearColor = new Color( 0x000000 ),
    	_clearAlpha = 0,

    	_width = _canvas.width,
    	_height = _canvas.height,

    	_pixelRatio = 1,

    	_scissor = new Vector4( 0, 0, _width, _height ),
    	_scissorTest = false,

    	_viewport = new Vector4( 0, 0, _width, _height ),

    	// frustum

    	_frustum = new Frustum(),

    	// clipping

    	_clipping = new WebGLClipping(),
    	_clippingEnabled = false,
    	_localClippingEnabled = false,

    	_sphere = new Sphere(),

    	// camera matrices cache

    	_projScreenMatrix = new Matrix4(),

    	_vector3 = new Vector3(),

    	// light arrays cache

    	_lights = {

    		hash: '',

    		ambient: [ 0, 0, 0 ],
    		directional: [],
    		directionalShadowMap: [],
    		directionalShadowMatrix: [],
    		spot: [],
    		spotShadowMap: [],
    		spotShadowMatrix: [],
    		point: [],
    		pointShadowMap: [],
    		pointShadowMatrix: [],
    		hemi: [],

    		shadows: []

    	},

    	// info

    	_infoRender = {

    		calls: 0,
    		vertices: 0,
    		faces: 0,
    		points: 0

    	};

    	this.info = {

    		render: _infoRender,
    		memory: {

    			geometries: 0,
    			textures: 0

    		},
    		programs: null

    	};


    	// initialize

    	var _gl;

    	try {

    		var attributes = {
    			alpha: _alpha,
    			depth: _depth,
    			stencil: _stencil,
    			antialias: _antialias,
    			premultipliedAlpha: _premultipliedAlpha,
    			preserveDrawingBuffer: _preserveDrawingBuffer
    		};

    		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

    		if ( _gl === null ) {

    			if ( _canvas.getContext( 'webgl' ) !== null ) {

    				throw 'Error creating WebGL context with your selected attributes.';

    			} else {

    				throw 'Error creating WebGL context.';

    			}

    		}

    		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

    		if ( _gl.getShaderPrecisionFormat === undefined ) {

    			_gl.getShaderPrecisionFormat = function () {

    				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

    			};

    		}

    		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

    	} catch ( error ) {

    		console.error( 'THREE.WebGLRenderer: ' + error );

    	}

    	var extensions = new WebGLExtensions( _gl );

    	extensions.get( 'WEBGL_depth_texture' );
    	extensions.get( 'OES_texture_float' );
    	extensions.get( 'OES_texture_float_linear' );
    	extensions.get( 'OES_texture_half_float' );
    	extensions.get( 'OES_texture_half_float_linear' );
    	extensions.get( 'OES_standard_derivatives' );
    	extensions.get( 'ANGLE_instanced_arrays' );

    	if ( extensions.get( 'OES_element_index_uint' ) ) {

    		BufferGeometry.MaxIndex = 4294967296;

    	}

    	var capabilities = new WebGLCapabilities( _gl, extensions, parameters );

    	var state = new WebGLState( _gl, extensions, paramThreeToGL );
    	var properties = new WebGLProperties();
    	var textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );
    	var objects = new WebGLObjects( _gl, properties, this.info );
    	var programCache = new WebGLPrograms( this, capabilities );
    	var lightCache = new WebGLLights();

    	this.info.programs = programCache.programs;

    	var bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
    	var indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

    	//

    	var backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
    	var backgroundCamera2 = new PerspectiveCamera();
    	var backgroundPlaneMesh = new Mesh(
    		new PlaneBufferGeometry( 2, 2 ),
    		new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
    	);
    	var backgroundBoxShader = ShaderLib[ 'cube' ];
    	var backgroundBoxMesh = new Mesh(
    		new BoxBufferGeometry( 5, 5, 5 ),
    		new ShaderMaterial( {
    			uniforms: backgroundBoxShader.uniforms,
    			vertexShader: backgroundBoxShader.vertexShader,
    			fragmentShader: backgroundBoxShader.fragmentShader,
    			side: BackSide,
    			depthTest: false,
    			depthWrite: false,
    			fog: false
    		} )
    	);

    	//

    	function getTargetPixelRatio() {

    		return _currentRenderTarget === null ? _pixelRatio : 1;

    	}

    	function glClearColor( r, g, b, a ) {

    		if ( _premultipliedAlpha === true ) {

    			r *= a; g *= a; b *= a;

    		}

    		state.clearColor( r, g, b, a );

    	}

    	function setDefaultGLState() {

    		state.init();

    		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
    		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

    		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    	}

    	function resetGLState() {

    		_currentProgram = null;
    		_currentCamera = null;

    		_currentGeometryProgram = '';
    		_currentMaterialId = - 1;

    		state.reset();

    	}

    	setDefaultGLState();

    	this.context = _gl;
    	this.capabilities = capabilities;
    	this.extensions = extensions;
    	this.properties = properties;
    	this.state = state;

    	// shadow map

    	var shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );

    	this.shadowMap = shadowMap;


    	// Plugins

    	var spritePlugin = new SpritePlugin( this, sprites );
    	var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );

    	// API

    	this.getContext = function () {

    		return _gl;

    	};

    	this.getContextAttributes = function () {

    		return _gl.getContextAttributes();

    	};

    	this.forceContextLoss = function () {

    		extensions.get( 'WEBGL_lose_context' ).loseContext();

    	};

    	this.getMaxAnisotropy = function () {

    		return capabilities.getMaxAnisotropy();

    	};

    	this.getPrecision = function () {

    		return capabilities.precision;

    	};

    	this.getPixelRatio = function () {

    		return _pixelRatio;

    	};

    	this.setPixelRatio = function ( value ) {

    		if ( value === undefined ) return;

    		_pixelRatio = value;

    		this.setSize( _viewport.z, _viewport.w, false );

    	};

    	this.getSize = function () {

    		return {
    			width: _width,
    			height: _height
    		};

    	};

    	this.setSize = function ( width, height, updateStyle ) {

    		_width = width;
    		_height = height;

    		_canvas.width = width * _pixelRatio;
    		_canvas.height = height * _pixelRatio;

    		if ( updateStyle !== false ) {

    			_canvas.style.width = width + 'px';
    			_canvas.style.height = height + 'px';

    		}

    		this.setViewport( 0, 0, width, height );

    	};

    	this.setViewport = function ( x, y, width, height ) {

    		state.viewport( _viewport.set( x, y, width, height ) );

    	};

    	this.setScissor = function ( x, y, width, height ) {

    		state.scissor( _scissor.set( x, y, width, height ) );

    	};

    	this.setScissorTest = function ( boolean ) {

    		state.setScissorTest( _scissorTest = boolean );

    	};

    	// Clearing

    	this.getClearColor = function () {

    		return _clearColor;

    	};

    	this.setClearColor = function ( color, alpha ) {

    		_clearColor.set( color );

    		_clearAlpha = alpha !== undefined ? alpha : 1;

    		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    	};

    	this.getClearAlpha = function () {

    		return _clearAlpha;

    	};

    	this.setClearAlpha = function ( alpha ) {

    		_clearAlpha = alpha;

    		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    	};

    	this.clear = function ( color, depth, stencil ) {

    		var bits = 0;

    		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
    		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
    		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

    		_gl.clear( bits );

    	};

    	this.clearColor = function () {

    		this.clear( true, false, false );

    	};

    	this.clearDepth = function () {

    		this.clear( false, true, false );

    	};

    	this.clearStencil = function () {

    		this.clear( false, false, true );

    	};

    	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

    		this.setRenderTarget( renderTarget );
    		this.clear( color, depth, stencil );

    	};

    	// Reset

    	this.resetGLState = resetGLState;

    	this.dispose = function() {

    		transparentObjects = [];
    		transparentObjectsLastIndex = -1;
    		opaqueObjects = [];
    		opaqueObjectsLastIndex = -1;

    		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

    	};

    	// Events

    	function onContextLost( event ) {

    		event.preventDefault();

    		resetGLState();
    		setDefaultGLState();

    		properties.clear();

    	}

    	function onMaterialDispose( event ) {

    		var material = event.target;

    		material.removeEventListener( 'dispose', onMaterialDispose );

    		deallocateMaterial( material );

    	}

    	// Buffer deallocation

    	function deallocateMaterial( material ) {

    		releaseMaterialProgramReference( material );

    		properties.delete( material );

    	}


    	function releaseMaterialProgramReference( material ) {

    		var programInfo = properties.get( material ).program;

    		material.program = undefined;

    		if ( programInfo !== undefined ) {

    			programCache.releaseProgram( programInfo );

    		}

    	}

    	// Buffer rendering

    	this.renderBufferImmediate = function ( object, program, material ) {

    		state.initAttributes();

    		var buffers = properties.get( object );

    		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
    		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
    		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
    		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

    		var attributes = program.getAttributes();

    		if ( object.hasPositions ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
    			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.position );
    			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

    		}

    		if ( object.hasNormals ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

    			if ( ! material.isMeshPhongMaterial &&
    			     ! material.isMeshStandardMaterial &&
    			       material.shading === FlatShading ) {

    				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

    					var array = object.normalArray;

    					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
    					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
    					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

    					array[ i + 0 ] = nx;
    					array[ i + 1 ] = ny;
    					array[ i + 2 ] = nz;

    					array[ i + 3 ] = nx;
    					array[ i + 4 ] = ny;
    					array[ i + 5 ] = nz;

    					array[ i + 6 ] = nx;
    					array[ i + 7 ] = ny;
    					array[ i + 8 ] = nz;

    				}

    			}

    			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.normal );

    			_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

    		}

    		if ( object.hasUvs && material.map ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
    			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.uv );

    			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

    		}

    		if ( object.hasColors && material.vertexColors !== NoColors ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
    			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.color );

    			_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

    		}

    		state.disableUnusedAttributes();

    		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

    		object.count = 0;

    	};

    	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

    		setMaterial( material );

    		var program = setProgram( camera, fog, material, object );

    		var updateBuffers = false;
    		var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

    		if ( geometryProgram !== _currentGeometryProgram ) {

    			_currentGeometryProgram = geometryProgram;
    			updateBuffers = true;

    		}

    		// morph targets

    		var morphTargetInfluences = object.morphTargetInfluences;

    		if ( morphTargetInfluences !== undefined ) {

    			var activeInfluences = [];

    			for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

    				var influence = morphTargetInfluences[ i ];
    				activeInfluences.push( [ influence, i ] );

    			}

    			activeInfluences.sort( absNumericalSort );

    			if ( activeInfluences.length > 8 ) {

    				activeInfluences.length = 8;

    			}

    			var morphAttributes = geometry.morphAttributes;

    			for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

    				var influence = activeInfluences[ i ];
    				morphInfluences[ i ] = influence[ 0 ];

    				if ( influence[ 0 ] !== 0 ) {

    					var index = influence[ 1 ];

    					if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
    					if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

    				} else {

    					if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
    					if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

    				}

    			}

    			for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {

    				morphInfluences[ i ] = 0.0;

    			}

    			program.getUniforms().setValue(
    					_gl, 'morphTargetInfluences', morphInfluences );

    			updateBuffers = true;

    		}

    		//

    		var index = geometry.index;
    		var position = geometry.attributes.position;
    		var rangeFactor = 1;

    		if ( material.wireframe === true ) {

    			index = objects.getWireframeAttribute( geometry );
    			rangeFactor = 2;

    		}

    		var renderer;

    		if ( index !== null ) {

    			renderer = indexedBufferRenderer;
    			renderer.setIndex( index );

    		} else {

    			renderer = bufferRenderer;

    		}

    		if ( updateBuffers ) {

    			setupVertexAttributes( material, program, geometry );

    			if ( index !== null ) {

    				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

    			}

    		}

    		//

    		var dataCount = 0;

    		if ( index !== null ) {

    			dataCount = index.count;

    		} else if ( position !== undefined ) {

    			dataCount = position.count;

    		}

    		var rangeStart = geometry.drawRange.start * rangeFactor;
    		var rangeCount = geometry.drawRange.count * rangeFactor;

    		var groupStart = group !== null ? group.start * rangeFactor : 0;
    		var groupCount = group !== null ? group.count * rangeFactor : Infinity;

    		var drawStart = Math.max( rangeStart, groupStart );
    		var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

    		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

    		if ( drawCount === 0 ) return;

    		//

    		if ( object.isMesh ) {

    			if ( material.wireframe === true ) {

    				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
    				renderer.setMode( _gl.LINES );

    			} else {

    				switch ( object.drawMode ) {

    					case TrianglesDrawMode:
    						renderer.setMode( _gl.TRIANGLES );
    						break;

    					case TriangleStripDrawMode:
    						renderer.setMode( _gl.TRIANGLE_STRIP );
    						break;

    					case TriangleFanDrawMode:
    						renderer.setMode( _gl.TRIANGLE_FAN );
    						break;

    				}

    			}


    		} else if ( object.isLine ) {

    			var lineWidth = material.linewidth;

    			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

    			state.setLineWidth( lineWidth * getTargetPixelRatio() );

    			if ( object.isLineSegments ) {

    				renderer.setMode( _gl.LINES );

    			} else {

    				renderer.setMode( _gl.LINE_STRIP );

    			}

    		} else if ( object.isPoints ) {

    			renderer.setMode( _gl.POINTS );

    		}

    		if ( geometry && geometry.isInstancedBufferGeometry ) {

    			if ( geometry.maxInstancedCount > 0 ) {

    				renderer.renderInstances( geometry, drawStart, drawCount );

    			}

    		} else {

    			renderer.render( drawStart, drawCount );

    		}

    	};

    	function setupVertexAttributes( material, program, geometry, startIndex ) {

    		var extension;

    		if ( geometry && geometry.isInstancedBufferGeometry ) {

    			extension = extensions.get( 'ANGLE_instanced_arrays' );

    			if ( extension === null ) {

    				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
    				return;

    			}

    		}

    		if ( startIndex === undefined ) startIndex = 0;

    		state.initAttributes();

    		var geometryAttributes = geometry.attributes;

    		var programAttributes = program.getAttributes();

    		var materialDefaultAttributeValues = material.defaultAttributeValues;

    		for ( var name in programAttributes ) {

    			var programAttribute = programAttributes[ name ];

    			if ( programAttribute >= 0 ) {

    				var geometryAttribute = geometryAttributes[ name ];

    				if ( geometryAttribute !== undefined ) {

    					var type = _gl.FLOAT;
    					var array = geometryAttribute.array;
    					var normalized = geometryAttribute.normalized;

    					if ( array instanceof Float32Array ) {

    						type = _gl.FLOAT;

    					} else if ( array instanceof Float64Array ) {

    						console.warn( "Unsupported data buffer format: Float64Array" );

    					} else if ( array instanceof Uint16Array ) {

    						type = _gl.UNSIGNED_SHORT;

    					} else if ( array instanceof Int16Array ) {

    						type = _gl.SHORT;

    					} else if ( array instanceof Uint32Array ) {

    						type = _gl.UNSIGNED_INT;

    					} else if ( array instanceof Int32Array ) {

    						type = _gl.INT;

    					} else if ( array instanceof Int8Array ) {

    						type = _gl.BYTE;

    					} else if ( array instanceof Uint8Array ) {

    						type = _gl.UNSIGNED_BYTE;

    					}

    					var size = geometryAttribute.itemSize;
    					var buffer = objects.getAttributeBuffer( geometryAttribute );

    					if ( geometryAttribute && geometryAttribute.isInterleavedBufferAttribute ) {

    						var data = geometryAttribute.data;
    						var stride = data.stride;
    						var offset = geometryAttribute.offset;

    						if ( data && data.isInstancedInterleavedBuffer ) {

    							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

    							if ( geometry.maxInstancedCount === undefined ) {

    								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

    							}

    						} else {

    							state.enableAttribute( programAttribute );

    						}

    						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
    						_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

    					} else {

    						if ( geometryAttribute && geometryAttribute.isInstancedBufferAttribute ) {

    							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

    							if ( geometry.maxInstancedCount === undefined ) {

    								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

    							}

    						} else {

    							state.enableAttribute( programAttribute );

    						}

    						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
    						_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );

    					}

    				} else if ( materialDefaultAttributeValues !== undefined ) {

    					var value = materialDefaultAttributeValues[ name ];

    					if ( value !== undefined ) {

    						switch ( value.length ) {

    							case 2:
    								_gl.vertexAttrib2fv( programAttribute, value );
    								break;

    							case 3:
    								_gl.vertexAttrib3fv( programAttribute, value );
    								break;

    							case 4:
    								_gl.vertexAttrib4fv( programAttribute, value );
    								break;

    							default:
    								_gl.vertexAttrib1fv( programAttribute, value );

    						}

    					}

    				}

    			}

    		}

    		state.disableUnusedAttributes();

    	}

    	// Sorting

    	function absNumericalSort( a, b ) {

    		return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );

    	}

    	function painterSortStable( a, b ) {

    		if ( a.object.renderOrder !== b.object.renderOrder ) {

    			return a.object.renderOrder - b.object.renderOrder;

    		} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {

    			return a.material.program.id - b.material.program.id;

    		} else if ( a.material.id !== b.material.id ) {

    			return a.material.id - b.material.id;

    		} else if ( a.z !== b.z ) {

    			return a.z - b.z;

    		} else {

    			return a.id - b.id;

    		}

    	}

    	function reversePainterSortStable( a, b ) {

    		if ( a.object.renderOrder !== b.object.renderOrder ) {

    			return a.object.renderOrder - b.object.renderOrder;

    		} if ( a.z !== b.z ) {

    			return b.z - a.z;

    		} else {

    			return a.id - b.id;

    		}

    	}

    	// Rendering

    	this.render = function ( scene, camera, renderTarget, forceClear ) {

    		if ( camera !== undefined && camera.isCamera !== true ) {

    			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
    			return;

    		}

    		var fog = scene.fog;

    		// reset caching for this frame

    		_currentGeometryProgram = '';
    		_currentMaterialId = - 1;
    		_currentCamera = null;

    		// update scene graph

    		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

    		// update camera matrices and frustum

    		if ( camera.parent === null ) camera.updateMatrixWorld();

    		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

    		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
    		_frustum.setFromMatrix( _projScreenMatrix );

    		lights.length = 0;

    		opaqueObjectsLastIndex = - 1;
    		transparentObjectsLastIndex = - 1;

    		sprites.length = 0;
    		lensFlares.length = 0;

    		_localClippingEnabled = this.localClippingEnabled;
    		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

    		projectObject( scene, camera );

    		opaqueObjects.length = opaqueObjectsLastIndex + 1;
    		transparentObjects.length = transparentObjectsLastIndex + 1;

    		if ( _this.sortObjects === true ) {

    			opaqueObjects.sort( painterSortStable );
    			transparentObjects.sort( reversePainterSortStable );

    		}

    		//

    		if ( _clippingEnabled ) _clipping.beginShadows();

    		setupShadows( lights );

    		shadowMap.render( scene, camera );

    		setupLights( lights, camera );

    		if ( _clippingEnabled ) _clipping.endShadows();

    		//

    		_infoRender.calls = 0;
    		_infoRender.vertices = 0;
    		_infoRender.faces = 0;
    		_infoRender.points = 0;

    		if ( renderTarget === undefined ) {

    			renderTarget = null;

    		}

    		this.setRenderTarget( renderTarget );

    		//

    		var background = scene.background;

    		if ( background === null ) {

    			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    		} else if ( background && background.isColor ) {

    			glClearColor( background.r, background.g, background.b, 1 );
    			forceClear = true;

    		}

    		if ( this.autoClear || forceClear ) {

    			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

    		}

    		if ( background && background.isCubeTexture ) {

    			backgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );

    			backgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );
    			backgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );

    			backgroundBoxMesh.material.uniforms[ "tCube" ].value = background;
    			backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );

    			objects.update( backgroundBoxMesh );

    			_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );

    		} else if ( background && background.isTexture ) {

    			backgroundPlaneMesh.material.map = background;

    			objects.update( backgroundPlaneMesh );

    			_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );

    		}

    		//

    		if ( scene.overrideMaterial ) {

    			var overrideMaterial = scene.overrideMaterial;

    			renderObjects( opaqueObjects, camera, fog, overrideMaterial );
    			renderObjects( transparentObjects, camera, fog, overrideMaterial );

    		} else {

    			// opaque pass (front-to-back order)

    			state.setBlending( NoBlending );
    			renderObjects( opaqueObjects, camera, fog );

    			// transparent pass (back-to-front order)

    			renderObjects( transparentObjects, camera, fog );

    		}

    		// custom render plugins (post pass)

    		spritePlugin.render( scene, camera );
    		lensFlarePlugin.render( scene, camera, _currentViewport );

    		// Generate mipmap if we're using any kind of mipmap filtering

    		if ( renderTarget ) {

    			textures.updateRenderTargetMipmap( renderTarget );

    		}

    		// Ensure depth buffer writing is enabled so it can be cleared on next render

    		state.setDepthTest( true );
    		state.setDepthWrite( true );
    		state.setColorWrite( true );

    		// _gl.finish();

    	};

    	function pushRenderItem( object, geometry, material, z, group ) {

    		var array, index;

    		// allocate the next position in the appropriate array

    		if ( material.transparent ) {

    			array = transparentObjects;
    			index = ++ transparentObjectsLastIndex;

    		} else {

    			array = opaqueObjects;
    			index = ++ opaqueObjectsLastIndex;

    		}

    		// recycle existing render item or grow the array

    		var renderItem = array[ index ];

    		if ( renderItem !== undefined ) {

    			renderItem.id = object.id;
    			renderItem.object = object;
    			renderItem.geometry = geometry;
    			renderItem.material = material;
    			renderItem.z = _vector3.z;
    			renderItem.group = group;

    		} else {

    			renderItem = {
    				id: object.id,
    				object: object,
    				geometry: geometry,
    				material: material,
    				z: _vector3.z,
    				group: group
    			};

    			// assert( index === array.length );
    			array.push( renderItem );

    		}

    	}

    	// TODO Duplicated code (Frustum)

    	function isObjectViewable( object ) {

    		var geometry = object.geometry;

    		if ( geometry.boundingSphere === null )
    			geometry.computeBoundingSphere();

    		_sphere.copy( geometry.boundingSphere ).
    			applyMatrix4( object.matrixWorld );

    		return isSphereViewable( _sphere );

    	}

    	function isSpriteViewable( sprite ) {

    		_sphere.center.set( 0, 0, 0 );
    		_sphere.radius = 0.7071067811865476;
    		_sphere.applyMatrix4( sprite.matrixWorld );

    		return isSphereViewable( _sphere );

    	}

    	function isSphereViewable( sphere ) {

    		if ( ! _frustum.intersectsSphere( sphere ) ) return false;

    		var numPlanes = _clipping.numPlanes;

    		if ( numPlanes === 0 ) return true;

    		var planes = _this.clippingPlanes,

    			center = sphere.center,
    			negRad = - sphere.radius,
    			i = 0;

    		do {

    			// out when deeper than radius in the negative halfspace
    			if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

    		} while ( ++ i !== numPlanes );

    		return true;

    	}

    	function projectObject( object, camera ) {

    		if ( object.visible === false ) return;

    		var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

    		if ( visible ) {

    			if ( object.isLight ) {

    				lights.push( object );

    			} else if ( object.isSprite ) {

    				if ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {

    					sprites.push( object );

    				}

    			} else if ( object.isLensFlare ) {

    				lensFlares.push( object );

    			} else if ( object.isImmediateRenderObject ) {

    				if ( _this.sortObjects === true ) {

    					_vector3.setFromMatrixPosition( object.matrixWorld );
    					_vector3.applyProjection( _projScreenMatrix );

    				}

    				pushRenderItem( object, null, object.material, _vector3.z, null );

    			} else if ( object.isMesh || object.isLine || object.isPoints ) {

    				if ( object.isSkinnedMesh ) {

    					object.skeleton.update();

    				}

    				if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {

    					var material = object.material;

    					if ( material.visible === true ) {

    						if ( _this.sortObjects === true ) {

    							_vector3.setFromMatrixPosition( object.matrixWorld );
    							_vector3.applyProjection( _projScreenMatrix );

    						}

    						var geometry = objects.update( object );

    						if ( material.isMultiMaterial ) {

    							var groups = geometry.groups;
    							var materials = material.materials;

    							for ( var i = 0, l = groups.length; i < l; i ++ ) {

    								var group = groups[ i ];
    								var groupMaterial = materials[ group.materialIndex ];

    								if ( groupMaterial.visible === true ) {

    									pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

    								}

    							}

    						} else {

    							pushRenderItem( object, geometry, material, _vector3.z, null );

    						}

    					}

    				}

    			}

    		}

    		var children = object.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			projectObject( children[ i ], camera );

    		}

    	}

    	function renderObjects( renderList, camera, fog, overrideMaterial ) {

    		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

    			var renderItem = renderList[ i ];

    			var object = renderItem.object;
    			var geometry = renderItem.geometry;
    			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
    			var group = renderItem.group;

    			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
    			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

    			if ( object.isImmediateRenderObject ) {

    				setMaterial( material );

    				var program = setProgram( camera, fog, material, object );

    				_currentGeometryProgram = '';

    				object.render( function ( object ) {

    					_this.renderBufferImmediate( object, program, material );

    				} );

    			} else {

    				if ( object.onBeforeRender !== null ) object.onBeforeRender();

    				_this.renderBufferDirect( camera, fog, geometry, material, object, group );

    			}

    		}

    	}

    	function initMaterial( material, fog, object ) {

    		var materialProperties = properties.get( material );

    		var parameters = programCache.getParameters(
    				material, _lights, fog, _clipping.numPlanes, object );

    		var code = programCache.getProgramCode( material, parameters );

    		var program = materialProperties.program;
    		var programChange = true;

    		if ( program === undefined ) {

    			// new material
    			material.addEventListener( 'dispose', onMaterialDispose );

    		} else if ( program.code !== code ) {

    			// changed glsl or parameters
    			releaseMaterialProgramReference( material );

    		} else if ( parameters.shaderID !== undefined ) {

    			// same glsl and uniform list
    			return;

    		} else {

    			// only rebuild uniform list
    			programChange = false;

    		}

    		if ( programChange ) {

    			if ( parameters.shaderID ) {

    				var shader = ShaderLib[ parameters.shaderID ];

    				materialProperties.__webglShader = {
    					name: material.type,
    					uniforms: exports.UniformsUtils.clone( shader.uniforms ),
    					vertexShader: shader.vertexShader,
    					fragmentShader: shader.fragmentShader
    				};

    			} else {

    				materialProperties.__webglShader = {
    					name: material.type,
    					uniforms: material.uniforms,
    					vertexShader: material.vertexShader,
    					fragmentShader: material.fragmentShader
    				};

    			}

    			material.__webglShader = materialProperties.__webglShader;

    			program = programCache.acquireProgram( material, parameters, code );

    			materialProperties.program = program;
    			material.program = program;

    		}

    		var attributes = program.getAttributes();

    		if ( material.morphTargets ) {

    			material.numSupportedMorphTargets = 0;

    			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

    				if ( attributes[ 'morphTarget' + i ] >= 0 ) {

    					material.numSupportedMorphTargets ++;

    				}

    			}

    		}

    		if ( material.morphNormals ) {

    			material.numSupportedMorphNormals = 0;

    			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

    				if ( attributes[ 'morphNormal' + i ] >= 0 ) {

    					material.numSupportedMorphNormals ++;

    				}

    			}

    		}

    		var uniforms = materialProperties.__webglShader.uniforms;

    		if ( ! material.isShaderMaterial &&
    		     ! material.isRawShaderMaterial ||
    		       material.clipping === true ) {

    			materialProperties.numClippingPlanes = _clipping.numPlanes;
    			uniforms.clippingPlanes = _clipping.uniform;

    		}

    		materialProperties.fog = fog;

    		// store the light setup it was created for

    		materialProperties.lightsHash = _lights.hash;

    		if ( material.lights ) {

    			// wire up the material to this renderer's lighting state

    			uniforms.ambientLightColor.value = _lights.ambient;
    			uniforms.directionalLights.value = _lights.directional;
    			uniforms.spotLights.value = _lights.spot;
    			uniforms.pointLights.value = _lights.point;
    			uniforms.hemisphereLights.value = _lights.hemi;

    			uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
    			uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
    			uniforms.spotShadowMap.value = _lights.spotShadowMap;
    			uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
    			uniforms.pointShadowMap.value = _lights.pointShadowMap;
    			uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;

    		}

    		var progUniforms = materialProperties.program.getUniforms(),
    			uniformsList =
    					WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

    		materialProperties.uniformsList = uniformsList;
    		materialProperties.dynamicUniforms =
    				WebGLUniforms.splitDynamic( uniformsList, uniforms );

    	}

    	function setMaterial( material ) {

    		material.side === DoubleSide
    			? state.disable( _gl.CULL_FACE )
    			: state.enable( _gl.CULL_FACE );

    		state.setFlipSided( material.side === BackSide );

    		material.transparent === true
    			? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
    			: state.setBlending( NoBlending );

    		state.setDepthFunc( material.depthFunc );
    		state.setDepthTest( material.depthTest );
    		state.setDepthWrite( material.depthWrite );
    		state.setColorWrite( material.colorWrite );
    		state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

    	}

    	function setProgram( camera, fog, material, object ) {

    		_usedTextureUnits = 0;

    		var materialProperties = properties.get( material );

    		if ( _clippingEnabled ) {

    			if ( _localClippingEnabled || camera !== _currentCamera ) {

    				var useCache =
    						camera === _currentCamera &&
    						material.id === _currentMaterialId;

    				// we might want to call this function with some ClippingGroup
    				// object instead of the material, once it becomes feasible
    				// (#8465, #8379)
    				_clipping.setState(
    						material.clippingPlanes, material.clipShadows,
    						camera, materialProperties, useCache );

    			}

    		}

    		if ( material.needsUpdate === false ) {

    			if ( materialProperties.program === undefined ) {

    				material.needsUpdate = true;

    			} else if ( material.fog && materialProperties.fog !== fog ) {

    				material.needsUpdate = true;

    			} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {

    				material.needsUpdate = true;

    			} else if ( materialProperties.numClippingPlanes !== undefined &&
    				materialProperties.numClippingPlanes !== _clipping.numPlanes ) {

    				material.needsUpdate = true;

    			}

    		}

    		if ( material.needsUpdate ) {

    			initMaterial( material, fog, object );
    			material.needsUpdate = false;

    		}

    		var refreshProgram = false;
    		var refreshMaterial = false;
    		var refreshLights = false;

    		var program = materialProperties.program,
    			p_uniforms = program.getUniforms(),
    			m_uniforms = materialProperties.__webglShader.uniforms;

    		if ( program.id !== _currentProgram ) {

    			_gl.useProgram( program.program );
    			_currentProgram = program.id;

    			refreshProgram = true;
    			refreshMaterial = true;
    			refreshLights = true;

    		}

    		if ( material.id !== _currentMaterialId ) {

    			_currentMaterialId = material.id;

    			refreshMaterial = true;

    		}

    		if ( refreshProgram || camera !== _currentCamera ) {

    			p_uniforms.set( _gl, camera, 'projectionMatrix' );

    			if ( capabilities.logarithmicDepthBuffer ) {

    				p_uniforms.setValue( _gl, 'logDepthBufFC',
    						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

    			}


    			if ( camera !== _currentCamera ) {

    				_currentCamera = camera;

    				// lighting uniforms depend on the camera so enforce an update
    				// now, in case this material supports lights - or later, when
    				// the next material that does gets activated:

    				refreshMaterial = true;		// set to true on material change
    				refreshLights = true;		// remains set until update done

    			}

    			// load material specific uniforms
    			// (shader material also gets them for the sake of genericity)

    			if ( material.isShaderMaterial ||
    			     material.isMeshPhongMaterial ||
    			     material.isMeshStandardMaterial ||
    			     material.envMap ) {

    				var uCamPos = p_uniforms.map.cameraPosition;

    				if ( uCamPos !== undefined ) {

    					uCamPos.setValue( _gl,
    							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

    				}

    			}

    			if ( material.isMeshPhongMaterial ||
    			     material.isMeshLambertMaterial ||
    			     material.isMeshBasicMaterial ||
    			     material.isMeshStandardMaterial ||
    			     material.isShaderMaterial ||
    			     material.skinning ) {

    				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

    			}

    			p_uniforms.set( _gl, _this, 'toneMappingExposure' );
    			p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );

    		}

    		// skinning uniforms must be set even if material didn't change
    		// auto-setting of texture unit for bone texture must go before other textures
    		// not sure why, but otherwise weird things happen

    		if ( material.skinning ) {

    			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
    			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

    			var skeleton = object.skeleton;

    			if ( skeleton ) {

    				if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {

    					p_uniforms.set( _gl, skeleton, 'boneTexture' );
    					p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );
    					p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );

    				} else {

    					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

    				}

    			}

    		}

    		if ( refreshMaterial ) {

    			if ( material.lights ) {

    				// the current material requires lighting info

    				// note: all lighting uniforms are always set correctly
    				// they simply reference the renderer's state for their
    				// values
    				//
    				// use the current material's .needsUpdate flags to set
    				// the GL state when required

    				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

    			}

    			// refresh uniforms common to several materials

    			if ( fog && material.fog ) {

    				refreshUniformsFog( m_uniforms, fog );

    			}

    			if ( material.isMeshBasicMaterial ||
    			     material.isMeshLambertMaterial ||
    			     material.isMeshPhongMaterial ||
    			     material.isMeshStandardMaterial ||
    			     material.isMeshDepthMaterial ) {

    				refreshUniformsCommon( m_uniforms, material );

    			}

    			// refresh single material specific uniforms

    			if ( material.isLineBasicMaterial ) {

    				refreshUniformsLine( m_uniforms, material );

    			} else if ( material.isLineDashedMaterial ) {

    				refreshUniformsLine( m_uniforms, material );
    				refreshUniformsDash( m_uniforms, material );

    			} else if ( material.isPointsMaterial ) {

    				refreshUniformsPoints( m_uniforms, material );

    			} else if ( material.isMeshLambertMaterial ) {

    				refreshUniformsLambert( m_uniforms, material );

    			} else if ( material.isMeshPhongMaterial ) {

    				refreshUniformsPhong( m_uniforms, material );

    			} else if ( material.isMeshPhysicalMaterial ) {

    				refreshUniformsPhysical( m_uniforms, material );

    			} else if ( material.isMeshStandardMaterial ) {

    				refreshUniformsStandard( m_uniforms, material );

    			} else if ( material.isMeshDepthMaterial ) {

    				if ( material.displacementMap ) {

    					m_uniforms.displacementMap.value = material.displacementMap;
    					m_uniforms.displacementScale.value = material.displacementScale;
    					m_uniforms.displacementBias.value = material.displacementBias;

    				}

    			} else if ( material.isMeshNormalMaterial ) {

    				m_uniforms.opacity.value = material.opacity;

    			}

    			WebGLUniforms.upload(
    					_gl, materialProperties.uniformsList, m_uniforms, _this );

    		}


    		// common matrices

    		p_uniforms.set( _gl, object, 'modelViewMatrix' );
    		p_uniforms.set( _gl, object, 'normalMatrix' );
    		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );


    		// dynamic uniforms

    		var dynUniforms = materialProperties.dynamicUniforms;

    		if ( dynUniforms !== null ) {

    			WebGLUniforms.evalDynamic( dynUniforms, m_uniforms, object, material, camera );
    			WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );

    		}

    		return program;

    	}

    	// Uniforms (refresh uniforms objects)

    	function refreshUniformsCommon( uniforms, material ) {

    		uniforms.opacity.value = material.opacity;

    		uniforms.diffuse.value = material.color;

    		if ( material.emissive ) {

    			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

    		}

    		uniforms.map.value = material.map;
    		uniforms.specularMap.value = material.specularMap;
    		uniforms.alphaMap.value = material.alphaMap;

    		if ( material.aoMap ) {

    			uniforms.aoMap.value = material.aoMap;
    			uniforms.aoMapIntensity.value = material.aoMapIntensity;

    		}

    		// uv repeat and offset setting priorities
    		// 1. color map
    		// 2. specular map
    		// 3. normal map
    		// 4. bump map
    		// 5. alpha map
    		// 6. emissive map

    		var uvScaleMap;

    		if ( material.map ) {

    			uvScaleMap = material.map;

    		} else if ( material.specularMap ) {

    			uvScaleMap = material.specularMap;

    		} else if ( material.displacementMap ) {

    			uvScaleMap = material.displacementMap;

    		} else if ( material.normalMap ) {

    			uvScaleMap = material.normalMap;

    		} else if ( material.bumpMap ) {

    			uvScaleMap = material.bumpMap;

    		} else if ( material.roughnessMap ) {

    			uvScaleMap = material.roughnessMap;

    		} else if ( material.metalnessMap ) {

    			uvScaleMap = material.metalnessMap;

    		} else if ( material.alphaMap ) {

    			uvScaleMap = material.alphaMap;

    		} else if ( material.emissiveMap ) {

    			uvScaleMap = material.emissiveMap;

    		}

    		if ( uvScaleMap !== undefined ) {

    			// backwards compatibility
    			if ( uvScaleMap.isWebGLRenderTarget ) {

    				uvScaleMap = uvScaleMap.texture;

    			}

    			var offset = uvScaleMap.offset;
    			var repeat = uvScaleMap.repeat;

    			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    		}

    		uniforms.envMap.value = material.envMap;

    		// don't flip CubeTexture envMaps, flip everything else:
    		//  WebGLRenderTargetCube will be flipped for backwards compatibility
    		//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
    		// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
    		uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

    		uniforms.reflectivity.value = material.reflectivity;
    		uniforms.refractionRatio.value = material.refractionRatio;

    	}

    	function refreshUniformsLine( uniforms, material ) {

    		uniforms.diffuse.value = material.color;
    		uniforms.opacity.value = material.opacity;

    	}

    	function refreshUniformsDash( uniforms, material ) {

    		uniforms.dashSize.value = material.dashSize;
    		uniforms.totalSize.value = material.dashSize + material.gapSize;
    		uniforms.scale.value = material.scale;

    	}

    	function refreshUniformsPoints( uniforms, material ) {

    		uniforms.diffuse.value = material.color;
    		uniforms.opacity.value = material.opacity;
    		uniforms.size.value = material.size * _pixelRatio;
    		uniforms.scale.value = _canvas.clientHeight * 0.5;

    		uniforms.map.value = material.map;

    		if ( material.map !== null ) {

    			var offset = material.map.offset;
    			var repeat = material.map.repeat;

    			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    		}

    	}

    	function refreshUniformsFog( uniforms, fog ) {

    		uniforms.fogColor.value = fog.color;

    		if ( fog.isFog ) {

    			uniforms.fogNear.value = fog.near;
    			uniforms.fogFar.value = fog.far;

    		} else if ( fog.isFogExp2 ) {

    			uniforms.fogDensity.value = fog.density;

    		}

    	}

    	function refreshUniformsLambert( uniforms, material ) {

    		if ( material.lightMap ) {

    			uniforms.lightMap.value = material.lightMap;
    			uniforms.lightMapIntensity.value = material.lightMapIntensity;

    		}

    		if ( material.emissiveMap ) {

    			uniforms.emissiveMap.value = material.emissiveMap;

    		}

    	}

    	function refreshUniformsPhong( uniforms, material ) {

    		uniforms.specular.value = material.specular;
    		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

    		if ( material.lightMap ) {

    			uniforms.lightMap.value = material.lightMap;
    			uniforms.lightMapIntensity.value = material.lightMapIntensity;

    		}

    		if ( material.emissiveMap ) {

    			uniforms.emissiveMap.value = material.emissiveMap;

    		}

    		if ( material.bumpMap ) {

    			uniforms.bumpMap.value = material.bumpMap;
    			uniforms.bumpScale.value = material.bumpScale;

    		}

    		if ( material.normalMap ) {

    			uniforms.normalMap.value = material.normalMap;
    			uniforms.normalScale.value.copy( material.normalScale );

    		}

    		if ( material.displacementMap ) {

    			uniforms.displacementMap.value = material.displacementMap;
    			uniforms.displacementScale.value = material.displacementScale;
    			uniforms.displacementBias.value = material.displacementBias;

    		}

    	}

    	function refreshUniformsStandard( uniforms, material ) {

    		uniforms.roughness.value = material.roughness;
    		uniforms.metalness.value = material.metalness;

    		if ( material.roughnessMap ) {

    			uniforms.roughnessMap.value = material.roughnessMap;

    		}

    		if ( material.metalnessMap ) {

    			uniforms.metalnessMap.value = material.metalnessMap;

    		}

    		if ( material.lightMap ) {

    			uniforms.lightMap.value = material.lightMap;
    			uniforms.lightMapIntensity.value = material.lightMapIntensity;

    		}

    		if ( material.emissiveMap ) {

    			uniforms.emissiveMap.value = material.emissiveMap;

    		}

    		if ( material.bumpMap ) {

    			uniforms.bumpMap.value = material.bumpMap;
    			uniforms.bumpScale.value = material.bumpScale;

    		}

    		if ( material.normalMap ) {

    			uniforms.normalMap.value = material.normalMap;
    			uniforms.normalScale.value.copy( material.normalScale );

    		}

    		if ( material.displacementMap ) {

    			uniforms.displacementMap.value = material.displacementMap;
    			uniforms.displacementScale.value = material.displacementScale;
    			uniforms.displacementBias.value = material.displacementBias;

    		}

    		if ( material.envMap ) {

    			//uniforms.envMap.value = material.envMap; // part of uniforms common
    			uniforms.envMapIntensity.value = material.envMapIntensity;

    		}

    	}

    	function refreshUniformsPhysical( uniforms, material ) {

    		uniforms.clearCoat.value = material.clearCoat;
    		uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

    		refreshUniformsStandard( uniforms, material );

    	}

    	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

    	function markUniformsLightsNeedsUpdate( uniforms, value ) {

    		uniforms.ambientLightColor.needsUpdate = value;

    		uniforms.directionalLights.needsUpdate = value;
    		uniforms.pointLights.needsUpdate = value;
    		uniforms.spotLights.needsUpdate = value;
    		uniforms.hemisphereLights.needsUpdate = value;

    	}

    	// Lighting

    	function setupShadows( lights ) {

    		var lightShadowsLength = 0;

    		for ( var i = 0, l = lights.length; i < l; i ++ ) {

    			var light = lights[ i ];

    			if ( light.castShadow ) {

    				_lights.shadows[ lightShadowsLength ++ ] = light;

    			}

    		}

    		_lights.shadows.length = lightShadowsLength;

    	}

    	function setupLights( lights, camera ) {

    		var l, ll, light,
    		r = 0, g = 0, b = 0,
    		color,
    		intensity,
    		distance,
    		shadowMap,

    		viewMatrix = camera.matrixWorldInverse,

    		directionalLength = 0,
    		pointLength = 0,
    		spotLength = 0,
    		hemiLength = 0;

    		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

    			light = lights[ l ];

    			color = light.color;
    			intensity = light.intensity;
    			distance = light.distance;

    			shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

    			if ( light.isAmbientLight ) {

    				r += color.r * intensity;
    				g += color.g * intensity;
    				b += color.b * intensity;

    			} else if ( light.isDirectionalLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
    				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
    				_vector3.setFromMatrixPosition( light.target.matrixWorld );
    				uniforms.direction.sub( _vector3 );
    				uniforms.direction.transformDirection( viewMatrix );

    				uniforms.shadow = light.castShadow;

    				if ( light.castShadow ) {

    					uniforms.shadowBias = light.shadow.bias;
    					uniforms.shadowRadius = light.shadow.radius;
    					uniforms.shadowMapSize = light.shadow.mapSize;

    				}

    				_lights.directionalShadowMap[ directionalLength ] = shadowMap;
    				_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
    				_lights.directional[ directionalLength ++ ] = uniforms;

    			} else if ( light.isSpotLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.position.setFromMatrixPosition( light.matrixWorld );
    				uniforms.position.applyMatrix4( viewMatrix );

    				uniforms.color.copy( color ).multiplyScalar( intensity );
    				uniforms.distance = distance;

    				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
    				_vector3.setFromMatrixPosition( light.target.matrixWorld );
    				uniforms.direction.sub( _vector3 );
    				uniforms.direction.transformDirection( viewMatrix );

    				uniforms.coneCos = Math.cos( light.angle );
    				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
    				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

    				uniforms.shadow = light.castShadow;

    				if ( light.castShadow ) {

    					uniforms.shadowBias = light.shadow.bias;
    					uniforms.shadowRadius = light.shadow.radius;
    					uniforms.shadowMapSize = light.shadow.mapSize;

    				}

    				_lights.spotShadowMap[ spotLength ] = shadowMap;
    				_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
    				_lights.spot[ spotLength ++ ] = uniforms;

    			} else if ( light.isPointLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.position.setFromMatrixPosition( light.matrixWorld );
    				uniforms.position.applyMatrix4( viewMatrix );

    				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
    				uniforms.distance = light.distance;
    				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

    				uniforms.shadow = light.castShadow;

    				if ( light.castShadow ) {

    					uniforms.shadowBias = light.shadow.bias;
    					uniforms.shadowRadius = light.shadow.radius;
    					uniforms.shadowMapSize = light.shadow.mapSize;

    				}

    				_lights.pointShadowMap[ pointLength ] = shadowMap;

    				if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {

    					_lights.pointShadowMatrix[ pointLength ] = new Matrix4();

    				}

    				// for point lights we set the shadow matrix to be a translation-only matrix
    				// equal to inverse of the light's position
    				_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
    				_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );

    				_lights.point[ pointLength ++ ] = uniforms;

    			} else if ( light.isHemisphereLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
    				uniforms.direction.transformDirection( viewMatrix );
    				uniforms.direction.normalize();

    				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
    				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

    				_lights.hemi[ hemiLength ++ ] = uniforms;

    			}

    		}

    		_lights.ambient[ 0 ] = r;
    		_lights.ambient[ 1 ] = g;
    		_lights.ambient[ 2 ] = b;

    		_lights.directional.length = directionalLength;
    		_lights.spot.length = spotLength;
    		_lights.point.length = pointLength;
    		_lights.hemi.length = hemiLength;

    		_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;

    	}

    	// GL state setting

    	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

    		state.setCullFace( cullFace );
    		state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );

    	};

    	// Textures

    	function allocTextureUnit() {

    		var textureUnit = _usedTextureUnits;

    		if ( textureUnit >= capabilities.maxTextures ) {

    			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

    		}

    		_usedTextureUnits += 1;

    		return textureUnit;

    	}

    	this.allocTextureUnit = allocTextureUnit;

    	// this.setTexture2D = setTexture2D;
    	this.setTexture2D = ( function() {

    		var warned = false;

    		// backwards compatibility: peel texture.texture
    		return function setTexture2D( texture, slot ) {

    			if ( texture && texture.isWebGLRenderTarget ) {

    				if ( ! warned ) {

    					console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
    					warned = true;

    				}

    				texture = texture.texture;

    			}

    			textures.setTexture2D( texture, slot );

    		};

    	}() );

    	this.setTexture = ( function() {

    		var warned = false;

    		return function setTexture( texture, slot ) {

    			if ( ! warned ) {

    				console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
    				warned = true;

    			}

    			textures.setTexture2D( texture, slot );

    		};

    	}() );

    	this.setTextureCube = ( function() {

    		var warned = false;

    		return function setTextureCube( texture, slot ) {

    			// backwards compatibility: peel texture.texture
    			if ( texture && texture.isWebGLRenderTargetCube ) {

    				if ( ! warned ) {

    					console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
    					warned = true;

    				}

    				texture = texture.texture;

    			}

    			// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
    			// TODO: unify these code paths
    			if ( ( texture && texture.isCubeTexture ) ||
    				 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

    				// CompressedTexture can have Array in image :/

    				// this function alone should take care of cube textures
    				textures.setTextureCube( texture, slot );

    			} else {

    				// assumed: texture property of THREE.WebGLRenderTargetCube

    				textures.setTextureCubeDynamic( texture, slot );

    			}

    		};

    	}() );

    	this.getCurrentRenderTarget = function() {

    		return _currentRenderTarget;

    	};

    	this.setRenderTarget = function ( renderTarget ) {

    		_currentRenderTarget = renderTarget;

    		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

    			textures.setupRenderTarget( renderTarget );

    		}

    		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
    		var framebuffer;

    		if ( renderTarget ) {

    			var renderTargetProperties = properties.get( renderTarget );

    			if ( isCube ) {

    				framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

    			} else {

    				framebuffer = renderTargetProperties.__webglFramebuffer;

    			}

    			_currentScissor.copy( renderTarget.scissor );
    			_currentScissorTest = renderTarget.scissorTest;

    			_currentViewport.copy( renderTarget.viewport );

    		} else {

    			framebuffer = null;

    			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
    			_currentScissorTest = _scissorTest;

    			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );

    		}

    		if ( _currentFramebuffer !== framebuffer ) {

    			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
    			_currentFramebuffer = framebuffer;

    		}

    		state.scissor( _currentScissor );
    		state.setScissorTest( _currentScissorTest );

    		state.viewport( _currentViewport );

    		if ( isCube ) {

    			var textureProperties = properties.get( renderTarget.texture );
    			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

    		}

    	};

    	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

    		if ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {

    			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
    			return;

    		}

    		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

    		if ( framebuffer ) {

    			var restore = false;

    			if ( framebuffer !== _currentFramebuffer ) {

    				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

    				restore = true;

    			}

    			try {

    				var texture = renderTarget.texture;
    				var textureFormat = texture.format;
    				var textureType = texture.type;

    				if ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

    					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
    					return;

    				}

    				if ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
    				     ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
    				     ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

    					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
    					return;

    				}

    				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

    					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

    					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

    						_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );

    					}

    				} else {

    					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

    				}

    			} finally {

    				if ( restore ) {

    					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

    				}

    			}

    		}

    	};

    	// Map three.js constants to WebGL constants

    	function paramThreeToGL( p ) {

    		var extension;

    		if ( p === RepeatWrapping ) return _gl.REPEAT;
    		if ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
    		if ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

    		if ( p === NearestFilter ) return _gl.NEAREST;
    		if ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
    		if ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

    		if ( p === LinearFilter ) return _gl.LINEAR;
    		if ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
    		if ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

    		if ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;
    		if ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
    		if ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
    		if ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

    		if ( p === ByteType ) return _gl.BYTE;
    		if ( p === ShortType ) return _gl.SHORT;
    		if ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;
    		if ( p === IntType ) return _gl.INT;
    		if ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;
    		if ( p === FloatType ) return _gl.FLOAT;

    		extension = extensions.get( 'OES_texture_half_float' );

    		if ( extension !== null ) {

    			if ( p === HalfFloatType ) return extension.HALF_FLOAT_OES;

    		}

    		if ( p === AlphaFormat ) return _gl.ALPHA;
    		if ( p === RGBFormat ) return _gl.RGB;
    		if ( p === RGBAFormat ) return _gl.RGBA;
    		if ( p === LuminanceFormat ) return _gl.LUMINANCE;
    		if ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
    		if ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;
    		if ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;

    		if ( p === AddEquation ) return _gl.FUNC_ADD;
    		if ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;
    		if ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

    		if ( p === ZeroFactor ) return _gl.ZERO;
    		if ( p === OneFactor ) return _gl.ONE;
    		if ( p === SrcColorFactor ) return _gl.SRC_COLOR;
    		if ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
    		if ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;
    		if ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
    		if ( p === DstAlphaFactor ) return _gl.DST_ALPHA;
    		if ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

    		if ( p === DstColorFactor ) return _gl.DST_COLOR;
    		if ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
    		if ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

    		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

    		if ( extension !== null ) {

    			if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
    			if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
    			if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
    			if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

    		}

    		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    		if ( extension !== null ) {

    			if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
    			if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
    			if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
    			if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

    		}

    		extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

    		if ( extension !== null ) {

    			if ( p === RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

    		}

    		extension = extensions.get( 'EXT_blend_minmax' );

    		if ( extension !== null ) {

    			if ( p === MinEquation ) return extension.MIN_EXT;
    			if ( p === MaxEquation ) return extension.MAX_EXT;

    		}

    		extension = extensions.get( 'WEBGL_depth_texture' );

    		if ( extension !== null ){

    			if ( p === UnsignedInt248Type ) return extension.UNSIGNED_INT_24_8_WEBGL;

    		}

    		return 0;

    	}

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function FogExp2 ( color, density ) {

    	this.name = '';

    	this.color = new Color( color );
    	this.density = ( density !== undefined ) ? density : 0.00025;

    }

    FogExp2.prototype.isFogExp2 = true;

    FogExp2.prototype.clone = function () {

    	return new FogExp2( this.color.getHex(), this.density );

    };

    FogExp2.prototype.toJSON = function ( meta ) {

    	return {
    		type: 'FogExp2',
    		color: this.color.getHex(),
    		density: this.density
    	};

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Fog ( color, near, far ) {

    	this.name = '';

    	this.color = new Color( color );

    	this.near = ( near !== undefined ) ? near : 1;
    	this.far = ( far !== undefined ) ? far : 1000;

    }

    Fog.prototype.isFog = true;

    Fog.prototype.clone = function () {

    	return new Fog( this.color.getHex(), this.near, this.far );

    };

    Fog.prototype.toJSON = function ( meta ) {

    	return {
    		type: 'Fog',
    		color: this.color.getHex(),
    		near: this.near,
    		far: this.far
    	};

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Scene () {

    	Object3D.call( this );

    	this.type = 'Scene';

    	this.background = null;
    	this.fog = null;
    	this.overrideMaterial = null;

    	this.autoUpdate = true; // checked by the renderer

    }

    Scene.prototype = Object.create( Object3D.prototype );

    Scene.prototype.constructor = Scene;

    Scene.prototype.copy = function ( source, recursive ) {

    	Object3D.prototype.copy.call( this, source, recursive );

    	if ( source.background !== null ) this.background = source.background.clone();
    	if ( source.fog !== null ) this.fog = source.fog.clone();
    	if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

    	this.autoUpdate = source.autoUpdate;
    	this.matrixAutoUpdate = source.matrixAutoUpdate;

    	return this;

    };

    Scene.prototype.toJSON = function ( meta ) {

    	var data = Object3D.prototype.toJSON.call( this, meta );

    	if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
    	if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

    	return data;

    };

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function LensFlare( texture, size, distance, blending, color ) {

    	Object3D.call( this );

    	this.lensFlares = [];

    	this.positionScreen = new Vector3();
    	this.customUpdateCallback = undefined;

    	if ( texture !== undefined ) {

    		this.add( texture, size, distance, blending, color );

    	}

    }

    LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: LensFlare,

    	isLensFlare: true,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.positionScreen.copy( source.positionScreen );
    		this.customUpdateCallback = source.customUpdateCallback;

    		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

    			this.lensFlares.push( source.lensFlares[ i ] );

    		}

    		return this;

    	},

    	add: function ( texture, size, distance, blending, color, opacity ) {

    		if ( size === undefined ) size = - 1;
    		if ( distance === undefined ) distance = 0;
    		if ( opacity === undefined ) opacity = 1;
    		if ( color === undefined ) color = new Color( 0xffffff );
    		if ( blending === undefined ) blending = NormalBlending;

    		distance = Math.min( distance, Math.max( 0, distance ) );

    		this.lensFlares.push( {
    			texture: texture,	// THREE.Texture
    			size: size, 		// size in pixels (-1 = use texture.width)
    			distance: distance, 	// distance (0-1) from light source (0=at light source)
    			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
    			scale: 1, 		// scale
    			rotation: 0, 		// rotation
    			opacity: opacity,	// opacity
    			color: color,		// color
    			blending: blending	// blending
    		} );

    	},

    	/*
    	 * Update lens flares update positions on all flares based on the screen position
    	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
    	 */

    	updateLensFlares: function () {

    		var f, fl = this.lensFlares.length;
    		var flare;
    		var vecX = - this.positionScreen.x * 2;
    		var vecY = - this.positionScreen.y * 2;

    		for ( f = 0; f < fl; f ++ ) {

    			flare = this.lensFlares[ f ];

    			flare.x = this.positionScreen.x + vecX * flare.distance;
    			flare.y = this.positionScreen.y + vecY * flare.distance;

    			flare.wantedRotation = flare.x * Math.PI * 0.25;
    			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

    		}

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *	uvOffset: new THREE.Vector2(),
     *	uvScale: new THREE.Vector2()
     * }
     */

    function SpriteMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'SpriteMaterial';

    	this.color = new Color( 0xffffff );
    	this.map = null;

    	this.rotation = 0;

    	this.fog = false;
    	this.lights = false;

    	this.setValues( parameters );

    }

    SpriteMaterial.prototype = Object.create( Material.prototype );
    SpriteMaterial.prototype.constructor = SpriteMaterial;

    SpriteMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );
    	this.map = source.map;

    	this.rotation = source.rotation;

    	return this;

    };

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function Sprite( material ) {

    	Object3D.call( this );

    	this.type = 'Sprite';

    	this.material = ( material !== undefined ) ? material : new SpriteMaterial();

    }

    Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Sprite,

    	isSprite: true,

    	raycast: ( function () {

    		var matrixPosition = new Vector3();

    		return function raycast( raycaster, intersects ) {

    			matrixPosition.setFromMatrixPosition( this.matrixWorld );

    			var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
    			var guessSizeSq = this.scale.x * this.scale.y / 4;

    			if ( distanceSq > guessSizeSq ) {

    				return;

    			}

    			intersects.push( {

    				distance: Math.sqrt( distanceSq ),
    				point: this.position,
    				face: null,
    				object: this

    			} );

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.material ).copy( this );

    	}

    } );

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function LOD() {

    	Object3D.call( this );

    	this.type = 'LOD';

    	Object.defineProperties( this, {
    		levels: {
    			enumerable: true,
    			value: []
    		}
    	} );

    }


    LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: LOD,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source, false );

    		var levels = source.levels;

    		for ( var i = 0, l = levels.length; i < l; i ++ ) {

    			var level = levels[ i ];

    			this.addLevel( level.object.clone(), level.distance );

    		}

    		return this;

    	},

    	addLevel: function ( object, distance ) {

    		if ( distance === undefined ) distance = 0;

    		distance = Math.abs( distance );

    		var levels = this.levels;

    		for ( var l = 0; l < levels.length; l ++ ) {

    			if ( distance < levels[ l ].distance ) {

    				break;

    			}

    		}

    		levels.splice( l, 0, { distance: distance, object: object } );

    		this.add( object );

    	},

    	getObjectForDistance: function ( distance ) {

    		var levels = this.levels;

    		for ( var i = 1, l = levels.length; i < l; i ++ ) {

    			if ( distance < levels[ i ].distance ) {

    				break;

    			}

    		}

    		return levels[ i - 1 ].object;

    	},

    	raycast: ( function () {

    		var matrixPosition = new Vector3();

    		return function raycast( raycaster, intersects ) {

    			matrixPosition.setFromMatrixPosition( this.matrixWorld );

    			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

    			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

    		};

    	}() ),

    	update: function () {

    		var v1 = new Vector3();
    		var v2 = new Vector3();

    		return function update( camera ) {

    			var levels = this.levels;

    			if ( levels.length > 1 ) {

    				v1.setFromMatrixPosition( camera.matrixWorld );
    				v2.setFromMatrixPosition( this.matrixWorld );

    				var distance = v1.distanceTo( v2 );

    				levels[ 0 ].object.visible = true;

    				for ( var i = 1, l = levels.length; i < l; i ++ ) {

    					if ( distance >= levels[ i ].distance ) {

    						levels[ i - 1 ].object.visible = false;
    						levels[ i ].object.visible = true;

    					} else {

    						break;

    					}

    				}

    				for ( ; i < l; i ++ ) {

    					levels[ i ].object.visible = false;

    				}

    			}

    		};

    	}(),

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.levels = [];

    		var levels = this.levels;

    		for ( var i = 0, l = levels.length; i < l; i ++ ) {

    			var level = levels[ i ];

    			data.object.levels.push( {
    				object: level.object.uuid,
    				distance: level.distance
    			} );

    		}

    		return data;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

    	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    	this.image = { data: data, width: width, height: height };

    	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

    	this.flipY = false;
    	this.generateMipmaps  = false;

    }

    DataTexture.prototype = Object.create( Texture.prototype );
    DataTexture.prototype.constructor = DataTexture;

    DataTexture.prototype.isDataTexture = true;

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author michael guerrero / http://realitymeltdown.com
     * @author ikerr / http://verold.com
     */

    function Skeleton( bones, boneInverses, useVertexTexture ) {

    	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

    	this.identityMatrix = new Matrix4();

    	// copy the bone array

    	bones = bones || [];

    	this.bones = bones.slice( 0 );

    	// create a bone texture or an array of floats

    	if ( this.useVertexTexture ) {

    		// layout (1 matrix = 4 pixels)
    		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
    		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
    		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
    		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
    		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


    		var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
    		size = exports.Math.nextPowerOfTwo( Math.ceil( size ) );
    		size = Math.max( size, 4 );

    		this.boneTextureWidth = size;
    		this.boneTextureHeight = size;

    		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
    		this.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );

    	} else {

    		this.boneMatrices = new Float32Array( 16 * this.bones.length );

    	}

    	// use the supplied bone inverses or calculate the inverses

    	if ( boneInverses === undefined ) {

    		this.calculateInverses();

    	} else {

    		if ( this.bones.length === boneInverses.length ) {

    			this.boneInverses = boneInverses.slice( 0 );

    		} else {

    			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

    			this.boneInverses = [];

    			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    				this.boneInverses.push( new Matrix4() );

    			}

    		}

    	}

    }

    Object.assign( Skeleton.prototype, {

    	calculateInverses: function () {

    		this.boneInverses = [];

    		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    			var inverse = new Matrix4();

    			if ( this.bones[ b ] ) {

    				inverse.getInverse( this.bones[ b ].matrixWorld );

    			}

    			this.boneInverses.push( inverse );

    		}

    	},

    	pose: function () {

    		var bone;

    		// recover the bind-time world matrices

    		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    			bone = this.bones[ b ];

    			if ( bone ) {

    				bone.matrixWorld.getInverse( this.boneInverses[ b ] );

    			}

    		}

    		// compute the local matrices, positions, rotations and scales

    		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    			bone = this.bones[ b ];

    			if ( bone ) {

    				if ( (bone.parent && bone.parent.isBone) ) {

    					bone.matrix.getInverse( bone.parent.matrixWorld );
    					bone.matrix.multiply( bone.matrixWorld );

    				} else {

    					bone.matrix.copy( bone.matrixWorld );

    				}

    				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

    			}

    		}

    	},

    	update: ( function () {

    		var offsetMatrix = new Matrix4();

    		return function update() {

    			// flatten bone matrices to array

    			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    				// compute the offset between the current and the original transform

    				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

    				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
    				offsetMatrix.toArray( this.boneMatrices, b * 16 );

    			}

    			if ( this.useVertexTexture ) {

    				this.boneTexture.needsUpdate = true;

    			}

    		};

    	} )(),

    	clone: function () {

    		return new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

    	}

    } );

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */

    function Bone( skin ) {

    	Object3D.call( this );

    	this.type = 'Bone';

    	this.skin = skin;

    }

    Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Bone,

    	isBone: true,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.skin = source.skin;

    		return this;

    	}

    } );

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */

    function SkinnedMesh( geometry, material, useVertexTexture ) {

    	Mesh.call( this, geometry, material );

    	this.type = 'SkinnedMesh';

    	this.bindMode = "attached";
    	this.bindMatrix = new Matrix4();
    	this.bindMatrixInverse = new Matrix4();

    	// init bones

    	// TODO: remove bone creation as there is no reason (other than
    	// convenience) for THREE.SkinnedMesh to do this.

    	var bones = [];

    	if ( this.geometry && this.geometry.bones !== undefined ) {

    		var bone, gbone;

    		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

    			gbone = this.geometry.bones[ b ];

    			bone = new Bone( this );
    			bones.push( bone );

    			bone.name = gbone.name;
    			bone.position.fromArray( gbone.pos );
    			bone.quaternion.fromArray( gbone.rotq );
    			if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

    		}

    		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

    			gbone = this.geometry.bones[ b ];

    			if ( gbone.parent !== - 1 && gbone.parent !== null &&
    					bones[ gbone.parent ] !== undefined ) {

    				bones[ gbone.parent ].add( bones[ b ] );

    			} else {

    				this.add( bones[ b ] );

    			}

    		}

    	}

    	this.normalizeSkinWeights();

    	this.updateMatrixWorld( true );
    	this.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

    }


    SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

    	constructor: SkinnedMesh,

    	isSkinnedMesh: true,

    	bind: function( skeleton, bindMatrix ) {

    		this.skeleton = skeleton;

    		if ( bindMatrix === undefined ) {

    			this.updateMatrixWorld( true );

    			this.skeleton.calculateInverses();

    			bindMatrix = this.matrixWorld;

    		}

    		this.bindMatrix.copy( bindMatrix );
    		this.bindMatrixInverse.getInverse( bindMatrix );

    	},

    	pose: function () {

    		this.skeleton.pose();

    	},

    	normalizeSkinWeights: function () {

    		if ( (this.geometry && this.geometry.isGeometry) ) {

    			for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {

    				var sw = this.geometry.skinWeights[ i ];

    				var scale = 1.0 / sw.lengthManhattan();

    				if ( scale !== Infinity ) {

    					sw.multiplyScalar( scale );

    				} else {

    					sw.set( 1, 0, 0, 0 ); // do something reasonable

    				}

    			}

    		} else if ( (this.geometry && this.geometry.isBufferGeometry) ) {

    			var vec = new Vector4();

    			var skinWeight = this.geometry.attributes.skinWeight;

    			for ( var i = 0; i < skinWeight.count; i ++ ) {

    				vec.x = skinWeight.getX( i );
    				vec.y = skinWeight.getY( i );
    				vec.z = skinWeight.getZ( i );
    				vec.w = skinWeight.getW( i );

    				var scale = 1.0 / vec.lengthManhattan();

    				if ( scale !== Infinity ) {

    					vec.multiplyScalar( scale );

    				} else {

    					vec.set( 1, 0, 0, 0 ); // do something reasonable

    				}

    				skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

    			}

    		}

    	},

    	updateMatrixWorld: function( force ) {

    		Mesh.prototype.updateMatrixWorld.call( this, true );

    		if ( this.bindMode === "attached" ) {

    			this.bindMatrixInverse.getInverse( this.matrixWorld );

    		} else if ( this.bindMode === "detached" ) {

    			this.bindMatrixInverse.getInverse( this.bindMatrix );

    		} else {

    			console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

    		}

    	},

    	clone: function() {

    		return new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  linewidth: <float>,
     *  linecap: "round",
     *  linejoin: "round"
     * }
     */

    function LineBasicMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'LineBasicMaterial';

    	this.color = new Color( 0xffffff );

    	this.linewidth = 1;
    	this.linecap = 'round';
    	this.linejoin = 'round';

    	this.lights = false;

    	this.setValues( parameters );

    }

    LineBasicMaterial.prototype = Object.create( Material.prototype );
    LineBasicMaterial.prototype.constructor = LineBasicMaterial;

    LineBasicMaterial.prototype.isLineBasicMaterial = true;

    LineBasicMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.linewidth = source.linewidth;
    	this.linecap = source.linecap;
    	this.linejoin = source.linejoin;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Line( geometry, material, mode ) {

    	if ( mode === 1 ) {

    		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
    		return new LineSegments( geometry, material );

    	}

    	Object3D.call( this );

    	this.type = 'Line';

    	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    	this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

    }

    Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Line,

    	isLine: true,

    	raycast: ( function () {

    		var inverseMatrix = new Matrix4();
    		var ray = new Ray();
    		var sphere = new Sphere();

    		return function raycast( raycaster, intersects ) {

    			var precision = raycaster.linePrecision;
    			var precisionSq = precision * precision;

    			var geometry = this.geometry;
    			var matrixWorld = this.matrixWorld;

    			// Checking boundingSphere distance to ray

    			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere );
    			sphere.applyMatrix4( matrixWorld );

    			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

    			//

    			inverseMatrix.getInverse( matrixWorld );
    			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    			var vStart = new Vector3();
    			var vEnd = new Vector3();
    			var interSegment = new Vector3();
    			var interRay = new Vector3();
    			var step = (this && this.isLineSegments) ? 2 : 1;

    			if ( (geometry && geometry.isBufferGeometry) ) {

    				var index = geometry.index;
    				var attributes = geometry.attributes;
    				var positions = attributes.position.array;

    				if ( index !== null ) {

    					var indices = index.array;

    					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

    						var a = indices[ i ];
    						var b = indices[ i + 1 ];

    						vStart.fromArray( positions, a * 3 );
    						vEnd.fromArray( positions, b * 3 );

    						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

    						if ( distSq > precisionSq ) continue;

    						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

    						var distance = raycaster.ray.origin.distanceTo( interRay );

    						if ( distance < raycaster.near || distance > raycaster.far ) continue;

    						intersects.push( {

    							distance: distance,
    							// What do we want? intersection point on the ray or on the segment??
    							// point: raycaster.ray.at( distance ),
    							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
    							index: i,
    							face: null,
    							faceIndex: null,
    							object: this

    						} );

    					}

    				} else {

    					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

    						vStart.fromArray( positions, 3 * i );
    						vEnd.fromArray( positions, 3 * i + 3 );

    						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

    						if ( distSq > precisionSq ) continue;

    						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

    						var distance = raycaster.ray.origin.distanceTo( interRay );

    						if ( distance < raycaster.near || distance > raycaster.far ) continue;

    						intersects.push( {

    							distance: distance,
    							// What do we want? intersection point on the ray or on the segment??
    							// point: raycaster.ray.at( distance ),
    							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
    							index: i,
    							face: null,
    							faceIndex: null,
    							object: this

    						} );

    					}

    				}

    			} else if ( (geometry && geometry.isGeometry) ) {

    				var vertices = geometry.vertices;
    				var nbVertices = vertices.length;

    				for ( var i = 0; i < nbVertices - 1; i += step ) {

    					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

    					if ( distSq > precisionSq ) continue;

    					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

    					var distance = raycaster.ray.origin.distanceTo( interRay );

    					if ( distance < raycaster.near || distance > raycaster.far ) continue;

    					intersects.push( {

    						distance: distance,
    						// What do we want? intersection point on the ray or on the segment??
    						// point: raycaster.ray.at( distance ),
    						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
    						index: i,
    						face: null,
    						faceIndex: null,
    						object: this

    					} );

    				}

    			}

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.geometry, this.material ).copy( this );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function LineSegments( geometry, material ) {

    	Line.call( this, geometry, material );

    	this.type = 'LineSegments';

    }

    LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

    	constructor: LineSegments,

    	isLineSegments: true

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  size: <float>,
     *  sizeAttenuation: <bool>
     * }
     */

    function PointsMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'PointsMaterial';

    	this.color = new Color( 0xffffff );

    	this.map = null;

    	this.size = 1;
    	this.sizeAttenuation = true;

    	this.lights = false;

    	this.setValues( parameters );

    }

    PointsMaterial.prototype = Object.create( Material.prototype );
    PointsMaterial.prototype.constructor = PointsMaterial;

    PointsMaterial.prototype.isPointsMaterial = true;

    PointsMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.map = source.map;

    	this.size = source.size;
    	this.sizeAttenuation = source.sizeAttenuation;

    	return this;

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function Points( geometry, material ) {

    	Object3D.call( this );

    	this.type = 'Points';

    	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    	this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

    }

    Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Points,

    	isPoints: true,

    	raycast: ( function () {

    		var inverseMatrix = new Matrix4();
    		var ray = new Ray();
    		var sphere = new Sphere();

    		return function raycast( raycaster, intersects ) {

    			var object = this;
    			var geometry = this.geometry;
    			var matrixWorld = this.matrixWorld;
    			var threshold = raycaster.params.Points.threshold;

    			// Checking boundingSphere distance to ray

    			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere );
    			sphere.applyMatrix4( matrixWorld );

    			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

    			//

    			inverseMatrix.getInverse( matrixWorld );
    			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
    			var localThresholdSq = localThreshold * localThreshold;
    			var position = new Vector3();

    			function testPoint( point, index ) {

    				var rayPointDistanceSq = ray.distanceSqToPoint( point );

    				if ( rayPointDistanceSq < localThresholdSq ) {

    					var intersectPoint = ray.closestPointToPoint( point );
    					intersectPoint.applyMatrix4( matrixWorld );

    					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

    					if ( distance < raycaster.near || distance > raycaster.far ) return;

    					intersects.push( {

    						distance: distance,
    						distanceToRay: Math.sqrt( rayPointDistanceSq ),
    						point: intersectPoint.clone(),
    						index: index,
    						face: null,
    						object: object

    					} );

    				}

    			}

    			if ( (geometry && geometry.isBufferGeometry) ) {

    				var index = geometry.index;
    				var attributes = geometry.attributes;
    				var positions = attributes.position.array;

    				if ( index !== null ) {

    					var indices = index.array;

    					for ( var i = 0, il = indices.length; i < il; i ++ ) {

    						var a = indices[ i ];

    						position.fromArray( positions, a * 3 );

    						testPoint( position, a );

    					}

    				} else {

    					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

    						position.fromArray( positions, i * 3 );

    						testPoint( position, i );

    					}

    				}

    			} else {

    				var vertices = geometry.vertices;

    				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

    					testPoint( vertices[ i ], i );

    				}

    			}

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.geometry, this.material ).copy( this );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Group() {

    	Object3D.call( this );

    	this.type = 'Group';

    }

    Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Group

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    	Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    	this.generateMipmaps = false;

    	var scope = this;

    	function update() {

    		requestAnimationFrame( update );

    		if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

    			scope.needsUpdate = true;

    		}

    	}

    	update();

    }

    VideoTexture.prototype = Object.create( Texture.prototype );
    VideoTexture.prototype.constructor = VideoTexture;

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

    	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    	this.image = { width: width, height: height };
    	this.mipmaps = mipmaps;

    	// no flipping for cube textures
    	// (also flipping doesn't work for compressed textures )

    	this.flipY = false;

    	// can't generate mipmaps for compressed textures
    	// mips must be embedded in DDS files

    	this.generateMipmaps = false;

    }

    CompressedTexture.prototype = Object.create( Texture.prototype );
    CompressedTexture.prototype.constructor = CompressedTexture;

    CompressedTexture.prototype.isCompressedTexture = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    	Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    	this.needsUpdate = true;

    }

    CanvasTexture.prototype = Object.create( Texture.prototype );
    CanvasTexture.prototype.constructor = CanvasTexture;

    /**
     * @author Matt DesLauriers / @mattdesl
     * @author atix / arthursilber.de
     */

    function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

    	format = format !== undefined ? format : DepthFormat;

    	if ( format !== DepthFormat && format !== DepthStencilFormat ) {

    		throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )

    	}

    	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    	this.image = { width: width, height: height };

    	this.type = type !== undefined ? type : UnsignedShortType;

    	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

    	this.flipY = false;
    	this.generateMipmaps	= false;

    }

    DepthTexture.prototype = Object.create( Texture.prototype );
    DepthTexture.prototype.constructor = DepthTexture;
    DepthTexture.prototype.isDepthTexture = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WireframeGeometry( geometry ) {

    	BufferGeometry.call( this );

    	var edge = [ 0, 0 ], hash = {};

    	function sortFunction( a, b ) {

    		return a - b;

    	}

    	var keys = [ 'a', 'b', 'c' ];

    	if ( (geometry && geometry.isGeometry) ) {

    		var vertices = geometry.vertices;
    		var faces = geometry.faces;
    		var numEdges = 0;

    		// allocate maximal size
    		var edges = new Uint32Array( 6 * faces.length );

    		for ( var i = 0, l = faces.length; i < l; i ++ ) {

    			var face = faces[ i ];

    			for ( var j = 0; j < 3; j ++ ) {

    				edge[ 0 ] = face[ keys[ j ] ];
    				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
    				edge.sort( sortFunction );

    				var key = edge.toString();

    				if ( hash[ key ] === undefined ) {

    					edges[ 2 * numEdges ] = edge[ 0 ];
    					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
    					hash[ key ] = true;
    					numEdges ++;

    				}

    			}

    		}

    		var coords = new Float32Array( numEdges * 2 * 3 );

    		for ( var i = 0, l = numEdges; i < l; i ++ ) {

    			for ( var j = 0; j < 2; j ++ ) {

    				var vertex = vertices[ edges [ 2 * i + j ] ];

    				var index = 6 * i + 3 * j;
    				coords[ index + 0 ] = vertex.x;
    				coords[ index + 1 ] = vertex.y;
    				coords[ index + 2 ] = vertex.z;

    			}

    		}

    		this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

    	} else if ( (geometry && geometry.isBufferGeometry) ) {

    		if ( geometry.index !== null ) {

    			// Indexed BufferGeometry

    			var indices = geometry.index.array;
    			var vertices = geometry.attributes.position;
    			var groups = geometry.groups;
    			var numEdges = 0;

    			if ( groups.length === 0 ) {

    				geometry.addGroup( 0, indices.length );

    			}

    			// allocate maximal size
    			var edges = new Uint32Array( 2 * indices.length );

    			for ( var o = 0, ol = groups.length; o < ol; ++ o ) {

    				var group = groups[ o ];

    				var start = group.start;
    				var count = group.count;

    				for ( var i = start, il = start + count; i < il; i += 3 ) {

    					for ( var j = 0; j < 3; j ++ ) {

    						edge[ 0 ] = indices[ i + j ];
    						edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
    						edge.sort( sortFunction );

    						var key = edge.toString();

    						if ( hash[ key ] === undefined ) {

    							edges[ 2 * numEdges ] = edge[ 0 ];
    							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
    							hash[ key ] = true;
    							numEdges ++;

    						}

    					}

    				}

    			}

    			var coords = new Float32Array( numEdges * 2 * 3 );

    			for ( var i = 0, l = numEdges; i < l; i ++ ) {

    				for ( var j = 0; j < 2; j ++ ) {

    					var index = 6 * i + 3 * j;
    					var index2 = edges[ 2 * i + j ];

    					coords[ index + 0 ] = vertices.getX( index2 );
    					coords[ index + 1 ] = vertices.getY( index2 );
    					coords[ index + 2 ] = vertices.getZ( index2 );

    				}

    			}

    			this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

    		} else {

    			// non-indexed BufferGeometry

    			var vertices = geometry.attributes.position.array;
    			var numEdges = vertices.length / 3;
    			var numTris = numEdges / 3;

    			var coords = new Float32Array( numEdges * 2 * 3 );

    			for ( var i = 0, l = numTris; i < l; i ++ ) {

    				for ( var j = 0; j < 3; j ++ ) {

    					var index = 18 * i + 6 * j;

    					var index1 = 9 * i + 3 * j;
    					coords[ index + 0 ] = vertices[ index1 ];
    					coords[ index + 1 ] = vertices[ index1 + 1 ];
    					coords[ index + 2 ] = vertices[ index1 + 2 ];

    					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
    					coords[ index + 3 ] = vertices[ index2 ];
    					coords[ index + 4 ] = vertices[ index2 + 1 ];
    					coords[ index + 5 ] = vertices[ index2 + 2 ];

    				}

    			}

    			this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

    		}

    	}

    }

    WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
    WireframeGeometry.prototype.constructor = WireframeGeometry;

    /**
     * @author zz85 / https://github.com/zz85
     * Parametric Surfaces Geometry
     * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
     *
     * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
     *
     */

    function ParametricGeometry( func, slices, stacks ) {

    	Geometry.call( this );

    	this.type = 'ParametricGeometry';

    	this.parameters = {
    		func: func,
    		slices: slices,
    		stacks: stacks
    	};

    	var verts = this.vertices;
    	var faces = this.faces;
    	var uvs = this.faceVertexUvs[ 0 ];

    	var i, j, p;
    	var u, v;

    	var sliceCount = slices + 1;

    	for ( i = 0; i <= stacks; i ++ ) {

    		v = i / stacks;

    		for ( j = 0; j <= slices; j ++ ) {

    			u = j / slices;

    			p = func( u, v );
    			verts.push( p );

    		}

    	}

    	var a, b, c, d;
    	var uva, uvb, uvc, uvd;

    	for ( i = 0; i < stacks; i ++ ) {

    		for ( j = 0; j < slices; j ++ ) {

    			a = i * sliceCount + j;
    			b = i * sliceCount + j + 1;
    			c = ( i + 1 ) * sliceCount + j + 1;
    			d = ( i + 1 ) * sliceCount + j;

    			uva = new Vector2( j / slices, i / stacks );
    			uvb = new Vector2( ( j + 1 ) / slices, i / stacks );
    			uvc = new Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
    			uvd = new Vector2( j / slices, ( i + 1 ) / stacks );

    			faces.push( new Face3( a, b, d ) );
    			uvs.push( [ uva, uvb, uvd ] );

    			faces.push( new Face3( b, c, d ) );
    			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

    		}

    	}

    	// console.log(this);

    	// magic bullet
    	// var diff = this.mergeVertices();
    	// console.log('removed ', diff, ' vertices by merging');

    	this.computeFaceNormals();
    	this.computeVertexNormals();

    }

    ParametricGeometry.prototype = Object.create( Geometry.prototype );
    ParametricGeometry.prototype.constructor = ParametricGeometry;

    /**
     * @author clockworkgeek / https://github.com/clockworkgeek
     * @author timothypratley / https://github.com/timothypratley
     * @author WestLangley / http://github.com/WestLangley
    */

    function PolyhedronGeometry( vertices, indices, radius, detail ) {

    	Geometry.call( this );

    	this.type = 'PolyhedronGeometry';

    	this.parameters = {
    		vertices: vertices,
    		indices: indices,
    		radius: radius,
    		detail: detail
    	};

    	radius = radius || 1;
    	detail = detail || 0;

    	var that = this;

    	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

    		prepare( new Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

    	}

    	var p = this.vertices;

    	var faces = [];

    	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

    		var v1 = p[ indices[ i ] ];
    		var v2 = p[ indices[ i + 1 ] ];
    		var v3 = p[ indices[ i + 2 ] ];

    		faces[ j ] = new Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

    	}

    	var centroid = new Vector3();

    	for ( var i = 0, l = faces.length; i < l; i ++ ) {

    		subdivide( faces[ i ], detail );

    	}


    	// Handle case when face straddles the seam

    	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

    		var uvs = this.faceVertexUvs[ 0 ][ i ];

    		var x0 = uvs[ 0 ].x;
    		var x1 = uvs[ 1 ].x;
    		var x2 = uvs[ 2 ].x;

    		var max = Math.max( x0, x1, x2 );
    		var min = Math.min( x0, x1, x2 );

    		if ( max > 0.9 && min < 0.1 ) {

    			// 0.9 is somewhat arbitrary

    			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
    			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
    			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

    		}

    	}


    	// Apply radius

    	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

    		this.vertices[ i ].multiplyScalar( radius );

    	}


    	// Merge vertices

    	this.mergeVertices();

    	this.computeFaceNormals();

    	this.boundingSphere = new Sphere( new Vector3(), radius );


    	// Project vector onto sphere's surface

    	function prepare( vector ) {

    		var vertex = vector.normalize().clone();
    		vertex.index = that.vertices.push( vertex ) - 1;

    		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

    		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
    		var v = inclination( vector ) / Math.PI + 0.5;
    		vertex.uv = new Vector2( u, 1 - v );

    		return vertex;

    	}


    	// Approximate a curved face with recursively sub-divided triangles.

    	function make( v1, v2, v3 ) {

    		var face = new Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
    		that.faces.push( face );

    		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

    		var azi = azimuth( centroid );

    		that.faceVertexUvs[ 0 ].push( [
    			correctUV( v1.uv, v1, azi ),
    			correctUV( v2.uv, v2, azi ),
    			correctUV( v3.uv, v3, azi )
    		] );

    	}


    	// Analytically subdivide a face to the required detail level.

    	function subdivide( face, detail ) {

    		var cols = Math.pow( 2, detail );
    		var a = prepare( that.vertices[ face.a ] );
    		var b = prepare( that.vertices[ face.b ] );
    		var c = prepare( that.vertices[ face.c ] );
    		var v = [];

    		// Construct all of the vertices for this subdivision.

    		for ( var i = 0 ; i <= cols; i ++ ) {

    			v[ i ] = [];

    			var aj = prepare( a.clone().lerp( c, i / cols ) );
    			var bj = prepare( b.clone().lerp( c, i / cols ) );
    			var rows = cols - i;

    			for ( var j = 0; j <= rows; j ++ ) {

    				if ( j === 0 && i === cols ) {

    					v[ i ][ j ] = aj;

    				} else {

    					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

    				}

    			}

    		}

    		// Construct all of the faces.

    		for ( var i = 0; i < cols ; i ++ ) {

    			for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

    				var k = Math.floor( j / 2 );

    				if ( j % 2 === 0 ) {

    					make(
    						v[ i ][ k + 1 ],
    						v[ i + 1 ][ k ],
    						v[ i ][ k ]
    					);

    				} else {

    					make(
    						v[ i ][ k + 1 ],
    						v[ i + 1 ][ k + 1 ],
    						v[ i + 1 ][ k ]
    					);

    				}

    			}

    		}

    	}


    	// Angle around the Y axis, counter-clockwise when looking from above.

    	function azimuth( vector ) {

    		return Math.atan2( vector.z, - vector.x );

    	}


    	// Angle above the XZ plane.

    	function inclination( vector ) {

    		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

    	}


    	// Texture fixing helper. Spheres have some odd behaviours.

    	function correctUV( uv, vector, azimuth ) {

    		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new Vector2( uv.x - 1, uv.y );
    		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
    		return uv.clone();

    	}

    }

    PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
    PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

    /**
     * @author timothypratley / https://github.com/timothypratley
     */

    function TetrahedronGeometry( radius, detail ) {

    	var vertices = [
    		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
    	];

    	var indices = [
    		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'TetrahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    TetrahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

    /**
     * @author timothypratley / https://github.com/timothypratley
     */

    function OctahedronGeometry( radius, detail ) {

    	var vertices = [
    		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
    	];

    	var indices = [
    		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'OctahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    OctahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    OctahedronGeometry.prototype.constructor = OctahedronGeometry;

    /**
     * @author timothypratley / https://github.com/timothypratley
     */

    function IcosahedronGeometry( radius, detail ) {

    	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

    	var vertices = [
    		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
    		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
    		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
    	];

    	var indices = [
    		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
    		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
    		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
    		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'IcosahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    IcosahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

    /**
     * @author Abe Pazos / https://hamoid.com
     */

    function DodecahedronGeometry( radius, detail ) {

    	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
    	var r = 1 / t;

    	var vertices = [

    		// (1, 1, 1)
    		- 1, - 1, - 1,    - 1, - 1,  1,
    		- 1,  1, - 1,    - 1,  1,  1,
    		 1, - 1, - 1,     1, - 1,  1,
    		 1,  1, - 1,     1,  1,  1,

    		// (0, 1/, )
    		 0, - r, - t,     0, - r,  t,
    		 0,  r, - t,     0,  r,  t,

    		// (1/, , 0)
    		- r, - t,  0,    - r,  t,  0,
    		 r, - t,  0,     r,  t,  0,

    		// (, 0, 1/)
    		- t,  0, - r,     t,  0, - r,
    		- t,  0,  r,     t,  0,  r
    	];

    	var indices = [
    		 3, 11,  7,      3,  7, 15,      3, 15, 13,
    		 7, 19, 17,      7, 17,  6,      7,  6, 15,
    		17,  4,  8,     17,  8, 10,     17, 10,  6,
    		 8,  0, 16,      8, 16,  2,      8,  2, 10,
    		 0, 12,  1,      0,  1, 18,      0, 18, 16,
    		 6, 10,  2,      6,  2, 13,      6, 13, 15,
    		 2, 16, 18,      2, 18,  3,      2,  3, 13,
    		18,  1,  9,     18,  9, 11,     18, 11,  3,
    		 4, 14, 12,      4, 12,  0,      4,  0,  8,
    		11,  9,  5,     11,  5, 19,     11, 19,  7,
    		19,  5, 14,     19, 14,  4,     19,  4, 17,
    		 1, 12, 14,      1, 14,  5,      1,  5,  9
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'DodecahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    DodecahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

    /**
     * @author WestLangley / https://github.com/WestLangley
     * @author zz85 / https://github.com/zz85
     * @author miningold / https://github.com/miningold
     * @author jonobr1 / https://github.com/jonobr1
     *
     * Modified from the TorusKnotGeometry by @oosmoxiecode
     *
     * Creates a tube which extrudes along a 3d spline
     *
     * Uses parallel transport frames as described in
     * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
     */

    function TubeGeometry( path, segments, radius, radialSegments, closed, taper ) {

    	Geometry.call( this );

    	this.type = 'TubeGeometry';

    	this.parameters = {
    		path: path,
    		segments: segments,
    		radius: radius,
    		radialSegments: radialSegments,
    		closed: closed,
    		taper: taper
    	};

    	segments = segments || 64;
    	radius = radius || 1;
    	radialSegments = radialSegments || 8;
    	closed = closed || false;
    	taper = taper || TubeGeometry.NoTaper;

    	var grid = [];

    	var scope = this,

    		tangent,
    		normal,
    		binormal,

    		numpoints = segments + 1,

    		u, v, r,

    		cx, cy,
    		pos, pos2 = new Vector3(),
    		i, j,
    		ip, jp,
    		a, b, c, d,
    		uva, uvb, uvc, uvd;

    	var frames = new TubeGeometry.FrenetFrames( path, segments, closed ),
    		tangents = frames.tangents,
    		normals = frames.normals,
    		binormals = frames.binormals;

    	// proxy internals
    	this.tangents = tangents;
    	this.normals = normals;
    	this.binormals = binormals;

    	function vert( x, y, z ) {

    		return scope.vertices.push( new Vector3( x, y, z ) ) - 1;

    	}

    	// construct the grid

    	for ( i = 0; i < numpoints; i ++ ) {

    		grid[ i ] = [];

    		u = i / ( numpoints - 1 );

    		pos = path.getPointAt( u );

    		tangent = tangents[ i ];
    		normal = normals[ i ];
    		binormal = binormals[ i ];

    		r = radius * taper( u );

    		for ( j = 0; j < radialSegments; j ++ ) {

    			v = j / radialSegments * 2 * Math.PI;

    			cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
    			cy = r * Math.sin( v );

    			pos2.copy( pos );
    			pos2.x += cx * normal.x + cy * binormal.x;
    			pos2.y += cx * normal.y + cy * binormal.y;
    			pos2.z += cx * normal.z + cy * binormal.z;

    			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

    		}

    	}


    	// construct the mesh

    	for ( i = 0; i < segments; i ++ ) {

    		for ( j = 0; j < radialSegments; j ++ ) {

    			ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
    			jp = ( j + 1 ) % radialSegments;

    			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
    			b = grid[ ip ][ j ];
    			c = grid[ ip ][ jp ];
    			d = grid[ i ][ jp ];

    			uva = new Vector2( i / segments, j / radialSegments );
    			uvb = new Vector2( ( i + 1 ) / segments, j / radialSegments );
    			uvc = new Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
    			uvd = new Vector2( i / segments, ( j + 1 ) / radialSegments );

    			this.faces.push( new Face3( a, b, d ) );
    			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

    			this.faces.push( new Face3( b, c, d ) );
    			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

    		}

    	}

    	this.computeFaceNormals();
    	this.computeVertexNormals();

    }

    TubeGeometry.prototype = Object.create( Geometry.prototype );
    TubeGeometry.prototype.constructor = TubeGeometry;

    TubeGeometry.NoTaper = function ( u ) {

    	return 1;

    };

    TubeGeometry.SinusoidalTaper = function ( u ) {

    	return Math.sin( Math.PI * u );

    };

    // For computing of Frenet frames, exposing the tangents, normals and binormals the spline
    TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

    	var	normal = new Vector3(),

    		tangents = [],
    		normals = [],
    		binormals = [],

    		vec = new Vector3(),
    		mat = new Matrix4(),

    		numpoints = segments + 1,
    		theta,
    		smallest,

    		tx, ty, tz,
    		i, u;


    	// expose internals
    	this.tangents = tangents;
    	this.normals = normals;
    	this.binormals = binormals;

    	// compute the tangent vectors for each segment on the path

    	for ( i = 0; i < numpoints; i ++ ) {

    		u = i / ( numpoints - 1 );

    		tangents[ i ] = path.getTangentAt( u );
    		tangents[ i ].normalize();

    	}

    	initialNormal3();

    	/*
    	function initialNormal1(lastBinormal) {
    		// fixed start binormal. Has dangers of 0 vectors
    		normals[ 0 ] = new THREE.Vector3();
    		binormals[ 0 ] = new THREE.Vector3();
    		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
    		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
    		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
    	}

    	function initialNormal2() {

    		// This uses the Frenet-Serret formula for deriving binormal
    		var t2 = path.getTangentAt( epsilon );

    		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
    		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

    		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
    		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

    	}
    	*/

    	function initialNormal3() {

    		// select an initial normal vector perpendicular to the first tangent vector,
    		// and in the direction of the smallest tangent xyz component

    		normals[ 0 ] = new Vector3();
    		binormals[ 0 ] = new Vector3();
    		smallest = Number.MAX_VALUE;
    		tx = Math.abs( tangents[ 0 ].x );
    		ty = Math.abs( tangents[ 0 ].y );
    		tz = Math.abs( tangents[ 0 ].z );

    		if ( tx <= smallest ) {

    			smallest = tx;
    			normal.set( 1, 0, 0 );

    		}

    		if ( ty <= smallest ) {

    			smallest = ty;
    			normal.set( 0, 1, 0 );

    		}

    		if ( tz <= smallest ) {

    			normal.set( 0, 0, 1 );

    		}

    		vec.crossVectors( tangents[ 0 ], normal ).normalize();

    		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
    		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

    	}


    	// compute the slowly-varying normal and binormal vectors for each segment on the path

    	for ( i = 1; i < numpoints; i ++ ) {

    		normals[ i ] = normals[ i - 1 ].clone();

    		binormals[ i ] = binormals[ i - 1 ].clone();

    		vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

    		if ( vec.length() > Number.EPSILON ) {

    			vec.normalize();

    			theta = Math.acos( exports.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

    			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

    		}

    		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    	}


    	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

    	if ( closed ) {

    		theta = Math.acos( exports.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
    		theta /= ( numpoints - 1 );

    		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

    			theta = - theta;

    		}

    		for ( i = 1; i < numpoints; i ++ ) {

    			// twist a little...
    			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
    			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    		}

    	}

    };

    /**
     * @author Mugen87 / https://github.com/Mugen87
     *
     * see: http://www.blackpawn.com/texts/pqtorus/
     */
    function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

    	BufferGeometry.call( this );

    	this.type = 'TorusKnotBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		tubularSegments: tubularSegments,
    		radialSegments: radialSegments,
    		p: p,
    		q: q
    	};

    	radius = radius || 100;
    	tube = tube || 40;
    	tubularSegments = Math.floor( tubularSegments ) || 64;
    	radialSegments = Math.floor( radialSegments ) || 8;
    	p = p || 2;
    	q = q || 3;

    	// used to calculate buffer length
    	var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
    	var indexCount = radialSegments * tubularSegments * 2 * 3;

    	// buffers
    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// helper variables
    	var i, j, index = 0, indexOffset = 0;

    	var vertex = new Vector3();
    	var normal = new Vector3();
    	var uv = new Vector2();

    	var P1 = new Vector3();
    	var P2 = new Vector3();

    	var B = new Vector3();
    	var T = new Vector3();
    	var N = new Vector3();

    	// generate vertices, normals and uvs

    	for ( i = 0; i <= tubularSegments; ++ i ) {

    		// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

    		var u = i / tubularSegments * p * Math.PI * 2;

    		// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
    		// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

    		calculatePositionOnCurve( u, p, q, radius, P1 );
    		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

    		// calculate orthonormal basis

    		T.subVectors( P2, P1 );
    		N.addVectors( P2, P1 );
    		B.crossVectors( T, N );
    		N.crossVectors( B, T );

    		// normalize B, N. T can be ignored, we don't use it

    		B.normalize();
    		N.normalize();

    		for ( j = 0; j <= radialSegments; ++ j ) {

    			// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
    			// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

    			var v = j / radialSegments * Math.PI * 2;
    			var cx = - tube * Math.cos( v );
    			var cy = tube * Math.sin( v );

    			// now calculate the final vertex position.
    			// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

    			vertex.x = P1.x + ( cx * N.x + cy * B.x );
    			vertex.y = P1.y + ( cx * N.y + cy * B.y );
    			vertex.z = P1.z + ( cx * N.z + cy * B.z );

    			// vertex
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
    			normal.subVectors( vertex, P1 ).normalize();
    			normals.setXYZ( index, normal.x, normal.y, normal.z );

    			// uv
    			uv.x = i / tubularSegments;
    			uv.y = j / radialSegments;
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    	}

    	// generate indices

    	for ( j = 1; j <= tubularSegments; j ++ ) {

    		for ( i = 1; i <= radialSegments; i ++ ) {

    			// indices
    			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
    			var b = ( radialSegments + 1 ) * j + ( i - 1 );
    			var c = ( radialSegments + 1 ) * j + i;
    			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

    			// face one
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    			// face two
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    		}

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    	// this function calculates the current position on the torus curve

    	function calculatePositionOnCurve( u, p, q, radius, position ) {

    		var cu = Math.cos( u );
    		var su = Math.sin( u );
    		var quOverP = q / p * u;
    		var cs = Math.cos( quOverP );

    		position.x = radius * ( 2 + cs ) * 0.5 * cu;
    		position.y = radius * ( 2 + cs ) * su * 0.5;
    		position.z = radius * Math.sin( quOverP ) * 0.5;

    	}

    }

    TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

    /**
     * @author oosmoxiecode
     */

    function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

    	Geometry.call( this );

    	this.type = 'TorusKnotGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		tubularSegments: tubularSegments,
    		radialSegments: radialSegments,
    		p: p,
    		q: q
    	};

    	if( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

    	this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
    	this.mergeVertices();

    }

    TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
    TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

    	BufferGeometry.call( this );

    	this.type = 'TorusBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		radialSegments: radialSegments,
    		tubularSegments: tubularSegments,
    		arc: arc
    	};

    	radius = radius || 100;
    	tube = tube || 40;
    	radialSegments = Math.floor( radialSegments ) || 8;
    	tubularSegments = Math.floor( tubularSegments ) || 6;
    	arc = arc || Math.PI * 2;

    	// used to calculate buffer length
    	var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
    	var indexCount = radialSegments * tubularSegments * 2 * 3;

    	// buffers
    	var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
    	var vertices = new Float32Array( vertexCount * 3 );
    	var normals = new Float32Array( vertexCount * 3 );
    	var uvs = new Float32Array( vertexCount * 2 );

    	// offset variables
    	var vertexBufferOffset = 0;
    	var uvBufferOffset = 0;
    	var indexBufferOffset = 0;

    	// helper variables
    	var center = new Vector3();
    	var vertex = new Vector3();
    	var normal = new Vector3();

    	var j, i;

    	// generate vertices, normals and uvs

    	for ( j = 0; j <= radialSegments; j ++ ) {

    		for ( i = 0; i <= tubularSegments; i ++ ) {

    			var u = i / tubularSegments * arc;
    			var v = j / radialSegments * Math.PI * 2;

    			// vertex
    			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
    			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
    			vertex.z = tube * Math.sin( v );

    			vertices[ vertexBufferOffset ] = vertex.x;
    			vertices[ vertexBufferOffset + 1 ] = vertex.y;
    			vertices[ vertexBufferOffset + 2 ] = vertex.z;

    			// this vector is used to calculate the normal
    			center.x = radius * Math.cos( u );
    			center.y = radius * Math.sin( u );

    			// normal
    			normal.subVectors( vertex, center ).normalize();

    			normals[ vertexBufferOffset ] = normal.x;
    			normals[ vertexBufferOffset + 1 ] = normal.y;
    			normals[ vertexBufferOffset + 2 ] = normal.z;

    			// uv
    			uvs[ uvBufferOffset ] = i / tubularSegments;
    			uvs[ uvBufferOffset + 1 ] = j / radialSegments;

    			// update offsets
    			vertexBufferOffset += 3;
    			uvBufferOffset += 2;

    		}

    	}

    	// generate indices

    	for ( j = 1; j <= radialSegments; j ++ ) {

    		for ( i = 1; i <= tubularSegments; i ++ ) {

    			// indices
    			var a = ( tubularSegments + 1 ) * j + i - 1;
    			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
    			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
    			var d = ( tubularSegments + 1 ) * j + i;

    			// face one
    			indices[ indexBufferOffset ] = a;
    			indices[ indexBufferOffset + 1 ] = b;
    			indices[ indexBufferOffset + 2 ] = d;

    			// face two
    			indices[ indexBufferOffset + 3 ] = b;
    			indices[ indexBufferOffset + 4 ] = c;
    			indices[ indexBufferOffset + 5 ] = d;

    			// update offset
    			indexBufferOffset += 6;

    		}

    	}

    	// build geometry
    	this.setIndex( new BufferAttribute( indices, 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    }

    TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

    /**
     * @author oosmoxiecode
     * @author mrdoob / http://mrdoob.com/
     * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
     */

    function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

    	Geometry.call( this );

    	this.type = 'TorusGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		radialSegments: radialSegments,
    		tubularSegments: tubularSegments,
    		arc: arc
    	};

    	this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );

    }

    TorusGeometry.prototype = Object.create( Geometry.prototype );
    TorusGeometry.prototype.constructor = TorusGeometry;

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */

    exports.ShapeUtils = {

    	// calculate area of the contour polygon

    	area: function ( contour ) {

    		var n = contour.length;
    		var a = 0.0;

    		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

    			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

    		}

    		return a * 0.5;

    	},

    	triangulate: ( function () {

    		/**
    		 * This code is a quick port of code written in C++ which was submitted to
    		 * flipcode.com by John W. Ratcliff  // July 22, 2000
    		 * See original code and more information here:
    		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
    		 *
    		 * ported to actionscript by Zevan Rosser
    		 * www.actionsnippet.com
    		 *
    		 * ported to javascript by Joshua Koo
    		 * http://www.lab4games.net/zz85/blog
    		 *
    		 */

    		function snip( contour, u, v, w, n, verts ) {

    			var p;
    			var ax, ay, bx, by;
    			var cx, cy, px, py;

    			ax = contour[ verts[ u ] ].x;
    			ay = contour[ verts[ u ] ].y;

    			bx = contour[ verts[ v ] ].x;
    			by = contour[ verts[ v ] ].y;

    			cx = contour[ verts[ w ] ].x;
    			cy = contour[ verts[ w ] ].y;

    			if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

    			var aX, aY, bX, bY, cX, cY;
    			var apx, apy, bpx, bpy, cpx, cpy;
    			var cCROSSap, bCROSScp, aCROSSbp;

    			aX = cx - bx;  aY = cy - by;
    			bX = ax - cx;  bY = ay - cy;
    			cX = bx - ax;  cY = by - ay;

    			for ( p = 0; p < n; p ++ ) {

    				px = contour[ verts[ p ] ].x;
    				py = contour[ verts[ p ] ].y;

    				if ( ( ( px === ax ) && ( py === ay ) ) ||
    					 ( ( px === bx ) && ( py === by ) ) ||
    					 ( ( px === cx ) && ( py === cy ) ) )	continue;

    				apx = px - ax;  apy = py - ay;
    				bpx = px - bx;  bpy = py - by;
    				cpx = px - cx;  cpy = py - cy;

    				// see if p is inside triangle abc

    				aCROSSbp = aX * bpy - aY * bpx;
    				cCROSSap = cX * apy - cY * apx;
    				bCROSScp = bX * cpy - bY * cpx;

    				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

    			}

    			return true;

    		}

    		// takes in an contour array and returns

    		return function triangulate( contour, indices ) {

    			var n = contour.length;

    			if ( n < 3 ) return null;

    			var result = [],
    				verts = [],
    				vertIndices = [];

    			/* we want a counter-clockwise polygon in verts */

    			var u, v, w;

    			if ( exports.ShapeUtils.area( contour ) > 0.0 ) {

    				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

    			} else {

    				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

    			}

    			var nv = n;

    			/*  remove nv - 2 vertices, creating 1 triangle every time */

    			var count = 2 * nv;   /* error detection */

    			for ( v = nv - 1; nv > 2; ) {

    				/* if we loop, it is probably a non-simple polygon */

    				if ( ( count -- ) <= 0 ) {

    					//** Triangulate: ERROR - probable bad polygon!

    					//throw ( "Warning, unable to triangulate polygon!" );
    					//return null;
    					// Sometimes warning is fine, especially polygons are triangulated in reverse.
    					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

    					if ( indices ) return vertIndices;
    					return result;

    				}

    				/* three consecutive vertices in current polygon, <u,v,w> */

    				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
    				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
    				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

    				if ( snip( contour, u, v, w, nv, verts ) ) {

    					var a, b, c, s, t;

    					/* true names of the vertices */

    					a = verts[ u ];
    					b = verts[ v ];
    					c = verts[ w ];

    					/* output Triangle */

    					result.push( [ contour[ a ],
    						contour[ b ],
    						contour[ c ] ] );


    					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

    					/* remove v from the remaining polygon */

    					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

    						verts[ s ] = verts[ t ];

    					}

    					nv --;

    					/* reset error detection counter */

    					count = 2 * nv;

    				}

    			}

    			if ( indices ) return vertIndices;
    			return result;

    		}

    	} )(),

    	triangulateShape: function ( contour, holes ) {

    		function removeDupEndPts(points) {

    			var l = points.length;

    			if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

    				points.pop();

    			}

    		}

    		removeDupEndPts( contour );
    		holes.forEach( removeDupEndPts );

    		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

    			// inOtherPt needs to be collinear to the inSegment
    			if ( inSegPt1.x !== inSegPt2.x ) {

    				if ( inSegPt1.x < inSegPt2.x ) {

    					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

    				} else {

    					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

    				}

    			} else {

    				if ( inSegPt1.y < inSegPt2.y ) {

    					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

    				} else {

    					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

    				}

    			}

    		}

    		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

    			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
    			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

    			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
    			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

    			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
    			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

    			if ( Math.abs( limit ) > Number.EPSILON ) {

    				// not parallel

    				var perpSeg2;
    				if ( limit > 0 ) {

    					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
    					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
    					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

    				} else {

    					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
    					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
    					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

    				}

    				// i.e. to reduce rounding errors
    				// intersection at endpoint of segment#1?
    				if ( perpSeg2 === 0 ) {

    					if ( ( inExcludeAdjacentSegs ) &&
    						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
    					return [ inSeg1Pt1 ];

    				}
    				if ( perpSeg2 === limit ) {

    					if ( ( inExcludeAdjacentSegs ) &&
    						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
    					return [ inSeg1Pt2 ];

    				}
    				// intersection at endpoint of segment#2?
    				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
    				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

    				// return real intersection point
    				var factorSeg1 = perpSeg2 / limit;
    				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
    							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

    			} else {

    				// parallel or collinear
    				if ( ( perpSeg1 !== 0 ) ||
    					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

    				// they are collinear or degenerate
    				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
    				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
    				// both segments are points
    				if ( seg1Pt && seg2Pt ) {

    					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
    						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
    					return [ inSeg1Pt1 ];                 						// they are the same point

    				}
    				// segment#1  is a single point
    				if ( seg1Pt ) {

    					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
    					return [ inSeg1Pt1 ];

    				}
    				// segment#2  is a single point
    				if ( seg2Pt ) {

    					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
    					return [ inSeg2Pt1 ];

    				}

    				// they are collinear segments, which might overlap
    				var seg1min, seg1max, seg1minVal, seg1maxVal;
    				var seg2min, seg2max, seg2minVal, seg2maxVal;
    				if ( seg1dx !== 0 ) {

    					// the segments are NOT on a vertical line
    					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

    						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
    						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

    					} else {

    						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
    						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

    					}
    					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

    						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
    						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

    					} else {

    						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
    						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

    					}

    				} else {

    					// the segments are on a vertical line
    					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

    						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
    						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

    					} else {

    						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
    						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

    					}
    					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

    						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
    						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

    					} else {

    						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
    						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

    					}

    				}
    				if ( seg1minVal <= seg2minVal ) {

    					if ( seg1maxVal <  seg2minVal )	return [];
    					if ( seg1maxVal === seg2minVal )	{

    						if ( inExcludeAdjacentSegs )		return [];
    						return [ seg2min ];

    					}
    					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
    					return	[ seg2min, seg2max ];

    				} else {

    					if ( seg1minVal >  seg2maxVal )	return [];
    					if ( seg1minVal === seg2maxVal )	{

    						if ( inExcludeAdjacentSegs )		return [];
    						return [ seg1min ];

    					}
    					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
    					return	[ seg1min, seg2max ];

    				}

    			}

    		}

    		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

    			// The order of legs is important

    			// translation of all points, so that Vertex is at (0,0)
    			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
    			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
    			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

    			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
    			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
    			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

    			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

    				// angle != 180 deg.

    				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
    				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

    				if ( from2toAngle > 0 ) {

    					// main angle < 180 deg.
    					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

    				} else {

    					// main angle > 180 deg.
    					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

    				}

    			} else {

    				// angle == 180 deg.
    				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
    				return	( from2otherAngle > 0 );

    			}

    		}


    		function removeHoles( contour, holes ) {

    			var shape = contour.concat(); // work on this shape
    			var hole;

    			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

    				// Check if hole point lies within angle around shape point
    				var lastShapeIdx = shape.length - 1;

    				var prevShapeIdx = inShapeIdx - 1;
    				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

    				var nextShapeIdx = inShapeIdx + 1;
    				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

    				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
    				if ( ! insideAngle ) {

    					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
    					return	false;

    				}

    				// Check if shape point lies within angle around hole point
    				var lastHoleIdx = hole.length - 1;

    				var prevHoleIdx = inHoleIdx - 1;
    				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

    				var nextHoleIdx = inHoleIdx + 1;
    				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

    				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
    				if ( ! insideAngle ) {

    					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
    					return	false;

    				}

    				return	true;

    			}

    			function intersectsShapeEdge( inShapePt, inHolePt ) {

    				// checks for intersections with shape edges
    				var sIdx, nextIdx, intersection;
    				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

    					nextIdx = sIdx + 1; nextIdx %= shape.length;
    					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
    					if ( intersection.length > 0 )		return	true;

    				}

    				return	false;

    			}

    			var indepHoles = [];

    			function intersectsHoleEdge( inShapePt, inHolePt ) {

    				// checks for intersections with hole edges
    				var ihIdx, chkHole,
    					hIdx, nextIdx, intersection;
    				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

    					chkHole = holes[ indepHoles[ ihIdx ]];
    					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

    						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
    						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
    						if ( intersection.length > 0 )		return	true;

    					}

    				}
    				return	false;

    			}

    			var holeIndex, shapeIndex,
    				shapePt, holePt,
    				holeIdx, cutKey, failedCuts = [],
    				tmpShape1, tmpShape2,
    				tmpHole1, tmpHole2;

    			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

    				indepHoles.push( h );

    			}

    			var minShapeIndex = 0;
    			var counter = indepHoles.length * 2;
    			while ( indepHoles.length > 0 ) {

    				counter --;
    				if ( counter < 0 ) {

    					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
    					break;

    				}

    				// search for shape-vertex and hole-vertex,
    				// which can be connected without intersections
    				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

    					shapePt = shape[ shapeIndex ];
    					holeIndex	= - 1;

    					// search for hole which can be reached without intersections
    					for ( var h = 0; h < indepHoles.length; h ++ ) {

    						holeIdx = indepHoles[ h ];

    						// prevent multiple checks
    						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
    						if ( failedCuts[ cutKey ] !== undefined )			continue;

    						hole = holes[ holeIdx ];
    						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

    							holePt = hole[ h2 ];
    							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
    							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
    							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

    							holeIndex = h2;
    							indepHoles.splice( h, 1 );

    							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
    							tmpShape2 = shape.slice( shapeIndex );
    							tmpHole1 = hole.slice( holeIndex );
    							tmpHole2 = hole.slice( 0, holeIndex + 1 );

    							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

    							minShapeIndex = shapeIndex;

    							// Debug only, to show the selected cuts
    							// glob_CutLines.push( [ shapePt, holePt ] );

    							break;

    						}
    						if ( holeIndex >= 0 )	break;		// hole-vertex found

    						failedCuts[ cutKey ] = true;			// remember failure

    					}
    					if ( holeIndex >= 0 )	break;		// hole-vertex found

    				}

    			}

    			return shape; 			/* shape with no holes */

    		}


    		var i, il, f, face,
    			key, index,
    			allPointsMap = {};

    		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

    		var allpoints = contour.concat();

    		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

    			Array.prototype.push.apply( allpoints, holes[ h ] );

    		}

    		//console.log( "allpoints",allpoints, allpoints.length );

    		// prepare all points map

    		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

    			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

    			if ( allPointsMap[ key ] !== undefined ) {

    				console.warn( "THREE.ShapeUtils: Duplicate point", key, i );

    			}

    			allPointsMap[ key ] = i;

    		}

    		// remove holes by cutting paths to holes and adding them to the shape
    		var shapeWithoutHoles = removeHoles( contour, holes );

    		var triangles = exports.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
    		//console.log( "triangles",triangles, triangles.length );

    		// check all face vertices against all points map

    		for ( i = 0, il = triangles.length; i < il; i ++ ) {

    			face = triangles[ i ];

    			for ( f = 0; f < 3; f ++ ) {

    				key = face[ f ].x + ":" + face[ f ].y;

    				index = allPointsMap[ key ];

    				if ( index !== undefined ) {

    					face[ f ] = index;

    				}

    			}

    		}

    		return triangles.concat();

    	},

    	isClockWise: function ( pts ) {

    		return exports.ShapeUtils.area( pts ) < 0;

    	},

    	// Bezier Curves formulas obtained from
    	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

    	// Quad Bezier Functions

    	b2: ( function () {

    		function b2p0( t, p ) {

    			var k = 1 - t;
    			return k * k * p;

    		}

    		function b2p1( t, p ) {

    			return 2 * ( 1 - t ) * t * p;

    		}

    		function b2p2( t, p ) {

    			return t * t * p;

    		}

    		return function b2( t, p0, p1, p2 ) {

    			return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

    		};

    	} )(),

    	// Cubic Bezier Functions

    	b3: ( function () {

    		function b3p0( t, p ) {

    			var k = 1 - t;
    			return k * k * k * p;

    		}

    		function b3p1( t, p ) {

    			var k = 1 - t;
    			return 3 * k * k * t * p;

    		}

    		function b3p2( t, p ) {

    			var k = 1 - t;
    			return 3 * k * t * t * p;

    		}

    		function b3p3( t, p ) {

    			return t * t * t * p;

    		}

    		return function b3( t, p0, p1, p2, p3 ) {

    			return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

    		};

    	} )()

    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     * Creates extruded geometry from a path shape.
     *
     * parameters = {
     *
     *  curveSegments: <int>, // number of points on the curves
     *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
     *  amount: <int>, // Depth to extrude the shape
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into the original shape bevel goes
     *  bevelSize: <float>, // how far from shape outline is bevel
     *  bevelSegments: <int>, // number of bevel layers
     *
     *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
     *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
     *
     *  uvGenerator: <Object> // object that provides UV generator functions
     *
     * }
     **/

    function ExtrudeGeometry( shapes, options ) {

    	if ( typeof( shapes ) === "undefined" ) {

    		shapes = [];
    		return;

    	}

    	Geometry.call( this );

    	this.type = 'ExtrudeGeometry';

    	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

    	this.addShapeList( shapes, options );

    	this.computeFaceNormals();

    	// can't really use automatic vertex normals
    	// as then front and back sides get smoothed too
    	// should do separate smoothing just for sides

    	//this.computeVertexNormals();

    	//console.log( "took", ( Date.now() - startTime ) );

    }

    ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
    ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

    ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

    	var sl = shapes.length;

    	for ( var s = 0; s < sl; s ++ ) {

    		var shape = shapes[ s ];
    		this.addShape( shape, options );

    	}

    };

    ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

    	var amount = options.amount !== undefined ? options.amount : 100;

    	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
    	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
    	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

    	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

    	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    	var steps = options.steps !== undefined ? options.steps : 1;

    	var extrudePath = options.extrudePath;
    	var extrudePts, extrudeByPath = false;

    	// Use default WorldUVGenerator if no UV generators are specified.
    	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

    	var splineTube, binormal, normal, position2;
    	if ( extrudePath ) {

    		extrudePts = extrudePath.getSpacedPoints( steps );

    		extrudeByPath = true;
    		bevelEnabled = false; // bevels not supported for path extrusion

    		// SETUP TNB variables

    		// Reuse TNB from TubeGeomtry for now.
    		// TODO1 - have a .isClosed in spline?

    		splineTube = options.frames !== undefined ? options.frames : new TubeGeometry.FrenetFrames( extrudePath, steps, false );

    		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

    		binormal = new Vector3();
    		normal = new Vector3();
    		position2 = new Vector3();

    	}

    	// Safeguards if bevels are not enabled

    	if ( ! bevelEnabled ) {

    		bevelSegments = 0;
    		bevelThickness = 0;
    		bevelSize = 0;

    	}

    	// Variables initialization

    	var ahole, h, hl; // looping of holes
    	var scope = this;

    	var shapesOffset = this.vertices.length;

    	var shapePoints = shape.extractPoints( curveSegments );

    	var vertices = shapePoints.shape;
    	var holes = shapePoints.holes;

    	var reverse = ! exports.ShapeUtils.isClockWise( vertices );

    	if ( reverse ) {

    		vertices = vertices.reverse();

    		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];

    			if ( exports.ShapeUtils.isClockWise( ahole ) ) {

    				holes[ h ] = ahole.reverse();

    			}

    		}

    		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

    	}


    	var faces = exports.ShapeUtils.triangulateShape( vertices, holes );

    	/* Vertices */

    	var contour = vertices; // vertices has all points but contour has only points of circumference

    	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    		ahole = holes[ h ];

    		vertices = vertices.concat( ahole );

    	}


    	function scalePt2( pt, vec, size ) {

    		if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

    		return vec.clone().multiplyScalar( size ).add( pt );

    	}

    	var b, bs, t, z,
    		vert, vlen = vertices.length,
    		face, flen = faces.length;


    	// Find directions for point movement


    	function getBevelVec( inPt, inPrev, inNext ) {

    		// computes for inPt the corresponding point inPt' on a new contour
    		//   shifted by 1 unit (length of normalized vector) to the left
    		// if we walk along contour clockwise, this new contour is outside the old one
    		//
    		// inPt' is the intersection of the two lines parallel to the two
    		//  adjacent edges of inPt at a distance of 1 unit on the left side.

    		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

    		// good reading for geometry algorithms (here: line-line intersection)
    		// http://geomalgorithms.com/a05-_intersect-1.html

    		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
    		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

    		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

    		// check for collinear edges
    		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

    		if ( Math.abs( collinear0 ) > Number.EPSILON ) {

    			// not collinear

    			// length of vectors for normalizing

    			var v_prev_len = Math.sqrt( v_prev_lensq );
    			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

    			// shift adjacent points by unit vectors to the left

    			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
    			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

    			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
    			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

    			// scaling factor for v_prev to intersection point

    			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
    						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
    					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

    			// vector from inPt to intersection point

    			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
    			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

    			// Don't normalize!, otherwise sharp corners become ugly
    			//  but prevent crazy spikes
    			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
    			if ( v_trans_lensq <= 2 ) {

    				return	new Vector2( v_trans_x, v_trans_y );

    			} else {

    				shrink_by = Math.sqrt( v_trans_lensq / 2 );

    			}

    		} else {

    			// handle special case of collinear edges

    			var direction_eq = false;		// assumes: opposite
    			if ( v_prev_x > Number.EPSILON ) {

    				if ( v_next_x > Number.EPSILON ) {

    					direction_eq = true;

    				}

    			} else {

    				if ( v_prev_x < - Number.EPSILON ) {

    					if ( v_next_x < - Number.EPSILON ) {

    						direction_eq = true;

    					}

    				} else {

    					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

    						direction_eq = true;

    					}

    				}

    			}

    			if ( direction_eq ) {

    				// console.log("Warning: lines are a straight sequence");
    				v_trans_x = - v_prev_y;
    				v_trans_y =  v_prev_x;
    				shrink_by = Math.sqrt( v_prev_lensq );

    			} else {

    				// console.log("Warning: lines are a straight spike");
    				v_trans_x = v_prev_x;
    				v_trans_y = v_prev_y;
    				shrink_by = Math.sqrt( v_prev_lensq / 2 );

    			}

    		}

    		return	new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

    	}


    	var contourMovements = [];

    	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

    		if ( j === il ) j = 0;
    		if ( k === il ) k = 0;

    		//  (j)---(i)---(k)
    		// console.log('i,j,k', i, j , k)

    		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

    	}

    	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

    	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    		ahole = holes[ h ];

    		oneHoleMovements = [];

    		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

    			if ( j === il ) j = 0;
    			if ( k === il ) k = 0;

    			//  (j)---(i)---(k)
    			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

    		}

    		holesMovements.push( oneHoleMovements );
    		verticesMovements = verticesMovements.concat( oneHoleMovements );

    	}


    	// Loop bevelSegments, 1 for the front, 1 for the back

    	for ( b = 0; b < bevelSegments; b ++ ) {

    		//for ( b = bevelSegments; b > 0; b -- ) {

    		t = b / bevelSegments;
    		z = bevelThickness * Math.cos( t * Math.PI / 2 );
    		bs = bevelSize * Math.sin( t * Math.PI / 2 );

    		// contract shape

    		for ( i = 0, il = contour.length; i < il; i ++ ) {

    			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

    			v( vert.x, vert.y,  - z );

    		}

    		// expand holes

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];
    			oneHoleMovements = holesMovements[ h ];

    			for ( i = 0, il = ahole.length; i < il; i ++ ) {

    				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

    				v( vert.x, vert.y,  - z );

    			}

    		}

    	}

    	bs = bevelSize;

    	// Back facing vertices

    	for ( i = 0; i < vlen; i ++ ) {

    		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

    		if ( ! extrudeByPath ) {

    			v( vert.x, vert.y, 0 );

    		} else {

    			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

    			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
    			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

    			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

    			v( position2.x, position2.y, position2.z );

    		}

    	}

    	// Add stepped vertices...
    	// Including front facing vertices

    	var s;

    	for ( s = 1; s <= steps; s ++ ) {

    		for ( i = 0; i < vlen; i ++ ) {

    			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

    			if ( ! extrudeByPath ) {

    				v( vert.x, vert.y, amount / steps * s );

    			} else {

    				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

    				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
    				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

    				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

    				v( position2.x, position2.y, position2.z );

    			}

    		}

    	}


    	// Add bevel segments planes

    	//for ( b = 1; b <= bevelSegments; b ++ ) {
    	for ( b = bevelSegments - 1; b >= 0; b -- ) {

    		t = b / bevelSegments;
    		z = bevelThickness * Math.cos ( t * Math.PI / 2 );
    		bs = bevelSize * Math.sin( t * Math.PI / 2 );

    		// contract shape

    		for ( i = 0, il = contour.length; i < il; i ++ ) {

    			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
    			v( vert.x, vert.y,  amount + z );

    		}

    		// expand holes

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];
    			oneHoleMovements = holesMovements[ h ];

    			for ( i = 0, il = ahole.length; i < il; i ++ ) {

    				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

    				if ( ! extrudeByPath ) {

    					v( vert.x, vert.y,  amount + z );

    				} else {

    					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

    				}

    			}

    		}

    	}

    	/* Faces */

    	// Top and bottom faces

    	buildLidFaces();

    	// Sides faces

    	buildSideFaces();


    	/////  Internal functions

    	function buildLidFaces() {

    		if ( bevelEnabled ) {

    			var layer = 0; // steps + 1
    			var offset = vlen * layer;

    			// Bottom faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

    			}

    			layer = steps + bevelSegments * 2;
    			offset = vlen * layer;

    			// Top faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

    			}

    		} else {

    			// Bottom faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

    			}

    			// Top faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

    			}

    		}

    	}

    	// Create faces for the z-sides of the shape

    	function buildSideFaces() {

    		var layeroffset = 0;
    		sidewalls( contour, layeroffset );
    		layeroffset += contour.length;

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];
    			sidewalls( ahole, layeroffset );

    			//, true
    			layeroffset += ahole.length;

    		}

    	}

    	function sidewalls( contour, layeroffset ) {

    		var j, k;
    		i = contour.length;

    		while ( -- i >= 0 ) {

    			j = i;
    			k = i - 1;
    			if ( k < 0 ) k = contour.length - 1;

    			//console.log('b', i,j, i-1, k,vertices.length);

    			var s = 0, sl = steps  + bevelSegments * 2;

    			for ( s = 0; s < sl; s ++ ) {

    				var slen1 = vlen * s;
    				var slen2 = vlen * ( s + 1 );

    				var a = layeroffset + j + slen1,
    					b = layeroffset + k + slen1,
    					c = layeroffset + k + slen2,
    					d = layeroffset + j + slen2;

    				f4( a, b, c, d, contour, s, sl, j, k );

    			}

    		}

    	}


    	function v( x, y, z ) {

    		scope.vertices.push( new Vector3( x, y, z ) );

    	}

    	function f3( a, b, c ) {

    		a += shapesOffset;
    		b += shapesOffset;
    		c += shapesOffset;

    		scope.faces.push( new Face3( a, b, c, null, null, 0 ) );

    		var uvs = uvgen.generateTopUV( scope, a, b, c );

    		scope.faceVertexUvs[ 0 ].push( uvs );

    	}

    	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

    		a += shapesOffset;
    		b += shapesOffset;
    		c += shapesOffset;
    		d += shapesOffset;

    		scope.faces.push( new Face3( a, b, d, null, null, 1 ) );
    		scope.faces.push( new Face3( b, c, d, null, null, 1 ) );

    		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

    		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
    		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

    	}

    };

    ExtrudeGeometry.WorldUVGenerator = {

    	generateTopUV: function ( geometry, indexA, indexB, indexC ) {

    		var vertices = geometry.vertices;

    		var a = vertices[ indexA ];
    		var b = vertices[ indexB ];
    		var c = vertices[ indexC ];

    		return [
    			new Vector2( a.x, a.y ),
    			new Vector2( b.x, b.y ),
    			new Vector2( c.x, c.y )
    		];

    	},

    	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

    		var vertices = geometry.vertices;

    		var a = vertices[ indexA ];
    		var b = vertices[ indexB ];
    		var c = vertices[ indexC ];
    		var d = vertices[ indexD ];

    		if ( Math.abs( a.y - b.y ) < 0.01 ) {

    			return [
    				new Vector2( a.x, 1 - a.z ),
    				new Vector2( b.x, 1 - b.z ),
    				new Vector2( c.x, 1 - c.z ),
    				new Vector2( d.x, 1 - d.z )
    			];

    		} else {

    			return [
    				new Vector2( a.y, 1 - a.z ),
    				new Vector2( b.y, 1 - b.z ),
    				new Vector2( c.y, 1 - c.z ),
    				new Vector2( d.y, 1 - d.z )
    			];

    		}

    	}
    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author alteredq / http://alteredqualia.com/
     *
     * Text = 3D Text
     *
     * parameters = {
     *  font: <THREE.Font>, // font
     *
     *  size: <float>, // size of the text
     *  height: <float>, // thickness to extrude text
     *  curveSegments: <int>, // number of points on the curves
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into text bevel goes
     *  bevelSize: <float> // how far from text outline is bevel
     * }
     */

    function TextGeometry( text, parameters ) {

    	parameters = parameters || {};

    	var font = parameters.font;

    	if ( (font && font.isFont) === false ) {

    		console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
    		return new Geometry();

    	}

    	var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

    	// translate parameters to ExtrudeGeometry API

    	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

    	// defaults

    	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
    	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
    	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

    	ExtrudeGeometry.call( this, shapes, parameters );

    	this.type = 'TextGeometry';

    }

    TextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );
    TextGeometry.prototype.constructor = TextGeometry;

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     * based on THREE.SphereGeometry
     */

    function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'SphereBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		phiStart: phiStart,
    		phiLength: phiLength,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	radius = radius || 50;

    	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
    	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

    	phiStart = phiStart !== undefined ? phiStart : 0;
    	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

    	thetaStart = thetaStart !== undefined ? thetaStart : 0;
    	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

    	var thetaEnd = thetaStart + thetaLength;

    	var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

    	var positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	var index = 0, vertices = [], normal = new Vector3();

    	for ( var y = 0; y <= heightSegments; y ++ ) {

    		var verticesRow = [];

    		var v = y / heightSegments;

    		for ( var x = 0; x <= widthSegments; x ++ ) {

    			var u = x / widthSegments;

    			var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
    			var py = radius * Math.cos( thetaStart + v * thetaLength );
    			var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

    			normal.set( px, py, pz ).normalize();

    			positions.setXYZ( index, px, py, pz );
    			normals.setXYZ( index, normal.x, normal.y, normal.z );
    			uvs.setXY( index, u, 1 - v );

    			verticesRow.push( index );

    			index ++;

    		}

    		vertices.push( verticesRow );

    	}

    	var indices = [];

    	for ( var y = 0; y < heightSegments; y ++ ) {

    		for ( var x = 0; x < widthSegments; x ++ ) {

    			var v1 = vertices[ y ][ x + 1 ];
    			var v2 = vertices[ y ][ x ];
    			var v3 = vertices[ y + 1 ][ x ];
    			var v4 = vertices[ y + 1 ][ x + 1 ];

    			if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
    			if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

    		}

    	}

    	this.setIndex( new ( positions.count > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );
    	this.addAttribute( 'position', positions );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    	this.boundingSphere = new Sphere( new Vector3(), radius );

    }

    SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'SphereGeometry';

    	this.parameters = {
    		radius: radius,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		phiStart: phiStart,
    		phiLength: phiLength,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

    }

    SphereGeometry.prototype = Object.create( Geometry.prototype );
    SphereGeometry.prototype.constructor = SphereGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'RingBufferGeometry';

    	this.parameters = {
    		innerRadius: innerRadius,
    		outerRadius: outerRadius,
    		thetaSegments: thetaSegments,
    		phiSegments: phiSegments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	innerRadius = innerRadius || 20;
    	outerRadius = outerRadius || 50;

    	thetaStart = thetaStart !== undefined ? thetaStart : 0;
    	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
    	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

    	// these are used to calculate buffer length
    	var vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );
    	var indexCount = thetaSegments * phiSegments * 2 * 3;

    	// buffers
    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// some helper variables
    	var index = 0, indexOffset = 0, segment;
    	var radius = innerRadius;
    	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
    	var vertex = new Vector3();
    	var uv = new Vector2();
    	var j, i;

    	// generate vertices, normals and uvs

    	// values are generate from the inside of the ring to the outside

    	for ( j = 0; j <= phiSegments; j ++ ) {

    		for ( i = 0; i <= thetaSegments; i ++ ) {

    			segment = thetaStart + i / thetaSegments * thetaLength;

    			// vertex
    			vertex.x = radius * Math.cos( segment );
    			vertex.y = radius * Math.sin( segment );
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// normal
    			normals.setXYZ( index, 0, 0, 1 );

    			// uv
    			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
    			uv.y = ( vertex.y / outerRadius + 1 ) / 2;
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index++;

    		}

    		// increase the radius for next row of vertices
    		radius += radiusStep;

    	}

    	// generate indices

    	for ( j = 0; j < phiSegments; j ++ ) {

    		var thetaSegmentLevel = j * ( thetaSegments + 1 );

    		for ( i = 0; i < thetaSegments; i ++ ) {

    			segment = i + thetaSegmentLevel;

    			// indices
    			var a = segment;
    			var b = segment + thetaSegments + 1;
    			var c = segment + thetaSegments + 2;
    			var d = segment + 1;

    			// face one
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;

    			// face two
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    		}

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    }

    RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    RingBufferGeometry.prototype.constructor = RingBufferGeometry;

    /**
     * @author Kaleb Murphy
     */

    function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'RingGeometry';

    	this.parameters = {
    		innerRadius: innerRadius,
    		outerRadius: outerRadius,
    		thetaSegments: thetaSegments,
    		phiSegments: phiSegments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );

    }

    RingGeometry.prototype = Object.create( Geometry.prototype );
    RingGeometry.prototype.constructor = RingGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
     */

    function PlaneGeometry( width, height, widthSegments, heightSegments ) {

    	Geometry.call( this );

    	this.type = 'PlaneGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments
    	};

    	this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

    }

    PlaneGeometry.prototype = Object.create( Geometry.prototype );
    PlaneGeometry.prototype.constructor = PlaneGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

     // points - to create a closed torus, one must use a set of points
     //    like so: [ a, b, c, d, a ], see first is the same as last.
     // segments - the number of circumference segments to create
     // phiStart - the starting radian
     // phiLength - the radian (0 to 2PI) range of the lathed section
     //    2PI is a closed lathe, less than 2PI is a portion.

    function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

    	BufferGeometry.call( this );

    	this.type = 'LatheBufferGeometry';

    	this.parameters = {
    		points: points,
    		segments: segments,
    		phiStart: phiStart,
    		phiLength: phiLength
    	};

    	segments = Math.floor( segments ) || 12;
    	phiStart = phiStart || 0;
    	phiLength = phiLength || Math.PI * 2;

    	// clamp phiLength so it's in range of [ 0, 2PI ]
    	phiLength = exports.Math.clamp( phiLength, 0, Math.PI * 2 );

    	// these are used to calculate buffer length
    	var vertexCount = ( segments + 1 ) * points.length;
    	var indexCount = segments * points.length * 2 * 3;

    	// buffers
    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// helper variables
    	var index = 0, indexOffset = 0, base;
    	var inverseSegments = 1.0 / segments;
    	var vertex = new Vector3();
    	var uv = new Vector2();
    	var i, j;

    	// generate vertices and uvs

    	for ( i = 0; i <= segments; i ++ ) {

    		var phi = phiStart + i * inverseSegments * phiLength;

    		var sin = Math.sin( phi );
    		var cos = Math.cos( phi );

    		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

    			// vertex
    			vertex.x = points[ j ].x * sin;
    			vertex.y = points[ j ].y;
    			vertex.z = points[ j ].x * cos;
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// uv
    			uv.x = i / segments;
    			uv.y = j / ( points.length - 1 );
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    	}

    	// generate indices

    	for ( i = 0; i < segments; i ++ ) {

    		for ( j = 0; j < ( points.length - 1 ); j ++ ) {

    			base = j + i * points.length;

    			// indices
    			var a = base;
    			var b = base + points.length;
    			var c = base + points.length + 1;
    			var d = base + 1;

    			// face one
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    			// face two
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    		}

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'uv', uvs );

    	// generate normals

    	this.computeVertexNormals();

    	// if the geometry is closed, we need to average the normals along the seam.
    	// because the corresponding vertices are identical (but still have different UVs).

    	if( phiLength === Math.PI * 2 ) {

    		var normals = this.attributes.normal.array;
    		var n1 = new Vector3();
    		var n2 = new Vector3();
    		var n = new Vector3();

    		// this is the buffer offset for the last line of vertices
    		base = segments * points.length * 3;

    		for( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

    			// select the normal of the vertex in the first line
    			n1.x = normals[ j + 0 ];
    			n1.y = normals[ j + 1 ];
    			n1.z = normals[ j + 2 ];

    			// select the normal of the vertex in the last line
    			n2.x = normals[ base + j + 0 ];
    			n2.y = normals[ base + j + 1 ];
    			n2.z = normals[ base + j + 2 ];

    			// average normals
    			n.addVectors( n1, n2 ).normalize();

    			// assign the new values to both normals
    			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
    			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
    			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

    		} // next row

    	}

    }

    LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

    /**
     * @author astrodud / http://astrodud.isgreat.org/
     * @author zz85 / https://github.com/zz85
     * @author bhouston / http://clara.io
     */

    // points - to create a closed torus, one must use a set of points
    //    like so: [ a, b, c, d, a ], see first is the same as last.
    // segments - the number of circumference segments to create
    // phiStart - the starting radian
    // phiLength - the radian (0 to 2PI) range of the lathed section
    //    2PI is a closed lathe, less than 2PI is a portion.

    function LatheGeometry( points, segments, phiStart, phiLength ) {

    	Geometry.call( this );

    	this.type = 'LatheGeometry';

    	this.parameters = {
    		points: points,
    		segments: segments,
    		phiStart: phiStart,
    		phiLength: phiLength
    	};

    	this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
    	this.mergeVertices();

    }

    LatheGeometry.prototype = Object.create( Geometry.prototype );
    LatheGeometry.prototype.constructor = LatheGeometry;

    /**
     * @author jonobr1 / http://jonobr1.com
     *
     * Creates a one-sided polygonal geometry from a path shape. Similar to
     * ExtrudeGeometry.
     *
     * parameters = {
     *
     *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
     *
     *	material: <int> // material index for front and back faces
     *	uvGenerator: <Object> // object that provides UV generator functions
     *
     * }
     **/

    function ShapeGeometry( shapes, options ) {

    	Geometry.call( this );

    	this.type = 'ShapeGeometry';

    	if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

    	this.addShapeList( shapes, options );

    	this.computeFaceNormals();

    }

    ShapeGeometry.prototype = Object.create( Geometry.prototype );
    ShapeGeometry.prototype.constructor = ShapeGeometry;

    /**
     * Add an array of shapes to THREE.ShapeGeometry.
     */
    ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

    	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

    		this.addShape( shapes[ i ], options );

    	}

    	return this;

    };

    /**
     * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
     */
    ShapeGeometry.prototype.addShape = function ( shape, options ) {

    	if ( options === undefined ) options = {};
    	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    	var material = options.material;
    	var uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

    	//

    	var i, l, hole;

    	var shapesOffset = this.vertices.length;
    	var shapePoints = shape.extractPoints( curveSegments );

    	var vertices = shapePoints.shape;
    	var holes = shapePoints.holes;

    	var reverse = ! exports.ShapeUtils.isClockWise( vertices );

    	if ( reverse ) {

    		vertices = vertices.reverse();

    		// Maybe we should also check if holes are in the opposite direction, just to be safe...

    		for ( i = 0, l = holes.length; i < l; i ++ ) {

    			hole = holes[ i ];

    			if ( exports.ShapeUtils.isClockWise( hole ) ) {

    				holes[ i ] = hole.reverse();

    			}

    		}

    		reverse = false;

    	}

    	var faces = exports.ShapeUtils.triangulateShape( vertices, holes );

    	// Vertices

    	for ( i = 0, l = holes.length; i < l; i ++ ) {

    		hole = holes[ i ];
    		vertices = vertices.concat( hole );

    	}

    	//

    	var vert, vlen = vertices.length;
    	var face, flen = faces.length;

    	for ( i = 0; i < vlen; i ++ ) {

    		vert = vertices[ i ];

    		this.vertices.push( new Vector3( vert.x, vert.y, 0 ) );

    	}

    	for ( i = 0; i < flen; i ++ ) {

    		face = faces[ i ];

    		var a = face[ 0 ] + shapesOffset;
    		var b = face[ 1 ] + shapesOffset;
    		var c = face[ 2 ] + shapesOffset;

    		this.faces.push( new Face3( a, b, c, null, null, material ) );
    		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

    	}

    };

    /**
     * @author WestLangley / http://github.com/WestLangley
     */

    function EdgesGeometry( geometry, thresholdAngle ) {

    	BufferGeometry.call( this );

    	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

    	var thresholdDot = Math.cos( exports.Math.DEG2RAD * thresholdAngle );

    	var edge = [ 0, 0 ], hash = {};

    	function sortFunction( a, b ) {

    		return a - b;

    	}

    	var keys = [ 'a', 'b', 'c' ];

    	var geometry2;

    	if ( (geometry && geometry.isBufferGeometry) ) {

    		geometry2 = new Geometry();
    		geometry2.fromBufferGeometry( geometry );

    	} else {

    		geometry2 = geometry.clone();

    	}

    	geometry2.mergeVertices();
    	geometry2.computeFaceNormals();

    	var vertices = geometry2.vertices;
    	var faces = geometry2.faces;

    	for ( var i = 0, l = faces.length; i < l; i ++ ) {

    		var face = faces[ i ];

    		for ( var j = 0; j < 3; j ++ ) {

    			edge[ 0 ] = face[ keys[ j ] ];
    			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
    			edge.sort( sortFunction );

    			var key = edge.toString();

    			if ( hash[ key ] === undefined ) {

    				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

    			} else {

    				hash[ key ].face2 = i;

    			}

    		}

    	}

    	var coords = [];

    	for ( var key in hash ) {

    		var h = hash[ key ];

    		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

    			var vertex = vertices[ h.vert1 ];
    			coords.push( vertex.x );
    			coords.push( vertex.y );
    			coords.push( vertex.z );

    			vertex = vertices[ h.vert2 ];
    			coords.push( vertex.x );
    			coords.push( vertex.y );
    			coords.push( vertex.z );

    		}

    	}

    	this.addAttribute( 'position', new BufferAttribute( new Float32Array( coords ), 3 ) );

    }

    EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
    EdgesGeometry.prototype.constructor = EdgesGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'CylinderBufferGeometry';

    	this.parameters = {
    		radiusTop: radiusTop,
    		radiusBottom: radiusBottom,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		openEnded: openEnded,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	var scope = this;

    	radiusTop = radiusTop !== undefined ? radiusTop : 20;
    	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
    	height = height !== undefined ? height : 100;

    	radialSegments = Math.floor( radialSegments ) || 8;
    	heightSegments = Math.floor( heightSegments ) || 1;

    	openEnded = openEnded !== undefined ? openEnded : false;
    	thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
    	thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

    	// used to calculate buffer length

    	var nbCap = 0;

    	if ( openEnded === false ) {

    		if ( radiusTop > 0 ) nbCap ++;
    		if ( radiusBottom > 0 ) nbCap ++;

    	}

    	var vertexCount = calculateVertexCount();
    	var indexCount = calculateIndexCount();

    	// buffers

    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// helper variables

    	var index = 0,
    	    indexOffset = 0,
    	    indexArray = [],
    	    halfHeight = height / 2;

    	// group variables
    	var groupStart = 0;

    	// generate geometry

    	generateTorso();

    	if ( openEnded === false ) {

    		if ( radiusTop > 0 ) generateCap( true );
    		if ( radiusBottom > 0 ) generateCap( false );

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    	// helper functions

    	function calculateVertexCount() {

    		var count = ( radialSegments + 1 ) * ( heightSegments + 1 );

    		if ( openEnded === false ) {

    			count += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );

    		}

    		return count;

    	}

    	function calculateIndexCount() {

    		var count = radialSegments * heightSegments * 2 * 3;

    		if ( openEnded === false ) {

    			count += radialSegments * nbCap * 3;

    		}

    		return count;

    	}

    	function generateTorso() {

    		var x, y;
    		var normal = new Vector3();
    		var vertex = new Vector3();

    		var groupCount = 0;

    		// this will be used to calculate the normal
    		var slope = ( radiusBottom - radiusTop ) / height;

    		// generate vertices, normals and uvs

    		for ( y = 0; y <= heightSegments; y ++ ) {

    			var indexRow = [];

    			var v = y / heightSegments;

    			// calculate the radius of the current row
    			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

    			for ( x = 0; x <= radialSegments; x ++ ) {

    				var u = x / radialSegments;

    				var theta = u * thetaLength + thetaStart;

    				var sinTheta = Math.sin( theta );
    				var cosTheta = Math.cos( theta );

    				// vertex
    				vertex.x = radius * sinTheta;
    				vertex.y = - v * height + halfHeight;
    				vertex.z = radius * cosTheta;
    				vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    				// normal
    				normal.set( sinTheta, slope, cosTheta ).normalize();
    				normals.setXYZ( index, normal.x, normal.y, normal.z );

    				// uv
    				uvs.setXY( index, u, 1 - v );

    				// save index of vertex in respective row
    				indexRow.push( index );

    				// increase index
    				index ++;

    			}

    			// now save vertices of the row in our index array
    			indexArray.push( indexRow );

    		}

    		// generate indices

    		for ( x = 0; x < radialSegments; x ++ ) {

    			for ( y = 0; y < heightSegments; y ++ ) {

    				// we use the index array to access the correct indices
    				var i1 = indexArray[ y ][ x ];
    				var i2 = indexArray[ y + 1 ][ x ];
    				var i3 = indexArray[ y + 1 ][ x + 1 ];
    				var i4 = indexArray[ y ][ x + 1 ];

    				// face one
    				indices.setX( indexOffset, i1 ); indexOffset ++;
    				indices.setX( indexOffset, i2 ); indexOffset ++;
    				indices.setX( indexOffset, i4 ); indexOffset ++;

    				// face two
    				indices.setX( indexOffset, i2 ); indexOffset ++;
    				indices.setX( indexOffset, i3 ); indexOffset ++;
    				indices.setX( indexOffset, i4 ); indexOffset ++;

    				// update counters
    				groupCount += 6;

    			}

    		}

    		// add a group to the geometry. this will ensure multi material support
    		scope.addGroup( groupStart, groupCount, 0 );

    		// calculate new start value for groups
    		groupStart += groupCount;

    	}

    	function generateCap( top ) {

    		var x, centerIndexStart, centerIndexEnd;

    		var uv = new Vector2();
    		var vertex = new Vector3();

    		var groupCount = 0;

    		var radius = ( top === true ) ? radiusTop : radiusBottom;
    		var sign = ( top === true ) ? 1 : - 1;

    		// save the index of the first center vertex
    		centerIndexStart = index;

    		// first we generate the center vertex data of the cap.
    		// because the geometry needs one set of uvs per face,
    		// we must generate a center vertex per face/segment

    		for ( x = 1; x <= radialSegments; x ++ ) {

    			// vertex
    			vertices.setXYZ( index, 0, halfHeight * sign, 0 );

    			// normal
    			normals.setXYZ( index, 0, sign, 0 );

    			// uv
    			uv.x = 0.5;
    			uv.y = 0.5;

    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    		// save the index of the last center vertex
    		centerIndexEnd = index;

    		// now we generate the surrounding vertices, normals and uvs

    		for ( x = 0; x <= radialSegments; x ++ ) {

    			var u = x / radialSegments;
    			var theta = u * thetaLength + thetaStart;

    			var cosTheta = Math.cos( theta );
    			var sinTheta = Math.sin( theta );

    			// vertex
    			vertex.x = radius * sinTheta;
    			vertex.y = halfHeight * sign;
    			vertex.z = radius * cosTheta;
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// normal
    			normals.setXYZ( index, 0, sign, 0 );

    			// uv
    			uv.x = ( cosTheta * 0.5 ) + 0.5;
    			uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    		// generate indices

    		for ( x = 0; x < radialSegments; x ++ ) {

    			var c = centerIndexStart + x;
    			var i = centerIndexEnd + x;

    			if ( top === true ) {

    				// face top
    				indices.setX( indexOffset, i ); indexOffset ++;
    				indices.setX( indexOffset, i + 1 ); indexOffset ++;
    				indices.setX( indexOffset, c ); indexOffset ++;

    			} else {

    				// face bottom
    				indices.setX( indexOffset, i + 1 ); indexOffset ++;
    				indices.setX( indexOffset, i ); indexOffset ++;
    				indices.setX( indexOffset, c ); indexOffset ++;

    			}

    			// update counters
    			groupCount += 3;

    		}

    		// add a group to the geometry. this will ensure multi material support
    		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

    		// calculate new start value for groups
    		groupStart += groupCount;

    	}

    }

    CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'CylinderGeometry';

    	this.parameters = {
    		radiusTop: radiusTop,
    		radiusBottom: radiusBottom,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		openEnded: openEnded,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
    	this.mergeVertices();

    }

    CylinderGeometry.prototype = Object.create( Geometry.prototype );
    CylinderGeometry.prototype.constructor = CylinderGeometry;

    /**
     * @author abelnation / http://github.com/abelnation
     */

    function ConeGeometry(
    	radius, height,
    	radialSegments, heightSegments,
    	openEnded, thetaStart, thetaLength ) {

    	CylinderGeometry.call( this,
    		0, radius, height,
    		radialSegments, heightSegments,
    		openEnded, thetaStart, thetaLength );

    	this.type = 'ConeGeometry';

    	this.parameters = {
    		radius: radius,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		openEnded: openEnded,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    }

    ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
    ConeGeometry.prototype.constructor = ConeGeometry;

    /*
     * @author: abelnation / http://github.com/abelnation
     */

    function ConeBufferGeometry(
    	radius, height,
    	radialSegments, heightSegments,
    	openEnded, thetaStart, thetaLength ) {

    	CylinderBufferGeometry.call( this,
    		0, radius, height,
    		radialSegments, heightSegments,
    		openEnded, thetaStart, thetaLength );

    	this.type = 'ConeBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    }

    ConeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'CircleBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		segments: segments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	radius = radius || 50;
    	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

    	thetaStart = thetaStart !== undefined ? thetaStart : 0;
    	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    	var vertices = segments + 2;

    	var positions = new Float32Array( vertices * 3 );
    	var normals = new Float32Array( vertices * 3 );
    	var uvs = new Float32Array( vertices * 2 );

    	// center data is already zero, but need to set a few extras
    	normals[ 2 ] = 1.0;
    	uvs[ 0 ] = 0.5;
    	uvs[ 1 ] = 0.5;

    	for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

    		var segment = thetaStart + s / segments * thetaLength;

    		positions[ i ] = radius * Math.cos( segment );
    		positions[ i + 1 ] = radius * Math.sin( segment );

    		normals[ i + 2 ] = 1; // normal z

    		uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
    		uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

    	}

    	var indices = [];

    	for ( var i = 1; i <= segments; i ++ ) {

    		indices.push( i, i + 1, 0 );

    	}

    	this.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    	this.boundingSphere = new Sphere( new Vector3(), radius );

    }

    CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;

    /**
     * @author hughes
     */

    function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'CircleGeometry';

    	this.parameters = {
    		radius: radius,
    		segments: segments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

    }

    CircleGeometry.prototype = Object.create( Geometry.prototype );
    CircleGeometry.prototype.constructor = CircleGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
     */

    function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

    	Geometry.call( this );

    	this.type = 'BoxGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		depth: depth,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		depthSegments: depthSegments
    	};

    	this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
    	this.mergeVertices();

    }

    BoxGeometry.prototype = Object.create( Geometry.prototype );
    BoxGeometry.prototype.constructor = BoxGeometry;



    var Geometries = Object.freeze({
    	WireframeGeometry: WireframeGeometry,
    	ParametricGeometry: ParametricGeometry,
    	TetrahedronGeometry: TetrahedronGeometry,
    	OctahedronGeometry: OctahedronGeometry,
    	IcosahedronGeometry: IcosahedronGeometry,
    	DodecahedronGeometry: DodecahedronGeometry,
    	PolyhedronGeometry: PolyhedronGeometry,
    	TubeGeometry: TubeGeometry,
    	TorusKnotGeometry: TorusKnotGeometry,
    	TorusKnotBufferGeometry: TorusKnotBufferGeometry,
    	TorusGeometry: TorusGeometry,
    	TorusBufferGeometry: TorusBufferGeometry,
    	TextGeometry: TextGeometry,
    	SphereBufferGeometry: SphereBufferGeometry,
    	SphereGeometry: SphereGeometry,
    	RingGeometry: RingGeometry,
    	RingBufferGeometry: RingBufferGeometry,
    	PlaneBufferGeometry: PlaneBufferGeometry,
    	PlaneGeometry: PlaneGeometry,
    	LatheGeometry: LatheGeometry,
    	LatheBufferGeometry: LatheBufferGeometry,
    	ShapeGeometry: ShapeGeometry,
    	ExtrudeGeometry: ExtrudeGeometry,
    	EdgesGeometry: EdgesGeometry,
    	ConeGeometry: ConeGeometry,
    	ConeBufferGeometry: ConeBufferGeometry,
    	CylinderGeometry: CylinderGeometry,
    	CylinderBufferGeometry: CylinderBufferGeometry,
    	CircleBufferGeometry: CircleBufferGeometry,
    	CircleGeometry: CircleGeometry,
    	BoxBufferGeometry: BoxBufferGeometry,
    	BoxGeometry: BoxGeometry
    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function ShadowMaterial() {

    	ShaderMaterial.call( this, {
    		uniforms: exports.UniformsUtils.merge( [
    			UniformsLib[ "lights" ],
    			{
    				opacity: { value: 1.0 }
    			}
    		] ),
    		vertexShader: ShaderChunk[ 'shadow_vert' ],
    		fragmentShader: ShaderChunk[ 'shadow_frag' ]
    	} );

    	this.lights = true;
    	this.transparent = true;

    	Object.defineProperties( this, {
    		opacity: {
    			enumerable: true,
    			get: function () {
    				return this.uniforms.opacity.value;
    			},
    			set: function ( value ) {
    				this.uniforms.opacity.value = value;
    			}
    		}
    	} );

    }

    ShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );
    ShadowMaterial.prototype.constructor = ShadowMaterial;

    ShadowMaterial.prototype.isShadowMaterial = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function RawShaderMaterial( parameters ) {

    	ShaderMaterial.call( this, parameters );

    	this.type = 'RawShaderMaterial';

    }

    RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
    RawShaderMaterial.prototype.constructor = RawShaderMaterial;

    RawShaderMaterial.prototype.isRawShaderMaterial = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function MultiMaterial( materials ) {

    	this.uuid = exports.Math.generateUUID();

    	this.type = 'MultiMaterial';

    	this.materials = materials instanceof Array ? materials : [];

    	this.visible = true;

    }

    MultiMaterial.prototype = {

    	constructor: MultiMaterial,

    	isMultiMaterial: true,

    	toJSON: function ( meta ) {

    		var output = {
    			metadata: {
    				version: 4.2,
    				type: 'material',
    				generator: 'MaterialExporter'
    			},
    			uuid: this.uuid,
    			type: this.type,
    			materials: []
    		};

    		var materials = this.materials;

    		for ( var i = 0, l = materials.length; i < l; i ++ ) {

    			var material = materials[ i ].toJSON( meta );
    			delete material.metadata;

    			output.materials.push( material );

    		}

    		output.visible = this.visible;

    		return output;

    	},

    	clone: function () {

    		var material = new this.constructor();

    		for ( var i = 0; i < this.materials.length; i ++ ) {

    			material.materials.push( this.materials[ i ].clone() );

    		}

    		material.visible = this.visible;

    		return material;

    	}

    };

    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  color: <hex>,
     *  roughness: <float>,
     *  metalness: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  roughnessMap: new THREE.Texture( <Image> ),
     *
     *  metalnessMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
     *  envMapIntensity: <float>
     *
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshStandardMaterial( parameters ) {

    	Material.call( this );

    	this.defines = { 'STANDARD': '' };

    	this.type = 'MeshStandardMaterial';

    	this.color = new Color( 0xffffff ); // diffuse
    	this.roughness = 0.5;
    	this.metalness = 0.5;

    	this.map = null;

    	this.lightMap = null;
    	this.lightMapIntensity = 1.0;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.emissive = new Color( 0x000000 );
    	this.emissiveIntensity = 1.0;
    	this.emissiveMap = null;

    	this.bumpMap = null;
    	this.bumpScale = 1;

    	this.normalMap = null;
    	this.normalScale = new Vector2( 1, 1 );

    	this.displacementMap = null;
    	this.displacementScale = 1;
    	this.displacementBias = 0;

    	this.roughnessMap = null;

    	this.metalnessMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.envMapIntensity = 1.0;

    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;
    	this.morphNormals = false;

    	this.setValues( parameters );

    }

    MeshStandardMaterial.prototype = Object.create( Material.prototype );
    MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

    MeshStandardMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.defines = { 'STANDARD': '' };

    	this.color.copy( source.color );
    	this.roughness = source.roughness;
    	this.metalness = source.metalness;

    	this.map = source.map;

    	this.lightMap = source.lightMap;
    	this.lightMapIntensity = source.lightMapIntensity;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.emissive.copy( source.emissive );
    	this.emissiveMap = source.emissiveMap;
    	this.emissiveIntensity = source.emissiveIntensity;

    	this.bumpMap = source.bumpMap;
    	this.bumpScale = source.bumpScale;

    	this.normalMap = source.normalMap;
    	this.normalScale.copy( source.normalScale );

    	this.displacementMap = source.displacementMap;
    	this.displacementScale = source.displacementScale;
    	this.displacementBias = source.displacementBias;

    	this.roughnessMap = source.roughnessMap;

    	this.metalnessMap = source.metalnessMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.envMapIntensity = source.envMapIntensity;

    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	return this;

    };

    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  reflectivity: <float>
     * }
     */

    function MeshPhysicalMaterial( parameters ) {

    	MeshStandardMaterial.call( this );

    	this.defines = { 'PHYSICAL': '' };

    	this.type = 'MeshPhysicalMaterial';

    	this.reflectivity = 0.5; // maps to F0 = 0.04

    	this.clearCoat = 0.0;
    	this.clearCoatRoughness = 0.0;

    	this.setValues( parameters );

    }

    MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
    MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

    MeshPhysicalMaterial.prototype.copy = function ( source ) {

    	MeshStandardMaterial.prototype.copy.call( this, source );

    	this.defines = { 'PHYSICAL': '' };

    	this.reflectivity = source.reflectivity;

    	this.clearCoat = source.clearCoat;
    	this.clearCoatRoughness = source.clearCoatRoughness;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  specular: <hex>,
     *  shininess: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshPhongMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshPhongMaterial';

    	this.color = new Color( 0xffffff ); // diffuse
    	this.specular = new Color( 0x111111 );
    	this.shininess = 30;

    	this.map = null;

    	this.lightMap = null;
    	this.lightMapIntensity = 1.0;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.emissive = new Color( 0x000000 );
    	this.emissiveIntensity = 1.0;
    	this.emissiveMap = null;

    	this.bumpMap = null;
    	this.bumpScale = 1;

    	this.normalMap = null;
    	this.normalScale = new Vector2( 1, 1 );

    	this.displacementMap = null;
    	this.displacementScale = 1;
    	this.displacementBias = 0;

    	this.specularMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.combine = MultiplyOperation;
    	this.reflectivity = 1;
    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;
    	this.morphNormals = false;

    	this.setValues( parameters );

    }

    MeshPhongMaterial.prototype = Object.create( Material.prototype );
    MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

    MeshPhongMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );
    	this.specular.copy( source.specular );
    	this.shininess = source.shininess;

    	this.map = source.map;

    	this.lightMap = source.lightMap;
    	this.lightMapIntensity = source.lightMapIntensity;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.emissive.copy( source.emissive );
    	this.emissiveMap = source.emissiveMap;
    	this.emissiveIntensity = source.emissiveIntensity;

    	this.bumpMap = source.bumpMap;
    	this.bumpScale = source.bumpScale;

    	this.normalMap = source.normalMap;
    	this.normalScale.copy( source.normalScale );

    	this.displacementMap = source.displacementMap;
    	this.displacementScale = source.displacementScale;
    	this.displacementBias = source.displacementBias;

    	this.specularMap = source.specularMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.combine = source.combine;
    	this.reflectivity = source.reflectivity;
    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * parameters = {
     *  opacity: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     * }
     */

    function MeshNormalMaterial( parameters ) {

    	Material.call( this, parameters );

    	this.type = 'MeshNormalMaterial';

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;

    	this.fog = false;
    	this.lights = false;
    	this.morphTargets = false;

    	this.setValues( parameters );

    }

    MeshNormalMaterial.prototype = Object.create( Material.prototype );
    MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

    MeshNormalMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshLambertMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshLambertMaterial';

    	this.color = new Color( 0xffffff ); // diffuse

    	this.map = null;

    	this.lightMap = null;
    	this.lightMapIntensity = 1.0;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.emissive = new Color( 0x000000 );
    	this.emissiveIntensity = 1.0;
    	this.emissiveMap = null;

    	this.specularMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.combine = MultiplyOperation;
    	this.reflectivity = 1;
    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;
    	this.morphNormals = false;

    	this.setValues( parameters );

    }

    MeshLambertMaterial.prototype = Object.create( Material.prototype );
    MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

    MeshLambertMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.map = source.map;

    	this.lightMap = source.lightMap;
    	this.lightMapIntensity = source.lightMapIntensity;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.emissive.copy( source.emissive );
    	this.emissiveMap = source.emissiveMap;
    	this.emissiveIntensity = source.emissiveIntensity;

    	this.specularMap = source.specularMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.combine = source.combine;
    	this.reflectivity = source.reflectivity;
    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	return this;

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  linewidth: <float>,
     *
     *  scale: <float>,
     *  dashSize: <float>,
     *  gapSize: <float>
     * }
     */

    function LineDashedMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'LineDashedMaterial';

    	this.color = new Color( 0xffffff );

    	this.linewidth = 1;

    	this.scale = 1;
    	this.dashSize = 3;
    	this.gapSize = 1;

    	this.lights = false;

    	this.setValues( parameters );

    }

    LineDashedMaterial.prototype = Object.create( Material.prototype );
    LineDashedMaterial.prototype.constructor = LineDashedMaterial;

    LineDashedMaterial.prototype.isLineDashedMaterial = true;

    LineDashedMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.linewidth = source.linewidth;

    	this.scale = source.scale;
    	this.dashSize = source.dashSize;
    	this.gapSize = source.gapSize;

    	return this;

    };



    var Materials = Object.freeze({
    	ShadowMaterial: ShadowMaterial,
    	SpriteMaterial: SpriteMaterial,
    	RawShaderMaterial: RawShaderMaterial,
    	ShaderMaterial: ShaderMaterial,
    	PointsMaterial: PointsMaterial,
    	MultiMaterial: MultiMaterial,
    	MeshPhysicalMaterial: MeshPhysicalMaterial,
    	MeshStandardMaterial: MeshStandardMaterial,
    	MeshPhongMaterial: MeshPhongMaterial,
    	MeshNormalMaterial: MeshNormalMaterial,
    	MeshLambertMaterial: MeshLambertMaterial,
    	MeshDepthMaterial: MeshDepthMaterial,
    	MeshBasicMaterial: MeshBasicMaterial,
    	LineDashedMaterial: LineDashedMaterial,
    	LineBasicMaterial: LineBasicMaterial,
    	Material: Material
    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    exports.Cache = {

    	enabled: false,

    	files: {},

    	add: function ( key, file ) {

    		if ( this.enabled === false ) return;

    		// console.log( 'THREE.Cache', 'Adding key:', key );

    		this.files[ key ] = file;

    	},

    	get: function ( key ) {

    		if ( this.enabled === false ) return;

    		// console.log( 'THREE.Cache', 'Checking key:', key );

    		return this.files[ key ];

    	},

    	remove: function ( key ) {

    		delete this.files[ key ];

    	},

    	clear: function () {

    		this.files = {};

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function LoadingManager( onLoad, onProgress, onError ) {

    	var scope = this;

    	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

    	this.onStart = undefined;
    	this.onLoad = onLoad;
    	this.onProgress = onProgress;
    	this.onError = onError;

    	this.itemStart = function ( url ) {

    		itemsTotal ++;

    		if ( isLoading === false ) {

    			if ( scope.onStart !== undefined ) {

    				scope.onStart( url, itemsLoaded, itemsTotal );

    			}

    		}

    		isLoading = true;

    	};

    	this.itemEnd = function ( url ) {

    		itemsLoaded ++;

    		if ( scope.onProgress !== undefined ) {

    			scope.onProgress( url, itemsLoaded, itemsTotal );

    		}

    		if ( itemsLoaded === itemsTotal ) {

    			isLoading = false;

    			if ( scope.onLoad !== undefined ) {

    				scope.onLoad();

    			}

    		}

    	};

    	this.itemError = function ( url ) {

    		if ( scope.onError !== undefined ) {

    			scope.onError( url );

    		}

    	};

    }

    exports.DefaultLoadingManager = new LoadingManager();

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function XHRLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( XHRLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		if ( this.path !== undefined ) url = this.path + url;

    		var scope = this;

    		var cached = exports.Cache.get( url );

    		if ( cached !== undefined ) {

    			scope.manager.itemStart( url );

    			setTimeout( function () {

    				if ( onLoad ) onLoad( cached );

    				scope.manager.itemEnd( url );

    			}, 0 );

    			return cached;

    		}

    		var request = new XMLHttpRequest();
    		request.open( 'GET', url, true );

    		request.addEventListener( 'load', function ( event ) {

    			var response = event.target.response;

    			exports.Cache.add( url, response );

    			if ( this.status === 200 ) {

    				if ( onLoad ) onLoad( response );

    				scope.manager.itemEnd( url );

    			} else if ( this.status === 0 ) {

    				// Some browsers return HTTP Status 0 when using non-http protocol
    				// e.g. 'file://' or 'data://'. Handle as success.

    				console.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );

    				if ( onLoad ) onLoad( response );

    				scope.manager.itemEnd( url );

    			} else {

    				if ( onError ) onError( event );

    				scope.manager.itemError( url );

    			}

    		}, false );

    		if ( onProgress !== undefined ) {

    			request.addEventListener( 'progress', function ( event ) {

    				onProgress( event );

    			}, false );

    		}

    		request.addEventListener( 'error', function ( event ) {

    			if ( onError ) onError( event );

    			scope.manager.itemError( url );

    		}, false );

    		if ( this.responseType !== undefined ) request.responseType = this.responseType;
    		if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

    		if ( request.overrideMimeType ) request.overrideMimeType( 'text/plain' );

    		request.send( null );

    		scope.manager.itemStart( url );

    		return request;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	},

    	setResponseType: function ( value ) {

    		this.responseType = value;
    		return this;

    	},

    	setWithCredentials: function ( value ) {

    		this.withCredentials = value;
    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * Abstract Base class to block based textures loader (dds, pvr, ...)
     */

    function CompressedTextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    	// override in sub classes
    	this._parser = null;

    }

    Object.assign( CompressedTextureLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var images = [];

    		var texture = new CompressedTexture();
    		texture.image = images;

    		var loader = new XHRLoader( this.manager );
    		loader.setPath( this.path );
    		loader.setResponseType( 'arraybuffer' );

    		function loadTexture( i ) {

    			loader.load( url[ i ], function ( buffer ) {

    				var texDatas = scope._parser( buffer, true );

    				images[ i ] = {
    					width: texDatas.width,
    					height: texDatas.height,
    					format: texDatas.format,
    					mipmaps: texDatas.mipmaps
    				};

    				loaded += 1;

    				if ( loaded === 6 ) {

    					if ( texDatas.mipmapCount === 1 )
    						texture.minFilter = LinearFilter;

    					texture.format = texDatas.format;
    					texture.needsUpdate = true;

    					if ( onLoad ) onLoad( texture );

    				}

    			}, onProgress, onError );

    		}

    		if ( Array.isArray( url ) ) {

    			var loaded = 0;

    			for ( var i = 0, il = url.length; i < il; ++ i ) {

    				loadTexture( i );

    			}

    		} else {

    			// compressed cubemap texture stored in a single DDS file

    			loader.load( url, function ( buffer ) {

    				var texDatas = scope._parser( buffer, true );

    				if ( texDatas.isCubemap ) {

    					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

    					for ( var f = 0; f < faces; f ++ ) {

    						images[ f ] = { mipmaps : [] };

    						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

    							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
    							images[ f ].format = texDatas.format;
    							images[ f ].width = texDatas.width;
    							images[ f ].height = texDatas.height;

    						}

    					}

    				} else {

    					texture.image.width = texDatas.width;
    					texture.image.height = texDatas.height;
    					texture.mipmaps = texDatas.mipmaps;

    				}

    				if ( texDatas.mipmapCount === 1 ) {

    					texture.minFilter = LinearFilter;

    				}

    				texture.format = texDatas.format;
    				texture.needsUpdate = true;

    				if ( onLoad ) onLoad( texture );

    			}, onProgress, onError );

    		}

    		return texture;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}

    } );

    /**
     * @author Nikos M. / https://github.com/foo123/
     *
     * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
     */

    var DataTextureLoader = BinaryTextureLoader;
    function BinaryTextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    	// override in sub classes
    	this._parser = null;

    }

    Object.assign( BinaryTextureLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var texture = new DataTexture();

    		var loader = new XHRLoader( this.manager );
    		loader.setResponseType( 'arraybuffer' );

    		loader.load( url, function ( buffer ) {

    			var texData = scope._parser( buffer );

    			if ( ! texData ) return;

    			if ( undefined !== texData.image ) {

    				texture.image = texData.image;

    			} else if ( undefined !== texData.data ) {

    				texture.image.width = texData.width;
    				texture.image.height = texData.height;
    				texture.image.data = texData.data;

    			}

    			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
    			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

    			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
    			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

    			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

    			if ( undefined !== texData.format ) {

    				texture.format = texData.format;

    			}
    			if ( undefined !== texData.type ) {

    				texture.type = texData.type;

    			}

    			if ( undefined !== texData.mipmaps ) {

    				texture.mipmaps = texData.mipmaps;

    			}

    			if ( 1 === texData.mipmapCount ) {

    				texture.minFilter = LinearFilter;

    			}

    			texture.needsUpdate = true;

    			if ( onLoad ) onLoad( texture, texData );

    		}, onProgress, onError );


    		return texture;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function ImageLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( ImageLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
    		image.onload = function () {

    			image.onload = null;

    			URL.revokeObjectURL( image.src );

    			if ( onLoad ) onLoad( image );

    			scope.manager.itemEnd( url );

    		};

    		if ( url.indexOf( 'data:' ) === 0 ) {

    			image.src = url;

    		} else {

    			var loader = new XHRLoader();
    			loader.setPath( this.path );
    			loader.setResponseType( 'blob' );
    			loader.setWithCredentials( this.withCredentials );
    			loader.load( url, function ( blob ) {

    				image.src = URL.createObjectURL( blob );

    			}, onProgress, onError );

    		}

    		scope.manager.itemStart( url );

    		return image;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;
    		return this;

    	},

    	setWithCredentials: function ( value ) {

    		this.withCredentials = value;
    		return this;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CubeTextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( CubeTextureLoader.prototype, {

    	load: function ( urls, onLoad, onProgress, onError ) {

    		var texture = new CubeTexture();

    		var loader = new ImageLoader( this.manager );
    		loader.setCrossOrigin( this.crossOrigin );
    		loader.setPath( this.path );

    		var loaded = 0;

    		function loadTexture( i ) {

    			loader.load( urls[ i ], function ( image ) {

    				texture.images[ i ] = image;

    				loaded ++;

    				if ( loaded === 6 ) {

    					texture.needsUpdate = true;

    					if ( onLoad ) onLoad( texture );

    				}

    			}, undefined, onError );

    		}

    		for ( var i = 0; i < urls.length; ++ i ) {

    			loadTexture( i );

    		}

    		return texture;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;
    		return this;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function TextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( TextureLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var texture = new Texture();

    		var loader = new ImageLoader( this.manager );
    		loader.setCrossOrigin( this.crossOrigin );
    		loader.setWithCredentials( this.withCredentials );
    		loader.setPath( this.path );
    		loader.load( url, function ( image ) {

    			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
    			var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

    			texture.format = isJPEG ? RGBFormat : RGBAFormat;
    			texture.image = image;
    			texture.needsUpdate = true;

    			if ( onLoad !== undefined ) {

    				onLoad( texture );

    			}

    		}, onProgress, onError );

    		return texture;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;
    		return this;

    	},

    	setWithCredentials: function ( value ) {

    		this.withCredentials = value;
    		return this;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}



    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Light( color, intensity ) {

    	Object3D.call( this );

    	this.type = 'Light';

    	this.color = new Color( color );
    	this.intensity = intensity !== undefined ? intensity : 1;

    	this.receiveShadow = undefined;

    }

    Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Light,

    	isLight: true,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.color.copy( source.color );
    		this.intensity = source.intensity;

    		return this;

    	},

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.color = this.color.getHex();
    		data.object.intensity = this.intensity;

    		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

    		if ( this.distance !== undefined ) data.object.distance = this.distance;
    		if ( this.angle !== undefined ) data.object.angle = this.angle;
    		if ( this.decay !== undefined ) data.object.decay = this.decay;
    		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

    		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

    		return data;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function HemisphereLight( skyColor, groundColor, intensity ) {

    	Light.call( this, skyColor, intensity );

    	this.type = 'HemisphereLight';

    	this.castShadow = undefined;

    	this.position.copy( Object3D.DefaultUp );
    	this.updateMatrix();

    	this.groundColor = new Color( groundColor );

    }

    HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: HemisphereLight,

    	isHemisphereLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.groundColor.copy( source.groundColor );

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function LightShadow( camera ) {

    	this.camera = camera;

    	this.bias = 0;
    	this.radius = 1;

    	this.mapSize = new Vector2( 512, 512 );

    	this.map = null;
    	this.matrix = new Matrix4();

    }

    Object.assign( LightShadow.prototype, {

    	copy: function ( source ) {

    		this.camera = source.camera.clone();

    		this.bias = source.bias;
    		this.radius = source.radius;

    		this.mapSize.copy( source.mapSize );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	toJSON: function () {

    		var object = {};

    		if ( this.bias !== 0 ) object.bias = this.bias;
    		if ( this.radius !== 1 ) object.radius = this.radius;
    		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

    		object.camera = this.camera.toJSON( false ).object;
    		delete object.camera.matrix;

    		return object;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function SpotLightShadow() {

    	LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

    }

    SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

    	constructor: SpotLightShadow,

    	isSpotLightShadow: true,

    	update: function ( light ) {

    		var fov = exports.Math.RAD2DEG * 2 * light.angle;
    		var aspect = this.mapSize.width / this.mapSize.height;
    		var far = light.distance || 500;

    		var camera = this.camera;

    		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

    			camera.fov = fov;
    			camera.aspect = aspect;
    			camera.far = far;
    			camera.updateProjectionMatrix();

    		}

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

    	Light.call( this, color, intensity );

    	this.type = 'SpotLight';

    	this.position.copy( Object3D.DefaultUp );
    	this.updateMatrix();

    	this.target = new Object3D();

    	Object.defineProperty( this, 'power', {
    		get: function () {
    			// intensity = power per solid angle.
    			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			return this.intensity * Math.PI;
    		},
    		set: function ( power ) {
    			// intensity = power per solid angle.
    			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			this.intensity = power / Math.PI;
    		}
    	} );

    	this.distance = ( distance !== undefined ) ? distance : 0;
    	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
    	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
    	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

    	this.shadow = new SpotLightShadow();

    }

    SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: SpotLight,

    	isSpotLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.distance = source.distance;
    		this.angle = source.angle;
    		this.penumbra = source.penumbra;
    		this.decay = source.decay;

    		this.target = source.target.clone();

    		this.shadow = source.shadow.clone();

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */


    function PointLight( color, intensity, distance, decay ) {

    	Light.call( this, color, intensity );

    	this.type = 'PointLight';

    	Object.defineProperty( this, 'power', {
    		get: function () {
    			// intensity = power per solid angle.
    			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			return this.intensity * 4 * Math.PI;

    		},
    		set: function ( power ) {
    			// intensity = power per solid angle.
    			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			this.intensity = power / ( 4 * Math.PI );
    		}
    	} );

    	this.distance = ( distance !== undefined ) ? distance : 0;
    	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

    	this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

    }

    PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: PointLight,

    	isPointLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.distance = source.distance;
    		this.decay = source.decay;

    		this.shadow = source.shadow.clone();

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function DirectionalLightShadow( light ) {

    	LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

    }

    DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

    	constructor: DirectionalLightShadow

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function DirectionalLight( color, intensity ) {

    	Light.call( this, color, intensity );

    	this.type = 'DirectionalLight';

    	this.position.copy( Object3D.DefaultUp );
    	this.updateMatrix();

    	this.target = new Object3D();

    	this.shadow = new DirectionalLightShadow();

    }

    DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: DirectionalLight,

    	isDirectionalLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.target = source.target.clone();

    		this.shadow = source.shadow.clone();

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function AmbientLight( color, intensity ) {

    	Light.call( this, color, intensity );

    	this.type = 'AmbientLight';

    	this.castShadow = undefined;

    }

    AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: AmbientLight,

    	isAmbientLight: true,

    } );

    /**
     * @author tschw
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     */

    exports.AnimationUtils = {

    	// same as Array.prototype.slice, but also works on typed arrays
    	arraySlice: function( array, from, to ) {

    		if ( exports.AnimationUtils.isTypedArray( array ) ) {

    			return new array.constructor( array.subarray( from, to ) );

    		}

    		return array.slice( from, to );

    	},

    	// converts an array to a specific type
    	convertArray: function( array, type, forceClone ) {

    		if ( ! array || // let 'undefined' and 'null' pass
    				! forceClone && array.constructor === type ) return array;

    		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

    			return new type( array ); // create typed array

    		}

    		return Array.prototype.slice.call( array ); // create Array

    	},

    	isTypedArray: function( object ) {

    		return ArrayBuffer.isView( object ) &&
    				! ( object instanceof DataView );

    	},

    	// returns an array by which times and values can be sorted
    	getKeyframeOrder: function( times ) {

    		function compareTime( i, j ) {

    			return times[ i ] - times[ j ];

    		}

    		var n = times.length;
    		var result = new Array( n );
    		for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

    		result.sort( compareTime );

    		return result;

    	},

    	// uses the array previously returned by 'getKeyframeOrder' to sort data
    	sortedArray: function( values, stride, order ) {

    		var nValues = values.length;
    		var result = new values.constructor( nValues );

    		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

    			var srcOffset = order[ i ] * stride;

    			for ( var j = 0; j !== stride; ++ j ) {

    				result[ dstOffset ++ ] = values[ srcOffset + j ];

    			}

    		}

    		return result;

    	},

    	// function for parsing AOS keyframe formats
    	flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {

    		var i = 1, key = jsonKeys[ 0 ];

    		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

    			key = jsonKeys[ i ++ ];

    		}

    		if ( key === undefined ) return; // no data

    		var value = key[ valuePropertyName ];
    		if ( value === undefined ) return; // no data

    		if ( Array.isArray( value ) ) {

    			do {

    				value = key[ valuePropertyName ];

    				if ( value !== undefined ) {

    					times.push( key.time );
    					values.push.apply( values, value ); // push all elements

    				}

    				key = jsonKeys[ i ++ ];

    			} while ( key !== undefined );

    		} else if ( value.toArray !== undefined ) {
    			// ...assume THREE.Math-ish

    			do {

    				value = key[ valuePropertyName ];

    				if ( value !== undefined ) {

    					times.push( key.time );
    					value.toArray( values, values.length );

    				}

    				key = jsonKeys[ i ++ ];

    			} while ( key !== undefined );

    		} else {
    			// otherwise push as-is

    			do {

    				value = key[ valuePropertyName ];

    				if ( value !== undefined ) {

    					times.push( key.time );
    					values.push( value );

    				}

    				key = jsonKeys[ i ++ ];

    			} while ( key !== undefined );

    		}

    	}

    };

    /**
     * Abstract base class of interpolants over parametric samples.
     *
     * The parameter domain is one dimensional, typically the time or a path
     * along a curve defined by the data.
     *
     * The sample values can have any dimensionality and derived classes may
     * apply special interpretations to the data.
     *
     * This class provides the interval seek in a Template Method, deferring
     * the actual interpolation to derived classes.
     *
     * Time complexity is O(1) for linear access crossing at most two points
     * and O(log N) for random access, where N is the number of positions.
     *
     * References:
     *
     * 		http://www.oodesign.com/template-method-pattern.html
     *
     * @author tschw
     */

    function Interpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	this.parameterPositions = parameterPositions;
    	this._cachedIndex = 0;

    	this.resultBuffer = resultBuffer !== undefined ?
    			resultBuffer : new sampleValues.constructor( sampleSize );
    	this.sampleValues = sampleValues;
    	this.valueSize = sampleSize;

    }

    Interpolant.prototype = {

    	constructor: Interpolant,

    	evaluate: function( t ) {

    		var pp = this.parameterPositions,
    			i1 = this._cachedIndex,

    			t1 = pp[   i1   ],
    			t0 = pp[ i1 - 1 ];

    		validate_interval: {

    			seek: {

    				var right;

    				linear_scan: {
    //- See http://jsperf.com/comparison-to-undefined/3
    //- slower code:
    //-
    //- 				if ( t >= t1 || t1 === undefined ) {
    					forward_scan: if ( ! ( t < t1 ) ) {

    						for ( var giveUpAt = i1 + 2; ;) {

    							if ( t1 === undefined ) {

    								if ( t < t0 ) break forward_scan;

    								// after end

    								i1 = pp.length;
    								this._cachedIndex = i1;
    								return this.afterEnd_( i1 - 1, t, t0 );

    							}

    							if ( i1 === giveUpAt ) break; // this loop

    							t0 = t1;
    							t1 = pp[ ++ i1 ];

    							if ( t < t1 ) {

    								// we have arrived at the sought interval
    								break seek;

    							}

    						}

    						// prepare binary search on the right side of the index
    						right = pp.length;
    						break linear_scan;

    					}

    //- slower code:
    //-					if ( t < t0 || t0 === undefined ) {
    					if ( ! ( t >= t0 ) ) {

    						// looping?

    						var t1global = pp[ 1 ];

    						if ( t < t1global ) {

    							i1 = 2; // + 1, using the scan for the details
    							t0 = t1global;

    						}

    						// linear reverse scan

    						for ( var giveUpAt = i1 - 2; ;) {

    							if ( t0 === undefined ) {

    								// before start

    								this._cachedIndex = 0;
    								return this.beforeStart_( 0, t, t1 );

    							}

    							if ( i1 === giveUpAt ) break; // this loop

    							t1 = t0;
    							t0 = pp[ -- i1 - 1 ];

    							if ( t >= t0 ) {

    								// we have arrived at the sought interval
    								break seek;

    							}

    						}

    						// prepare binary search on the left side of the index
    						right = i1;
    						i1 = 0;
    						break linear_scan;

    					}

    					// the interval is valid

    					break validate_interval;

    				} // linear scan

    				// binary search

    				while ( i1 < right ) {

    					var mid = ( i1 + right ) >>> 1;

    					if ( t < pp[ mid ] ) {

    						right = mid;

    					} else {

    						i1 = mid + 1;

    					}

    				}

    				t1 = pp[   i1   ];
    				t0 = pp[ i1 - 1 ];

    				// check boundary cases, again

    				if ( t0 === undefined ) {

    					this._cachedIndex = 0;
    					return this.beforeStart_( 0, t, t1 );

    				}

    				if ( t1 === undefined ) {

    					i1 = pp.length;
    					this._cachedIndex = i1;
    					return this.afterEnd_( i1 - 1, t0, t );

    				}

    			} // seek

    			this._cachedIndex = i1;

    			this.intervalChanged_( i1, t0, t1 );

    		} // validate_interval

    		return this.interpolate_( i1, t0, t, t1 );

    	},

    	settings: null, // optional, subclass-specific settings structure
    	// Note: The indirection allows central control of many interpolants.

    	// --- Protected interface

    	DefaultSettings_: {},

    	getSettings_: function() {

    		return this.settings || this.DefaultSettings_;

    	},

    	copySampleValue_: function( index ) {

    		// copies a sample value to the result buffer

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,
    			offset = index * stride;

    		for ( var i = 0; i !== stride; ++ i ) {

    			result[ i ] = values[ offset + i ];

    		}

    		return result;

    	},

    	// Template methods for derived classes:

    	interpolate_: function( i1, t0, t, t1 ) {

    		throw new Error( "call to abstract method" );
    		// implementations shall return this.resultBuffer

    	},

    	intervalChanged_: function( i1, t0, t1 ) {

    		// empty

    	}

    };

    Object.assign( Interpolant.prototype, {

    	beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
    		Interpolant.prototype.copySampleValue_,

    	afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
    		Interpolant.prototype.copySampleValue_

    } );

    /**
     * Fast and simple cubic spline interpolant.
     *
     * It was derived from a Hermitian construction setting the first derivative
     * at each sample position to the linear slope between neighboring positions
     * over their parameter interval.
     *
     * @author tschw
     */

    function CubicInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    	this._weightPrev = -0;
    	this._offsetPrev = -0;
    	this._weightNext = -0;
    	this._offsetNext = -0;

    }

    CubicInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: CubicInterpolant,

    	DefaultSettings_: {

    		endingStart: 	ZeroCurvatureEnding,
    		endingEnd:		ZeroCurvatureEnding

    	},

    	intervalChanged_: function( i1, t0, t1 ) {

    		var pp = this.parameterPositions,
    			iPrev = i1 - 2,
    			iNext = i1 + 1,

    			tPrev = pp[ iPrev ],
    			tNext = pp[ iNext ];

    		if ( tPrev === undefined ) {

    			switch ( this.getSettings_().endingStart ) {

    				case ZeroSlopeEnding:

    					// f'(t0) = 0
    					iPrev = i1;
    					tPrev = 2 * t0 - t1;

    					break;

    				case WrapAroundEnding:

    					// use the other end of the curve
    					iPrev = pp.length - 2;
    					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

    					break;

    				default: // ZeroCurvatureEnding

    					// f''(t0) = 0 a.k.a. Natural Spline
    					iPrev = i1;
    					tPrev = t1;

    			}

    		}

    		if ( tNext === undefined ) {

    			switch ( this.getSettings_().endingEnd ) {

    				case ZeroSlopeEnding:

    					// f'(tN) = 0
    					iNext = i1;
    					tNext = 2 * t1 - t0;

    					break;

    				case WrapAroundEnding:

    					// use the other end of the curve
    					iNext = 1;
    					tNext = t1 + pp[ 1 ] - pp[ 0 ];

    					break;

    				default: // ZeroCurvatureEnding

    					// f''(tN) = 0, a.k.a. Natural Spline
    					iNext = i1 - 1;
    					tNext = t0;

    			}

    		}

    		var halfDt = ( t1 - t0 ) * 0.5,
    			stride = this.valueSize;

    		this._weightPrev = halfDt / ( t0 - tPrev );
    		this._weightNext = halfDt / ( tNext - t1 );
    		this._offsetPrev = iPrev * stride;
    		this._offsetNext = iNext * stride;

    	},

    	interpolate_: function( i1, t0, t, t1 ) {

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,

    			o1 = i1 * stride,		o0 = o1 - stride,
    			oP = this._offsetPrev, 	oN = this._offsetNext,
    			wP = this._weightPrev,	wN = this._weightNext,

    			p = ( t - t0 ) / ( t1 - t0 ),
    			pp = p * p,
    			ppp = pp * p;

    		// evaluate polynomials

    		var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
    		var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
    		var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
    		var sN =       wN   * ppp   -           wN      * pp;

    		// combine data linearly

    		for ( var i = 0; i !== stride; ++ i ) {

    			result[ i ] =
    					sP * values[ oP + i ] +
    					s0 * values[ o0 + i ] +
    					s1 * values[ o1 + i ] +
    					sN * values[ oN + i ];

    		}

    		return result;

    	}

    } );

    /**
     * @author tschw
     */

    function LinearInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    }

    LinearInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: LinearInterpolant,

    	interpolate_: function( i1, t0, t, t1 ) {

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,

    			offset1 = i1 * stride,
    			offset0 = offset1 - stride,

    			weight1 = ( t - t0 ) / ( t1 - t0 ),
    			weight0 = 1 - weight1;

    		for ( var i = 0; i !== stride; ++ i ) {

    			result[ i ] =
    					values[ offset0 + i ] * weight0 +
    					values[ offset1 + i ] * weight1;

    		}

    		return result;

    	}

    } );

    /**
     *
     * Interpolant that evaluates to the sample value at the position preceeding
     * the parameter.
     *
     * @author tschw
     */

    function DiscreteInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    }

    DiscreteInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: DiscreteInterpolant,

    	interpolate_: function( i1, t0, t, t1 ) {

    		return this.copySampleValue_( i1 - 1 );

    	}

    } );

    var KeyframeTrackPrototype;

    KeyframeTrackPrototype = {

    	TimeBufferType: Float32Array,
    	ValueBufferType: Float32Array,

    	DefaultInterpolation: InterpolateLinear,

    	InterpolantFactoryMethodDiscrete: function( result ) {

    		return new DiscreteInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	InterpolantFactoryMethodLinear: function( result ) {

    		return new LinearInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	InterpolantFactoryMethodSmooth: function( result ) {

    		return new CubicInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	setInterpolation: function( interpolation ) {

    		var factoryMethod;

    		switch ( interpolation ) {

    			case InterpolateDiscrete:

    				factoryMethod = this.InterpolantFactoryMethodDiscrete;

    				break;

    			case InterpolateLinear:

    				factoryMethod = this.InterpolantFactoryMethodLinear;

    				break;

    			case InterpolateSmooth:

    				factoryMethod = this.InterpolantFactoryMethodSmooth;

    				break;

    		}

    		if ( factoryMethod === undefined ) {

    			var message = "unsupported interpolation for " +
    					this.ValueTypeName + " keyframe track named " + this.name;

    			if ( this.createInterpolant === undefined ) {

    				// fall back to default, unless the default itself is messed up
    				if ( interpolation !== this.DefaultInterpolation ) {

    					this.setInterpolation( this.DefaultInterpolation );

    				} else {

    					throw new Error( message ); // fatal, in this case

    				}

    			}

    			console.warn( message );
    			return;

    		}

    		this.createInterpolant = factoryMethod;

    	},

    	getInterpolation: function() {

    		switch ( this.createInterpolant ) {

    			case this.InterpolantFactoryMethodDiscrete:

    				return InterpolateDiscrete;

    			case this.InterpolantFactoryMethodLinear:

    				return InterpolateLinear;

    			case this.InterpolantFactoryMethodSmooth:

    				return InterpolateSmooth;

    		}

    	},

    	getValueSize: function() {

    		return this.values.length / this.times.length;

    	},

    	// move all keyframes either forwards or backwards in time
    	shift: function( timeOffset ) {

    		if( timeOffset !== 0.0 ) {

    			var times = this.times;

    			for( var i = 0, n = times.length; i !== n; ++ i ) {

    				times[ i ] += timeOffset;

    			}

    		}

    		return this;

    	},

    	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    	scale: function( timeScale ) {

    		if( timeScale !== 1.0 ) {

    			var times = this.times;

    			for( var i = 0, n = times.length; i !== n; ++ i ) {

    				times[ i ] *= timeScale;

    			}

    		}

    		return this;

    	},

    	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    	trim: function( startTime, endTime ) {

    		var times = this.times,
    			nKeys = times.length,
    			from = 0,
    			to = nKeys - 1;

    		while ( from !== nKeys && times[ from ] < startTime ) ++ from;
    		while ( to !== -1 && times[ to ] > endTime ) -- to;

    		++ to; // inclusive -> exclusive bound

    		if( from !== 0 || to !== nKeys ) {

    			// empty tracks are forbidden, so keep at least one keyframe
    			if ( from >= to ) to = Math.max( to , 1 ), from = to - 1;

    			var stride = this.getValueSize();
    			this.times = exports.AnimationUtils.arraySlice( times, from, to );
    			this.values = exports.AnimationUtils.
    					arraySlice( this.values, from * stride, to * stride );

    		}

    		return this;

    	},

    	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    	validate: function() {

    		var valid = true;

    		var valueSize = this.getValueSize();
    		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

    			console.error( "invalid value size in track", this );
    			valid = false;

    		}

    		var times = this.times,
    			values = this.values,

    			nKeys = times.length;

    		if( nKeys === 0 ) {

    			console.error( "track is empty", this );
    			valid = false;

    		}

    		var prevTime = null;

    		for( var i = 0; i !== nKeys; i ++ ) {

    			var currTime = times[ i ];

    			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

    				console.error( "time is not a valid number", this, i, currTime );
    				valid = false;
    				break;

    			}

    			if( prevTime !== null && prevTime > currTime ) {

    				console.error( "out of order keys", this, i, currTime, prevTime );
    				valid = false;
    				break;

    			}

    			prevTime = currTime;

    		}

    		if ( values !== undefined ) {

    			if ( exports.AnimationUtils.isTypedArray( values ) ) {

    				for ( var i = 0, n = values.length; i !== n; ++ i ) {

    					var value = values[ i ];

    					if ( isNaN( value ) ) {

    						console.error( "value is not a valid number", this, i, value );
    						valid = false;
    						break;

    					}

    				}

    			}

    		}

    		return valid;

    	},

    	// removes equivalent sequential keys as common in morph target sequences
    	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    	optimize: function() {

    		var times = this.times,
    			values = this.values,
    			stride = this.getValueSize(),

    			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

    			writeIndex = 1,
    			lastIndex = times.length - 1;

    		for( var i = 1; i < lastIndex; ++ i ) {

    			var keep = false;

    			var time = times[ i ];
    			var timeNext = times[ i + 1 ];

    			// remove adjacent keyframes scheduled at the same time

    			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

    				if ( ! smoothInterpolation ) {

    					// remove unnecessary keyframes same as their neighbors

    					var offset = i * stride,
    						offsetP = offset - stride,
    						offsetN = offset + stride;

    					for ( var j = 0; j !== stride; ++ j ) {

    						var value = values[ offset + j ];

    						if ( value !== values[ offsetP + j ] ||
    								value !== values[ offsetN + j ] ) {

    							keep = true;
    							break;

    						}

    					}

    				} else keep = true;

    			}

    			// in-place compaction

    			if ( keep ) {

    				if ( i !== writeIndex ) {

    					times[ writeIndex ] = times[ i ];

    					var readOffset = i * stride,
    						writeOffset = writeIndex * stride;

    					for ( var j = 0; j !== stride; ++ j )

    						values[ writeOffset + j ] = values[ readOffset + j ];

    				}

    				++ writeIndex;

    			}

    		}

    		// flush last keyframe (compaction looks ahead)

    		if ( lastIndex > 0 ) {

    			times[ writeIndex ] = times[ lastIndex ];

    			for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )

    				values[ writeOffset + j ] = values[ readOffset + j ];

    			++ writeIndex;

    		}

    		if ( writeIndex !== times.length ) {

    			this.times = exports.AnimationUtils.arraySlice( times, 0, writeIndex );
    			this.values = exports.AnimationUtils.arraySlice( values, 0, writeIndex * stride );

    		}

    		return this;

    	}

    }

    function KeyframeTrackConstructor( name, times, values, interpolation ) {

    	if( name === undefined ) throw new Error( "track name is undefined" );

    	if( times === undefined || times.length === 0 ) {

    		throw new Error( "no keyframes in track named " + name );

    	}

    	this.name = name;

    	this.times = exports.AnimationUtils.convertArray( times, this.TimeBufferType );
    	this.values = exports.AnimationUtils.convertArray( values, this.ValueBufferType );

    	this.setInterpolation( interpolation || this.DefaultInterpolation );

    	this.validate();
    	this.optimize();

    }

    /**
     *
     * A Track of vectored keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function VectorKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    VectorKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: VectorKeyframeTrack,

    	ValueTypeName: 'vector'

    	// ValueBufferType is inherited

    	// DefaultInterpolation is inherited

    } );

    /**
     * Spherical linear unit quaternion interpolant.
     *
     * @author tschw
     */

    function QuaternionLinearInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    }

    QuaternionLinearInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: QuaternionLinearInterpolant,

    	interpolate_: function( i1, t0, t, t1 ) {

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,

    			offset = i1 * stride,

    			alpha = ( t - t0 ) / ( t1 - t0 );

    		for ( var end = offset + stride; offset !== end; offset += 4 ) {

    			Quaternion.slerpFlat( result, 0,
    					values, offset - stride, values, offset, alpha );

    		}

    		return result;

    	}

    } );

    /**
     *
     * A Track of quaternion keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function QuaternionKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    QuaternionKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: QuaternionKeyframeTrack,

    	ValueTypeName: 'quaternion',

    	// ValueBufferType is inherited

    	DefaultInterpolation: InterpolateLinear,

    	InterpolantFactoryMethodLinear: function( result ) {

    		return new QuaternionLinearInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	InterpolantFactoryMethodSmooth: undefined // not yet implemented

    } );

    /**
     *
     * A Track of numeric keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function NumberKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    NumberKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: NumberKeyframeTrack,

    	ValueTypeName: 'number',

    	// ValueBufferType is inherited

    	// DefaultInterpolation is inherited

    } );

    /**
     *
     * A Track that interpolates Strings
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function StringKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    StringKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: StringKeyframeTrack,

    	ValueTypeName: 'string',
    	ValueBufferType: Array,

    	DefaultInterpolation: InterpolateDiscrete,

    	InterpolantFactoryMethodLinear: undefined,

    	InterpolantFactoryMethodSmooth: undefined

    } );

    /**
     *
     * A Track of Boolean keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function BooleanKeyframeTrack( name, times, values ) {

    	KeyframeTrackConstructor.call( this, name, times, values );

    }

    BooleanKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: BooleanKeyframeTrack,

    	ValueTypeName: 'bool',
    	ValueBufferType: Array,

    	DefaultInterpolation: InterpolateDiscrete,

    	InterpolantFactoryMethodLinear: undefined,
    	InterpolantFactoryMethodSmooth: undefined

    	// Note: Actually this track could have a optimized / compressed
    	// representation of a single value and a custom interpolant that
    	// computes "firstValue ^ isOdd( index )".

    } );

    /**
     *
     * A Track of keyframe values that represent color.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function ColorKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    ColorKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: ColorKeyframeTrack,

    	ValueTypeName: 'color'

    	// ValueBufferType is inherited

    	// DefaultInterpolation is inherited


    	// Note: Very basic implementation and nothing special yet.
    	// However, this is the place for color space parameterization.

    } );

    /**
     *
     * A timed sequence of keyframes for a specific property.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function KeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.apply( this, arguments );

    }

    KeyframeTrack.prototype = KeyframeTrackPrototype;
    KeyframeTrackPrototype.constructor = KeyframeTrack;

    // Static methods:

    Object.assign( KeyframeTrack, {

    	// Serialization (in static context, because of constructor invocation
    	// and automatic invocation of .toJSON):

    	parse: function( json ) {

    		if( json.type === undefined ) {

    			throw new Error( "track type undefined, can not parse" );

    		}

    		var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );

    		if ( json.times === undefined ) {

    			var times = [], values = [];

    			exports.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

    			json.times = times;
    			json.values = values;

    		}

    		// derived classes can define a static parse method
    		if ( trackType.parse !== undefined ) {

    			return trackType.parse( json );

    		} else {

    			// by default, we asssume a constructor compatible with the base
    			return new trackType(
    					json.name, json.times, json.values, json.interpolation );

    		}

    	},

    	toJSON: function( track ) {

    		var trackType = track.constructor;

    		var json;

    		// derived classes can define a static toJSON method
    		if ( trackType.toJSON !== undefined ) {

    			json = trackType.toJSON( track );

    		} else {

    			// by default, we assume the data can be serialized as-is
    			json = {

    				'name': track.name,
    				'times': exports.AnimationUtils.convertArray( track.times, Array ),
    				'values': exports.AnimationUtils.convertArray( track.values, Array )

    			};

    			var interpolation = track.getInterpolation();

    			if ( interpolation !== track.DefaultInterpolation ) {

    				json.interpolation = interpolation;

    			}

    		}

    		json.type = track.ValueTypeName; // mandatory

    		return json;

    	},

    	_getTrackTypeForValueTypeName: function( typeName ) {

    		switch( typeName.toLowerCase() ) {

    			case "scalar":
    			case "double":
    			case "float":
    			case "number":
    			case "integer":

    				return NumberKeyframeTrack;

    			case "vector":
    			case "vector2":
    			case "vector3":
    			case "vector4":

    				return VectorKeyframeTrack;

    			case "color":

    				return ColorKeyframeTrack;

    			case "quaternion":

    				return QuaternionKeyframeTrack;

    			case "bool":
    			case "boolean":

    				return BooleanKeyframeTrack;

    			case "string":

    				return StringKeyframeTrack;

    		}

    		throw new Error( "Unsupported typeName: " + typeName );

    	}

    } );

    /**
     *
     * Reusable set of Tracks that represent an animation.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     */

    function AnimationClip( name, duration, tracks ) {

    	this.name = name;
    	this.tracks = tracks;
    	this.duration = ( duration !== undefined ) ? duration : -1;

    	this.uuid = exports.Math.generateUUID();

    	// this means it should figure out its duration by scanning the tracks
    	if ( this.duration < 0 ) {

    		this.resetDuration();

    	}

    	this.optimize();

    }

    AnimationClip.prototype = {

    	constructor: AnimationClip,

    	resetDuration: function() {

    		var tracks = this.tracks,
    			duration = 0;

    		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

    			var track = this.tracks[ i ];

    			duration = Math.max(
    					duration, track.times[ track.times.length - 1 ] );

    		}

    		this.duration = duration;

    	},

    	trim: function() {

    		for ( var i = 0; i < this.tracks.length; i ++ ) {

    			this.tracks[ i ].trim( 0, this.duration );

    		}

    		return this;

    	},

    	optimize: function() {

    		for ( var i = 0; i < this.tracks.length; i ++ ) {

    			this.tracks[ i ].optimize();

    		}

    		return this;

    	}

    };

    // Static methods:

    Object.assign( AnimationClip, {

    	parse: function( json ) {

    		var tracks = [],
    			jsonTracks = json.tracks,
    			frameTime = 1.0 / ( json.fps || 1.0 );

    		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

    			tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

    		}

    		return new AnimationClip( json.name, json.duration, tracks );

    	},


    	toJSON: function( clip ) {

    		var tracks = [],
    			clipTracks = clip.tracks;

    		var json = {

    			'name': clip.name,
    			'duration': clip.duration,
    			'tracks': tracks

    		};

    		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

    			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

    		}

    		return json;

    	},


    	CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {

    		var numMorphTargets = morphTargetSequence.length;
    		var tracks = [];

    		for ( var i = 0; i < numMorphTargets; i ++ ) {

    			var times = [];
    			var values = [];

    			times.push(
    					( i + numMorphTargets - 1 ) % numMorphTargets,
    					i,
    					( i + 1 ) % numMorphTargets );

    			values.push( 0, 1, 0 );

    			var order = exports.AnimationUtils.getKeyframeOrder( times );
    			times = exports.AnimationUtils.sortedArray( times, 1, order );
    			values = exports.AnimationUtils.sortedArray( values, 1, order );

    			// if there is a key at the first frame, duplicate it as the
    			// last frame as well for perfect loop.
    			if ( ! noLoop && times[ 0 ] === 0 ) {

    				times.push( numMorphTargets );
    				values.push( values[ 0 ] );

    			}

    			tracks.push(
    					new NumberKeyframeTrack(
    						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
    						times, values
    					).scale( 1.0 / fps ) );
    		}

    		return new AnimationClip( name, -1, tracks );

    	},

    	findByName: function( objectOrClipArray, name ) {

    		var clipArray = objectOrClipArray;

    		if ( ! Array.isArray( objectOrClipArray ) ) {

    			var o = objectOrClipArray;
    			clipArray = o.geometry && o.geometry.animations || o.animations;

    		}

    		for ( var i = 0; i < clipArray.length; i ++ ) {

    			if ( clipArray[ i ].name === name ) {

    				return clipArray[ i ];

    			}
    		}

    		return null;

    	},

    	CreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {

    		var animationToMorphTargets = {};

    		// tested with https://regex101.com/ on trick sequences
    		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
    		var pattern = /^([\w-]*?)([\d]+)$/;

    		// sort morph target names into animation groups based
    		// patterns like Walk_001, Walk_002, Run_001, Run_002
    		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

    			var morphTarget = morphTargets[ i ];
    			var parts = morphTarget.name.match( pattern );

    			if ( parts && parts.length > 1 ) {

    				var name = parts[ 1 ];

    				var animationMorphTargets = animationToMorphTargets[ name ];
    				if ( ! animationMorphTargets ) {

    					animationToMorphTargets[ name ] = animationMorphTargets = [];

    				}

    				animationMorphTargets.push( morphTarget );

    			}

    		}

    		var clips = [];

    		for ( var name in animationToMorphTargets ) {

    			clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

    		}

    		return clips;

    	},

    	// parse the animation.hierarchy format
    	parseAnimation: function( animation, bones ) {

    		if ( ! animation ) {

    			console.error( "  no animation in JSONLoader data" );
    			return null;

    		}

    		var addNonemptyTrack = function(
    				trackType, trackName, animationKeys, propertyName, destTracks ) {

    			// only return track if there are actually keys.
    			if ( animationKeys.length !== 0 ) {

    				var times = [];
    				var values = [];

    				exports.AnimationUtils.flattenJSON(
    						animationKeys, times, values, propertyName );

    				// empty keys are filtered out, so check again
    				if ( times.length !== 0 ) {

    					destTracks.push( new trackType( trackName, times, values ) );

    				}

    			}

    		};

    		var tracks = [];

    		var clipName = animation.name || 'default';
    		// automatic length determination in AnimationClip.
    		var duration = animation.length || -1;
    		var fps = animation.fps || 30;

    		var hierarchyTracks = animation.hierarchy || [];

    		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

    			var animationKeys = hierarchyTracks[ h ].keys;

    			// skip empty tracks
    			if ( ! animationKeys || animationKeys.length === 0 ) continue;

    			// process morph targets in a way exactly compatible
    			// with AnimationHandler.init( animation )
    			if ( animationKeys[0].morphTargets ) {

    				// figure out all morph targets used in this track
    				var morphTargetNames = {};
    				for ( var k = 0; k < animationKeys.length; k ++ ) {

    					if ( animationKeys[k].morphTargets ) {

    						for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

    							morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
    						}

    					}

    				}

    				// create a track for each morph target with all zero
    				// morphTargetInfluences except for the keys in which
    				// the morphTarget is named.
    				for ( var morphTargetName in morphTargetNames ) {

    					var times = [];
    					var values = [];

    					for ( var m = 0;
    							m !== animationKeys[k].morphTargets.length; ++ m ) {

    						var animationKey = animationKeys[k];

    						times.push( animationKey.time );
    						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

    					}

    					tracks.push( new NumberKeyframeTrack(
    							'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

    				}

    				duration = morphTargetNames.length * ( fps || 1.0 );

    			} else {
    				// ...assume skeletal animation

    				var boneName = '.bones[' + bones[ h ].name + ']';

    				addNonemptyTrack(
    						VectorKeyframeTrack, boneName + '.position',
    						animationKeys, 'pos', tracks );

    				addNonemptyTrack(
    						QuaternionKeyframeTrack, boneName + '.quaternion',
    						animationKeys, 'rot', tracks );

    				addNonemptyTrack(
    						VectorKeyframeTrack, boneName + '.scale',
    						animationKeys, 'scl', tracks );

    			}

    		}

    		if ( tracks.length === 0 ) {

    			return null;

    		}

    		var clip = new AnimationClip( clipName, duration, tracks );

    		return clip;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function MaterialLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;
    	this.textures = {};

    }

    Object.assign( MaterialLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var loader = new XHRLoader( scope.manager );
    		loader.load( url, function ( text ) {

    			onLoad( scope.parse( JSON.parse( text ) ) );

    		}, onProgress, onError );

    	},

    	setTextures: function ( value ) {

    		this.textures = value;

    	},

    	parse: function ( json ) {

    		var textures = this.textures;

    		function getTexture( name ) {

    			if ( textures[ name ] === undefined ) {

    				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

    			}

    			return textures[ name ];

    		}

    		var material = new Materials[ json.type ]();

    		if ( json.uuid !== undefined ) material.uuid = json.uuid;
    		if ( json.name !== undefined ) material.name = json.name;
    		if ( json.color !== undefined ) material.color.setHex( json.color );
    		if ( json.roughness !== undefined ) material.roughness = json.roughness;
    		if ( json.metalness !== undefined ) material.metalness = json.metalness;
    		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
    		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
    		if ( json.shininess !== undefined ) material.shininess = json.shininess;
    		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
    		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
    		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
    		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
    		if ( json.fog !== undefined ) material.fog = json.fog;
    		if ( json.shading !== undefined ) material.shading = json.shading;
    		if ( json.blending !== undefined ) material.blending = json.blending;
    		if ( json.side !== undefined ) material.side = json.side;
    		if ( json.opacity !== undefined ) material.opacity = json.opacity;
    		if ( json.transparent !== undefined ) material.transparent = json.transparent;
    		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
    		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
    		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
    		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
    		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
    		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
    		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
    		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
    		if ( json.skinning !== undefined ) material.skinning = json.skinning;
    		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;

    		// for PointsMaterial

    		if ( json.size !== undefined ) material.size = json.size;
    		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

    		// maps

    		if ( json.map !== undefined ) material.map = getTexture( json.map );

    		if ( json.alphaMap !== undefined ) {

    			material.alphaMap = getTexture( json.alphaMap );
    			material.transparent = true;

    		}

    		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
    		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

    		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
    		if ( json.normalScale !== undefined ) {

    			var normalScale = json.normalScale;

    			if ( Array.isArray( normalScale ) === false ) {

    				// Blender exporter used to export a scalar. See #7459

    				normalScale = [ normalScale, normalScale ];

    			}

    			material.normalScale = new Vector2().fromArray( normalScale );

    		}

    		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
    		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
    		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

    		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
    		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

    		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
    		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

    		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

    		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

    		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

    		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
    		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

    		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
    		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

    		// MultiMaterial

    		if ( json.materials !== undefined ) {

    			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

    				material.materials.push( this.parse( json.materials[ i ] ) );

    			}

    		}

    		return material;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function BufferGeometryLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( BufferGeometryLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var loader = new XHRLoader( scope.manager );
    		loader.load( url, function ( text ) {

    			onLoad( scope.parse( JSON.parse( text ) ) );

    		}, onProgress, onError );

    	},

    	parse: function ( json ) {

    		var geometry = new BufferGeometry();

    		var index = json.data.index;

    		var TYPED_ARRAYS = {
    			'Int8Array': Int8Array,
    			'Uint8Array': Uint8Array,
    			'Uint8ClampedArray': Uint8ClampedArray,
    			'Int16Array': Int16Array,
    			'Uint16Array': Uint16Array,
    			'Int32Array': Int32Array,
    			'Uint32Array': Uint32Array,
    			'Float32Array': Float32Array,
    			'Float64Array': Float64Array
    		};

    		if ( index !== undefined ) {

    			var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
    			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

    		}

    		var attributes = json.data.attributes;

    		for ( var key in attributes ) {

    			var attribute = attributes[ key ];
    			var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

    			geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

    		}

    		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

    		if ( groups !== undefined ) {

    			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

    				var group = groups[ i ];

    				geometry.addGroup( group.start, group.count, group.materialIndex );

    			}

    		}

    		var boundingSphere = json.data.boundingSphere;

    		if ( boundingSphere !== undefined ) {

    			var center = new Vector3();

    			if ( boundingSphere.center !== undefined ) {

    				center.fromArray( boundingSphere.center );

    			}

    			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

    		}

    		return geometry;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function Loader() {

    	this.onLoadStart = function () {};
    	this.onLoadProgress = function () {};
    	this.onLoadComplete = function () {};

    }

    Loader.prototype = {

    	constructor: Loader,

    	crossOrigin: undefined,

    	extractUrlBase: function ( url ) {

    		var parts = url.split( '/' );

    		if ( parts.length === 1 ) return './';

    		parts.pop();

    		return parts.join( '/' ) + '/';

    	},

    	initMaterials: function ( materials, texturePath, crossOrigin ) {

    		var array = [];

    		for ( var i = 0; i < materials.length; ++ i ) {

    			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

    		}

    		return array;

    	},

    	createMaterial: ( function () {

    		var color, textureLoader, materialLoader;

    		return function createMaterial( m, texturePath, crossOrigin ) {

    			if ( color === undefined ) color = new Color();
    			if ( textureLoader === undefined ) textureLoader = new TextureLoader();
    			if ( materialLoader === undefined ) materialLoader = new MaterialLoader();

    			// convert from old material format

    			var textures = {};

    			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

    				var fullPath = texturePath + path;
    				var loader = Loader.Handlers.get( fullPath );

    				var texture;

    				if ( loader !== null ) {

    					texture = loader.load( fullPath );

    				} else {

    					textureLoader.setCrossOrigin( crossOrigin );
    					texture = textureLoader.load( fullPath );

    				}

    				if ( repeat !== undefined ) {

    					texture.repeat.fromArray( repeat );

    					if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
    					if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

    				}

    				if ( offset !== undefined ) {

    					texture.offset.fromArray( offset );

    				}

    				if ( wrap !== undefined ) {

    					if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
    					if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

    					if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
    					if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

    				}

    				if ( anisotropy !== undefined ) {

    					texture.anisotropy = anisotropy;

    				}

    				var uuid = exports.Math.generateUUID();

    				textures[ uuid ] = texture;

    				return uuid;

    			}

    			//

    			var json = {
    				uuid: exports.Math.generateUUID(),
    				type: 'MeshLambertMaterial'
    			};

    			for ( var name in m ) {

    				var value = m[ name ];

    				switch ( name ) {
    					case 'DbgColor':
    					case 'DbgIndex':
    					case 'opticalDensity':
    					case 'illumination':
    						break;
    					case 'DbgName':
    						json.name = value;
    						break;
    					case 'blending':
    						json.blending = BlendingMode[ value ];
    						break;
    					case 'colorAmbient':
    					case 'mapAmbient':
    						console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
    						break;
    					case 'colorDiffuse':
    						json.color = color.fromArray( value ).getHex();
    						break;
    					case 'colorSpecular':
    						json.specular = color.fromArray( value ).getHex();
    						break;
    					case 'colorEmissive':
    						json.emissive = color.fromArray( value ).getHex();
    						break;
    					case 'specularCoef':
    						json.shininess = value;
    						break;
    					case 'shading':
    						if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
    						if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
    						if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
    						break;
    					case 'mapDiffuse':
    						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
    						break;
    					case 'mapDiffuseRepeat':
    					case 'mapDiffuseOffset':
    					case 'mapDiffuseWrap':
    					case 'mapDiffuseAnisotropy':
    						break;
    					case 'mapEmissive':
    						json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
    						break;
    					case 'mapEmissiveRepeat':
    					case 'mapEmissiveOffset':
    					case 'mapEmissiveWrap':
    					case 'mapEmissiveAnisotropy':
    						break;
    					case 'mapLight':
    						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
    						break;
    					case 'mapLightRepeat':
    					case 'mapLightOffset':
    					case 'mapLightWrap':
    					case 'mapLightAnisotropy':
    						break;
    					case 'mapAO':
    						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
    						break;
    					case 'mapAORepeat':
    					case 'mapAOOffset':
    					case 'mapAOWrap':
    					case 'mapAOAnisotropy':
    						break;
    					case 'mapBump':
    						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
    						break;
    					case 'mapBumpScale':
    						json.bumpScale = value;
    						break;
    					case 'mapBumpRepeat':
    					case 'mapBumpOffset':
    					case 'mapBumpWrap':
    					case 'mapBumpAnisotropy':
    						break;
    					case 'mapNormal':
    						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
    						break;
    					case 'mapNormalFactor':
    						json.normalScale = [ value, value ];
    						break;
    					case 'mapNormalRepeat':
    					case 'mapNormalOffset':
    					case 'mapNormalWrap':
    					case 'mapNormalAnisotropy':
    						break;
    					case 'mapSpecular':
    						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
    						break;
    					case 'mapSpecularRepeat':
    					case 'mapSpecularOffset':
    					case 'mapSpecularWrap':
    					case 'mapSpecularAnisotropy':
    						break;
    					case 'mapMetalness':
    						json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
    						break;
    					case 'mapMetalnessRepeat':
    					case 'mapMetalnessOffset':
    					case 'mapMetalnessWrap':
    					case 'mapMetalnessAnisotropy':
    						break;
    					case 'mapRoughness':
    						json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
    						break;
    					case 'mapRoughnessRepeat':
    					case 'mapRoughnessOffset':
    					case 'mapRoughnessWrap':
    					case 'mapRoughnessAnisotropy':
    						break;
    					case 'mapAlpha':
    						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
    						break;
    					case 'mapAlphaRepeat':
    					case 'mapAlphaOffset':
    					case 'mapAlphaWrap':
    					case 'mapAlphaAnisotropy':
    						break;
    					case 'flipSided':
    						json.side = BackSide;
    						break;
    					case 'doubleSided':
    						json.side = DoubleSide;
    						break;
    					case 'transparency':
    						console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
    						json.opacity = value;
    						break;
    					case 'depthTest':
    					case 'depthWrite':
    					case 'colorWrite':
    					case 'opacity':
    					case 'reflectivity':
    					case 'transparent':
    					case 'visible':
    					case 'wireframe':
    						json[ name ] = value;
    						break;
    					case 'vertexColors':
    						if ( value === true ) json.vertexColors = VertexColors;
    						if ( value === 'face' ) json.vertexColors = FaceColors;
    						break;
    					default:
    						console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
    						break;
    				}

    			}

    			if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
    			if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

    			if ( json.opacity < 1 ) json.transparent = true;

    			materialLoader.setTextures( textures );

    			return materialLoader.parse( json );

    		};

    	} )()

    };

    Loader.Handlers = {

    	handlers: [],

    	add: function ( regex, loader ) {

    		this.handlers.push( regex, loader );

    	},

    	get: function ( file ) {

    		var handlers = this.handlers;

    		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

    			var regex = handlers[ i ];
    			var loader  = handlers[ i + 1 ];

    			if ( regex.test( file ) ) {

    				return loader;

    			}

    		}

    		return null;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function JSONLoader( manager ) {

    	if ( typeof manager === 'boolean' ) {

    		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
    		manager = undefined;

    	}

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    	this.withCredentials = false;

    }

    Object.assign( JSONLoader.prototype, {

    	load: function( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );

    		var loader = new XHRLoader( this.manager );
    		loader.setWithCredentials( this.withCredentials );
    		loader.load( url, function ( text ) {

    			var json = JSON.parse( text );
    			var metadata = json.metadata;

    			if ( metadata !== undefined ) {

    				var type = metadata.type;

    				if ( type !== undefined ) {

    					if ( type.toLowerCase() === 'object' ) {

    						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
    						return;

    					}

    					if ( type.toLowerCase() === 'scene' ) {

    						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
    						return;

    					}

    				}

    			}

    			var object = scope.parse( json, texturePath );
    			onLoad( object.geometry, object.materials );

    		}, onProgress, onError );

    	},

    	setTexturePath: function ( value ) {

    		this.texturePath = value;

    	},

    	parse: function ( json, texturePath ) {

    		var geometry = new Geometry(),
    		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

    		parseModel( scale );

    		parseSkin();
    		parseMorphing( scale );
    		parseAnimations();

    		geometry.computeFaceNormals();
    		geometry.computeBoundingSphere();

    		function parseModel( scale ) {

    			function isBitSet( value, position ) {

    				return value & ( 1 << position );

    			}

    			var i, j, fi,

    			offset, zLength,

    		colorIndex, normalIndex, uvIndex, materialIndex,

    			type,
    			isQuad,
    			hasMaterial,
    			hasFaceVertexUv,
    			hasFaceNormal, hasFaceVertexNormal,
    			hasFaceColor, hasFaceVertexColor,

    		vertex, face, faceA, faceB, hex, normal,

    			uvLayer, uv, u, v,

    			faces = json.faces,
    			vertices = json.vertices,
    			normals = json.normals,
    			colors = json.colors,

    			nUvLayers = 0;

    			if ( json.uvs !== undefined ) {

    				// disregard empty arrays

    				for ( i = 0; i < json.uvs.length; i ++ ) {

    					if ( json.uvs[ i ].length ) nUvLayers ++;

    				}

    				for ( i = 0; i < nUvLayers; i ++ ) {

    					geometry.faceVertexUvs[ i ] = [];

    				}

    			}

    			offset = 0;
    			zLength = vertices.length;

    			while ( offset < zLength ) {

    				vertex = new Vector3();

    				vertex.x = vertices[ offset ++ ] * scale;
    				vertex.y = vertices[ offset ++ ] * scale;
    				vertex.z = vertices[ offset ++ ] * scale;

    				geometry.vertices.push( vertex );

    			}

    			offset = 0;
    			zLength = faces.length;

    			while ( offset < zLength ) {

    				type = faces[ offset ++ ];


    				isQuad              = isBitSet( type, 0 );
    				hasMaterial         = isBitSet( type, 1 );
    				hasFaceVertexUv     = isBitSet( type, 3 );
    				hasFaceNormal       = isBitSet( type, 4 );
    				hasFaceVertexNormal = isBitSet( type, 5 );
    				hasFaceColor	     = isBitSet( type, 6 );
    				hasFaceVertexColor  = isBitSet( type, 7 );

    				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

    				if ( isQuad ) {

    					faceA = new Face3();
    					faceA.a = faces[ offset ];
    					faceA.b = faces[ offset + 1 ];
    					faceA.c = faces[ offset + 3 ];

    					faceB = new Face3();
    					faceB.a = faces[ offset + 1 ];
    					faceB.b = faces[ offset + 2 ];
    					faceB.c = faces[ offset + 3 ];

    					offset += 4;

    					if ( hasMaterial ) {

    						materialIndex = faces[ offset ++ ];
    						faceA.materialIndex = materialIndex;
    						faceB.materialIndex = materialIndex;

    					}

    					// to get face <=> uv index correspondence

    					fi = geometry.faces.length;

    					if ( hasFaceVertexUv ) {

    						for ( i = 0; i < nUvLayers; i ++ ) {

    							uvLayer = json.uvs[ i ];

    							geometry.faceVertexUvs[ i ][ fi ] = [];
    							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

    							for ( j = 0; j < 4; j ++ ) {

    								uvIndex = faces[ offset ++ ];

    								u = uvLayer[ uvIndex * 2 ];
    								v = uvLayer[ uvIndex * 2 + 1 ];

    								uv = new Vector2( u, v );

    								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
    								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

    							}

    						}

    					}

    					if ( hasFaceNormal ) {

    						normalIndex = faces[ offset ++ ] * 3;

    						faceA.normal.set(
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ]
    						);

    						faceB.normal.copy( faceA.normal );

    					}

    					if ( hasFaceVertexNormal ) {

    						for ( i = 0; i < 4; i ++ ) {

    							normalIndex = faces[ offset ++ ] * 3;

    							normal = new Vector3(
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ]
    							);


    							if ( i !== 2 ) faceA.vertexNormals.push( normal );
    							if ( i !== 0 ) faceB.vertexNormals.push( normal );

    						}

    					}


    					if ( hasFaceColor ) {

    						colorIndex = faces[ offset ++ ];
    						hex = colors[ colorIndex ];

    						faceA.color.setHex( hex );
    						faceB.color.setHex( hex );

    					}


    					if ( hasFaceVertexColor ) {

    						for ( i = 0; i < 4; i ++ ) {

    							colorIndex = faces[ offset ++ ];
    							hex = colors[ colorIndex ];

    							if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
    							if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

    						}

    					}

    					geometry.faces.push( faceA );
    					geometry.faces.push( faceB );

    				} else {

    					face = new Face3();
    					face.a = faces[ offset ++ ];
    					face.b = faces[ offset ++ ];
    					face.c = faces[ offset ++ ];

    					if ( hasMaterial ) {

    						materialIndex = faces[ offset ++ ];
    						face.materialIndex = materialIndex;

    					}

    					// to get face <=> uv index correspondence

    					fi = geometry.faces.length;

    					if ( hasFaceVertexUv ) {

    						for ( i = 0; i < nUvLayers; i ++ ) {

    							uvLayer = json.uvs[ i ];

    							geometry.faceVertexUvs[ i ][ fi ] = [];

    							for ( j = 0; j < 3; j ++ ) {

    								uvIndex = faces[ offset ++ ];

    								u = uvLayer[ uvIndex * 2 ];
    								v = uvLayer[ uvIndex * 2 + 1 ];

    								uv = new Vector2( u, v );

    								geometry.faceVertexUvs[ i ][ fi ].push( uv );

    							}

    						}

    					}

    					if ( hasFaceNormal ) {

    						normalIndex = faces[ offset ++ ] * 3;

    						face.normal.set(
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ]
    						);

    					}

    					if ( hasFaceVertexNormal ) {

    						for ( i = 0; i < 3; i ++ ) {

    							normalIndex = faces[ offset ++ ] * 3;

    							normal = new Vector3(
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ]
    							);

    							face.vertexNormals.push( normal );

    						}

    					}


    					if ( hasFaceColor ) {

    						colorIndex = faces[ offset ++ ];
    						face.color.setHex( colors[ colorIndex ] );

    					}


    					if ( hasFaceVertexColor ) {

    						for ( i = 0; i < 3; i ++ ) {

    							colorIndex = faces[ offset ++ ];
    							face.vertexColors.push( new Color( colors[ colorIndex ] ) );

    						}

    					}

    					geometry.faces.push( face );

    				}

    			}

    		}

    		function parseSkin() {

    			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

    			if ( json.skinWeights ) {

    				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

    					var x =                               json.skinWeights[ i ];
    					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
    					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
    					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

    					geometry.skinWeights.push( new Vector4( x, y, z, w ) );

    				}

    			}

    			if ( json.skinIndices ) {

    				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

    					var a =                               json.skinIndices[ i ];
    					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
    					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
    					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

    					geometry.skinIndices.push( new Vector4( a, b, c, d ) );

    				}

    			}

    			geometry.bones = json.bones;

    			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

    				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
    					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

    			}

    		}

    		function parseMorphing( scale ) {

    			if ( json.morphTargets !== undefined ) {

    				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

    					geometry.morphTargets[ i ] = {};
    					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
    					geometry.morphTargets[ i ].vertices = [];

    					var dstVertices = geometry.morphTargets[ i ].vertices;
    					var srcVertices = json.morphTargets[ i ].vertices;

    					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

    						var vertex = new Vector3();
    						vertex.x = srcVertices[ v ] * scale;
    						vertex.y = srcVertices[ v + 1 ] * scale;
    						vertex.z = srcVertices[ v + 2 ] * scale;

    						dstVertices.push( vertex );

    					}

    				}

    			}

    			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

    				console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

    				var faces = geometry.faces;
    				var morphColors = json.morphColors[ 0 ].colors;

    				for ( var i = 0, l = faces.length; i < l; i ++ ) {

    					faces[ i ].color.fromArray( morphColors, i * 3 );

    				}

    			}

    		}

    		function parseAnimations() {

    			var outputAnimations = [];

    			// parse old style Bone/Hierarchy animations
    			var animations = [];

    			if ( json.animation !== undefined ) {

    				animations.push( json.animation );

    			}

    			if ( json.animations !== undefined ) {

    				if ( json.animations.length ) {

    					animations = animations.concat( json.animations );

    				} else {

    					animations.push( json.animations );

    				}

    			}

    			for ( var i = 0; i < animations.length; i ++ ) {

    				var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
    				if ( clip ) outputAnimations.push( clip );

    			}

    			// parse implicit morph animations
    			if ( geometry.morphTargets ) {

    				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
    				var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
    				outputAnimations = outputAnimations.concat( morphAnimationClips );

    			}

    			if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

    		}

    		if ( json.materials === undefined || json.materials.length === 0 ) {

    			return { geometry: geometry };

    		} else {

    			var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

    			return { geometry: geometry, materials: materials };

    		}

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function ObjectLoader ( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;
    	this.texturePath = '';

    }

    Object.assign( ObjectLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		if ( this.texturePath === '' ) {

    			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

    		}

    		var scope = this;

    		var loader = new XHRLoader( scope.manager );
    		loader.load( url, function ( text ) {

    			scope.parse( JSON.parse( text ), onLoad );

    		}, onProgress, onError );

    	},

    	setTexturePath: function ( value ) {

    		this.texturePath = value;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;

    	},

    	parse: function ( json, onLoad ) {

    		var geometries = this.parseGeometries( json.geometries );

    		var images = this.parseImages( json.images, function () {

    			if ( onLoad !== undefined ) onLoad( object );

    		} );

    		var textures  = this.parseTextures( json.textures, images );
    		var materials = this.parseMaterials( json.materials, textures );

    		var object = this.parseObject( json.object, geometries, materials );

    		if ( json.animations ) {

    			object.animations = this.parseAnimations( json.animations );

    		}

    		if ( json.images === undefined || json.images.length === 0 ) {

    			if ( onLoad !== undefined ) onLoad( object );

    		}

    		return object;

    	},

    	parseGeometries: function ( json ) {

    		var geometries = {};

    		if ( json !== undefined ) {

    			var geometryLoader = new JSONLoader();
    			var bufferGeometryLoader = new BufferGeometryLoader();

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var geometry;
    				var data = json[ i ];

    				switch ( data.type ) {

    					case 'PlaneGeometry':
    					case 'PlaneBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.width,
    							data.height,
    							data.widthSegments,
    							data.heightSegments
    						);

    						break;

    					case 'BoxGeometry':
    					case 'BoxBufferGeometry':
    					case 'CubeGeometry': // backwards compatible

    						geometry = new Geometries[ data.type ](
    							data.width,
    							data.height,
    							data.depth,
    							data.widthSegments,
    							data.heightSegments,
    							data.depthSegments
    						);

    						break;

    					case 'CircleGeometry':
    					case 'CircleBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.segments,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'CylinderGeometry':
    					case 'CylinderBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radiusTop,
    							data.radiusBottom,
    							data.height,
    							data.radialSegments,
    							data.heightSegments,
    							data.openEnded,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'ConeGeometry':
    					case 'ConeBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.height,
    							data.radialSegments,
    							data.heightSegments,
    							data.openEnded,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'SphereGeometry':
    					case 'SphereBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.widthSegments,
    							data.heightSegments,
    							data.phiStart,
    							data.phiLength,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'DodecahedronGeometry':
    					case 'IcosahedronGeometry':
    					case 'OctahedronGeometry':
    					case 'TetrahedronGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.detail
    						);

    						break;

    					case 'RingGeometry':
    					case 'RingBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.innerRadius,
    							data.outerRadius,
    							data.thetaSegments,
    							data.phiSegments,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'TorusGeometry':
    					case 'TorusBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.tube,
    							data.radialSegments,
    							data.tubularSegments,
    							data.arc
    						);

    						break;

    					case 'TorusKnotGeometry':
    					case 'TorusKnotBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.tube,
    							data.tubularSegments,
    							data.radialSegments,
    							data.p,
    							data.q
    						);

    						break;

    					case 'LatheGeometry':
    					case 'LatheBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.points,
    							data.segments,
    							data.phiStart,
    							data.phiLength
    						);

    						break;

    					case 'BufferGeometry':

    						geometry = bufferGeometryLoader.parse( data );

    						break;

    					case 'Geometry':

    						geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

    						break;

    					default:

    						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

    						continue;

    				}

    				geometry.uuid = data.uuid;

    				if ( data.name !== undefined ) geometry.name = data.name;

    				geometries[ data.uuid ] = geometry;

    			}

    		}

    		return geometries;

    	},

    	parseMaterials: function ( json, textures ) {

    		var materials = {};

    		if ( json !== undefined ) {

    			var loader = new MaterialLoader();
    			loader.setTextures( textures );

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var material = loader.parse( json[ i ] );
    				materials[ material.uuid ] = material;

    			}

    		}

    		return materials;

    	},

    	parseAnimations: function ( json ) {

    		var animations = [];

    		for ( var i = 0; i < json.length; i ++ ) {

    			var clip = AnimationClip.parse( json[ i ] );

    			animations.push( clip );

    		}

    		return animations;

    	},

    	parseImages: function ( json, onLoad ) {

    		var scope = this;
    		var images = {};

    		function loadImage( url ) {

    			scope.manager.itemStart( url );

    			return loader.load( url, function () {

    				scope.manager.itemEnd( url );

    			}, undefined, function () {

    				scope.manager.itemError( url );

    			} );

    		}

    		if ( json !== undefined && json.length > 0 ) {

    			var manager = new LoadingManager( onLoad );

    			var loader = new ImageLoader( manager );
    			loader.setCrossOrigin( this.crossOrigin );

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var image = json[ i ];
    				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

    				images[ image.uuid ] = loadImage( path );

    			}

    		}

    		return images;

    	},

    	parseTextures: function ( json, images ) {

    		function parseConstant( value, type ) {

    			if ( typeof( value ) === 'number' ) return value;

    			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

    			return type[ value ];

    		}

    		var textures = {};

    		if ( json !== undefined ) {

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var data = json[ i ];

    				if ( data.image === undefined ) {

    					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

    				}

    				if ( images[ data.image ] === undefined ) {

    					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

    				}

    				var texture = new Texture( images[ data.image ] );
    				texture.needsUpdate = true;

    				texture.uuid = data.uuid;

    				if ( data.name !== undefined ) texture.name = data.name;

    				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );

    				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
    				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
    				if ( data.wrap !== undefined ) {

    					texture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );
    					texture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );

    				}

    				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );
    				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );
    				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

    				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

    				textures[ data.uuid ] = texture;

    			}

    		}

    		return textures;

    	},

    	parseObject: function () {

    		var matrix = new Matrix4();

    		return function parseObject( data, geometries, materials ) {

    			var object;

    			function getGeometry( name ) {

    				if ( geometries[ name ] === undefined ) {

    					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

    				}

    				return geometries[ name ];

    			}

    			function getMaterial( name ) {

    				if ( name === undefined ) return undefined;

    				if ( materials[ name ] === undefined ) {

    					console.warn( 'THREE.ObjectLoader: Undefined material', name );

    				}

    				return materials[ name ];

    			}

    			switch ( data.type ) {

    				case 'Scene':

    					object = new Scene();

    					if ( data.background !== undefined ) {

    						if ( Number.isInteger( data.background ) ) {

    							object.background = new Color( data.background );

    						}

    					}

    					if ( data.fog !== undefined ) {

    						if ( data.fog.type === 'Fog' ) {

    							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

    						} else if ( data.fog.type === 'FogExp2' ) {

    							object.fog = new FogExp2( data.fog.color, data.fog.density );

    						}

    					}

    					break;

    				case 'PerspectiveCamera':

    					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

    					if ( data.focus !== undefined ) object.focus = data.focus;
    					if ( data.zoom !== undefined ) object.zoom = data.zoom;
    					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
    					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
    					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

    					break;

    				case 'OrthographicCamera':

    					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

    					break;

    				case 'AmbientLight':

    					object = new AmbientLight( data.color, data.intensity );

    					break;

    				case 'DirectionalLight':

    					object = new DirectionalLight( data.color, data.intensity );

    					break;

    				case 'PointLight':

    					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

    					break;

    				case 'SpotLight':

    					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

    					break;

    				case 'HemisphereLight':

    					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

    					break;

    				case 'Mesh':

    					var geometry = getGeometry( data.geometry );
    					var material = getMaterial( data.material );

    					if ( geometry.bones && geometry.bones.length > 0 ) {

    						object = new SkinnedMesh( geometry, material );

    					} else {

    						object = new Mesh( geometry, material );

    					}

    					break;

    				case 'LOD':

    					object = new LOD();

    					break;

    				case 'Line':

    					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

    					break;

    				case 'LineSegments':

    					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

    					break;

    				case 'PointCloud':
    				case 'Points':

    					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

    					break;

    				case 'Sprite':

    					object = new Sprite( getMaterial( data.material ) );

    					break;

    				case 'Group':

    					object = new Group();

    					break;

    				default:

    					object = new Object3D();

    			}

    			object.uuid = data.uuid;

    			if ( data.name !== undefined ) object.name = data.name;
    			if ( data.matrix !== undefined ) {

    				matrix.fromArray( data.matrix );
    				matrix.decompose( object.position, object.quaternion, object.scale );

    			} else {

    				if ( data.position !== undefined ) object.position.fromArray( data.position );
    				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
    				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
    				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

    			}

    			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
    			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

    			if ( data.shadow ) {

    				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
    				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
    				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
    				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

    			}

    			if ( data.visible !== undefined ) object.visible = data.visible;
    			if ( data.userData !== undefined ) object.userData = data.userData;

    			if ( data.children !== undefined ) {

    				for ( var child in data.children ) {

    					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

    				}

    			}

    			if ( data.type === 'LOD' ) {

    				var levels = data.levels;

    				for ( var l = 0; l < levels.length; l ++ ) {

    					var level = levels[ l ];
    					var child = object.getObjectByProperty( 'uuid', level.object );

    					if ( child !== undefined ) {

    						object.addLevel( child, level.distance );

    					}

    				}

    			}

    			return object;

    		};

    	}()

    } );

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Extensible curve object
     *
     * Some common of Curve methods
     * .getPoint(t), getTangent(t)
     * .getPointAt(u), getTangentAt(u)
     * .getPoints(), .getSpacedPoints()
     * .getLength()
     * .updateArcLengths()
     *
     * This following classes subclasses THREE.Curve:
     *
     * -- 2d classes --
     * THREE.LineCurve
     * THREE.QuadraticBezierCurve
     * THREE.CubicBezierCurve
     * THREE.SplineCurve
     * THREE.ArcCurve
     * THREE.EllipseCurve
     *
     * -- 3d classes --
     * THREE.LineCurve3
     * THREE.QuadraticBezierCurve3
     * THREE.CubicBezierCurve3
     * THREE.SplineCurve3
     *
     * A series of curves can be represented as a THREE.CurvePath
     *
     **/

    /**************************************************************
     *	Abstract Curve base class
     **************************************************************/

    function Curve() {}

    Curve.prototype = {

    	constructor: Curve,

    	// Virtual base class method to overwrite and implement in subclasses
    	//	- t [0 .. 1]

    	getPoint: function ( t ) {

    		console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
    		return null;

    	},

    	// Get point at relative position in curve according to arc length
    	// - u [0 .. 1]

    	getPointAt: function ( u ) {

    		var t = this.getUtoTmapping( u );
    		return this.getPoint( t );

    	},

    	// Get sequence of points using getPoint( t )

    	getPoints: function ( divisions ) {

    		if ( ! divisions ) divisions = 5;

    		var points = [];

    		for ( var d = 0; d <= divisions; d ++ ) {

    			points.push( this.getPoint( d / divisions ) );

    		}

    		return points;

    	},

    	// Get sequence of points using getPointAt( u )

    	getSpacedPoints: function ( divisions ) {

    		if ( ! divisions ) divisions = 5;

    		var points = [];

    		for ( var d = 0; d <= divisions; d ++ ) {

    			points.push( this.getPointAt( d / divisions ) );

    		}

    		return points;

    	},

    	// Get total curve arc length

    	getLength: function () {

    		var lengths = this.getLengths();
    		return lengths[ lengths.length - 1 ];

    	},

    	// Get list of cumulative segment lengths

    	getLengths: function ( divisions ) {

    		if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

    		if ( this.cacheArcLengths
    			&& ( this.cacheArcLengths.length === divisions + 1 )
    			&& ! this.needsUpdate ) {

    			//console.log( "cached", this.cacheArcLengths );
    			return this.cacheArcLengths;

    		}

    		this.needsUpdate = false;

    		var cache = [];
    		var current, last = this.getPoint( 0 );
    		var p, sum = 0;

    		cache.push( 0 );

    		for ( p = 1; p <= divisions; p ++ ) {

    			current = this.getPoint ( p / divisions );
    			sum += current.distanceTo( last );
    			cache.push( sum );
    			last = current;

    		}

    		this.cacheArcLengths = cache;

    		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

    	},

    	updateArcLengths: function() {

    		this.needsUpdate = true;
    		this.getLengths();

    	},

    	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

    	getUtoTmapping: function ( u, distance ) {

    		var arcLengths = this.getLengths();

    		var i = 0, il = arcLengths.length;

    		var targetArcLength; // The targeted u distance value to get

    		if ( distance ) {

    			targetArcLength = distance;

    		} else {

    			targetArcLength = u * arcLengths[ il - 1 ];

    		}

    		//var time = Date.now();

    		// binary search for the index with largest value smaller than target u distance

    		var low = 0, high = il - 1, comparison;

    		while ( low <= high ) {

    			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

    			comparison = arcLengths[ i ] - targetArcLength;

    			if ( comparison < 0 ) {

    				low = i + 1;

    			} else if ( comparison > 0 ) {

    				high = i - 1;

    			} else {

    				high = i;
    				break;

    				// DONE

    			}

    		}

    		i = high;

    		//console.log('b' , i, low, high, Date.now()- time);

    		if ( arcLengths[ i ] === targetArcLength ) {

    			var t = i / ( il - 1 );
    			return t;

    		}

    		// we could get finer grain at lengths, or use simple interpolation between two points

    		var lengthBefore = arcLengths[ i ];
    		var lengthAfter = arcLengths[ i + 1 ];

    		var segmentLength = lengthAfter - lengthBefore;

    		// determine where we are between the 'before' and 'after' points

    		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    		// add that fractional amount to t

    		var t = ( i + segmentFraction ) / ( il - 1 );

    		return t;

    	},

    	// Returns a unit vector tangent at t
    	// In case any sub curve does not implement its tangent derivation,
    	// 2 points a small delta apart will be used to find its gradient
    	// which seems to give a reasonable approximation

    	getTangent: function( t ) {

    		var delta = 0.0001;
    		var t1 = t - delta;
    		var t2 = t + delta;

    		// Capping in case of danger

    		if ( t1 < 0 ) t1 = 0;
    		if ( t2 > 1 ) t2 = 1;

    		var pt1 = this.getPoint( t1 );
    		var pt2 = this.getPoint( t2 );

    		var vec = pt2.clone().sub( pt1 );
    		return vec.normalize();

    	},

    	getTangentAt: function ( u ) {

    		var t = this.getUtoTmapping( u );
    		return this.getTangent( t );

    	}

    };

    // TODO: Transformation for Curves?

    /**************************************************************
     *	3D Curves
     **************************************************************/

    // A Factory method for creating new curve subclasses

    Curve.create = function ( constructor, getPointFunc ) {

    	constructor.prototype = Object.create( Curve.prototype );
    	constructor.prototype.constructor = constructor;
    	constructor.prototype.getPoint = getPointFunc;

    	return constructor;

    };

    /**************************************************************
     *	Line
     **************************************************************/

    function LineCurve( v1, v2 ) {

    	this.v1 = v1;
    	this.v2 = v2;

    }

    LineCurve.prototype = Object.create( Curve.prototype );
    LineCurve.prototype.constructor = LineCurve;

    LineCurve.prototype.isLineCurve = true;

    LineCurve.prototype.getPoint = function ( t ) {

    	if ( t === 1 ) {

    		return this.v2.clone();

    	}

    	var point = this.v2.clone().sub( this.v1 );
    	point.multiplyScalar( t ).add( this.v1 );

    	return point;

    };

    // Line curve is linear, so we can overwrite default getPointAt

    LineCurve.prototype.getPointAt = function ( u ) {

    	return this.getPoint( u );

    };

    LineCurve.prototype.getTangent = function( t ) {

    	var tangent = this.v2.clone().sub( this.v1 );

    	return tangent.normalize();

    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     **/

    /**************************************************************
     *	Curved Path - a curve path is simply a array of connected
     *  curves, but retains the api of a curve
     **************************************************************/

    function CurvePath() {

    	this.curves = [];

    	this.autoClose = false; // Automatically closes the path

    }

    CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

    	constructor: CurvePath,

    	add: function ( curve ) {

    		this.curves.push( curve );

    	},

    	closePath: function () {

    		// Add a line curve if start and end of lines are not connected
    		var startPoint = this.curves[ 0 ].getPoint( 0 );
    		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

    		if ( ! startPoint.equals( endPoint ) ) {

    			this.curves.push( new LineCurve( endPoint, startPoint ) );

    		}

    	},

    	// To get accurate point with reference to
    	// entire path distance at time t,
    	// following has to be done:

    	// 1. Length of each sub path have to be known
    	// 2. Locate and identify type of curve
    	// 3. Get t for the curve
    	// 4. Return curve.getPointAt(t')

    	getPoint: function ( t ) {

    		var d = t * this.getLength();
    		var curveLengths = this.getCurveLengths();
    		var i = 0;

    		// To think about boundaries points.

    		while ( i < curveLengths.length ) {

    			if ( curveLengths[ i ] >= d ) {

    				var diff = curveLengths[ i ] - d;
    				var curve = this.curves[ i ];

    				var segmentLength = curve.getLength();
    				var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

    				return curve.getPointAt( u );

    			}

    			i ++;

    		}

    		return null;

    		// loop where sum != 0, sum > d , sum+1 <d

    	},

    	// We cannot use the default THREE.Curve getPoint() with getLength() because in
    	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    	// getPoint() depends on getLength

    	getLength: function () {

    		var lens = this.getCurveLengths();
    		return lens[ lens.length - 1 ];

    	},

    	// cacheLengths must be recalculated.
    	updateArcLengths: function () {

    		this.needsUpdate = true;
    		this.cacheLengths = null;
    		this.getLengths();

    	},

    	// Compute lengths and cache them
    	// We cannot overwrite getLengths() because UtoT mapping uses it.

    	getCurveLengths: function () {

    		// We use cache values if curves and cache array are same length

    		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

    			return this.cacheLengths;

    		}

    		// Get length of sub-curve
    		// Push sums into cached array

    		var lengths = [], sums = 0;

    		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

    			sums += this.curves[ i ].getLength();
    			lengths.push( sums );

    		}

    		this.cacheLengths = lengths;

    		return lengths;

    	},

    	getSpacedPoints: function ( divisions ) {

    		if ( ! divisions ) divisions = 40;

    		var points = [];

    		for ( var i = 0; i <= divisions; i ++ ) {

    			points.push( this.getPoint( i / divisions ) );

    		}

    		if ( this.autoClose ) {

    			points.push( points[ 0 ] );

    		}

    		return points;

    	},

    	getPoints: function ( divisions ) {

    		divisions = divisions || 12;

    		var points = [], last;

    		for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

    			var curve = curves[ i ];
    			var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
    				: (curve && curve.isLineCurve) ? 1
    				: (curve && curve.isSplineCurve) ? divisions * curve.points.length
    				: divisions;

    			var pts = curve.getPoints( resolution );

    			for ( var j = 0; j < pts.length; j++ ) {

    				var point = pts[ j ];

    				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

    				points.push( point );
    				last = point;

    			}

    		}

    		if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {

    			points.push( points[ 0 ] );

    		}

    		return points;

    	},

    	/**************************************************************
    	 *	Create Geometries Helpers
    	 **************************************************************/

    	/// Generate geometry from path points (for Line or Points objects)

    	createPointsGeometry: function ( divisions ) {

    		var pts = this.getPoints( divisions );
    		return this.createGeometry( pts );

    	},

    	// Generate geometry from equidistant sampling along the path

    	createSpacedPointsGeometry: function ( divisions ) {

    		var pts = this.getSpacedPoints( divisions );
    		return this.createGeometry( pts );

    	},

    	createGeometry: function ( points ) {

    		var geometry = new Geometry();

    		for ( var i = 0, l = points.length; i < l; i ++ ) {

    			var point = points[ i ];
    			geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

    		}

    		return geometry;

    	}

    } );

    /**************************************************************
     *	Ellipse curve
     **************************************************************/

    function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    	this.aX = aX;
    	this.aY = aY;

    	this.xRadius = xRadius;
    	this.yRadius = yRadius;

    	this.aStartAngle = aStartAngle;
    	this.aEndAngle = aEndAngle;

    	this.aClockwise = aClockwise;

    	this.aRotation = aRotation || 0;

    }

    EllipseCurve.prototype = Object.create( Curve.prototype );
    EllipseCurve.prototype.constructor = EllipseCurve;

    EllipseCurve.prototype.isEllipseCurve = true;

    EllipseCurve.prototype.getPoint = function( t ) {

    	var twoPi = Math.PI * 2;
    	var deltaAngle = this.aEndAngle - this.aStartAngle;
    	var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

    	// ensures that deltaAngle is 0 .. 2 PI
    	while ( deltaAngle < 0 ) deltaAngle += twoPi;
    	while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

    	if ( deltaAngle < Number.EPSILON ) {

    		if ( samePoints ) {

    			deltaAngle = 0;

    		} else {

    			deltaAngle = twoPi;

    		}

    	}

    	if ( this.aClockwise === true && ! samePoints ) {

    		if ( deltaAngle === twoPi ) {

    			deltaAngle = - twoPi;

    		} else {

    			deltaAngle = deltaAngle - twoPi;

    		}

    	}

    	var angle = this.aStartAngle + t * deltaAngle;
    	var x = this.aX + this.xRadius * Math.cos( angle );
    	var y = this.aY + this.yRadius * Math.sin( angle );

    	if ( this.aRotation !== 0 ) {

    		var cos = Math.cos( this.aRotation );
    		var sin = Math.sin( this.aRotation );

    		var tx = x - this.aX;
    		var ty = y - this.aY;

    		// Rotate the point about the center of the ellipse.
    		x = tx * cos - ty * sin + this.aX;
    		y = tx * sin + ty * cos + this.aY;

    	}

    	return new Vector2( x, y );

    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */

    exports.CurveUtils = {

    	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

    		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

    	},

    	// Puay Bing, thanks for helping with this derivative!

    	tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

    		return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
    			3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
    			6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
    			3 * t * t * p3;

    	},

    	tangentSpline: function ( t, p0, p1, p2, p3 ) {

    		// To check if my formulas are correct

    		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3  3t^2 + 1
    		var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
    		var h01 = - 6 * t * t + 6 * t; 	//  2t3 + 3t2
    		var h11 = 3 * t * t - 2 * t;	// t3  t2

    		return h00 + h10 + h01 + h11;

    	},

    	// Catmull-Rom

    	interpolate: function( p0, p1, p2, p3, t ) {

    		var v0 = ( p2 - p0 ) * 0.5;
    		var v1 = ( p3 - p1 ) * 0.5;
    		var t2 = t * t;
    		var t3 = t * t2;
    		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    	}

    };

    /**************************************************************
     *	Spline curve
     **************************************************************/

    function SplineCurve( points /* array of Vector2 */ ) {

    	this.points = ( points === undefined ) ? [] : points;

    }

    SplineCurve.prototype = Object.create( Curve.prototype );
    SplineCurve.prototype.constructor = SplineCurve;

    SplineCurve.prototype.isSplineCurve = true;

    SplineCurve.prototype.getPoint = function ( t ) {

    	var points = this.points;
    	var point = ( points.length - 1 ) * t;

    	var intPoint = Math.floor( point );
    	var weight = point - intPoint;

    	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
    	var point1 = points[ intPoint ];
    	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    	var interpolate = exports.CurveUtils.interpolate;

    	return new Vector2(
    		interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
    		interpolate( point0.y, point1.y, point2.y, point3.y, weight )
    	);

    };

    /**************************************************************
     *	Cubic Bezier curve
     **************************************************************/

    function CubicBezierCurve( v0, v1, v2, v3 ) {

    	this.v0 = v0;
    	this.v1 = v1;
    	this.v2 = v2;
    	this.v3 = v3;

    }

    CubicBezierCurve.prototype = Object.create( Curve.prototype );
    CubicBezierCurve.prototype.constructor = CubicBezierCurve;

    CubicBezierCurve.prototype.getPoint = function ( t ) {

    	var b3 = exports.ShapeUtils.b3;

    	return new Vector2(
    		b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
    		b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
    	);

    };

    CubicBezierCurve.prototype.getTangent = function( t ) {

    	var tangentCubicBezier = exports.CurveUtils.tangentCubicBezier;

    	return new Vector2(
    		tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
    		tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
    	).normalize();

    };

    /**************************************************************
     *	Quadratic Bezier curve
     **************************************************************/


    function QuadraticBezierCurve( v0, v1, v2 ) {

    	this.v0 = v0;
    	this.v1 = v1;
    	this.v2 = v2;

    }

    QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
    QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;


    QuadraticBezierCurve.prototype.getPoint = function ( t ) {

    	var b2 = exports.ShapeUtils.b2;

    	return new Vector2(
    		b2( t, this.v0.x, this.v1.x, this.v2.x ),
    		b2( t, this.v0.y, this.v1.y, this.v2.y )
    	);

    };


    QuadraticBezierCurve.prototype.getTangent = function( t ) {

    	var tangentQuadraticBezier = exports.CurveUtils.tangentQuadraticBezier;

    	return new Vector2(
    		tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
    		tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
    	).normalize();

    };

    var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {

    	fromPoints: function ( vectors ) {

    		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

    		for ( var i = 1, l = vectors.length; i < l; i ++ ) {

    			this.lineTo( vectors[ i ].x, vectors[ i ].y );

    		}

    	},

    	moveTo: function ( x, y ) {

    		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

    	},

    	lineTo: function ( x, y ) {

    		var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
    		this.curves.push( curve );

    		this.currentPoint.set( x, y );

    	},

    	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

    		var curve = new QuadraticBezierCurve(
    			this.currentPoint.clone(),
    			new Vector2( aCPx, aCPy ),
    			new Vector2( aX, aY )
    		);

    		this.curves.push( curve );

    		this.currentPoint.set( aX, aY );

    	},

    	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

    		var curve = new CubicBezierCurve(
    			this.currentPoint.clone(),
    			new Vector2( aCP1x, aCP1y ),
    			new Vector2( aCP2x, aCP2y ),
    			new Vector2( aX, aY )
    		);

    		this.curves.push( curve );

    		this.currentPoint.set( aX, aY );

    	},

    	splineThru: function ( pts /*Array of Vector*/ ) {

    		var npts = [ this.currentPoint.clone() ].concat( pts );

    		var curve = new SplineCurve( npts );
    		this.curves.push( curve );

    		this.currentPoint.copy( pts[ pts.length - 1 ] );

    	},

    	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    		var x0 = this.currentPoint.x;
    		var y0 = this.currentPoint.y;

    		this.absarc( aX + x0, aY + y0, aRadius,
    			aStartAngle, aEndAngle, aClockwise );

    	},

    	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

    	},

    	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    		var x0 = this.currentPoint.x;
    		var y0 = this.currentPoint.y;

    		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

    	},

    	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    		var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

    		if ( this.curves.length > 0 ) {

    			// if a previous curve is present, attempt to join
    			var firstPoint = curve.getPoint( 0 );

    			if ( ! firstPoint.equals( this.currentPoint ) ) {

    				this.lineTo( firstPoint.x, firstPoint.y );

    			}

    		}

    		this.curves.push( curve );

    		var lastPoint = curve.getPoint( 1 );
    		this.currentPoint.copy( lastPoint );

    	}

    } );

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Defines a 2d shape plane using paths.
     **/

    // STEP 1 Create a path.
    // STEP 2 Turn path into shape.
    // STEP 3 ExtrudeGeometry takes in Shape/Shapes
    // STEP 3a - Extract points from each shape, turn to vertices
    // STEP 3b - Triangulate each shape, add faces.

    function Shape() {

    	Path.apply( this, arguments );

    	this.holes = [];

    }

    Shape.prototype = Object.assign( Object.create( PathPrototype ), {

    	constructor: Shape,

    	getPointsHoles: function ( divisions ) {

    		var holesPts = [];

    		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

    			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

    		}

    		return holesPts;

    	},

    	// Get points of shape and holes (keypoints based on segments parameter)

    	extractAllPoints: function ( divisions ) {

    		return {

    			shape: this.getPoints( divisions ),
    			holes: this.getPointsHoles( divisions )

    		};

    	},

    	extractPoints: function ( divisions ) {

    		return this.extractAllPoints( divisions );

    	}

    } );

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Creates free form 2d path using series of points, lines or curves.
     *
     **/

    function Path( points ) {

    	CurvePath.call( this );
    	this.currentPoint = new Vector2();

    	if ( points ) {

    		this.fromPoints( points );

    	}

    }

    Path.prototype = PathPrototype;
    PathPrototype.constructor = Path;


    // minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
    function ShapePath() {
    	this.subPaths = [];
    	this.currentPath = null;
    }

    ShapePath.prototype = {
    	moveTo: function ( x, y ) {
    		this.currentPath = new Path();
    		this.subPaths.push(this.currentPath);
    		this.currentPath.moveTo( x, y );
    	},
    	lineTo: function ( x, y ) {
    		this.currentPath.lineTo( x, y );
    	},
    	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
    		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
    	},
    	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
    		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
    	},
    	splineThru: function ( pts ) {
    		this.currentPath.splineThru( pts );
    	},

    	toShapes: function ( isCCW, noHoles ) {

    		function toShapesNoHoles( inSubpaths ) {

    			var shapes = [];

    			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

    				var tmpPath = inSubpaths[ i ];

    				var tmpShape = new Shape();
    				tmpShape.curves = tmpPath.curves;

    				shapes.push( tmpShape );

    			}

    			return shapes;

    		}

    		function isPointInsidePolygon( inPt, inPolygon ) {

    			var polyLen = inPolygon.length;

    			// inPt on polygon contour => immediate success    or
    			// toggling of inside/outside at every single! intersection point of an edge
    			//  with the horizontal line through inPt, left of inPt
    			//  not counting lowerY endpoints of edges and whole edges on that line
    			var inside = false;
    			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

    				var edgeLowPt  = inPolygon[ p ];
    				var edgeHighPt = inPolygon[ q ];

    				var edgeDx = edgeHighPt.x - edgeLowPt.x;
    				var edgeDy = edgeHighPt.y - edgeLowPt.y;

    				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

    					// not parallel
    					if ( edgeDy < 0 ) {

    						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
    						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

    					}
    					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

    					if ( inPt.y === edgeLowPt.y ) {

    						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
    						// continue;				// no intersection or edgeLowPt => doesn't count !!!

    					} else {

    						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
    						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
    						if ( perpEdge < 0 ) 				continue;
    						inside = ! inside;		// true intersection left of inPt

    					}

    				} else {

    					// parallel or collinear
    					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
    					// edge lies on the same horizontal line as inPt
    					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
    						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
    					// continue;

    				}

    			}

    			return	inside;

    		}

    		var isClockWise = exports.ShapeUtils.isClockWise;

    		var subPaths = this.subPaths;
    		if ( subPaths.length === 0 ) return [];

    		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


    		var solid, tmpPath, tmpShape, shapes = [];

    		if ( subPaths.length === 1 ) {

    			tmpPath = subPaths[ 0 ];
    			tmpShape = new Shape();
    			tmpShape.curves = tmpPath.curves;
    			shapes.push( tmpShape );
    			return shapes;

    		}

    		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
    		holesFirst = isCCW ? ! holesFirst : holesFirst;

    		// console.log("Holes first", holesFirst);

    		var betterShapeHoles = [];
    		var newShapes = [];
    		var newShapeHoles = [];
    		var mainIdx = 0;
    		var tmpPoints;

    		newShapes[ mainIdx ] = undefined;
    		newShapeHoles[ mainIdx ] = [];

    		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

    			tmpPath = subPaths[ i ];
    			tmpPoints = tmpPath.getPoints();
    			solid = isClockWise( tmpPoints );
    			solid = isCCW ? ! solid : solid;

    			if ( solid ) {

    				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

    				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
    				newShapes[ mainIdx ].s.curves = tmpPath.curves;

    				if ( holesFirst )	mainIdx ++;
    				newShapeHoles[ mainIdx ] = [];

    				//console.log('cw', i);

    			} else {

    				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

    				//console.log('ccw', i);

    			}

    		}

    		// only Holes? -> probably all Shapes with wrong orientation
    		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


    		if ( newShapes.length > 1 ) {

    			var ambiguous = false;
    			var toChange = [];

    			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

    				betterShapeHoles[ sIdx ] = [];

    			}

    			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

    				var sho = newShapeHoles[ sIdx ];

    				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

    					var ho = sho[ hIdx ];
    					var hole_unassigned = true;

    					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

    						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

    							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
    							if ( hole_unassigned ) {

    								hole_unassigned = false;
    								betterShapeHoles[ s2Idx ].push( ho );

    							} else {

    								ambiguous = true;

    							}

    						}

    					}
    					if ( hole_unassigned ) {

    						betterShapeHoles[ sIdx ].push( ho );

    					}

    				}

    			}
    			// console.log("ambiguous: ", ambiguous);
    			if ( toChange.length > 0 ) {

    				// console.log("to change: ", toChange);
    				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

    			}

    		}

    		var tmpHoles;

    		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

    			tmpShape = newShapes[ i ].s;
    			shapes.push( tmpShape );
    			tmpHoles = newShapeHoles[ i ];

    			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

    				tmpShape.holes.push( tmpHoles[ j ].h );

    			}

    		}

    		//console.log("shape", shapes);

    		return shapes;

    	}
    }

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author mrdoob / http://mrdoob.com/
     */

    function Font( data ) {

    	this.data = data;

    }

    Object.assign( Font.prototype, {

    	isFont: true,

    	generateShapes: function ( text, size, divisions ) {

    		function createPaths( text ) {

    			var chars = String( text ).split( '' );
    			var scale = size / data.resolution;
    			var offset = 0;

    			var paths = [];

    			for ( var i = 0; i < chars.length; i ++ ) {

    				var ret = createPath( chars[ i ], scale, offset );
    				offset += ret.offset;

    				paths.push( ret.path );

    			}

    			return paths;

    		}

    		function createPath( c, scale, offset ) {

    			var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

    			if ( ! glyph ) return;

    			var path = new ShapePath();

    			var pts = [], b2 = exports.ShapeUtils.b2, b3 = exports.ShapeUtils.b3;
    			var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

    			if ( glyph.o ) {

    				var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

    				for ( var i = 0, l = outline.length; i < l; ) {

    					var action = outline[ i ++ ];

    					switch ( action ) {

    						case 'm': // moveTo

    							x = outline[ i ++ ] * scale + offset;
    							y = outline[ i ++ ] * scale;

    							path.moveTo( x, y );

    							break;

    						case 'l': // lineTo

    							x = outline[ i ++ ] * scale + offset;
    							y = outline[ i ++ ] * scale;

    							path.lineTo( x, y );

    							break;

    						case 'q': // quadraticCurveTo

    							cpx  = outline[ i ++ ] * scale + offset;
    							cpy  = outline[ i ++ ] * scale;
    							cpx1 = outline[ i ++ ] * scale + offset;
    							cpy1 = outline[ i ++ ] * scale;

    							path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

    							laste = pts[ pts.length - 1 ];

    							if ( laste ) {

    								cpx0 = laste.x;
    								cpy0 = laste.y;

    								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

    									var t = i2 / divisions;
    									b2( t, cpx0, cpx1, cpx );
    									b2( t, cpy0, cpy1, cpy );

    								}

    							}

    							break;

    						case 'b': // bezierCurveTo

    							cpx  = outline[ i ++ ] * scale + offset;
    							cpy  = outline[ i ++ ] * scale;
    							cpx1 = outline[ i ++ ] * scale + offset;
    							cpy1 = outline[ i ++ ] * scale;
    							cpx2 = outline[ i ++ ] * scale + offset;
    							cpy2 = outline[ i ++ ] * scale;

    							path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

    							laste = pts[ pts.length - 1 ];

    							if ( laste ) {

    								cpx0 = laste.x;
    								cpy0 = laste.y;

    								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

    									var t = i2 / divisions;
    									b3( t, cpx0, cpx1, cpx2, cpx );
    									b3( t, cpy0, cpy1, cpy2, cpy );

    								}

    							}

    							break;

    					}

    				}

    			}

    			return { offset: glyph.ha * scale, path: path };

    		}

    		//

    		if ( size === undefined ) size = 100;
    		if ( divisions === undefined ) divisions = 4;

    		var data = this.data;

    		var paths = createPaths( text );
    		var shapes = [];

    		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

    			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

    		}

    		return shapes;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function FontLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( FontLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var loader = new XHRLoader( this.manager );
    		loader.load( url, function ( text ) {

    			var json;

    			try {

    				json = JSON.parse( text );

    			} catch ( e ) {

    				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
    				json = JSON.parse( text.substring( 65, text.length - 2 ) );

    			}

    			var font = scope.parse( json );

    			if ( onLoad ) onLoad( font );

    		}, onProgress, onError );

    	},

    	parse: function ( json ) {

    		return new Font( json );

    	}

    } );

    var context;

    function getAudioContext() {

    	if ( context === undefined ) {

    		context = new ( window.AudioContext || window.webkitAudioContext )();

    	}

    	return context;

    }

    /**
     * @author Reece Aaron Lecrivain / http://reecenotes.com/
     */

    function AudioLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( AudioLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var loader = new XHRLoader( this.manager );
    		loader.setResponseType( 'arraybuffer' );
    		loader.load( url, function ( buffer ) {

    			var context = getAudioContext();

    			context.decodeAudioData( buffer, function ( audioBuffer ) {

    				onLoad( audioBuffer );

    			} );

    		}, onProgress, onError );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function StereoCamera() {

    	this.type = 'StereoCamera';

    	this.aspect = 1;

    	this.eyeSep = 0.064;

    	this.cameraL = new PerspectiveCamera();
    	this.cameraL.layers.enable( 1 );
    	this.cameraL.matrixAutoUpdate = false;

    	this.cameraR = new PerspectiveCamera();
    	this.cameraR.layers.enable( 2 );
    	this.cameraR.matrixAutoUpdate = false;

    }

    Object.assign( StereoCamera.prototype, {

    	update: ( function () {

    		var instance, focus, fov, aspect, near, far, zoom;

    		var eyeRight = new Matrix4();
    		var eyeLeft = new Matrix4();

    		return function update( camera ) {

    			var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
    												aspect !== camera.aspect * this.aspect || near !== camera.near ||
    												far !== camera.far || zoom !== camera.zoom;

    			if ( needsUpdate ) {

    				instance = this;
    				focus = camera.focus;
    				fov = camera.fov;
    				aspect = camera.aspect * this.aspect;
    				near = camera.near;
    				far = camera.far;
    				zoom = camera.zoom;

    				// Off-axis stereoscopic effect based on
    				// http://paulbourke.net/stereographics/stereorender/

    				var projectionMatrix = camera.projectionMatrix.clone();
    				var eyeSep = this.eyeSep / 2;
    				var eyeSepOnProjection = eyeSep * near / focus;
    				var ymax = ( near * Math.tan( exports.Math.DEG2RAD * fov * 0.5 ) ) / zoom;
    				var xmin, xmax;

    				// translate xOffset

    				eyeLeft.elements[ 12 ] = - eyeSep;
    				eyeRight.elements[ 12 ] = eyeSep;

    				// for left eye

    				xmin = - ymax * aspect + eyeSepOnProjection;
    				xmax = ymax * aspect + eyeSepOnProjection;

    				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
    				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

    				this.cameraL.projectionMatrix.copy( projectionMatrix );

    				// for right eye

    				xmin = - ymax * aspect - eyeSepOnProjection;
    				xmax = ymax * aspect - eyeSepOnProjection;

    				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
    				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

    				this.cameraR.projectionMatrix.copy( projectionMatrix );

    			}

    			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
    			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

    		};

    	} )()

    } );

    /**
     * Camera for rendering cube maps
     *	- renders scene into axis-aligned cube
     *
     * @author alteredq / http://alteredqualia.com/
     */

    function CubeCamera( near, far, cubeResolution ) {

    	Object3D.call( this );

    	this.type = 'CubeCamera';

    	var fov = 90, aspect = 1;

    	var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
    	cameraPX.up.set( 0, - 1, 0 );
    	cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
    	this.add( cameraPX );

    	var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
    	cameraNX.up.set( 0, - 1, 0 );
    	cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
    	this.add( cameraNX );

    	var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
    	cameraPY.up.set( 0, 0, 1 );
    	cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
    	this.add( cameraPY );

    	var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
    	cameraNY.up.set( 0, 0, - 1 );
    	cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
    	this.add( cameraNY );

    	var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
    	cameraPZ.up.set( 0, - 1, 0 );
    	cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
    	this.add( cameraPZ );

    	var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
    	cameraNZ.up.set( 0, - 1, 0 );
    	cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
    	this.add( cameraNZ );

    	var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

    	this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );

    	this.updateCubeMap = function ( renderer, scene ) {

    		if ( this.parent === null ) this.updateMatrixWorld();

    		var renderTarget = this.renderTarget;
    		var generateMipmaps = renderTarget.texture.generateMipmaps;

    		renderTarget.texture.generateMipmaps = false;

    		renderTarget.activeCubeFace = 0;
    		renderer.render( scene, cameraPX, renderTarget );

    		renderTarget.activeCubeFace = 1;
    		renderer.render( scene, cameraNX, renderTarget );

    		renderTarget.activeCubeFace = 2;
    		renderer.render( scene, cameraPY, renderTarget );

    		renderTarget.activeCubeFace = 3;
    		renderer.render( scene, cameraNY, renderTarget );

    		renderTarget.activeCubeFace = 4;
    		renderer.render( scene, cameraPZ, renderTarget );

    		renderTarget.texture.generateMipmaps = generateMipmaps;

    		renderTarget.activeCubeFace = 5;
    		renderer.render( scene, cameraNZ, renderTarget );

    		renderer.setRenderTarget( null );

    	};

    }

    CubeCamera.prototype = Object.create( Object3D.prototype );
    CubeCamera.prototype.constructor = CubeCamera;

    function AudioListener() {

    	Object3D.call( this );

    	this.type = 'AudioListener';

    	this.context = getAudioContext();

    	this.gain = this.context.createGain();
    	this.gain.connect( this.context.destination );

    	this.filter = null;

    }

    AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: AudioListener,

    	getInput: function () {

    		return this.gain;

    	},

    	removeFilter: function ( ) {

    		if ( this.filter !== null ) {

    			this.gain.disconnect( this.filter );
    			this.filter.disconnect( this.context.destination );
    			this.gain.connect( this.context.destination );
    			this.filter = null;

    		}

    	},

    	getFilter: function () {

    		return this.filter;

    	},

    	setFilter: function ( value ) {

    		if ( this.filter !== null ) {

    			this.gain.disconnect( this.filter );
    			this.filter.disconnect( this.context.destination );

    		} else {

    			this.gain.disconnect( this.context.destination );

    		}

    		this.filter = value;
    		this.gain.connect( this.filter );
    		this.filter.connect( this.context.destination );

    	},

    	getMasterVolume: function () {

    		return this.gain.gain.value;

    	},

    	setMasterVolume: function ( value ) {

    		this.gain.gain.value = value;

    	},

    	updateMatrixWorld: ( function () {

    		var position = new Vector3();
    		var quaternion = new Quaternion();
    		var scale = new Vector3();

    		var orientation = new Vector3();

    		return function updateMatrixWorld( force ) {

    			Object3D.prototype.updateMatrixWorld.call( this, force );

    			var listener = this.context.listener;
    			var up = this.up;

    			this.matrixWorld.decompose( position, quaternion, scale );

    			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

    			listener.setPosition( position.x, position.y, position.z );
    			listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

    		};

    	} )()

    } );

    function Audio( listener ) {

    	Object3D.call( this );

    	this.type = 'Audio';

    	this.context = listener.context;
    	this.source = this.context.createBufferSource();
    	this.source.onended = this.onEnded.bind( this );

    	this.gain = this.context.createGain();
    	this.gain.connect( listener.getInput() );

    	this.autoplay = false;

    	this.startTime = 0;
    	this.playbackRate = 1;
    	this.isPlaying = false;
    	this.hasPlaybackControl = true;
    	this.sourceType = 'empty';

    	this.filters = [];

    }

    Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Audio,

    	getOutput: function () {

    		return this.gain;

    	},

    	setNodeSource: function ( audioNode ) {

    		this.hasPlaybackControl = false;
    		this.sourceType = 'audioNode';
    		this.source = audioNode;
    		this.connect();

    		return this;

    	},

    	setBuffer: function ( audioBuffer ) {

    		this.source.buffer = audioBuffer;
    		this.sourceType = 'buffer';

    		if ( this.autoplay ) this.play();

    		return this;

    	},

    	play: function () {

    		if ( this.isPlaying === true ) {

    			console.warn( 'THREE.Audio: Audio is already playing.' );
    			return;

    		}

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		var source = this.context.createBufferSource();

    		source.buffer = this.source.buffer;
    		source.loop = this.source.loop;
    		source.onended = this.source.onended;
    		source.start( 0, this.startTime );
    		source.playbackRate.value = this.playbackRate;

    		this.isPlaying = true;

    		this.source = source;

    		return this.connect();

    	},

    	pause: function () {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.source.stop();
    		this.startTime = this.context.currentTime;
    		this.isPlaying = false;

    		return this;

    	},

    	stop: function () {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.source.stop();
    		this.startTime = 0;
    		this.isPlaying = false;

    		return this;

    	},

    	connect: function () {

    		if ( this.filters.length > 0 ) {

    			this.source.connect( this.filters[ 0 ] );

    			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

    				this.filters[ i - 1 ].connect( this.filters[ i ] );

    			}

    			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

    		} else {

    			this.source.connect( this.getOutput() );

    		}

    		return this;

    	},

    	disconnect: function () {

    		if ( this.filters.length > 0 ) {

    			this.source.disconnect( this.filters[ 0 ] );

    			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

    				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

    			}

    			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

    		} else {

    			this.source.disconnect( this.getOutput() );

    		}

    		return this;

    	},

    	getFilters: function () {

    		return this.filters;

    	},

    	setFilters: function ( value ) {

    		if ( ! value ) value = [];

    		if ( this.isPlaying === true ) {

    			this.disconnect();
    			this.filters = value;
    			this.connect();

    		} else {

    			this.filters = value;

    		}

    		return this;

    	},

    	getFilter: function () {

    		return this.getFilters()[ 0 ];

    	},

    	setFilter: function ( filter ) {

    		return this.setFilters( filter ? [ filter ] : [] );

    	},

    	setPlaybackRate: function ( value ) {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.playbackRate = value;

    		if ( this.isPlaying === true ) {

    			this.source.playbackRate.value = this.playbackRate;

    		}

    		return this;

    	},

    	getPlaybackRate: function () {

    		return this.playbackRate;

    	},

    	onEnded: function () {

    		this.isPlaying = false;

    	},

    	getLoop: function () {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return false;

    		}

    		return this.source.loop;

    	},

    	setLoop: function ( value ) {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.source.loop = value;

    	},

    	getVolume: function () {

    		return this.gain.gain.value;

    	},


    	setVolume: function ( value ) {

    		this.gain.gain.value = value;

    		return this;

    	}

    } );

    function PositionalAudio( listener ) {

    	Audio.call( this, listener );

    	this.panner = this.context.createPanner();
    	this.panner.connect( this.gain );

    }

    PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

    	constructor: PositionalAudio,

    	getOutput: function () {

    		return this.panner;

    	},

    	getRefDistance: function () {

    		return this.panner.refDistance;

    	},

    	setRefDistance: function ( value ) {

    		this.panner.refDistance = value;

    	},

    	getRolloffFactor: function () {

    		return this.panner.rolloffFactor;

    	},

    	setRolloffFactor: function ( value ) {

    		this.panner.rolloffFactor = value;

    	},

    	getDistanceModel: function () {

    		return this.panner.distanceModel;

    	},

    	setDistanceModel: function ( value ) {

    		this.panner.distanceModel = value;

    	},

    	getMaxDistance: function () {

    		return this.panner.maxDistance;

    	},

    	setMaxDistance: function ( value ) {

    		this.panner.maxDistance = value;

    	},

    	updateMatrixWorld: ( function () {

    		var position = new Vector3();

    		return function updateMatrixWorld( force ) {

    			Object3D.prototype.updateMatrixWorld.call( this, force );

    			position.setFromMatrixPosition( this.matrixWorld );

    			this.panner.setPosition( position.x, position.y, position.z );

    		};

    	} )()


    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function AudioAnalyser( audio, fftSize ) {

    	this.analyser = audio.context.createAnalyser();
    	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

    	this.data = new Uint8Array( this.analyser.frequencyBinCount );

    	audio.getOutput().connect( this.analyser );

    }

    Object.assign( AudioAnalyser.prototype, {

    	getFrequencyData: function () {

    		this.analyser.getByteFrequencyData( this.data );

    		return this.data;

    	},

    	getAverageFrequency: function () {

    		var value = 0, data = this.getFrequencyData();

    		for ( var i = 0; i < data.length; i ++ ) {

    			value += data[ i ];

    		}

    		return value / data.length;

    	}

    } );

    /**
     *
     * Buffered scene graph property that allows weighted accumulation.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function PropertyMixer( binding, typeName, valueSize ) {

    	this.binding = binding;
    	this.valueSize = valueSize;

    	var bufferType = Float64Array,
    		mixFunction;

    	switch ( typeName ) {

    		case 'quaternion':			mixFunction = this._slerp;		break;

    		case 'string':
    		case 'bool':

    			bufferType = Array,		mixFunction = this._select;		break;

    		default:					mixFunction = this._lerp;

    	}

    	this.buffer = new bufferType( valueSize * 4 );
    	// layout: [ incoming | accu0 | accu1 | orig ]
    	//
    	// interpolators can use .buffer as their .result
    	// the data then goes to 'incoming'
    	//
    	// 'accu0' and 'accu1' are used frame-interleaved for
    	// the cumulative result and are compared to detect
    	// changes
    	//
    	// 'orig' stores the original state of the property

    	this._mixBufferRegion = mixFunction;

    	this.cumulativeWeight = 0;

    	this.useCount = 0;
    	this.referenceCount = 0;

    }

    PropertyMixer.prototype = {

    	constructor: PropertyMixer,

    	// accumulate data in the 'incoming' region into 'accu<i>'
    	accumulate: function( accuIndex, weight ) {

    		// note: happily accumulating nothing when weight = 0, the caller knows
    		// the weight and shouldn't have made the call in the first place

    		var buffer = this.buffer,
    			stride = this.valueSize,
    			offset = accuIndex * stride + stride,

    			currentWeight = this.cumulativeWeight;

    		if ( currentWeight === 0 ) {

    			// accuN := incoming * weight

    			for ( var i = 0; i !== stride; ++ i ) {

    				buffer[ offset + i ] = buffer[ i ];

    			}

    			currentWeight = weight;

    		} else {

    			// accuN := accuN + incoming * weight

    			currentWeight += weight;
    			var mix = weight / currentWeight;
    			this._mixBufferRegion( buffer, offset, 0, mix, stride );

    		}

    		this.cumulativeWeight = currentWeight;

    	},

    	// apply the state of 'accu<i>' to the binding when accus differ
    	apply: function( accuIndex ) {

    		var stride = this.valueSize,
    			buffer = this.buffer,
    			offset = accuIndex * stride + stride,

    			weight = this.cumulativeWeight,

    			binding = this.binding;

    		this.cumulativeWeight = 0;

    		if ( weight < 1 ) {

    			// accuN := accuN + original * ( 1 - cumulativeWeight )

    			var originalValueOffset = stride * 3;

    			this._mixBufferRegion(
    					buffer, offset, originalValueOffset, 1 - weight, stride );

    		}

    		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

    			if ( buffer[ i ] !== buffer[ i + stride ] ) {

    				// value has changed -> update scene graph

    				binding.setValue( buffer, offset );
    				break;

    			}

    		}

    	},

    	// remember the state of the bound property and copy it to both accus
    	saveOriginalState: function() {

    		var binding = this.binding;

    		var buffer = this.buffer,
    			stride = this.valueSize,

    			originalValueOffset = stride * 3;

    		binding.getValue( buffer, originalValueOffset );

    		// accu[0..1] := orig -- initially detect changes against the original
    		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

    			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

    		}

    		this.cumulativeWeight = 0;

    	},

    	// apply the state previously taken via 'saveOriginalState' to the binding
    	restoreOriginalState: function() {

    		var originalValueOffset = this.valueSize * 3;
    		this.binding.setValue( this.buffer, originalValueOffset );

    	},


    	// mix functions

    	_select: function( buffer, dstOffset, srcOffset, t, stride ) {

    		if ( t >= 0.5 ) {

    			for ( var i = 0; i !== stride; ++ i ) {

    				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

    			}

    		}

    	},

    	_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {

    		Quaternion.slerpFlat( buffer, dstOffset,
    				buffer, dstOffset, buffer, srcOffset, t );

    	},

    	_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {

    		var s = 1 - t;

    		for ( var i = 0; i !== stride; ++ i ) {

    			var j = dstOffset + i;

    			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

    		}

    	}

    };

    /**
     *
     * A reference to a real property in the scene graph.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function PropertyBinding( rootNode, path, parsedPath ) {

    	this.path = path;
    	this.parsedPath = parsedPath ||
    			PropertyBinding.parseTrackName( path );

    	this.node = PropertyBinding.findNode(
    			rootNode, this.parsedPath.nodeName ) || rootNode;

    	this.rootNode = rootNode;

    }

    PropertyBinding.prototype = {

    	constructor: PropertyBinding,

    	getValue: function getValue_unbound( targetArray, offset ) {

    		this.bind();
    		this.getValue( targetArray, offset );

    		// Note: This class uses a State pattern on a per-method basis:
    		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
    		// prototype version of these methods with one that represents
    		// the bound state. When the property is not found, the methods
    		// become no-ops.

    	},

    	setValue: function getValue_unbound( sourceArray, offset ) {

    		this.bind();
    		this.setValue( sourceArray, offset );

    	},

    	// create getter / setter pair for a property in the scene graph
    	bind: function() {

    		var targetObject = this.node,
    			parsedPath = this.parsedPath,

    			objectName = parsedPath.objectName,
    			propertyName = parsedPath.propertyName,
    			propertyIndex = parsedPath.propertyIndex;

    		if ( ! targetObject ) {

    			targetObject = PropertyBinding.findNode(
    					this.rootNode, parsedPath.nodeName ) || this.rootNode;

    			this.node = targetObject;

    		}

    		// set fail state so we can just 'return' on error
    		this.getValue = this._getValue_unavailable;
    		this.setValue = this._setValue_unavailable;

     		// ensure there is a value node
    		if ( ! targetObject ) {

    			console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
    			return;

    		}

    		if ( objectName ) {

    			var objectIndex = parsedPath.objectIndex;

    			// special cases were we need to reach deeper into the hierarchy to get the face materials....
    			switch ( objectName ) {

    				case 'materials':

    					if ( ! targetObject.material ) {

    						console.error( '  can not bind to material as node does not have a material', this );
    						return;

    					}

    					if ( ! targetObject.material.materials ) {

    						console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
    						return;

    					}

    					targetObject = targetObject.material.materials;

    					break;

    				case 'bones':

    					if ( ! targetObject.skeleton ) {

    						console.error( '  can not bind to bones as node does not have a skeleton', this );
    						return;

    					}

    					// potential future optimization: skip this if propertyIndex is already an integer
    					// and convert the integer string to a true integer.

    					targetObject = targetObject.skeleton.bones;

    					// support resolving morphTarget names into indices.
    					for ( var i = 0; i < targetObject.length; i ++ ) {

    						if ( targetObject[ i ].name === objectIndex ) {

    							objectIndex = i;
    							break;

    						}

    					}

    					break;

    				default:

    					if ( targetObject[ objectName ] === undefined ) {

    						console.error( '  can not bind to objectName of node, undefined', this );
    						return;

    					}

    					targetObject = targetObject[ objectName ];

    			}


    			if ( objectIndex !== undefined ) {

    				if ( targetObject[ objectIndex ] === undefined ) {

    					console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
    					return;

    				}

    				targetObject = targetObject[ objectIndex ];

    			}

    		}

    		// resolve property
    		var nodeProperty = targetObject[ propertyName ];

    		if ( nodeProperty === undefined ) {

    			var nodeName = parsedPath.nodeName;

    			console.error( "  trying to update property for track: " + nodeName +
    					'.' + propertyName + " but it wasn't found.", targetObject );
    			return;

    		}

    		// determine versioning scheme
    		var versioning = this.Versioning.None;

    		if ( targetObject.needsUpdate !== undefined ) { // material

    			versioning = this.Versioning.NeedsUpdate;
    			this.targetObject = targetObject;

    		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

    			versioning = this.Versioning.MatrixWorldNeedsUpdate;
    			this.targetObject = targetObject;

    		}

    		// determine how the property gets bound
    		var bindingType = this.BindingType.Direct;

    		if ( propertyIndex !== undefined ) {
    			// access a sub element of the property array (only primitives are supported right now)

    			if ( propertyName === "morphTargetInfluences" ) {
    				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

    				// support resolving morphTarget names into indices.
    				if ( ! targetObject.geometry ) {

    					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
    					return;

    				}

    				if ( ! targetObject.geometry.morphTargets ) {

    					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
    					return;

    				}

    				for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

    					if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

    						propertyIndex = i;
    						break;

    					}

    				}

    			}

    			bindingType = this.BindingType.ArrayElement;

    			this.resolvedProperty = nodeProperty;
    			this.propertyIndex = propertyIndex;

    		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
    			// must use copy for Object3D.Euler/Quaternion

    			bindingType = this.BindingType.HasFromToArray;

    			this.resolvedProperty = nodeProperty;

    		} else if ( nodeProperty.length !== undefined ) {

    			bindingType = this.BindingType.EntireArray;

    			this.resolvedProperty = nodeProperty;

    		} else {

    			this.propertyName = propertyName;

    		}

    		// select getter / setter
    		this.getValue = this.GetterByBindingType[ bindingType ];
    		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

    	},

    	unbind: function() {

    		this.node = null;

    		// back to the prototype version of getValue / setValue
    		// note: avoiding to mutate the shape of 'this' via 'delete'
    		this.getValue = this._getValue_unbound;
    		this.setValue = this._setValue_unbound;

    	}

    };

    Object.assign( PropertyBinding.prototype, { // prototype, continued

    	// these are used to "bind" a nonexistent property
    	_getValue_unavailable: function() {},
    	_setValue_unavailable: function() {},

    	// initial state of these methods that calls 'bind'
    	_getValue_unbound: PropertyBinding.prototype.getValue,
    	_setValue_unbound: PropertyBinding.prototype.setValue,

    	BindingType: {
    		Direct: 0,
    		EntireArray: 1,
    		ArrayElement: 2,
    		HasFromToArray: 3
    	},

    	Versioning: {
    		None: 0,
    		NeedsUpdate: 1,
    		MatrixWorldNeedsUpdate: 2
    	},

    	GetterByBindingType: [

    		function getValue_direct( buffer, offset ) {

    			buffer[ offset ] = this.node[ this.propertyName ];

    		},

    		function getValue_array( buffer, offset ) {

    			var source = this.resolvedProperty;

    			for ( var i = 0, n = source.length; i !== n; ++ i ) {

    				buffer[ offset ++ ] = source[ i ];

    			}

    		},

    		function getValue_arrayElement( buffer, offset ) {

    			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

    		},

    		function getValue_toArray( buffer, offset ) {

    			this.resolvedProperty.toArray( buffer, offset );

    		}

    	],

    	SetterByBindingTypeAndVersioning: [

    		[
    			// Direct

    			function setValue_direct( buffer, offset ) {

    				this.node[ this.propertyName ] = buffer[ offset ];

    			},

    			function setValue_direct_setNeedsUpdate( buffer, offset ) {

    				this.node[ this.propertyName ] = buffer[ offset ];
    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				this.node[ this.propertyName ] = buffer[ offset ];
    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		], [

    			// EntireArray

    			function setValue_array( buffer, offset ) {

    				var dest = this.resolvedProperty;

    				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

    					dest[ i ] = buffer[ offset ++ ];

    				}

    			},

    			function setValue_array_setNeedsUpdate( buffer, offset ) {

    				var dest = this.resolvedProperty;

    				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

    					dest[ i ] = buffer[ offset ++ ];

    				}

    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				var dest = this.resolvedProperty;

    				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

    					dest[ i ] = buffer[ offset ++ ];

    				}

    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		], [

    			// ArrayElement

    			function setValue_arrayElement( buffer, offset ) {

    				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

    			},

    			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		], [

    			// HasToFromArray

    			function setValue_fromArray( buffer, offset ) {

    				this.resolvedProperty.fromArray( buffer, offset );

    			},

    			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty.fromArray( buffer, offset );
    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty.fromArray( buffer, offset );
    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		]

    	]

    } );

    PropertyBinding.Composite =
    		function( targetGroup, path, optionalParsedPath ) {

    	var parsedPath = optionalParsedPath ||
    			PropertyBinding.parseTrackName( path );

    	this._targetGroup = targetGroup;
    	this._bindings = targetGroup.subscribe_( path, parsedPath );

    };

    PropertyBinding.Composite.prototype = {

    	constructor: PropertyBinding.Composite,

    	getValue: function( array, offset ) {

    		this.bind(); // bind all binding

    		var firstValidIndex = this._targetGroup.nCachedObjects_,
    			binding = this._bindings[ firstValidIndex ];

    		// and only call .getValue on the first
    		if ( binding !== undefined ) binding.getValue( array, offset );

    	},

    	setValue: function( array, offset ) {

    		var bindings = this._bindings;

    		for ( var i = this._targetGroup.nCachedObjects_,
    				n = bindings.length; i !== n; ++ i ) {

    			bindings[ i ].setValue( array, offset );

    		}

    	},

    	bind: function() {

    		var bindings = this._bindings;

    		for ( var i = this._targetGroup.nCachedObjects_,
    				n = bindings.length; i !== n; ++ i ) {

    			bindings[ i ].bind();

    		}

    	},

    	unbind: function() {

    		var bindings = this._bindings;

    		for ( var i = this._targetGroup.nCachedObjects_,
    				n = bindings.length; i !== n; ++ i ) {

    			bindings[ i ].unbind();

    		}

    	}

    };

    PropertyBinding.create = function( root, path, parsedPath ) {

    	if ( ! ( (root && root.isAnimationObjectGroup) ) ) {

    		return new PropertyBinding( root, path, parsedPath );

    	} else {

    		return new PropertyBinding.Composite( root, path, parsedPath );

    	}

    };

    PropertyBinding.parseTrackName = function( trackName ) {

    	// matches strings in the form of:
    	//    nodeName.property
    	//    nodeName.property[accessor]
    	//    nodeName.material.property[accessor]
    	//    uuid.property[accessor]
    	//    uuid.objectName[objectIndex].propertyName[propertyIndex]
    	//    parentName/nodeName.property
    	//    parentName/parentName/nodeName.property[index]
    	//    .bone[Armature.DEF_cog].position
    	//    scene:helium_balloon_model:helium_balloon_model.position
    	// created and tested via https://regex101.com/#javascript

    	var re = /^((?:\w+[\/:])*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/;
    	var matches = re.exec( trackName );

    	if ( ! matches ) {

    		throw new Error( "cannot parse trackName at all: " + trackName );

    	}

    	var results = {
    		// directoryName: matches[ 1 ], // (tschw) currently unused
    		nodeName: matches[ 2 ], 	// allowed to be null, specified root node.
    		objectName: matches[ 3 ],
    		objectIndex: matches[ 4 ],
    		propertyName: matches[ 5 ],
    		propertyIndex: matches[ 6 ]	// allowed to be null, specifies that the whole property is set.
    	};

    	if ( results.propertyName === null || results.propertyName.length === 0 ) {

    		throw new Error( "can not parse propertyName from trackName: " + trackName );

    	}

    	return results;

    };

    PropertyBinding.findNode = function( root, nodeName ) {

    	if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

    		return root;

    	}

    	// search into skeleton bones.
    	if ( root.skeleton ) {

    		var searchSkeleton = function( skeleton ) {

    			for( var i = 0; i < skeleton.bones.length; i ++ ) {

    				var bone = skeleton.bones[ i ];

    				if ( bone.name === nodeName ) {

    					return bone;

    				}
    			}

    			return null;

    		};

    		var bone = searchSkeleton( root.skeleton );

    		if ( bone ) {

    			return bone;

    		}
    	}

    	// search into node subtree.
    	if ( root.children ) {

    		var searchNodeSubtree = function( children ) {

    			for( var i = 0; i < children.length; i ++ ) {

    				var childNode = children[ i ];

    				if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

    					return childNode;

    				}

    				var result = searchNodeSubtree( childNode.children );

    				if ( result ) return result;

    			}

    			return null;

    		};

    		var subTreeNode = searchNodeSubtree( root.children );

    		if ( subTreeNode ) {

    			return subTreeNode;

    		}

    	}

    	return null;

    };

    /**
     *
     * A group of objects that receives a shared animation state.
     *
     * Usage:
     *
     * 	-	Add objects you would otherwise pass as 'root' to the
     * 		constructor or the .clipAction method of AnimationMixer.
     *
     * 	-	Instead pass this object as 'root'.
     *
     * 	-	You can also add and remove objects later when the mixer
     * 		is running.
     *
     * Note:
     *
     *  	Objects of this class appear as one object to the mixer,
     *  	so cache control of the individual objects must be done
     *  	on the group.
     *
     * Limitation:
     *
     * 	- 	The animated properties must be compatible among the
     * 		all objects in the group.
     *
     *  -	A single property can either be controlled through a
     *  	target group or directly, but not both.
     *
     * @author tschw
     */

    function AnimationObjectGroup( var_args ) {

    	this.uuid = exports.Math.generateUUID();

    	// cached objects followed by the active ones
    	this._objects = Array.prototype.slice.call( arguments );

    	this.nCachedObjects_ = 0;			// threshold
    	// note: read by PropertyBinding.Composite

    	var indices = {};
    	this._indicesByUUID = indices;		// for bookkeeping

    	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    		indices[ arguments[ i ].uuid ] = i;

    	}

    	this._paths = [];					// inside: string
    	this._parsedPaths = [];				// inside: { we don't care, here }
    	this._bindings = []; 				// inside: Array< PropertyBinding >
    	this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

    	var scope = this;

    	this.stats = {

    		objects: {
    			get total() { return scope._objects.length; },
    			get inUse() { return this.total - scope.nCachedObjects_;  }
    		},

    		get bindingsPerObject() { return scope._bindings.length; }

    	};

    }

    AnimationObjectGroup.prototype = {

    	constructor: AnimationObjectGroup,

    	isAnimationObjectGroup: true,

    	add: function( var_args ) {

    		var objects = this._objects,
    			nObjects = objects.length,
    			nCachedObjects = this.nCachedObjects_,
    			indicesByUUID = this._indicesByUUID,
    			paths = this._paths,
    			parsedPaths = this._parsedPaths,
    			bindings = this._bindings,
    			nBindings = bindings.length;

    		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    			var object = arguments[ i ],
    				uuid = object.uuid,
    				index = indicesByUUID[ uuid ];

    			if ( index === undefined ) {

    				// unknown object -> add it to the ACTIVE region

    				index = nObjects ++;
    				indicesByUUID[ uuid ] = index;
    				objects.push( object );

    				// accounting is done, now do the same for all bindings

    				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    					bindings[ j ].push(
    							new PropertyBinding(
    								object, paths[ j ], parsedPaths[ j ] ) );

    				}

    			} else if ( index < nCachedObjects ) {

    				var knownObject = objects[ index ];

    				// move existing object to the ACTIVE region

    				var firstActiveIndex = -- nCachedObjects,
    					lastCachedObject = objects[ firstActiveIndex ];

    				indicesByUUID[ lastCachedObject.uuid ] = index;
    				objects[ index ] = lastCachedObject;

    				indicesByUUID[ uuid ] = firstActiveIndex;
    				objects[ firstActiveIndex ] = object;

    				// accounting is done, now do the same for all bindings

    				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    					var bindingsForPath = bindings[ j ],
    						lastCached = bindingsForPath[ firstActiveIndex ],
    						binding = bindingsForPath[ index ];

    					bindingsForPath[ index ] = lastCached;

    					if ( binding === undefined ) {

    						// since we do not bother to create new bindings
    						// for objects that are cached, the binding may
    						// or may not exist

    						binding = new PropertyBinding(
    								object, paths[ j ], parsedPaths[ j ] );

    					}

    					bindingsForPath[ firstActiveIndex ] = binding;

    				}

    			} else if ( objects[ index ] !== knownObject) {

    				console.error( "Different objects with the same UUID " +
    						"detected. Clean the caches or recreate your " +
    						"infrastructure when reloading scenes..." );

    			} // else the object is already where we want it to be

    		} // for arguments

    		this.nCachedObjects_ = nCachedObjects;

    	},

    	remove: function( var_args ) {

    		var objects = this._objects,
    			nCachedObjects = this.nCachedObjects_,
    			indicesByUUID = this._indicesByUUID,
    			bindings = this._bindings,
    			nBindings = bindings.length;

    		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    			var object = arguments[ i ],
    				uuid = object.uuid,
    				index = indicesByUUID[ uuid ];

    			if ( index !== undefined && index >= nCachedObjects ) {

    				// move existing object into the CACHED region

    				var lastCachedIndex = nCachedObjects ++,
    					firstActiveObject = objects[ lastCachedIndex ];

    				indicesByUUID[ firstActiveObject.uuid ] = index;
    				objects[ index ] = firstActiveObject;

    				indicesByUUID[ uuid ] = lastCachedIndex;
    				objects[ lastCachedIndex ] = object;

    				// accounting is done, now do the same for all bindings

    				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    					var bindingsForPath = bindings[ j ],
    						firstActive = bindingsForPath[ lastCachedIndex ],
    						binding = bindingsForPath[ index ];

    					bindingsForPath[ index ] = firstActive;
    					bindingsForPath[ lastCachedIndex ] = binding;

    				}

    			}

    		} // for arguments

    		this.nCachedObjects_ = nCachedObjects;

    	},

    	// remove & forget
    	uncache: function( var_args ) {

    		var objects = this._objects,
    			nObjects = objects.length,
    			nCachedObjects = this.nCachedObjects_,
    			indicesByUUID = this._indicesByUUID,
    			bindings = this._bindings,
    			nBindings = bindings.length;

    		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    			var object = arguments[ i ],
    				uuid = object.uuid,
    				index = indicesByUUID[ uuid ];

    			if ( index !== undefined ) {

    				delete indicesByUUID[ uuid ];

    				if ( index < nCachedObjects ) {

    					// object is cached, shrink the CACHED region

    					var firstActiveIndex = -- nCachedObjects,
    						lastCachedObject = objects[ firstActiveIndex ],
    						lastIndex = -- nObjects,
    						lastObject = objects[ lastIndex ];

    					// last cached object takes this object's place
    					indicesByUUID[ lastCachedObject.uuid ] = index;
    					objects[ index ] = lastCachedObject;

    					// last object goes to the activated slot and pop
    					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
    					objects[ firstActiveIndex ] = lastObject;
    					objects.pop();

    					// accounting is done, now do the same for all bindings

    					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    						var bindingsForPath = bindings[ j ],
    							lastCached = bindingsForPath[ firstActiveIndex ],
    							last = bindingsForPath[ lastIndex ];

    						bindingsForPath[ index ] = lastCached;
    						bindingsForPath[ firstActiveIndex ] = last;
    						bindingsForPath.pop();

    					}

    				} else {

    					// object is active, just swap with the last and pop

    					var lastIndex = -- nObjects,
    						lastObject = objects[ lastIndex ];

    					indicesByUUID[ lastObject.uuid ] = index;
    					objects[ index ] = lastObject;
    					objects.pop();

    					// accounting is done, now do the same for all bindings

    					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    						var bindingsForPath = bindings[ j ];

    						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
    						bindingsForPath.pop();

    					}

    				} // cached or active

    			} // if object is known

    		} // for arguments

    		this.nCachedObjects_ = nCachedObjects;

    	},

    	// Internal interface used by befriended PropertyBinding.Composite:

    	subscribe_: function( path, parsedPath ) {
    		// returns an array of bindings for the given path that is changed
    		// according to the contained objects in the group

    		var indicesByPath = this._bindingsIndicesByPath,
    			index = indicesByPath[ path ],
    			bindings = this._bindings;

    		if ( index !== undefined ) return bindings[ index ];

    		var paths = this._paths,
    			parsedPaths = this._parsedPaths,
    			objects = this._objects,
    			nObjects = objects.length,
    			nCachedObjects = this.nCachedObjects_,
    			bindingsForPath = new Array( nObjects );

    		index = bindings.length;

    		indicesByPath[ path ] = index;

    		paths.push( path );
    		parsedPaths.push( parsedPath );
    		bindings.push( bindingsForPath );

    		for ( var i = nCachedObjects,
    				n = objects.length; i !== n; ++ i ) {

    			var object = objects[ i ];

    			bindingsForPath[ i ] =
    					new PropertyBinding( object, path, parsedPath );

    		}

    		return bindingsForPath;

    	},

    	unsubscribe_: function( path ) {
    		// tells the group to forget about a property path and no longer
    		// update the array previously obtained with 'subscribe_'

    		var indicesByPath = this._bindingsIndicesByPath,
    			index = indicesByPath[ path ];

    		if ( index !== undefined ) {

    			var paths = this._paths,
    				parsedPaths = this._parsedPaths,
    				bindings = this._bindings,
    				lastBindingsIndex = bindings.length - 1,
    				lastBindings = bindings[ lastBindingsIndex ],
    				lastBindingsPath = path[ lastBindingsIndex ];

    			indicesByPath[ lastBindingsPath ] = index;

    			bindings[ index ] = lastBindings;
    			bindings.pop();

    			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
    			parsedPaths.pop();

    			paths[ index ] = paths[ lastBindingsIndex ];
    			paths.pop();

    		}

    	}

    };

    /**
     *
     * Action provided by AnimationMixer for scheduling clip playback on specific
     * objects.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     *
     */

    function AnimationAction( mixer, clip, localRoot ) {

    	this._mixer = mixer;
    	this._clip = clip;
    	this._localRoot = localRoot || null;

    	var tracks = clip.tracks,
    		nTracks = tracks.length,
    		interpolants = new Array( nTracks );

    	var interpolantSettings = {
    			endingStart: 	ZeroCurvatureEnding,
    			endingEnd:		ZeroCurvatureEnding
    	};

    	for ( var i = 0; i !== nTracks; ++ i ) {

    		var interpolant = tracks[ i ].createInterpolant( null );
    		interpolants[ i ] = interpolant;
    		interpolant.settings = interpolantSettings;

    	}

    	this._interpolantSettings = interpolantSettings;

    	this._interpolants = interpolants;	// bound by the mixer

    	// inside: PropertyMixer (managed by the mixer)
    	this._propertyBindings = new Array( nTracks );

    	this._cacheIndex = null;			// for the memory manager
    	this._byClipCacheIndex = null;		// for the memory manager

    	this._timeScaleInterpolant = null;
    	this._weightInterpolant = null;

    	this.loop = LoopRepeat;
    	this._loopCount = -1;

    	// global mixer time when the action is to be started
    	// it's set back to 'null' upon start of the action
    	this._startTime = null;

    	// scaled local time of the action
    	// gets clamped or wrapped to 0..clip.duration according to loop
    	this.time = 0;

    	this.timeScale = 1;
    	this._effectiveTimeScale = 1;

    	this.weight = 1;
    	this._effectiveWeight = 1;

    	this.repetitions = Infinity; 		// no. of repetitions when looping

    	this.paused = false;				// false -> zero effective time scale
    	this.enabled = true;				// true -> zero effective weight

    	this.clampWhenFinished 	= false;	// keep feeding the last frame?

    	this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
    	this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

    };

    AnimationAction.prototype = {

    	constructor: AnimationAction,

    	// State & Scheduling

    	play: function() {

    		this._mixer._activateAction( this );

    		return this;

    	},

    	stop: function() {

    		this._mixer._deactivateAction( this );

    		return this.reset();

    	},

    	reset: function() {

    		this.paused = false;
    		this.enabled = true;

    		this.time = 0;			// restart clip
    		this._loopCount = -1;	// forget previous loops
    		this._startTime = null;	// forget scheduling

    		return this.stopFading().stopWarping();

    	},

    	isRunning: function() {

    		return this.enabled && ! this.paused && this.timeScale !== 0 &&
    				this._startTime === null && this._mixer._isActiveAction( this );

    	},

    	// return true when play has been called
    	isScheduled: function() {

    		return this._mixer._isActiveAction( this );

    	},

    	startAt: function( time ) {

    		this._startTime = time;

    		return this;

    	},

    	setLoop: function( mode, repetitions ) {

    		this.loop = mode;
    		this.repetitions = repetitions;

    		return this;

    	},

    	// Weight

    	// set the weight stopping any scheduled fading
    	// although .enabled = false yields an effective weight of zero, this
    	// method does *not* change .enabled, because it would be confusing
    	setEffectiveWeight: function( weight ) {

    		this.weight = weight;

    		// note: same logic as when updated at runtime
    		this._effectiveWeight = this.enabled ? weight : 0;

    		return this.stopFading();

    	},

    	// return the weight considering fading and .enabled
    	getEffectiveWeight: function() {

    		return this._effectiveWeight;

    	},

    	fadeIn: function( duration ) {

    		return this._scheduleFading( duration, 0, 1 );

    	},

    	fadeOut: function( duration ) {

    		return this._scheduleFading( duration, 1, 0 );

    	},

    	crossFadeFrom: function( fadeOutAction, duration, warp ) {

    		fadeOutAction.fadeOut( duration );
    		this.fadeIn( duration );

    		if( warp ) {

    			var fadeInDuration = this._clip.duration,
    				fadeOutDuration = fadeOutAction._clip.duration,

    				startEndRatio = fadeOutDuration / fadeInDuration,
    				endStartRatio = fadeInDuration / fadeOutDuration;

    			fadeOutAction.warp( 1.0, startEndRatio, duration );
    			this.warp( endStartRatio, 1.0, duration );

    		}

    		return this;

    	},

    	crossFadeTo: function( fadeInAction, duration, warp ) {

    		return fadeInAction.crossFadeFrom( this, duration, warp );

    	},

    	stopFading: function() {

    		var weightInterpolant = this._weightInterpolant;

    		if ( weightInterpolant !== null ) {

    			this._weightInterpolant = null;
    			this._mixer._takeBackControlInterpolant( weightInterpolant );

    		}

    		return this;

    	},

    	// Time Scale Control

    	// set the weight stopping any scheduled warping
    	// although .paused = true yields an effective time scale of zero, this
    	// method does *not* change .paused, because it would be confusing
    	setEffectiveTimeScale: function( timeScale ) {

    		this.timeScale = timeScale;
    		this._effectiveTimeScale = this.paused ? 0 :timeScale;

    		return this.stopWarping();

    	},

    	// return the time scale considering warping and .paused
    	getEffectiveTimeScale: function() {

    		return this._effectiveTimeScale;

    	},

    	setDuration: function( duration ) {

    		this.timeScale = this._clip.duration / duration;

    		return this.stopWarping();

    	},

    	syncWith: function( action ) {

    		this.time = action.time;
    		this.timeScale = action.timeScale;

    		return this.stopWarping();

    	},

    	halt: function( duration ) {

    		return this.warp( this._effectiveTimeScale, 0, duration );

    	},

    	warp: function( startTimeScale, endTimeScale, duration ) {

    		var mixer = this._mixer, now = mixer.time,
    			interpolant = this._timeScaleInterpolant,

    			timeScale = this.timeScale;

    		if ( interpolant === null ) {

    			interpolant = mixer._lendControlInterpolant(),
    			this._timeScaleInterpolant = interpolant;

    		}

    		var times = interpolant.parameterPositions,
    			values = interpolant.sampleValues;

    		times[ 0 ] = now;
    		times[ 1 ] = now + duration;

    		values[ 0 ] = startTimeScale / timeScale;
    		values[ 1 ] = endTimeScale / timeScale;

    		return this;

    	},

    	stopWarping: function() {

    		var timeScaleInterpolant = this._timeScaleInterpolant;

    		if ( timeScaleInterpolant !== null ) {

    			this._timeScaleInterpolant = null;
    			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

    		}

    		return this;

    	},

    	// Object Accessors

    	getMixer: function() {

    		return this._mixer;

    	},

    	getClip: function() {

    		return this._clip;

    	},

    	getRoot: function() {

    		return this._localRoot || this._mixer._root;

    	},

    	// Interna

    	_update: function( time, deltaTime, timeDirection, accuIndex ) {
    		// called by the mixer

    		var startTime = this._startTime;

    		if ( startTime !== null ) {

    			// check for scheduled start of action

    			var timeRunning = ( time - startTime ) * timeDirection;
    			if ( timeRunning < 0 || timeDirection === 0 ) {

    				return; // yet to come / don't decide when delta = 0

    			}

    			// start

    			this._startTime = null; // unschedule
    			deltaTime = timeDirection * timeRunning;

    		}

    		// apply time scale and advance time

    		deltaTime *= this._updateTimeScale( time );
    		var clipTime = this._updateTime( deltaTime );

    		// note: _updateTime may disable the action resulting in
    		// an effective weight of 0

    		var weight = this._updateWeight( time );

    		if ( weight > 0 ) {

    			var interpolants = this._interpolants;
    			var propertyMixers = this._propertyBindings;

    			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

    				interpolants[ j ].evaluate( clipTime );
    				propertyMixers[ j ].accumulate( accuIndex, weight );

    			}

    		}

    	},

    	_updateWeight: function( time ) {

    		var weight = 0;

    		if ( this.enabled ) {

    			weight = this.weight;
    			var interpolant = this._weightInterpolant;

    			if ( interpolant !== null ) {

    				var interpolantValue = interpolant.evaluate( time )[ 0 ];

    				weight *= interpolantValue;

    				if ( time > interpolant.parameterPositions[ 1 ] ) {

    					this.stopFading();

    					if ( interpolantValue === 0 ) {

    						// faded out, disable
    						this.enabled = false;

    					}

    				}

    			}

    		}

    		this._effectiveWeight = weight;
    		return weight;

    	},

    	_updateTimeScale: function( time ) {

    		var timeScale = 0;

    		if ( ! this.paused ) {

    			timeScale = this.timeScale;

    			var interpolant = this._timeScaleInterpolant;

    			if ( interpolant !== null ) {

    				var interpolantValue = interpolant.evaluate( time )[ 0 ];

    				timeScale *= interpolantValue;

    				if ( time > interpolant.parameterPositions[ 1 ] ) {

    					this.stopWarping();

    					if ( timeScale === 0 ) {

    						// motion has halted, pause
    						this.paused = true;

    					} else {

    						// warp done - apply final time scale
    						this.timeScale = timeScale;

    					}

    				}

    			}

    		}

    		this._effectiveTimeScale = timeScale;
    		return timeScale;

    	},

    	_updateTime: function( deltaTime ) {

    		var time = this.time + deltaTime;

    		if ( deltaTime === 0 ) return time;

    		var duration = this._clip.duration,

    			loop = this.loop,
    			loopCount = this._loopCount;

    		if ( loop === LoopOnce ) {

    			if ( loopCount === -1 ) {
    				// just started

    				this.loopCount = 0;
    				this._setEndings( true, true, false );

    			}

    			handle_stop: {

    				if ( time >= duration ) {

    					time = duration;

    				} else if ( time < 0 ) {

    					time = 0;

    				} else break handle_stop;

    				if ( this.clampWhenFinished ) this.paused = true;
    				else this.enabled = false;

    				this._mixer.dispatchEvent( {
    					type: 'finished', action: this,
    					direction: deltaTime < 0 ? -1 : 1
    				} );

    			}

    		} else { // repetitive Repeat or PingPong

    			var pingPong = ( loop === LoopPingPong );

    			if ( loopCount === -1 ) {
    				// just started

    				if ( deltaTime >= 0 ) {

    					loopCount = 0;

    					this._setEndings(
    							true, this.repetitions === 0, pingPong );

    				} else {

    					// when looping in reverse direction, the initial
    					// transition through zero counts as a repetition,
    					// so leave loopCount at -1

    					this._setEndings(
    							this.repetitions === 0, true, pingPong );

    				}

    			}

    			if ( time >= duration || time < 0 ) {
    				// wrap around

    				var loopDelta = Math.floor( time / duration ); // signed
    				time -= duration * loopDelta;

    				loopCount += Math.abs( loopDelta );

    				var pending = this.repetitions - loopCount;

    				if ( pending < 0 ) {
    					// have to stop (switch state, clamp time, fire event)

    					if ( this.clampWhenFinished ) this.paused = true;
    					else this.enabled = false;

    					time = deltaTime > 0 ? duration : 0;

    					this._mixer.dispatchEvent( {
    						type: 'finished', action: this,
    						direction: deltaTime > 0 ? 1 : -1
    					} );

    				} else {
    					// keep running

    					if ( pending === 0 ) {
    						// entering the last round

    						var atStart = deltaTime < 0;
    						this._setEndings( atStart, ! atStart, pingPong );

    					} else {

    						this._setEndings( false, false, pingPong );

    					}

    					this._loopCount = loopCount;

    					this._mixer.dispatchEvent( {
    						type: 'loop', action: this, loopDelta: loopDelta
    					} );

    				}

    			}

    			if ( pingPong && ( loopCount & 1 ) === 1 ) {
    				// invert time for the "pong round"

    				this.time = time;
    				return duration - time;

    			}

    		}

    		this.time = time;
    		return time;

    	},

    	_setEndings: function( atStart, atEnd, pingPong ) {

    		var settings = this._interpolantSettings;

    		if ( pingPong ) {

    			settings.endingStart 	= ZeroSlopeEnding;
    			settings.endingEnd		= ZeroSlopeEnding;

    		} else {

    			// assuming for LoopOnce atStart == atEnd == true

    			if ( atStart ) {

    				settings.endingStart = this.zeroSlopeAtStart ?
    						ZeroSlopeEnding : ZeroCurvatureEnding;

    			} else {

    				settings.endingStart = WrapAroundEnding;

    			}

    			if ( atEnd ) {

    				settings.endingEnd = this.zeroSlopeAtEnd ?
    						ZeroSlopeEnding : ZeroCurvatureEnding;

    			} else {

    				settings.endingEnd 	 = WrapAroundEnding;

    			}

    		}

    	},

    	_scheduleFading: function( duration, weightNow, weightThen ) {

    		var mixer = this._mixer, now = mixer.time,
    			interpolant = this._weightInterpolant;

    		if ( interpolant === null ) {

    			interpolant = mixer._lendControlInterpolant(),
    			this._weightInterpolant = interpolant;

    		}

    		var times = interpolant.parameterPositions,
    			values = interpolant.sampleValues;

    		times[ 0 ] = now; 				values[ 0 ] = weightNow;
    		times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

    		return this;

    	}

    };

    /**
     *
     * Player for AnimationClips.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function AnimationMixer( root ) {

    	this._root = root;
    	this._initMemoryManager();
    	this._accuIndex = 0;

    	this.time = 0;

    	this.timeScale = 1.0;

    }

    Object.assign( AnimationMixer.prototype, EventDispatcher.prototype, {

    	// return an action for a clip optionally using a custom root target
    	// object (this method allocates a lot of dynamic memory in case a
    	// previously unknown clip/root combination is specified)
    	clipAction: function( clip, optionalRoot ) {

    		var root = optionalRoot || this._root,
    			rootUuid = root.uuid,

    			clipObject = typeof clip === 'string' ?
    					AnimationClip.findByName( root, clip ) : clip,

    			clipUuid = clipObject !== null ? clipObject.uuid : clip,

    			actionsForClip = this._actionsByClip[ clipUuid ],
    			prototypeAction = null;

    		if ( actionsForClip !== undefined ) {

    			var existingAction =
    					actionsForClip.actionByRoot[ rootUuid ];

    			if ( existingAction !== undefined ) {

    				return existingAction;

    			}

    			// we know the clip, so we don't have to parse all
    			// the bindings again but can just copy
    			prototypeAction = actionsForClip.knownActions[ 0 ];

    			// also, take the clip from the prototype action
    			if ( clipObject === null )
    				clipObject = prototypeAction._clip;

    		}

    		// clip must be known when specified via string
    		if ( clipObject === null ) return null;

    		// allocate all resources required to run it
    		var newAction = new AnimationAction( this, clipObject, optionalRoot );

    		this._bindAction( newAction, prototypeAction );

    		// and make the action known to the memory manager
    		this._addInactiveAction( newAction, clipUuid, rootUuid );

    		return newAction;

    	},

    	// get an existing action
    	existingAction: function( clip, optionalRoot ) {

    		var root = optionalRoot || this._root,
    			rootUuid = root.uuid,

    			clipObject = typeof clip === 'string' ?
    					AnimationClip.findByName( root, clip ) : clip,

    			clipUuid = clipObject ? clipObject.uuid : clip,

    			actionsForClip = this._actionsByClip[ clipUuid ];

    		if ( actionsForClip !== undefined ) {

    			return actionsForClip.actionByRoot[ rootUuid ] || null;

    		}

    		return null;

    	},

    	// deactivates all previously scheduled actions
    	stopAllAction: function() {

    		var actions = this._actions,
    			nActions = this._nActiveActions,
    			bindings = this._bindings,
    			nBindings = this._nActiveBindings;

    		this._nActiveActions = 0;
    		this._nActiveBindings = 0;

    		for ( var i = 0; i !== nActions; ++ i ) {

    			actions[ i ].reset();

    		}

    		for ( var i = 0; i !== nBindings; ++ i ) {

    			bindings[ i ].useCount = 0;

    		}

    		return this;

    	},

    	// advance the time and update apply the animation
    	update: function( deltaTime ) {

    		deltaTime *= this.timeScale;

    		var actions = this._actions,
    			nActions = this._nActiveActions,

    			time = this.time += deltaTime,
    			timeDirection = Math.sign( deltaTime ),

    			accuIndex = this._accuIndex ^= 1;

    		// run active actions

    		for ( var i = 0; i !== nActions; ++ i ) {

    			var action = actions[ i ];

    			if ( action.enabled ) {

    				action._update( time, deltaTime, timeDirection, accuIndex );

    			}

    		}

    		// update scene graph

    		var bindings = this._bindings,
    			nBindings = this._nActiveBindings;

    		for ( var i = 0; i !== nBindings; ++ i ) {

    			bindings[ i ].apply( accuIndex );

    		}

    		return this;

    	},

    	// return this mixer's root target object
    	getRoot: function() {

    		return this._root;

    	},

    	// free all resources specific to a particular clip
    	uncacheClip: function( clip ) {

    		var actions = this._actions,
    			clipUuid = clip.uuid,
    			actionsByClip = this._actionsByClip,
    			actionsForClip = actionsByClip[ clipUuid ];

    		if ( actionsForClip !== undefined ) {

    			// note: just calling _removeInactiveAction would mess up the
    			// iteration state and also require updating the state we can
    			// just throw away

    			var actionsToRemove = actionsForClip.knownActions;

    			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

    				var action = actionsToRemove[ i ];

    				this._deactivateAction( action );

    				var cacheIndex = action._cacheIndex,
    					lastInactiveAction = actions[ actions.length - 1 ];

    				action._cacheIndex = null;
    				action._byClipCacheIndex = null;

    				lastInactiveAction._cacheIndex = cacheIndex;
    				actions[ cacheIndex ] = lastInactiveAction;
    				actions.pop();

    				this._removeInactiveBindingsForAction( action );

    			}

    			delete actionsByClip[ clipUuid ];

    		}

    	},

    	// free all resources specific to a particular root target object
    	uncacheRoot: function( root ) {

    		var rootUuid = root.uuid,
    			actionsByClip = this._actionsByClip;

    		for ( var clipUuid in actionsByClip ) {

    			var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
    				action = actionByRoot[ rootUuid ];

    			if ( action !== undefined ) {

    				this._deactivateAction( action );
    				this._removeInactiveAction( action );

    			}

    		}

    		var bindingsByRoot = this._bindingsByRootAndName,
    			bindingByName = bindingsByRoot[ rootUuid ];

    		if ( bindingByName !== undefined ) {

    			for ( var trackName in bindingByName ) {

    				var binding = bindingByName[ trackName ];
    				binding.restoreOriginalState();
    				this._removeInactiveBinding( binding );

    			}

    		}

    	},

    	// remove a targeted clip from the cache
    	uncacheAction: function( clip, optionalRoot ) {

    		var action = this.existingAction( clip, optionalRoot );

    		if ( action !== null ) {

    			this._deactivateAction( action );
    			this._removeInactiveAction( action );

    		}

    	}

    } );

    // Implementation details:

    Object.assign( AnimationMixer.prototype, {

    	_bindAction: function( action, prototypeAction ) {

    		var root = action._localRoot || this._root,
    			tracks = action._clip.tracks,
    			nTracks = tracks.length,
    			bindings = action._propertyBindings,
    			interpolants = action._interpolants,
    			rootUuid = root.uuid,
    			bindingsByRoot = this._bindingsByRootAndName,
    			bindingsByName = bindingsByRoot[ rootUuid ];

    		if ( bindingsByName === undefined ) {

    			bindingsByName = {};
    			bindingsByRoot[ rootUuid ] = bindingsByName;

    		}

    		for ( var i = 0; i !== nTracks; ++ i ) {

    			var track = tracks[ i ],
    				trackName = track.name,
    				binding = bindingsByName[ trackName ];

    			if ( binding !== undefined ) {

    				bindings[ i ] = binding;

    			} else {

    				binding = bindings[ i ];

    				if ( binding !== undefined ) {

    					// existing binding, make sure the cache knows

    					if ( binding._cacheIndex === null ) {

    						++ binding.referenceCount;
    						this._addInactiveBinding( binding, rootUuid, trackName );

    					}

    					continue;

    				}

    				var path = prototypeAction && prototypeAction.
    						_propertyBindings[ i ].binding.parsedPath;

    				binding = new PropertyMixer(
    						PropertyBinding.create( root, trackName, path ),
    						track.ValueTypeName, track.getValueSize() );

    				++ binding.referenceCount;
    				this._addInactiveBinding( binding, rootUuid, trackName );

    				bindings[ i ] = binding;

    			}

    			interpolants[ i ].resultBuffer = binding.buffer;

    		}

    	},

    	_activateAction: function( action ) {

    		if ( ! this._isActiveAction( action ) ) {

    			if ( action._cacheIndex === null ) {

    				// this action has been forgotten by the cache, but the user
    				// appears to be still using it -> rebind

    				var rootUuid = ( action._localRoot || this._root ).uuid,
    					clipUuid = action._clip.uuid,
    					actionsForClip = this._actionsByClip[ clipUuid ];

    				this._bindAction( action,
    						actionsForClip && actionsForClip.knownActions[ 0 ] );

    				this._addInactiveAction( action, clipUuid, rootUuid );

    			}

    			var bindings = action._propertyBindings;

    			// increment reference counts / sort out state
    			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

    				var binding = bindings[ i ];

    				if ( binding.useCount ++ === 0 ) {

    					this._lendBinding( binding );
    					binding.saveOriginalState();

    				}

    			}

    			this._lendAction( action );

    		}

    	},

    	_deactivateAction: function( action ) {

    		if ( this._isActiveAction( action ) ) {

    			var bindings = action._propertyBindings;

    			// decrement reference counts / sort out state
    			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

    				var binding = bindings[ i ];

    				if ( -- binding.useCount === 0 ) {

    					binding.restoreOriginalState();
    					this._takeBackBinding( binding );

    				}

    			}

    			this._takeBackAction( action );

    		}

    	},

    	// Memory manager

    	_initMemoryManager: function() {

    		this._actions = []; // 'nActiveActions' followed by inactive ones
    		this._nActiveActions = 0;

    		this._actionsByClip = {};
    		// inside:
    		// {
    		// 		knownActions: Array< AnimationAction >	- used as prototypes
    		// 		actionByRoot: AnimationAction			- lookup
    		// }


    		this._bindings = []; // 'nActiveBindings' followed by inactive ones
    		this._nActiveBindings = 0;

    		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


    		this._controlInterpolants = []; // same game as above
    		this._nActiveControlInterpolants = 0;

    		var scope = this;

    		this.stats = {

    			actions: {
    				get total() { return scope._actions.length; },
    				get inUse() { return scope._nActiveActions; }
    			},
    			bindings: {
    				get total() { return scope._bindings.length; },
    				get inUse() { return scope._nActiveBindings; }
    			},
    			controlInterpolants: {
    				get total() { return scope._controlInterpolants.length; },
    				get inUse() { return scope._nActiveControlInterpolants; }
    			}

    		};

    	},

    	// Memory management for AnimationAction objects

    	_isActiveAction: function( action ) {

    		var index = action._cacheIndex;
    		return index !== null && index < this._nActiveActions;

    	},

    	_addInactiveAction: function( action, clipUuid, rootUuid ) {

    		var actions = this._actions,
    			actionsByClip = this._actionsByClip,
    			actionsForClip = actionsByClip[ clipUuid ];

    		if ( actionsForClip === undefined ) {

    			actionsForClip = {

    				knownActions: [ action ],
    				actionByRoot: {}

    			};

    			action._byClipCacheIndex = 0;

    			actionsByClip[ clipUuid ] = actionsForClip;

    		} else {

    			var knownActions = actionsForClip.knownActions;

    			action._byClipCacheIndex = knownActions.length;
    			knownActions.push( action );

    		}

    		action._cacheIndex = actions.length;
    		actions.push( action );

    		actionsForClip.actionByRoot[ rootUuid ] = action;

    	},

    	_removeInactiveAction: function( action ) {

    		var actions = this._actions,
    			lastInactiveAction = actions[ actions.length - 1 ],
    			cacheIndex = action._cacheIndex;

    		lastInactiveAction._cacheIndex = cacheIndex;
    		actions[ cacheIndex ] = lastInactiveAction;
    		actions.pop();

    		action._cacheIndex = null;


    		var clipUuid = action._clip.uuid,
    			actionsByClip = this._actionsByClip,
    			actionsForClip = actionsByClip[ clipUuid ],
    			knownActionsForClip = actionsForClip.knownActions,

    			lastKnownAction =
    				knownActionsForClip[ knownActionsForClip.length - 1 ],

    			byClipCacheIndex = action._byClipCacheIndex;

    		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
    		knownActionsForClip.pop();

    		action._byClipCacheIndex = null;


    		var actionByRoot = actionsForClip.actionByRoot,
    			rootUuid = ( actions._localRoot || this._root ).uuid;

    		delete actionByRoot[ rootUuid ];

    		if ( knownActionsForClip.length === 0 ) {

    			delete actionsByClip[ clipUuid ];

    		}

    		this._removeInactiveBindingsForAction( action );

    	},

    	_removeInactiveBindingsForAction: function( action ) {

    		var bindings = action._propertyBindings;
    		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

    			var binding = bindings[ i ];

    			if ( -- binding.referenceCount === 0 ) {

    				this._removeInactiveBinding( binding );

    			}

    		}

    	},

    	_lendAction: function( action ) {

    		// [ active actions |  inactive actions  ]
    		// [  active actions >| inactive actions ]
    		//                 s        a
    		//                  <-swap->
    		//                 a        s

    		var actions = this._actions,
    			prevIndex = action._cacheIndex,

    			lastActiveIndex = this._nActiveActions ++,

    			firstInactiveAction = actions[ lastActiveIndex ];

    		action._cacheIndex = lastActiveIndex;
    		actions[ lastActiveIndex ] = action;

    		firstInactiveAction._cacheIndex = prevIndex;
    		actions[ prevIndex ] = firstInactiveAction;

    	},

    	_takeBackAction: function( action ) {

    		// [  active actions  | inactive actions ]
    		// [ active actions |< inactive actions  ]
    		//        a        s
    		//         <-swap->
    		//        s        a

    		var actions = this._actions,
    			prevIndex = action._cacheIndex,

    			firstInactiveIndex = -- this._nActiveActions,

    			lastActiveAction = actions[ firstInactiveIndex ];

    		action._cacheIndex = firstInactiveIndex;
    		actions[ firstInactiveIndex ] = action;

    		lastActiveAction._cacheIndex = prevIndex;
    		actions[ prevIndex ] = lastActiveAction;

    	},

    	// Memory management for PropertyMixer objects

    	_addInactiveBinding: function( binding, rootUuid, trackName ) {

    		var bindingsByRoot = this._bindingsByRootAndName,
    			bindingByName = bindingsByRoot[ rootUuid ],

    			bindings = this._bindings;

    		if ( bindingByName === undefined ) {

    			bindingByName = {};
    			bindingsByRoot[ rootUuid ] = bindingByName;

    		}

    		bindingByName[ trackName ] = binding;

    		binding._cacheIndex = bindings.length;
    		bindings.push( binding );

    	},

    	_removeInactiveBinding: function( binding ) {

    		var bindings = this._bindings,
    			propBinding = binding.binding,
    			rootUuid = propBinding.rootNode.uuid,
    			trackName = propBinding.path,
    			bindingsByRoot = this._bindingsByRootAndName,
    			bindingByName = bindingsByRoot[ rootUuid ],

    			lastInactiveBinding = bindings[ bindings.length - 1 ],
    			cacheIndex = binding._cacheIndex;

    		lastInactiveBinding._cacheIndex = cacheIndex;
    		bindings[ cacheIndex ] = lastInactiveBinding;
    		bindings.pop();

    		delete bindingByName[ trackName ];

    		remove_empty_map: {

    			for ( var _ in bindingByName ) break remove_empty_map;

    			delete bindingsByRoot[ rootUuid ];

    		}

    	},

    	_lendBinding: function( binding ) {

    		var bindings = this._bindings,
    			prevIndex = binding._cacheIndex,

    			lastActiveIndex = this._nActiveBindings ++,

    			firstInactiveBinding = bindings[ lastActiveIndex ];

    		binding._cacheIndex = lastActiveIndex;
    		bindings[ lastActiveIndex ] = binding;

    		firstInactiveBinding._cacheIndex = prevIndex;
    		bindings[ prevIndex ] = firstInactiveBinding;

    	},

    	_takeBackBinding: function( binding ) {

    		var bindings = this._bindings,
    			prevIndex = binding._cacheIndex,

    			firstInactiveIndex = -- this._nActiveBindings,

    			lastActiveBinding = bindings[ firstInactiveIndex ];

    		binding._cacheIndex = firstInactiveIndex;
    		bindings[ firstInactiveIndex ] = binding;

    		lastActiveBinding._cacheIndex = prevIndex;
    		bindings[ prevIndex ] = lastActiveBinding;

    	},


    	// Memory management of Interpolants for weight and time scale

    	_lendControlInterpolant: function() {

    		var interpolants = this._controlInterpolants,
    			lastActiveIndex = this._nActiveControlInterpolants ++,
    			interpolant = interpolants[ lastActiveIndex ];

    		if ( interpolant === undefined ) {

    			interpolant = new LinearInterpolant(
    					new Float32Array( 2 ), new Float32Array( 2 ),
    						1, this._controlInterpolantsResultBuffer );

    			interpolant.__cacheIndex = lastActiveIndex;
    			interpolants[ lastActiveIndex ] = interpolant;

    		}

    		return interpolant;

    	},

    	_takeBackControlInterpolant: function( interpolant ) {

    		var interpolants = this._controlInterpolants,
    			prevIndex = interpolant.__cacheIndex,

    			firstInactiveIndex = -- this._nActiveControlInterpolants,

    			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

    		interpolant.__cacheIndex = firstInactiveIndex;
    		interpolants[ firstInactiveIndex ] = interpolant;

    		lastActiveInterpolant.__cacheIndex = prevIndex;
    		interpolants[ prevIndex ] = lastActiveInterpolant;

    	},

    	_controlInterpolantsResultBuffer: new Float32Array( 1 )

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Uniform( value ) {

    	if ( typeof value === 'string' ) {

    		console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
    		value = arguments[ 1 ];

    	}

    	this.value = value;

    	this.dynamic = false;

    }

    Uniform.prototype = {

    	constructor: Uniform,

    	onUpdate: function ( callback ) {

    		this.dynamic = true;
    		this.onUpdateCallback = callback;

    		return this;

    	}

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InstancedBufferGeometry() {

    	BufferGeometry.call( this );

    	this.type = 'InstancedBufferGeometry';
    	this.maxInstancedCount = undefined;

    }

    InstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;

    InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

    InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {

    	this.groups.push( {

    		start: start,
    		count: count,
    		instances: instances

    	} );

    };

    InstancedBufferGeometry.prototype.copy = function ( source ) {

    	var index = source.index;

    	if ( index !== null ) {

    		this.setIndex( index.clone() );

    	}

    	var attributes = source.attributes;

    	for ( var name in attributes ) {

    		var attribute = attributes[ name ];
    		this.addAttribute( name, attribute.clone() );

    	}

    	var groups = source.groups;

    	for ( var i = 0, l = groups.length; i < l; i ++ ) {

    		var group = groups[ i ];
    		this.addGroup( group.start, group.count, group.instances );

    	}

    	return this;

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

    	this.uuid = exports.Math.generateUUID();

    	this.data = interleavedBuffer;
    	this.itemSize = itemSize;
    	this.offset = offset;

    	this.normalized = normalized === true;

    }


    InterleavedBufferAttribute.prototype = {

    	constructor: InterleavedBufferAttribute,

    	isInterleavedBufferAttribute: true,

    	get count() {

    		return this.data.count;

    	},

    	get array() {

    		return this.data.array;

    	},

    	setX: function ( index, x ) {

    		this.data.array[ index * this.data.stride + this.offset ] = x;

    		return this;

    	},

    	setY: function ( index, y ) {

    		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

    		return this;

    	},

    	setZ: function ( index, z ) {

    		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

    		return this;

    	},

    	setW: function ( index, w ) {

    		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

    		return this;

    	},

    	getX: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset ];

    	},

    	getY: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset + 1 ];

    	},

    	getZ: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset + 2 ];

    	},

    	getW: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset + 3 ];

    	},

    	setXY: function ( index, x, y ) {

    		index = index * this.data.stride + this.offset;

    		this.data.array[ index + 0 ] = x;
    		this.data.array[ index + 1 ] = y;

    		return this;

    	},

    	setXYZ: function ( index, x, y, z ) {

    		index = index * this.data.stride + this.offset;

    		this.data.array[ index + 0 ] = x;
    		this.data.array[ index + 1 ] = y;
    		this.data.array[ index + 2 ] = z;

    		return this;

    	},

    	setXYZW: function ( index, x, y, z, w ) {

    		index = index * this.data.stride + this.offset;

    		this.data.array[ index + 0 ] = x;
    		this.data.array[ index + 1 ] = y;
    		this.data.array[ index + 2 ] = z;
    		this.data.array[ index + 3 ] = w;

    		return this;

    	}

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InterleavedBuffer( array, stride ) {

    	this.uuid = exports.Math.generateUUID();

    	this.array = array;
    	this.stride = stride;
    	this.count = array !== undefined ? array.length / stride : 0;

    	this.dynamic = false;
    	this.updateRange = { offset: 0, count: - 1 };

    	this.version = 0;

    }

    InterleavedBuffer.prototype = {

    	constructor: InterleavedBuffer,

    	isInterleavedBuffer: true,

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	},

    	setDynamic: function ( value ) {

    		this.dynamic = value;

    		return this;

    	},

    	copy: function ( source ) {

    		this.array = new source.array.constructor( source.array );
    		this.count = source.count;
    		this.stride = source.stride;
    		this.dynamic = source.dynamic;

    		return this;

    	},

    	copyAt: function ( index1, attribute, index2 ) {

    		index1 *= this.stride;
    		index2 *= attribute.stride;

    		for ( var i = 0, l = this.stride; i < l; i ++ ) {

    			this.array[ index1 + i ] = attribute.array[ index2 + i ];

    		}

    		return this;

    	},

    	set: function ( value, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.array.set( value, offset );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	}

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

    	InterleavedBuffer.call( this, array, stride );

    	this.meshPerAttribute = meshPerAttribute || 1;

    }

    InstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );
    InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;

    InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

    InstancedInterleavedBuffer.prototype.copy = function ( source ) {

    	InterleavedBuffer.prototype.copy.call( this, source );

    	this.meshPerAttribute = source.meshPerAttribute;

    	return this;

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

    	BufferAttribute.call( this, array, itemSize );

    	this.meshPerAttribute = meshPerAttribute || 1;

    }

    InstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
    InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;

    InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

    InstancedBufferAttribute.prototype.copy = function ( source ) {

    	BufferAttribute.prototype.copy.call( this, source );

    	this.meshPerAttribute = source.meshPerAttribute;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author bhouston / http://clara.io/
     * @author stephomi / http://stephaneginier.com/
     */

    function Raycaster( origin, direction, near, far ) {

    	this.ray = new Ray( origin, direction );
    	// direction is assumed to be normalized (for accurate distance calculations)

    	this.near = near || 0;
    	this.far = far || Infinity;

    	this.params = {
    		Mesh: {},
    		Line: {},
    		LOD: {},
    		Points: { threshold: 1 },
    		Sprite: {}
    	};

    	Object.defineProperties( this.params, {
    		PointCloud: {
    			get: function () {
    				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
    				return this.Points;
    			}
    		}
    	} );

    }

    function ascSort( a, b ) {

    	return a.distance - b.distance;

    }

    function intersectObject( object, raycaster, intersects, recursive ) {

    	if ( object.visible === false ) return;

    	object.raycast( raycaster, intersects );

    	if ( recursive === true ) {

    		var children = object.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			intersectObject( children[ i ], raycaster, intersects, true );

    		}

    	}

    }

    //

    Raycaster.prototype = {

    	constructor: Raycaster,

    	linePrecision: 1,

    	set: function ( origin, direction ) {

    		// direction is assumed to be normalized (for accurate distance calculations)

    		this.ray.set( origin, direction );

    	},

    	setFromCamera: function ( coords, camera ) {

    		if ( (camera && camera.isPerspectiveCamera) ) {

    			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
    			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

    		} else if ( (camera && camera.isOrthographicCamera) ) {

    			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
    			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

    		} else {

    			console.error( 'THREE.Raycaster: Unsupported camera type.' );

    		}

    	},

    	intersectObject: function ( object, recursive ) {

    		var intersects = [];

    		intersectObject( object, this, intersects, recursive );

    		intersects.sort( ascSort );

    		return intersects;

    	},

    	intersectObjects: function ( objects, recursive ) {

    		var intersects = [];

    		if ( Array.isArray( objects ) === false ) {

    			console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
    			return intersects;

    		}

    		for ( var i = 0, l = objects.length; i < l; i ++ ) {

    			intersectObject( objects[ i ], this, intersects, recursive );

    		}

    		intersects.sort( ascSort );

    		return intersects;

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function Clock( autoStart ) {

    	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

    	this.startTime = 0;
    	this.oldTime = 0;
    	this.elapsedTime = 0;

    	this.running = false;

    }

    Clock.prototype = {

    	constructor: Clock,

    	start: function () {

    		this.startTime = ( performance || Date ).now();

    		this.oldTime = this.startTime;
    		this.running = true;

    	},

    	stop: function () {

    		this.getElapsedTime();
    		this.running = false;

    	},

    	getElapsedTime: function () {

    		this.getDelta();
    		return this.elapsedTime;

    	},

    	getDelta: function () {

    		var diff = 0;

    		if ( this.autoStart && ! this.running ) {

    			this.start();

    		}

    		if ( this.running ) {

    			var newTime = ( performance || Date ).now();

    			diff = ( newTime - this.oldTime ) / 1000;
    			this.oldTime = newTime;

    			this.elapsedTime += diff;

    		}

    		return diff;

    	}

    };

    /**
     * Spline from Tween.js, slightly optimized (and trashed)
     * http://sole.github.com/tween.js/examples/05_spline.html
     *
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Spline( points ) {

    	this.points = points;

    	var c = [], v3 = { x: 0, y: 0, z: 0 },
    	point, intPoint, weight, w2, w3,
    	pa, pb, pc, pd;

    	this.initFromArray = function ( a ) {

    		this.points = [];

    		for ( var i = 0; i < a.length; i ++ ) {

    			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

    		}

    	};

    	this.getPoint = function ( k ) {

    		point = ( this.points.length - 1 ) * k;
    		intPoint = Math.floor( point );
    		weight = point - intPoint;

    		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
    		c[ 1 ] = intPoint;
    		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
    		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

    		pa = this.points[ c[ 0 ] ];
    		pb = this.points[ c[ 1 ] ];
    		pc = this.points[ c[ 2 ] ];
    		pd = this.points[ c[ 3 ] ];

    		w2 = weight * weight;
    		w3 = weight * w2;

    		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
    		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
    		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

    		return v3;

    	};

    	this.getControlPointsArray = function () {

    		var i, p, l = this.points.length,
    			coords = [];

    		for ( i = 0; i < l; i ++ ) {

    			p = this.points[ i ];
    			coords[ i ] = [ p.x, p.y, p.z ];

    		}

    		return coords;

    	};

    	// approximate length by summing linear segments

    	this.getLength = function ( nSubDivisions ) {

    		var i, index, nSamples, position,
    			point = 0, intPoint = 0, oldIntPoint = 0,
    			oldPosition = new Vector3(),
    			tmpVec = new Vector3(),
    			chunkLengths = [],
    			totalLength = 0;

    		// first point has 0 length

    		chunkLengths[ 0 ] = 0;

    		if ( ! nSubDivisions ) nSubDivisions = 100;

    		nSamples = this.points.length * nSubDivisions;

    		oldPosition.copy( this.points[ 0 ] );

    		for ( i = 1; i < nSamples; i ++ ) {

    			index = i / nSamples;

    			position = this.getPoint( index );
    			tmpVec.copy( position );

    			totalLength += tmpVec.distanceTo( oldPosition );

    			oldPosition.copy( position );

    			point = ( this.points.length - 1 ) * index;
    			intPoint = Math.floor( point );

    			if ( intPoint !== oldIntPoint ) {

    				chunkLengths[ intPoint ] = totalLength;
    				oldIntPoint = intPoint;

    			}

    		}

    		// last point ends with total length

    		chunkLengths[ chunkLengths.length ] = totalLength;

    		return { chunks: chunkLengths, total: totalLength };

    	};

    	this.reparametrizeByArcLength = function ( samplingCoef ) {

    		var i, j,
    			index, indexCurrent, indexNext,
    			realDistance,
    			sampling, position,
    			newpoints = [],
    			tmpVec = new Vector3(),
    			sl = this.getLength();

    		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

    		for ( i = 1; i < this.points.length; i ++ ) {

    			//tmpVec.copy( this.points[ i - 1 ] );
    			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

    			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

    			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

    			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
    			indexNext = i / ( this.points.length - 1 );

    			for ( j = 1; j < sampling - 1; j ++ ) {

    				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

    				position = this.getPoint( index );
    				newpoints.push( tmpVec.copy( position ).clone() );

    			}

    			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

    		}

    		this.points = newpoints;

    	};

    	// Catmull-Rom

    	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

    		var v0 = ( p2 - p0 ) * 0.5,
    			v1 = ( p3 - p1 ) * 0.5;

    		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    	}

    }

    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
     *
     * The poles (phi) are at the positive and negative y axis.
     * The equator starts at positive z.
     */

    function Spherical( radius, phi, theta ) {

    	this.radius = ( radius !== undefined ) ? radius : 1.0;
    	this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
    	this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

    	return this;

    }

    Spherical.prototype = {

    	constructor: Spherical,

    	set: function ( radius, phi, theta ) {

    		this.radius = radius;
    		this.phi = phi;
    		this.theta = theta;

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( other ) {

    		this.radius.copy( other.radius );
    		this.phi.copy( other.phi );
    		this.theta.copy( other.theta );

    		return this;

    	},

    	// restrict phi to be betwee EPS and PI-EPS
    	makeSafe: function() {

    		var EPS = 0.000001;
    		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

    		return this;

    	},

    	setFromVector3: function( vec3 ) {

    		this.radius = vec3.length();

    		if ( this.radius === 0 ) {

    			this.theta = 0;
    			this.phi = 0;

    		} else {

    			this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
    			this.phi = Math.acos( exports.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

    		}

    		return this;

    	},

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function MorphBlendMesh( geometry, material ) {

    	Mesh.call( this, geometry, material );

    	this.animationsMap = {};
    	this.animationsList = [];

    	// prepare default animation
    	// (all frames played together in 1 second)

    	var numFrames = this.geometry.morphTargets.length;

    	var name = "__default";

    	var startFrame = 0;
    	var endFrame = numFrames - 1;

    	var fps = numFrames / 1;

    	this.createAnimation( name, startFrame, endFrame, fps );
    	this.setAnimationWeight( name, 1 );

    }

    MorphBlendMesh.prototype = Object.create( Mesh.prototype );
    MorphBlendMesh.prototype.constructor = MorphBlendMesh;

    MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

    	var animation = {

    		start: start,
    		end: end,

    		length: end - start + 1,

    		fps: fps,
    		duration: ( end - start ) / fps,

    		lastFrame: 0,
    		currentFrame: 0,

    		active: false,

    		time: 0,
    		direction: 1,
    		weight: 1,

    		directionBackwards: false,
    		mirroredLoop: false

    	};

    	this.animationsMap[ name ] = animation;
    	this.animationsList.push( animation );

    };

    MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

    	var pattern = /([a-z]+)_?(\d+)/i;

    	var firstAnimation, frameRanges = {};

    	var geometry = this.geometry;

    	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

    		var morph = geometry.morphTargets[ i ];
    		var chunks = morph.name.match( pattern );

    		if ( chunks && chunks.length > 1 ) {

    			var name = chunks[ 1 ];

    			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

    			var range = frameRanges[ name ];

    			if ( i < range.start ) range.start = i;
    			if ( i > range.end ) range.end = i;

    			if ( ! firstAnimation ) firstAnimation = name;

    		}

    	}

    	for ( var name in frameRanges ) {

    		var range = frameRanges[ name ];
    		this.createAnimation( name, range.start, range.end, fps );

    	}

    	this.firstAnimation = firstAnimation;

    };

    MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.direction = 1;
    		animation.directionBackwards = false;

    	}

    };

    MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.direction = - 1;
    		animation.directionBackwards = true;

    	}

    };

    MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.fps = fps;
    		animation.duration = ( animation.end - animation.start ) / animation.fps;

    	}

    };

    MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.duration = duration;
    		animation.fps = ( animation.end - animation.start ) / animation.duration;

    	}

    };

    MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.weight = weight;

    	}

    };

    MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.time = time;

    	}

    };

    MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

    	var time = 0;

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		time = animation.time;

    	}

    	return time;

    };

    MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

    	var duration = - 1;

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		duration = animation.duration;

    	}

    	return duration;

    };

    MorphBlendMesh.prototype.playAnimation = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.time = 0;
    		animation.active = true;

    	} else {

    		console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

    	}

    };

    MorphBlendMesh.prototype.stopAnimation = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.active = false;

    	}

    };

    MorphBlendMesh.prototype.update = function ( delta ) {

    	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

    		var animation = this.animationsList[ i ];

    		if ( ! animation.active ) continue;

    		var frameTime = animation.duration / animation.length;

    		animation.time += animation.direction * delta;

    		if ( animation.mirroredLoop ) {

    			if ( animation.time > animation.duration || animation.time < 0 ) {

    				animation.direction *= - 1;

    				if ( animation.time > animation.duration ) {

    					animation.time = animation.duration;
    					animation.directionBackwards = true;

    				}

    				if ( animation.time < 0 ) {

    					animation.time = 0;
    					animation.directionBackwards = false;

    				}

    			}

    		} else {

    			animation.time = animation.time % animation.duration;

    			if ( animation.time < 0 ) animation.time += animation.duration;

    		}

    		var keyframe = animation.start + exports.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
    		var weight = animation.weight;

    		if ( keyframe !== animation.currentFrame ) {

    			this.morphTargetInfluences[ animation.lastFrame ] = 0;
    			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

    			this.morphTargetInfluences[ keyframe ] = 0;

    			animation.lastFrame = animation.currentFrame;
    			animation.currentFrame = keyframe;

    		}

    		var mix = ( animation.time % frameTime ) / frameTime;

    		if ( animation.directionBackwards ) mix = 1 - mix;

    		if ( animation.currentFrame !== animation.lastFrame ) {

    			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
    			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

    		} else {

    			this.morphTargetInfluences[ animation.currentFrame ] = weight;

    		}

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function ImmediateRenderObject( material ) {

    	Object3D.call( this );

    	this.material = material;
    	this.render = function ( renderCallback ) {};

    }

    ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
    ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

    ImmediateRenderObject.prototype.isImmediateRenderObject = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
    */

    function VertexNormalsHelper( object, size, hex, linewidth ) {

    	this.object = object;

    	this.size = ( size !== undefined ) ? size : 1;

    	var color = ( hex !== undefined ) ? hex : 0xff0000;

    	var width = ( linewidth !== undefined ) ? linewidth : 1;

    	//

    	var nNormals = 0;

    	var objGeometry = this.object.geometry;

    	if ( (objGeometry && objGeometry.isGeometry) ) {

    		nNormals = objGeometry.faces.length * 3;

    	} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {

    		nNormals = objGeometry.attributes.normal.count;

    	}

    	//

    	var geometry = new BufferGeometry();

    	var positions = new Float32Attribute( nNormals * 2 * 3, 3 );

    	geometry.addAttribute( 'position', positions );

    	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

    	//

    	this.matrixAutoUpdate = false;

    	this.update();

    }

    VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
    VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

    VertexNormalsHelper.prototype.update = ( function () {

    	var v1 = new Vector3();
    	var v2 = new Vector3();
    	var normalMatrix = new Matrix3();

    	return function update() {

    		var keys = [ 'a', 'b', 'c' ];

    		this.object.updateMatrixWorld( true );

    		normalMatrix.getNormalMatrix( this.object.matrixWorld );

    		var matrixWorld = this.object.matrixWorld;

    		var position = this.geometry.attributes.position;

    		//

    		var objGeometry = this.object.geometry;

    		if ( (objGeometry && objGeometry.isGeometry) ) {

    			var vertices = objGeometry.vertices;

    			var faces = objGeometry.faces;

    			var idx = 0;

    			for ( var i = 0, l = faces.length; i < l; i ++ ) {

    				var face = faces[ i ];

    				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

    					var vertex = vertices[ face[ keys[ j ] ] ];

    					var normal = face.vertexNormals[ j ];

    					v1.copy( vertex ).applyMatrix4( matrixWorld );

    					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

    					position.setXYZ( idx, v1.x, v1.y, v1.z );

    					idx = idx + 1;

    					position.setXYZ( idx, v2.x, v2.y, v2.z );

    					idx = idx + 1;

    				}

    			}

    		} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {

    			var objPos = objGeometry.attributes.position;

    			var objNorm = objGeometry.attributes.normal;

    			var idx = 0;

    			// for simplicity, ignore index and drawcalls, and render every normal

    			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

    				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

    				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

    				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

    				position.setXYZ( idx, v1.x, v1.y, v1.z );

    				idx = idx + 1;

    				position.setXYZ( idx, v2.x, v2.y, v2.z );

    				idx = idx + 1;

    			}

    		}

    		position.needsUpdate = true;

    		return this;

    	};

    }() );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
    */

    function SpotLightHelper( light ) {

    	Object3D.call( this );

    	this.light = light;
    	this.light.updateMatrixWorld();

    	this.matrix = light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	var geometry = new BufferGeometry();

    	var positions = [
    		0, 0, 0,   0,   0,   1,
    		0, 0, 0,   1,   0,   1,
    		0, 0, 0, - 1,   0,   1,
    		0, 0, 0,   0,   1,   1,
    		0, 0, 0,   0, - 1,   1
    	];

    	for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

    		var p1 = ( i / l ) * Math.PI * 2;
    		var p2 = ( j / l ) * Math.PI * 2;

    		positions.push(
    			Math.cos( p1 ), Math.sin( p1 ), 1,
    			Math.cos( p2 ), Math.sin( p2 ), 1
    		);

    	}

    	geometry.addAttribute( 'position', new Float32Attribute( positions, 3 ) );

    	var material = new LineBasicMaterial( { fog: false } );

    	this.cone = new LineSegments( geometry, material );
    	this.add( this.cone );

    	this.update();

    }

    SpotLightHelper.prototype = Object.create( Object3D.prototype );
    SpotLightHelper.prototype.constructor = SpotLightHelper;

    SpotLightHelper.prototype.dispose = function () {

    	this.cone.geometry.dispose();
    	this.cone.material.dispose();

    };

    SpotLightHelper.prototype.update = function () {

    	var vector = new Vector3();
    	var vector2 = new Vector3();

    	return function update() {

    		var coneLength = this.light.distance ? this.light.distance : 1000;
    		var coneWidth = coneLength * Math.tan( this.light.angle );

    		this.cone.scale.set( coneWidth, coneWidth, coneLength );

    		vector.setFromMatrixPosition( this.light.matrixWorld );
    		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

    		this.cone.lookAt( vector2.sub( vector ) );

    		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    	};

    }();

    /**
     * @author Sean Griffin / http://twitter.com/sgrif
     * @author Michael Guerrero / http://realitymeltdown.com
     * @author mrdoob / http://mrdoob.com/
     * @author ikerr / http://verold.com
     */

    function SkeletonHelper( object ) {

    	this.bones = this.getBoneList( object );

    	var geometry = new Geometry();

    	for ( var i = 0; i < this.bones.length; i ++ ) {

    		var bone = this.bones[ i ];

    		if ( (bone.parent && bone.parent.isBone) ) {

    			geometry.vertices.push( new Vector3() );
    			geometry.vertices.push( new Vector3() );
    			geometry.colors.push( new Color( 0, 0, 1 ) );
    			geometry.colors.push( new Color( 0, 1, 0 ) );

    		}

    	}

    	geometry.dynamic = true;

    	var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

    	LineSegments.call( this, geometry, material );

    	this.root = object;

    	this.matrix = object.matrixWorld;
    	this.matrixAutoUpdate = false;

    	this.update();

    }


    SkeletonHelper.prototype = Object.create( LineSegments.prototype );
    SkeletonHelper.prototype.constructor = SkeletonHelper;

    SkeletonHelper.prototype.getBoneList = function( object ) {

    	var boneList = [];

    	if ( (object && object.isBone) ) {

    		boneList.push( object );

    	}

    	for ( var i = 0; i < object.children.length; i ++ ) {

    		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

    	}

    	return boneList;

    };

    SkeletonHelper.prototype.update = function () {

    	var geometry = this.geometry;

    	var matrixWorldInv = new Matrix4().getInverse( this.root.matrixWorld );

    	var boneMatrix = new Matrix4();

    	var j = 0;

    	for ( var i = 0; i < this.bones.length; i ++ ) {

    		var bone = this.bones[ i ];

    		if ( (bone.parent && bone.parent.isBone) ) {

    			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
    			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

    			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
    			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

    			j += 2;

    		}

    	}

    	geometry.verticesNeedUpdate = true;

    	geometry.computeBoundingSphere();

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function PointLightHelper( light, sphereSize ) {

    	this.light = light;
    	this.light.updateMatrixWorld();

    	var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
    	var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
    	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    	Mesh.call( this, geometry, material );

    	this.matrix = this.light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	/*
    	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
    	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

    	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
    	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

    	var d = light.distance;

    	if ( d === 0.0 ) {

    		this.lightDistance.visible = false;

    	} else {

    		this.lightDistance.scale.set( d, d, d );

    	}

    	this.add( this.lightDistance );
    	*/

    }

    PointLightHelper.prototype = Object.create( Mesh.prototype );
    PointLightHelper.prototype.constructor = PointLightHelper;

    PointLightHelper.prototype.dispose = function () {

    	this.geometry.dispose();
    	this.material.dispose();

    };

    PointLightHelper.prototype.update = function () {

    	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    	/*
    	var d = this.light.distance;

    	if ( d === 0.0 ) {

    		this.lightDistance.visible = false;

    	} else {

    		this.lightDistance.visible = true;
    		this.lightDistance.scale.set( d, d, d );

    	}
    	*/

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function HemisphereLightHelper( light, sphereSize ) {

    	Object3D.call( this );

    	this.light = light;
    	this.light.updateMatrixWorld();

    	this.matrix = light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	this.colors = [ new Color(), new Color() ];

    	var geometry = new SphereGeometry( sphereSize, 4, 2 );
    	geometry.rotateX( - Math.PI / 2 );

    	for ( var i = 0, il = 8; i < il; i ++ ) {

    		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

    	}

    	var material = new MeshBasicMaterial( { vertexColors: FaceColors, wireframe: true } );

    	this.lightSphere = new Mesh( geometry, material );
    	this.add( this.lightSphere );

    	this.update();

    }

    HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
    HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

    HemisphereLightHelper.prototype.dispose = function () {

    	this.lightSphere.geometry.dispose();
    	this.lightSphere.material.dispose();

    };

    HemisphereLightHelper.prototype.update = function () {

    	var vector = new Vector3();

    	return function update() {

    		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
    		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

    		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
    		this.lightSphere.geometry.colorsNeedUpdate = true;

    	};

    }();

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function GridHelper( size, divisions, color1, color2 ) {

    	divisions = divisions || 1;
    	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
    	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

    	var center = divisions / 2;
    	var step = ( size * 2 ) / divisions;
    	var vertices = [], colors = [];

    	for ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {

    		vertices.push( - size, 0, k, size, 0, k );
    		vertices.push( k, 0, - size, k, 0, size );

    		var color = i === center ? color1 : color2;

    		color.toArray( colors, j ); j += 3;
    		color.toArray( colors, j ); j += 3;
    		color.toArray( colors, j ); j += 3;
    		color.toArray( colors, j ); j += 3;

    	}

    	var geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new Float32Attribute( vertices, 3 ) );
    	geometry.addAttribute( 'color', new Float32Attribute( colors, 3 ) );

    	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

    	LineSegments.call( this, geometry, material );

    }

    GridHelper.prototype = Object.create( LineSegments.prototype );
    GridHelper.prototype.constructor = GridHelper;

    GridHelper.prototype.setColors = function () {

    	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
    */

    function FaceNormalsHelper( object, size, hex, linewidth ) {

    	// FaceNormalsHelper only supports THREE.Geometry

    	this.object = object;

    	this.size = ( size !== undefined ) ? size : 1;

    	var color = ( hex !== undefined ) ? hex : 0xffff00;

    	var width = ( linewidth !== undefined ) ? linewidth : 1;

    	//

    	var nNormals = 0;

    	var objGeometry = this.object.geometry;

    	if ( (objGeometry && objGeometry.isGeometry) ) {

    		nNormals = objGeometry.faces.length;

    	} else {

    		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

    	}

    	//

    	var geometry = new BufferGeometry();

    	var positions = new Float32Attribute( nNormals * 2 * 3, 3 );

    	geometry.addAttribute( 'position', positions );

    	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

    	//

    	this.matrixAutoUpdate = false;
    	this.update();

    }

    FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
    FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

    FaceNormalsHelper.prototype.update = ( function () {

    	var v1 = new Vector3();
    	var v2 = new Vector3();
    	var normalMatrix = new Matrix3();

    	return function update() {

    		this.object.updateMatrixWorld( true );

    		normalMatrix.getNormalMatrix( this.object.matrixWorld );

    		var matrixWorld = this.object.matrixWorld;

    		var position = this.geometry.attributes.position;

    		//

    		var objGeometry = this.object.geometry;

    		var vertices = objGeometry.vertices;

    		var faces = objGeometry.faces;

    		var idx = 0;

    		for ( var i = 0, l = faces.length; i < l; i ++ ) {

    			var face = faces[ i ];

    			var normal = face.normal;

    			v1.copy( vertices[ face.a ] )
    				.add( vertices[ face.b ] )
    				.add( vertices[ face.c ] )
    				.divideScalar( 3 )
    				.applyMatrix4( matrixWorld );

    			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

    			position.setXYZ( idx, v1.x, v1.y, v1.z );

    			idx = idx + 1;

    			position.setXYZ( idx, v2.x, v2.y, v2.z );

    			idx = idx + 1;

    		}

    		position.needsUpdate = true;

    		return this;

    	};

    }() );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function DirectionalLightHelper( light, size ) {

    	Object3D.call( this );

    	this.light = light;
    	this.light.updateMatrixWorld();

    	this.matrix = light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	if ( size === undefined ) size = 1;

    	var geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new Float32Attribute( [
    		- size,   size, 0,
    		  size,   size, 0,
    		  size, - size, 0,
    		- size, - size, 0,
    		- size,   size, 0
    	], 3 ) );

    	var material = new LineBasicMaterial( { fog: false } );

    	this.add( new Line( geometry, material ) );

    	geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

    	this.add( new Line( geometry, material ));

    	this.update();

    }

    DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
    DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

    DirectionalLightHelper.prototype.dispose = function () {

    	var lightPlane = this.children[ 0 ];
    	var targetLine = this.children[ 1 ];

    	lightPlane.geometry.dispose();
    	lightPlane.material.dispose();
    	targetLine.geometry.dispose();
    	targetLine.material.dispose();

    };

    DirectionalLightHelper.prototype.update = function () {

    	var v1 = new Vector3();
    	var v2 = new Vector3();
    	var v3 = new Vector3();

    	return function update() {

    		v1.setFromMatrixPosition( this.light.matrixWorld );
    		v2.setFromMatrixPosition( this.light.target.matrixWorld );
    		v3.subVectors( v2, v1 );

    		var lightPlane = this.children[ 0 ];
    		var targetLine = this.children[ 1 ];

    		lightPlane.lookAt( v3 );
    		lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    		targetLine.lookAt( v3 );
    		targetLine.scale.z = v3.length();

    	};

    }();

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     *	- shows frustum, line of sight and up of the camera
     *	- suitable for fast updates
     * 	- based on frustum visualization in lightgl.js shadowmap example
     *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
     */

    function CameraHelper( camera ) {

    	var geometry = new Geometry();
    	var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

    	var pointMap = {};

    	// colors

    	var hexFrustum = 0xffaa00;
    	var hexCone = 0xff0000;
    	var hexUp = 0x00aaff;
    	var hexTarget = 0xffffff;
    	var hexCross = 0x333333;

    	// near

    	addLine( "n1", "n2", hexFrustum );
    	addLine( "n2", "n4", hexFrustum );
    	addLine( "n4", "n3", hexFrustum );
    	addLine( "n3", "n1", hexFrustum );

    	// far

    	addLine( "f1", "f2", hexFrustum );
    	addLine( "f2", "f4", hexFrustum );
    	addLine( "f4", "f3", hexFrustum );
    	addLine( "f3", "f1", hexFrustum );

    	// sides

    	addLine( "n1", "f1", hexFrustum );
    	addLine( "n2", "f2", hexFrustum );
    	addLine( "n3", "f3", hexFrustum );
    	addLine( "n4", "f4", hexFrustum );

    	// cone

    	addLine( "p", "n1", hexCone );
    	addLine( "p", "n2", hexCone );
    	addLine( "p", "n3", hexCone );
    	addLine( "p", "n4", hexCone );

    	// up

    	addLine( "u1", "u2", hexUp );
    	addLine( "u2", "u3", hexUp );
    	addLine( "u3", "u1", hexUp );

    	// target

    	addLine( "c", "t", hexTarget );
    	addLine( "p", "c", hexCross );

    	// cross

    	addLine( "cn1", "cn2", hexCross );
    	addLine( "cn3", "cn4", hexCross );

    	addLine( "cf1", "cf2", hexCross );
    	addLine( "cf3", "cf4", hexCross );

    	function addLine( a, b, hex ) {

    		addPoint( a, hex );
    		addPoint( b, hex );

    	}

    	function addPoint( id, hex ) {

    		geometry.vertices.push( new Vector3() );
    		geometry.colors.push( new Color( hex ) );

    		if ( pointMap[ id ] === undefined ) {

    			pointMap[ id ] = [];

    		}

    		pointMap[ id ].push( geometry.vertices.length - 1 );

    	}

    	LineSegments.call( this, geometry, material );

    	this.camera = camera;
    	if( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

    	this.matrix = camera.matrixWorld;
    	this.matrixAutoUpdate = false;

    	this.pointMap = pointMap;

    	this.update();

    }

    CameraHelper.prototype = Object.create( LineSegments.prototype );
    CameraHelper.prototype.constructor = CameraHelper;

    CameraHelper.prototype.update = function () {

    	var geometry, pointMap;

    	var vector = new Vector3();
    	var camera = new Camera();

    	function setPoint( point, x, y, z ) {

    		vector.set( x, y, z ).unproject( camera );

    		var points = pointMap[ point ];

    		if ( points !== undefined ) {

    			for ( var i = 0, il = points.length; i < il; i ++ ) {

    				geometry.vertices[ points[ i ] ].copy( vector );

    			}

    		}

    	}

    	return function update() {

    		geometry = this.geometry;
    		pointMap = this.pointMap;

    		var w = 1, h = 1;

    		// we need just camera projection matrix
    		// world matrix must be identity

    		camera.projectionMatrix.copy( this.camera.projectionMatrix );

    		// center / target

    		setPoint( "c", 0, 0, - 1 );
    		setPoint( "t", 0, 0,  1 );

    		// near

    		setPoint( "n1", - w, - h, - 1 );
    		setPoint( "n2",   w, - h, - 1 );
    		setPoint( "n3", - w,   h, - 1 );
    		setPoint( "n4",   w,   h, - 1 );

    		// far

    		setPoint( "f1", - w, - h, 1 );
    		setPoint( "f2",   w, - h, 1 );
    		setPoint( "f3", - w,   h, 1 );
    		setPoint( "f4",   w,   h, 1 );

    		// up

    		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
    		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
    		setPoint( "u3",         0, h * 2,   - 1 );

    		// cross

    		setPoint( "cf1", - w,   0, 1 );
    		setPoint( "cf2",   w,   0, 1 );
    		setPoint( "cf3",   0, - h, 1 );
    		setPoint( "cf4",   0,   h, 1 );

    		setPoint( "cn1", - w,   0, - 1 );
    		setPoint( "cn2",   w,   0, - 1 );
    		setPoint( "cn3",   0, - h, - 1 );
    		setPoint( "cn4",   0,   h, - 1 );

    		geometry.verticesNeedUpdate = true;

    	};

    }();

    /**
     * @author WestLangley / http://github.com/WestLangley
     */

    // a helper to show the world-axis-aligned bounding box for an object

    function BoundingBoxHelper( object, hex ) {

    	var color = ( hex !== undefined ) ? hex : 0x888888;

    	this.object = object;

    	this.box = new Box3();

    	Mesh.call( this, new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( { color: color, wireframe: true } ) );

    }

    BoundingBoxHelper.prototype = Object.create( Mesh.prototype );
    BoundingBoxHelper.prototype.constructor = BoundingBoxHelper;

    BoundingBoxHelper.prototype.update = function () {

    	this.box.setFromObject( this.object );

    	this.box.size( this.scale );

    	this.box.getCenter( this.position );

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function BoxHelper( object, color ) {

    	if ( color === undefined ) color = 0xffff00;

    	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
    	var positions = new Float32Array( 8 * 3 );

    	var geometry = new BufferGeometry();
    	geometry.setIndex( new BufferAttribute( indices, 1 ) );
    	geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

    	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

    	if ( object !== undefined ) {

    		this.update( object );

    	}

    }

    BoxHelper.prototype = Object.create( LineSegments.prototype );
    BoxHelper.prototype.constructor = BoxHelper;

    BoxHelper.prototype.update = ( function () {

    	var box = new Box3();

    	return function update( object ) {

    		if ( (object && object.isBox3) ) {

    			box.copy( object );

    		} else {

    			box.setFromObject( object );

    		}

    		if ( box.isEmpty() ) return;

    		var min = box.min;
    		var max = box.max;

    		/*
    		  5____4
    		1/___0/|
    		| 6__|_7
    		2/___3/

    		0: max.x, max.y, max.z
    		1: min.x, max.y, max.z
    		2: min.x, min.y, max.z
    		3: max.x, min.y, max.z
    		4: max.x, max.y, min.z
    		5: min.x, max.y, min.z
    		6: min.x, min.y, min.z
    		7: max.x, min.y, min.z
    		*/

    		var position = this.geometry.attributes.position;
    		var array = position.array;

    		array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
    		array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
    		array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
    		array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
    		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
    		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
    		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
    		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

    		position.needsUpdate = true;

    		this.geometry.computeBoundingSphere();

    	};

    } )();

    var lineGeometry = new BufferGeometry();
    lineGeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

    var coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
    coneGeometry.translate( 0, - 0.5, 0 );

    function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

    	// dir is assumed to be normalized

    	Object3D.call( this );

    	if ( color === undefined ) color = 0xffff00;
    	if ( length === undefined ) length = 1;
    	if ( headLength === undefined ) headLength = 0.2 * length;
    	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    	this.position.copy( origin );

    	this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
    	this.line.matrixAutoUpdate = false;
    	this.add( this.line );

    	this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
    	this.cone.matrixAutoUpdate = false;
    	this.add( this.cone );

    	this.setDirection( dir );
    	this.setLength( length, headLength, headWidth );

    }

    ArrowHelper.prototype = Object.create( Object3D.prototype );
    ArrowHelper.prototype.constructor = ArrowHelper;

    ArrowHelper.prototype.setDirection = ( function () {

    	var axis = new Vector3();
    	var radians;

    	return function setDirection( dir ) {

    		// dir is assumed to be normalized

    		if ( dir.y > 0.99999 ) {

    			this.quaternion.set( 0, 0, 0, 1 );

    		} else if ( dir.y < - 0.99999 ) {

    			this.quaternion.set( 1, 0, 0, 0 );

    		} else {

    			axis.set( dir.z, 0, - dir.x ).normalize();

    			radians = Math.acos( dir.y );

    			this.quaternion.setFromAxisAngle( axis, radians );

    		}

    	};

    }() );

    ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

    	if ( headLength === undefined ) headLength = 0.2 * length;
    	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    	this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
    	this.line.updateMatrix();

    	this.cone.scale.set( headWidth, headLength, headWidth );
    	this.cone.position.y = length;
    	this.cone.updateMatrix();

    };

    ArrowHelper.prototype.setColor = function ( color ) {

    	this.line.material.color.copy( color );
    	this.cone.material.color.copy( color );

    };

    /**
     * @author sroucheray / http://sroucheray.org/
     * @author mrdoob / http://mrdoob.com/
     */

    function AxisHelper( size ) {

    	size = size || 1;

    	var vertices = new Float32Array( [
    		0, 0, 0,  size, 0, 0,
    		0, 0, 0,  0, size, 0,
    		0, 0, 0,  0, 0, size
    	] );

    	var colors = new Float32Array( [
    		1, 0, 0,  1, 0.6, 0,
    		0, 1, 0,  0.6, 1, 0,
    		0, 0, 1,  0, 0.6, 1
    	] );

    	var geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

    	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

    	LineSegments.call( this, geometry, material );

    }

    AxisHelper.prototype = Object.create( LineSegments.prototype );
    AxisHelper.prototype.constructor = AxisHelper;

    /**
     * @author zz85 https://github.com/zz85
     *
     * Centripetal CatmullRom Curve - which is useful for avoiding
     * cusps and self-intersections in non-uniform catmull rom curves.
     * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
     *
     * curve.type accepts centripetal(default), chordal and catmullrom
     * curve.tension is used for catmullrom which defaults to 0.5
     */

    exports.CatmullRomCurve3 = ( function() {

    	var
    		tmp = new Vector3(),
    		px = new CubicPoly(),
    		py = new CubicPoly(),
    		pz = new CubicPoly();

    	/*
    	Based on an optimized c++ solution in
    	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
    	 - http://ideone.com/NoEbVM

    	This CubicPoly class could be used for reusing some variables and calculations,
    	but for three.js curve use, it could be possible inlined and flatten into a single function call
    	which can be placed in CurveUtils.
    	*/

    	function CubicPoly() {

    	}

    	/*
    	 * Compute coefficients for a cubic polynomial
    	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
    	 * such that
    	 *   p(0) = x0, p(1) = x1
    	 *  and
    	 *   p'(0) = t0, p'(1) = t1.
    	 */
    	CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

    		this.c0 = x0;
    		this.c1 = t0;
    		this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
    		this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

    	};

    	CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

    		// compute tangents when parameterized in [t1,t2]
    		var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
    		var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

    		// rescale tangents for parametrization in [0,1]
    		t1 *= dt1;
    		t2 *= dt1;

    		// initCubicPoly
    		this.init( x1, x2, t1, t2 );

    	};

    	// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
    	CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

    		this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

    	};

    	CubicPoly.prototype.calc = function( t ) {

    		var t2 = t * t;
    		var t3 = t2 * t;
    		return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

    	};

    	// Subclass Three.js curve
    	return Curve.create(

    		function ( p /* array of Vector3 */ ) {

    			this.points = p || [];
    			this.closed = false;

    		},

    		function ( t ) {

    			var points = this.points,
    				point, intPoint, weight, l;

    			l = points.length;

    			if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

    			point = ( l - ( this.closed ? 0 : 1 ) ) * t;
    			intPoint = Math.floor( point );
    			weight = point - intPoint;

    			if ( this.closed ) {

    				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

    			} else if ( weight === 0 && intPoint === l - 1 ) {

    				intPoint = l - 2;
    				weight = 1;

    			}

    			var p0, p1, p2, p3; // 4 points

    			if ( this.closed || intPoint > 0 ) {

    				p0 = points[ ( intPoint - 1 ) % l ];

    			} else {

    				// extrapolate first point
    				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
    				p0 = tmp;

    			}

    			p1 = points[ intPoint % l ];
    			p2 = points[ ( intPoint + 1 ) % l ];

    			if ( this.closed || intPoint + 2 < l ) {

    				p3 = points[ ( intPoint + 2 ) % l ];

    			} else {

    				// extrapolate last point
    				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
    				p3 = tmp;

    			}

    			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

    				// init Centripetal / Chordal Catmull-Rom
    				var pow = this.type === 'chordal' ? 0.5 : 0.25;
    				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
    				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
    				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

    				// safety check for repeated points
    				if ( dt1 < 1e-4 ) dt1 = 1.0;
    				if ( dt0 < 1e-4 ) dt0 = dt1;
    				if ( dt2 < 1e-4 ) dt2 = dt1;

    				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
    				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
    				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

    			} else if ( this.type === 'catmullrom' ) {

    				var tension = this.tension !== undefined ? this.tension : 0.5;
    				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
    				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
    				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

    			}

    			var v = new Vector3(
    				px.calc( weight ),
    				py.calc( weight ),
    				pz.calc( weight )
    			);

    			return v;

    		}

    	);

    } )();

    /**************************************************************
     *	Closed Spline 3D curve
     **************************************************************/


    function ClosedSplineCurve3( points ) {

    	console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );

    	exports.CatmullRomCurve3.call( this, points );
    	this.type = 'catmullrom';
    	this.closed = true;

    }

    ClosedSplineCurve3.prototype = Object.create( exports.CatmullRomCurve3.prototype );

    /**************************************************************
     *	Spline 3D curve
     **************************************************************/


    var SplineCurve3 = Curve.create(

    	function ( points /* array of Vector3 */ ) {

    		console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
    		this.points = ( points === undefined ) ? [] : points;

    	},

    	function ( t ) {

    		var points = this.points;
    		var point = ( points.length - 1 ) * t;

    		var intPoint = Math.floor( point );
    		var weight = point - intPoint;

    		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
    		var point1 = points[ intPoint ];
    		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    		var interpolate = exports.CurveUtils.interpolate;

    		return new Vector3(
    			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
    			interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
    			interpolate( point0.z, point1.z, point2.z, point3.z, weight )
    		);

    	}

    );

    /**************************************************************
     *	Cubic Bezier 3D curve
     **************************************************************/

    exports.CubicBezierCurve3 = Curve.create(

    	function ( v0, v1, v2, v3 ) {

    		this.v0 = v0;
    		this.v1 = v1;
    		this.v2 = v2;
    		this.v3 = v3;

    	},

    	function ( t ) {

    		var b3 = exports.ShapeUtils.b3;

    		return new Vector3(
    			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
    			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
    			b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
    		);

    	}

    );

    /**************************************************************
     *	Quadratic Bezier 3D curve
     **************************************************************/

    exports.QuadraticBezierCurve3 = Curve.create(

    	function ( v0, v1, v2 ) {

    		this.v0 = v0;
    		this.v1 = v1;
    		this.v2 = v2;

    	},

    	function ( t ) {

    		var b2 = exports.ShapeUtils.b2;		

    		return new Vector3(
    			b2( t, this.v0.x, this.v1.x, this.v2.x ),
    			b2( t, this.v0.y, this.v1.y, this.v2.y ),
    			b2( t, this.v0.z, this.v1.z, this.v2.z )
    		);

    	}

    );

    /**************************************************************
     *	Line3D
     **************************************************************/

    exports.LineCurve3 = Curve.create(

    	function ( v1, v2 ) {

    		this.v1 = v1;
    		this.v2 = v2;

    	},

    	function ( t ) {

    		if ( t === 1 ) {

    			return this.v2.clone();

    		}

    		var vector = new Vector3();

    		vector.subVectors( this.v2, this.v1 ); // diff
    		vector.multiplyScalar( t );
    		vector.add( this.v1 );

    		return vector;

    	}

    );

    /**************************************************************
     *	Arc curve
     **************************************************************/

    function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    	EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

    }

    ArcCurve.prototype = Object.create( EllipseCurve.prototype );
    ArcCurve.prototype.constructor = ArcCurve;

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    exports.SceneUtils = {

    	createMultiMaterialObject: function ( geometry, materials ) {

    		var group = new Group();

    		for ( var i = 0, l = materials.length; i < l; i ++ ) {

    			group.add( new Mesh( geometry, materials[ i ] ) );

    		}

    		return group;

    	},

    	detach: function ( child, parent, scene ) {

    		child.applyMatrix( parent.matrixWorld );
    		parent.remove( child );
    		scene.add( child );

    	},

    	attach: function ( child, scene, parent ) {

    		var matrixWorldInverse = new Matrix4();
    		matrixWorldInverse.getInverse( parent.matrixWorld );
    		child.applyMatrix( matrixWorldInverse );

    		scene.remove( child );
    		parent.add( child );

    	}

    };

    function Face4 ( a, b, c, d, normal, color, materialIndex ) {
    	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
    	return new Face3( a, b, c, normal, color, materialIndex );
    }

    var LineStrip = 0;

    var LinePieces = 1;

    function PointCloud ( geometry, material ) {
    	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
    	return new Points( geometry, material );
    }

    function ParticleSystem ( geometry, material ) {
    	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
    	return new Points( geometry, material );
    }

    function PointCloudMaterial ( parameters ) {
    	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
    	return new PointsMaterial( parameters );
    }

    function ParticleBasicMaterial ( parameters ) {
    	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
    	return new PointsMaterial( parameters );
    }

    function ParticleSystemMaterial ( parameters ) {
    	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
    	return new PointsMaterial( parameters );
    }

    function Vertex ( x, y, z ) {
    	console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
    	return new Vector3( x, y, z );
    }

    //

    function EdgesHelper( object, hex ) {
    	console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
    	return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
    }

    function WireframeHelper( object, hex ) {
    	console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
    	return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
    }

    //

    Object.assign( Box2.prototype, {
    	center: function ( optionalTarget ) {
    		console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
    		return this.getCenter( optionalTarget );
    	},
    	empty: function () {
    		console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
    		return this.isEmpty();
    	},
    	isIntersectionBox: function ( box ) {
    		console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
    		return this.intersectsBox( box );
    	},
    	size: function ( optionalTarget ) {
    		console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
    		return this.getSize( optionalTarget );
    	}
    } );

    Object.assign( Box3.prototype, {
    	center: function ( optionalTarget ) {
    		console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
    		return this.getCenter( optionalTarget );
    	},
    	empty: function () {
    		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
    		return this.isEmpty();
    	},
    	isIntersectionBox: function ( box ) {
    		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
    		return this.intersectsBox( box );
    	},
    	isIntersectionSphere: function ( sphere ) {
    		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
    		return this.intersectsSphere( sphere );
    	},
    	size: function ( optionalTarget ) {
    		console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
    		return this.getSize( optionalTarget );
    	}
    } );

    Object.assign( Line3.prototype, {
    	center: function ( optionalTarget ) {
    		console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
    		return this.getCenter( optionalTarget );
    	}
    } );

    Object.assign( Matrix3.prototype, {
    	multiplyVector3: function ( vector ) {
    		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
    		return vector.applyMatrix3( this );
    	},
    	multiplyVector3Array: function ( a ) {
    		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    		return this.applyToVector3Array( a );
    	}
    } );

    Object.assign( Matrix4.prototype, {
    	extractPosition: function ( m ) {
    		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
    		return this.copyPosition( m );
    	},
    	setRotationFromQuaternion: function ( q ) {
    		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
    		return this.makeRotationFromQuaternion( q );
    	},
    	multiplyVector3: function ( vector ) {
    		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
    		return vector.applyProjection( this );
    	},
    	multiplyVector4: function ( vector ) {
    		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    		return vector.applyMatrix4( this );
    	},
    	multiplyVector3Array: function ( a ) {
    		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    		return this.applyToVector3Array( a );
    	},
    	rotateAxis: function ( v ) {
    		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
    		v.transformDirection( this );
    	},
    	crossVector: function ( vector ) {
    		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    		return vector.applyMatrix4( this );
    	},
    	translate: function ( v ) {
    		console.error( 'THREE.Matrix4: .translate() has been removed.' );
    	},
    	rotateX: function ( angle ) {
    		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
    	},
    	rotateY: function ( angle ) {
    		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
    	},
    	rotateZ: function ( angle ) {
    		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
    	},
    	rotateByAxis: function ( axis, angle ) {
    		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
    	}
    } );

    Object.assign( Plane.prototype, {
    	isIntersectionLine: function ( line ) {
    		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
    		return this.intersectsLine( line );
    	}
    } );

    Object.assign( Quaternion.prototype, {
    	multiplyVector3: function ( vector ) {
    		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
    		return vector.applyQuaternion( this );
    	}
    } );

    Object.assign( Ray.prototype, {
    	isIntersectionBox: function ( box ) {
    		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
    		return this.intersectsBox( box );
    	},
    	isIntersectionPlane: function ( plane ) {
    		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
    		return this.intersectsPlane( plane );
    	},
    	isIntersectionSphere: function ( sphere ) {
    		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
    		return this.intersectsSphere( sphere );
    	}
    } );

    Object.assign( Shape.prototype, {
    	extrude: function ( options ) {
    		console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
    		return new ExtrudeGeometry( this, options );
    	},
    	makeGeometry: function ( options ) {
    		console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
    		return new ShapeGeometry( this, options );
    	}
    } );

    Object.assign( Vector3.prototype, {
    	setEulerFromRotationMatrix: function () {
    		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
    	},
    	setEulerFromQuaternion: function () {
    		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
    	},
    	getPositionFromMatrix: function ( m ) {
    		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
    		return this.setFromMatrixPosition( m );
    	},
    	getScaleFromMatrix: function ( m ) {
    		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
    		return this.setFromMatrixScale( m );
    	},
    	getColumnFromMatrix: function ( index, matrix ) {
    		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
    		return this.setFromMatrixColumn( matrix, index );
    	}
    } );

    //

    Object.assign( Object3D.prototype, {
    	getChildByName: function ( name ) {
    		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
    		return this.getObjectByName( name );
    	},
    	renderDepth: function ( value ) {
    		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
    	},
    	translate: function ( distance, axis ) {
    		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
    		return this.translateOnAxis( axis, distance );
    	}
    } );

    Object.defineProperties( Object3D.prototype, {
    	eulerOrder: {
    		get: function () {
    			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
    			return this.rotation.order;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
    			this.rotation.order = value;
    		}
    	},
    	useQuaternion: {
    		get: function () {
    			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
    		}
    	}
    } );

    Object.defineProperties( LOD.prototype, {
    	objects: {
    		get: function () {
    			console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
    			return this.levels;
    		}
    	}
    } );

    //

    PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

    	console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
    			"Use .setFocalLength and .filmGauge for a photographic setup." );

    	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
    	this.setFocalLength( focalLength );

    };

    //

    Object.defineProperties( Light.prototype, {
    	onlyShadow: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .onlyShadow has been removed.' );
    		}
    	},
    	shadowCameraFov: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
    			this.shadow.camera.fov = value;
    		}
    	},
    	shadowCameraLeft: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
    			this.shadow.camera.left = value;
    		}
    	},
    	shadowCameraRight: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
    			this.shadow.camera.right = value;
    		}
    	},
    	shadowCameraTop: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
    			this.shadow.camera.top = value;
    		}
    	},
    	shadowCameraBottom: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
    			this.shadow.camera.bottom = value;
    		}
    	},
    	shadowCameraNear: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
    			this.shadow.camera.near = value;
    		}
    	},
    	shadowCameraFar: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
    			this.shadow.camera.far = value;
    		}
    	},
    	shadowCameraVisible: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
    		}
    	},
    	shadowBias: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
    			this.shadow.bias = value;
    		}
    	},
    	shadowDarkness: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
    		}
    	},
    	shadowMapWidth: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
    			this.shadow.mapSize.width = value;
    		}
    	},
    	shadowMapHeight: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
    			this.shadow.mapSize.height = value;
    		}
    	}
    } );

    //

    Object.defineProperties( BufferAttribute.prototype, {
    	length: {
    		get: function () {
    			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
    			return this.array.length;
    		}
    	}
    } );

    Object.assign( BufferGeometry.prototype, {
    	addIndex: function ( index ) {
    		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
    		this.setIndex( index );
    	},
    	addDrawCall: function ( start, count, indexOffset ) {
    		if ( indexOffset !== undefined ) {
    			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
    		}
    		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
    		this.addGroup( start, count );
    	},
    	clearDrawCalls: function () {
    		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
    		this.clearGroups();
    	},
    	computeTangents: function () {
    		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
    	},
    	computeOffsets: function () {
    		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
    	}
    } );

    Object.defineProperties( BufferGeometry.prototype, {
    	drawcalls: {
    		get: function () {
    			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
    			return this.groups;
    		}
    	},
    	offsets: {
    		get: function () {
    			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
    			return this.groups;
    		}
    	}
    } );

    //

    Object.defineProperties( Material.prototype, {
    	wrapAround: {
    		get: function () {
    			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
    		}
    	},
    	wrapRGB: {
    		get: function () {
    			console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
    			return new Color();
    		}
    	}
    } );

    Object.defineProperties( MeshPhongMaterial.prototype, {
    	metal: {
    		get: function () {
    			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
    			return false;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
    		}
    	}
    } );

    Object.defineProperties( ShaderMaterial.prototype, {
    	derivatives: {
    		get: function () {
    			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
    			return this.extensions.derivatives;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
    			this.extensions.derivatives = value;
    		}
    	}
    } );

    //

    EventDispatcher.prototype = Object.assign( Object.create( {

    	// Note: Extra base ensures these properties are not 'assign'ed.

    	constructor: EventDispatcher,

    	apply: function ( target ) {

    		console.warn( "THREE.EventDispatcher: .apply is deprecated, " +
    				"just inherit or Object.assign the prototype to mix-in." );

    		Object.assign( target, this );

    	}

    } ), EventDispatcher.prototype );

    //

    Object.assign( WebGLRenderer.prototype, {
    	supportsFloatTextures: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
    		return this.extensions.get( 'OES_texture_float' );
    	},
    	supportsHalfFloatTextures: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
    		return this.extensions.get( 'OES_texture_half_float' );
    	},
    	supportsStandardDerivatives: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
    		return this.extensions.get( 'OES_standard_derivatives' );
    	},
    	supportsCompressedTextureS3TC: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
    		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
    	},
    	supportsCompressedTexturePVRTC: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
    		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
    	},
    	supportsBlendMinMax: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
    		return this.extensions.get( 'EXT_blend_minmax' );
    	},
    	supportsVertexTextures: function () {
    		return this.capabilities.vertexTextures;
    	},
    	supportsInstancedArrays: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
    		return this.extensions.get( 'ANGLE_instanced_arrays' );
    	},
    	enableScissorTest: function ( boolean ) {
    		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
    		this.setScissorTest( boolean );
    	},
    	initMaterial: function () {
    		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
    	},
    	addPrePlugin: function () {
    		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
    	},
    	addPostPlugin: function () {
    		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
    	},
    	updateShadowMap: function () {
    		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
    	}
    } );

    Object.defineProperties( WebGLRenderer.prototype, {
    	shadowMapEnabled: {
    		get: function () {
    			return this.shadowMap.enabled;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
    			this.shadowMap.enabled = value;
    		}
    	},
    	shadowMapType: {
    		get: function () {
    			return this.shadowMap.type;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
    			this.shadowMap.type = value;
    		}
    	},
    	shadowMapCullFace: {
    		get: function () {
    			return this.shadowMap.cullFace;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
    			this.shadowMap.cullFace = value;
    		}
    	}
    } );

    Object.defineProperties( WebGLShadowMap.prototype, {
    	cullFace: {
    		get: function () {
    			return this.renderReverseSided ? CullFaceFront : CullFaceBack;
    		},
    		set: function ( cullFace ) {
    			var value = ( cullFace !== CullFaceBack );
    			console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
    			this.renderReverseSided = value;
    		}
    	}
    } );

    //

    Object.defineProperties( WebGLRenderTarget.prototype, {
    	wrapS: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
    			return this.texture.wrapS;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
    			this.texture.wrapS = value;
    		}
    	},
    	wrapT: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
    			return this.texture.wrapT;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
    			this.texture.wrapT = value;
    		}
    	},
    	magFilter: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
    			return this.texture.magFilter;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
    			this.texture.magFilter = value;
    		}
    	},
    	minFilter: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
    			return this.texture.minFilter;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
    			this.texture.minFilter = value;
    		}
    	},
    	anisotropy: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
    			return this.texture.anisotropy;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
    			this.texture.anisotropy = value;
    		}
    	},
    	offset: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
    			return this.texture.offset;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
    			this.texture.offset = value;
    		}
    	},
    	repeat: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
    			return this.texture.repeat;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
    			this.texture.repeat = value;
    		}
    	},
    	format: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
    			return this.texture.format;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
    			this.texture.format = value;
    		}
    	},
    	type: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
    			return this.texture.type;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
    			this.texture.type = value;
    		}
    	},
    	generateMipmaps: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
    			return this.texture.generateMipmaps;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
    			this.texture.generateMipmaps = value;
    		}
    	}
    } );

    //

    Object.assign( Audio.prototype, {
    	load: function ( file ) {
    		console.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );
    		var scope = this;
    		var audioLoader = new AudioLoader();
    		audioLoader.load( file, function ( buffer ) {
    			scope.setBuffer( buffer );
    		} );
    		return this;
    	}
    } );

    Object.assign( AudioAnalyser.prototype, {
    	getData: function ( file ) {
    		console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
    		return this.getFrequencyData();
    	}
    } );

    //

    var GeometryUtils = {

    	merge: function ( geometry1, geometry2, materialIndexOffset ) {

    		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

    		var matrix;

    		if ( geometry2.isMesh ) {

    			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

    			matrix = geometry2.matrix;
    			geometry2 = geometry2.geometry;

    		}

    		geometry1.merge( geometry2, matrix, materialIndexOffset );

    	},

    	center: function ( geometry ) {

    		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
    		return geometry.center();

    	}

    };

    var ImageUtils = {

    	crossOrigin: undefined,

    	loadTexture: function ( url, mapping, onLoad, onError ) {

    		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

    		var loader = new TextureLoader();
    		loader.setCrossOrigin( this.crossOrigin );

    		var texture = loader.load( url, onLoad, undefined, onError );

    		if ( mapping ) texture.mapping = mapping;

    		return texture;

    	},

    	loadTextureCube: function ( urls, mapping, onLoad, onError ) {

    		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

    		var loader = new CubeTextureLoader();
    		loader.setCrossOrigin( this.crossOrigin );

    		var texture = loader.load( urls, onLoad, undefined, onError );

    		if ( mapping ) texture.mapping = mapping;

    		return texture;

    	},

    	loadCompressedTexture: function () {

    		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

    	},

    	loadCompressedTextureCube: function () {

    		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

    	}

    };

    //

    function Projector () {

    	console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

    	this.projectVector = function ( vector, camera ) {

    		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
    		vector.project( camera );

    	};

    	this.unprojectVector = function ( vector, camera ) {

    		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
    		vector.unproject( camera );

    	};

    	this.pickingRay = function ( vector, camera ) {

    		console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

    	};

    }

    //

    function CanvasRenderer () {

    	console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

    	this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    	this.clear = function () {};
    	this.render = function () {};
    	this.setClearColor = function () {};
    	this.setSize = function () {};

    }

    Object.defineProperty( exports, 'AudioContext', {
    	get: function () {
    		return exports.getAudioContext();
    	}
    });

    exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
    exports.WebGLRenderTarget = WebGLRenderTarget;
    exports.WebGLRenderer = WebGLRenderer;
    exports.ShaderLib = ShaderLib;
    exports.UniformsLib = UniformsLib;
    exports.ShaderChunk = ShaderChunk;
    exports.FogExp2 = FogExp2;
    exports.Fog = Fog;
    exports.Scene = Scene;
    exports.LensFlare = LensFlare;
    exports.Sprite = Sprite;
    exports.LOD = LOD;
    exports.SkinnedMesh = SkinnedMesh;
    exports.Skeleton = Skeleton;
    exports.Bone = Bone;
    exports.Mesh = Mesh;
    exports.LineSegments = LineSegments;
    exports.Line = Line;
    exports.Points = Points;
    exports.Group = Group;
    exports.VideoTexture = VideoTexture;
    exports.DataTexture = DataTexture;
    exports.CompressedTexture = CompressedTexture;
    exports.CubeTexture = CubeTexture;
    exports.CanvasTexture = CanvasTexture;
    exports.DepthTexture = DepthTexture;
    exports.TextureIdCount = TextureIdCount;
    exports.Texture = Texture;
    exports.MaterialIdCount = MaterialIdCount;
    exports.CompressedTextureLoader = CompressedTextureLoader;
    exports.BinaryTextureLoader = BinaryTextureLoader;
    exports.DataTextureLoader = DataTextureLoader;
    exports.CubeTextureLoader = CubeTextureLoader;
    exports.TextureLoader = TextureLoader;
    exports.ObjectLoader = ObjectLoader;
    exports.MaterialLoader = MaterialLoader;
    exports.BufferGeometryLoader = BufferGeometryLoader;
    exports.LoadingManager = LoadingManager;
    exports.JSONLoader = JSONLoader;
    exports.ImageLoader = ImageLoader;
    exports.FontLoader = FontLoader;
    exports.XHRLoader = XHRLoader;
    exports.Loader = Loader;
    exports.AudioLoader = AudioLoader;
    exports.SpotLightShadow = SpotLightShadow;
    exports.SpotLight = SpotLight;
    exports.PointLight = PointLight;
    exports.HemisphereLight = HemisphereLight;
    exports.DirectionalLightShadow = DirectionalLightShadow;
    exports.DirectionalLight = DirectionalLight;
    exports.AmbientLight = AmbientLight;
    exports.LightShadow = LightShadow;
    exports.Light = Light;
    exports.StereoCamera = StereoCamera;
    exports.PerspectiveCamera = PerspectiveCamera;
    exports.OrthographicCamera = OrthographicCamera;
    exports.CubeCamera = CubeCamera;
    exports.Camera = Camera;
    exports.AudioListener = AudioListener;
    exports.PositionalAudio = PositionalAudio;
    exports.getAudioContext = getAudioContext;
    exports.AudioAnalyser = AudioAnalyser;
    exports.Audio = Audio;
    exports.VectorKeyframeTrack = VectorKeyframeTrack;
    exports.StringKeyframeTrack = StringKeyframeTrack;
    exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
    exports.NumberKeyframeTrack = NumberKeyframeTrack;
    exports.ColorKeyframeTrack = ColorKeyframeTrack;
    exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
    exports.PropertyMixer = PropertyMixer;
    exports.PropertyBinding = PropertyBinding;
    exports.KeyframeTrack = KeyframeTrack;
    exports.AnimationObjectGroup = AnimationObjectGroup;
    exports.AnimationMixer = AnimationMixer;
    exports.AnimationClip = AnimationClip;
    exports.Uniform = Uniform;
    exports.InstancedBufferGeometry = InstancedBufferGeometry;
    exports.BufferGeometry = BufferGeometry;
    exports.GeometryIdCount = GeometryIdCount;
    exports.Geometry = Geometry;
    exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
    exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
    exports.InterleavedBuffer = InterleavedBuffer;
    exports.InstancedBufferAttribute = InstancedBufferAttribute;
    exports.DynamicBufferAttribute = DynamicBufferAttribute;
    exports.Float64Attribute = Float64Attribute;
    exports.Float32Attribute = Float32Attribute;
    exports.Uint32Attribute = Uint32Attribute;
    exports.Int32Attribute = Int32Attribute;
    exports.Uint16Attribute = Uint16Attribute;
    exports.Int16Attribute = Int16Attribute;
    exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
    exports.Uint8Attribute = Uint8Attribute;
    exports.Int8Attribute = Int8Attribute;
    exports.BufferAttribute = BufferAttribute;
    exports.Face3 = Face3;
    exports.Object3DIdCount = Object3DIdCount;
    exports.Object3D = Object3D;
    exports.Raycaster = Raycaster;
    exports.Layers = Layers;
    exports.EventDispatcher = EventDispatcher;
    exports.Clock = Clock;
    exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
    exports.LinearInterpolant = LinearInterpolant;
    exports.DiscreteInterpolant = DiscreteInterpolant;
    exports.CubicInterpolant = CubicInterpolant;
    exports.Interpolant = Interpolant;
    exports.Triangle = Triangle;
    exports.Spline = Spline;
    exports.Spherical = Spherical;
    exports.Plane = Plane;
    exports.Frustum = Frustum;
    exports.Sphere = Sphere;
    exports.Ray = Ray;
    exports.Matrix4 = Matrix4;
    exports.Matrix3 = Matrix3;
    exports.Box3 = Box3;
    exports.Box2 = Box2;
    exports.Line3 = Line3;
    exports.Euler = Euler;
    exports.Vector4 = Vector4;
    exports.Vector3 = Vector3;
    exports.Vector2 = Vector2;
    exports.Quaternion = Quaternion;
    exports.Color = Color;
    exports.MorphBlendMesh = MorphBlendMesh;
    exports.ImmediateRenderObject = ImmediateRenderObject;
    exports.VertexNormalsHelper = VertexNormalsHelper;
    exports.SpotLightHelper = SpotLightHelper;
    exports.SkeletonHelper = SkeletonHelper;
    exports.PointLightHelper = PointLightHelper;
    exports.HemisphereLightHelper = HemisphereLightHelper;
    exports.GridHelper = GridHelper;
    exports.FaceNormalsHelper = FaceNormalsHelper;
    exports.DirectionalLightHelper = DirectionalLightHelper;
    exports.CameraHelper = CameraHelper;
    exports.BoundingBoxHelper = BoundingBoxHelper;
    exports.BoxHelper = BoxHelper;
    exports.ArrowHelper = ArrowHelper;
    exports.AxisHelper = AxisHelper;
    exports.ClosedSplineCurve3 = ClosedSplineCurve3;
    exports.SplineCurve3 = SplineCurve3;
    exports.ArcCurve = ArcCurve;
    exports.EllipseCurve = EllipseCurve;
    exports.SplineCurve = SplineCurve;
    exports.CubicBezierCurve = CubicBezierCurve;
    exports.QuadraticBezierCurve = QuadraticBezierCurve;
    exports.LineCurve = LineCurve;
    exports.Shape = Shape;
    exports.ShapePath = ShapePath;
    exports.Path = Path;
    exports.Font = Font;
    exports.CurvePath = CurvePath;
    exports.Curve = Curve;
    exports.WireframeGeometry = WireframeGeometry;
    exports.ParametricGeometry = ParametricGeometry;
    exports.TetrahedronGeometry = TetrahedronGeometry;
    exports.OctahedronGeometry = OctahedronGeometry;
    exports.IcosahedronGeometry = IcosahedronGeometry;
    exports.DodecahedronGeometry = DodecahedronGeometry;
    exports.PolyhedronGeometry = PolyhedronGeometry;
    exports.TubeGeometry = TubeGeometry;
    exports.TorusKnotGeometry = TorusKnotGeometry;
    exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
    exports.TorusGeometry = TorusGeometry;
    exports.TorusBufferGeometry = TorusBufferGeometry;
    exports.TextGeometry = TextGeometry;
    exports.SphereBufferGeometry = SphereBufferGeometry;
    exports.SphereGeometry = SphereGeometry;
    exports.RingGeometry = RingGeometry;
    exports.RingBufferGeometry = RingBufferGeometry;
    exports.PlaneBufferGeometry = PlaneBufferGeometry;
    exports.PlaneGeometry = PlaneGeometry;
    exports.LatheGeometry = LatheGeometry;
    exports.LatheBufferGeometry = LatheBufferGeometry;
    exports.ShapeGeometry = ShapeGeometry;
    exports.ExtrudeGeometry = ExtrudeGeometry;
    exports.EdgesGeometry = EdgesGeometry;
    exports.ConeGeometry = ConeGeometry;
    exports.ConeBufferGeometry = ConeBufferGeometry;
    exports.CylinderGeometry = CylinderGeometry;
    exports.CylinderBufferGeometry = CylinderBufferGeometry;
    exports.CircleBufferGeometry = CircleBufferGeometry;
    exports.CircleGeometry = CircleGeometry;
    exports.BoxBufferGeometry = BoxBufferGeometry;
    exports.BoxGeometry = BoxGeometry;
    exports.ShadowMaterial = ShadowMaterial;
    exports.SpriteMaterial = SpriteMaterial;
    exports.RawShaderMaterial = RawShaderMaterial;
    exports.ShaderMaterial = ShaderMaterial;
    exports.PointsMaterial = PointsMaterial;
    exports.MultiMaterial = MultiMaterial;
    exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
    exports.MeshStandardMaterial = MeshStandardMaterial;
    exports.MeshPhongMaterial = MeshPhongMaterial;
    exports.MeshNormalMaterial = MeshNormalMaterial;
    exports.MeshLambertMaterial = MeshLambertMaterial;
    exports.MeshDepthMaterial = MeshDepthMaterial;
    exports.MeshBasicMaterial = MeshBasicMaterial;
    exports.LineDashedMaterial = LineDashedMaterial;
    exports.LineBasicMaterial = LineBasicMaterial;
    exports.Material = Material;
    exports.REVISION = REVISION;
    exports.MOUSE = MOUSE;
    exports.CullFaceNone = CullFaceNone;
    exports.CullFaceBack = CullFaceBack;
    exports.CullFaceFront = CullFaceFront;
    exports.CullFaceFrontBack = CullFaceFrontBack;
    exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
    exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
    exports.BasicShadowMap = BasicShadowMap;
    exports.PCFShadowMap = PCFShadowMap;
    exports.PCFSoftShadowMap = PCFSoftShadowMap;
    exports.FrontSide = FrontSide;
    exports.BackSide = BackSide;
    exports.DoubleSide = DoubleSide;
    exports.FlatShading = FlatShading;
    exports.SmoothShading = SmoothShading;
    exports.NoColors = NoColors;
    exports.FaceColors = FaceColors;
    exports.VertexColors = VertexColors;
    exports.NoBlending = NoBlending;
    exports.NormalBlending = NormalBlending;
    exports.AdditiveBlending = AdditiveBlending;
    exports.SubtractiveBlending = SubtractiveBlending;
    exports.MultiplyBlending = MultiplyBlending;
    exports.CustomBlending = CustomBlending;
    exports.BlendingMode = BlendingMode;
    exports.AddEquation = AddEquation;
    exports.SubtractEquation = SubtractEquation;
    exports.ReverseSubtractEquation = ReverseSubtractEquation;
    exports.MinEquation = MinEquation;
    exports.MaxEquation = MaxEquation;
    exports.ZeroFactor = ZeroFactor;
    exports.OneFactor = OneFactor;
    exports.SrcColorFactor = SrcColorFactor;
    exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
    exports.SrcAlphaFactor = SrcAlphaFactor;
    exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
    exports.DstAlphaFactor = DstAlphaFactor;
    exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
    exports.DstColorFactor = DstColorFactor;
    exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
    exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
    exports.NeverDepth = NeverDepth;
    exports.AlwaysDepth = AlwaysDepth;
    exports.LessDepth = LessDepth;
    exports.LessEqualDepth = LessEqualDepth;
    exports.EqualDepth = EqualDepth;
    exports.GreaterEqualDepth = GreaterEqualDepth;
    exports.GreaterDepth = GreaterDepth;
    exports.NotEqualDepth = NotEqualDepth;
    exports.MultiplyOperation = MultiplyOperation;
    exports.MixOperation = MixOperation;
    exports.AddOperation = AddOperation;
    exports.NoToneMapping = NoToneMapping;
    exports.LinearToneMapping = LinearToneMapping;
    exports.ReinhardToneMapping = ReinhardToneMapping;
    exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
    exports.CineonToneMapping = CineonToneMapping;
    exports.UVMapping = UVMapping;
    exports.CubeReflectionMapping = CubeReflectionMapping;
    exports.CubeRefractionMapping = CubeRefractionMapping;
    exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
    exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
    exports.SphericalReflectionMapping = SphericalReflectionMapping;
    exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
    exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
    exports.TextureMapping = TextureMapping;
    exports.RepeatWrapping = RepeatWrapping;
    exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
    exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
    exports.TextureWrapping = TextureWrapping;
    exports.NearestFilter = NearestFilter;
    exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
    exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
    exports.LinearFilter = LinearFilter;
    exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
    exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
    exports.TextureFilter = TextureFilter;
    exports.UnsignedByteType = UnsignedByteType;
    exports.ByteType = ByteType;
    exports.ShortType = ShortType;
    exports.UnsignedShortType = UnsignedShortType;
    exports.IntType = IntType;
    exports.UnsignedIntType = UnsignedIntType;
    exports.FloatType = FloatType;
    exports.HalfFloatType = HalfFloatType;
    exports.UnsignedShort4444Type = UnsignedShort4444Type;
    exports.UnsignedShort5551Type = UnsignedShort5551Type;
    exports.UnsignedShort565Type = UnsignedShort565Type;
    exports.UnsignedInt248Type = UnsignedInt248Type;
    exports.AlphaFormat = AlphaFormat;
    exports.RGBFormat = RGBFormat;
    exports.RGBAFormat = RGBAFormat;
    exports.LuminanceFormat = LuminanceFormat;
    exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
    exports.RGBEFormat = RGBEFormat;
    exports.DepthFormat = DepthFormat;
    exports.DepthStencilFormat = DepthStencilFormat;
    exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
    exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
    exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
    exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
    exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
    exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
    exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
    exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
    exports.RGB_ETC1_Format = RGB_ETC1_Format;
    exports.LoopOnce = LoopOnce;
    exports.LoopRepeat = LoopRepeat;
    exports.LoopPingPong = LoopPingPong;
    exports.InterpolateDiscrete = InterpolateDiscrete;
    exports.InterpolateLinear = InterpolateLinear;
    exports.InterpolateSmooth = InterpolateSmooth;
    exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
    exports.ZeroSlopeEnding = ZeroSlopeEnding;
    exports.WrapAroundEnding = WrapAroundEnding;
    exports.TrianglesDrawMode = TrianglesDrawMode;
    exports.TriangleStripDrawMode = TriangleStripDrawMode;
    exports.TriangleFanDrawMode = TriangleFanDrawMode;
    exports.LinearEncoding = LinearEncoding;
    exports.sRGBEncoding = sRGBEncoding;
    exports.GammaEncoding = GammaEncoding;
    exports.RGBEEncoding = RGBEEncoding;
    exports.LogLuvEncoding = LogLuvEncoding;
    exports.RGBM7Encoding = RGBM7Encoding;
    exports.RGBM16Encoding = RGBM16Encoding;
    exports.RGBDEncoding = RGBDEncoding;
    exports.BasicDepthPacking = BasicDepthPacking;
    exports.RGBADepthPacking = RGBADepthPacking;
    exports.CubeGeometry = BoxGeometry;
    exports.Face4 = Face4;
    exports.LineStrip = LineStrip;
    exports.LinePieces = LinePieces;
    exports.MeshFaceMaterial = MultiMaterial;
    exports.PointCloud = PointCloud;
    exports.Particle = Sprite;
    exports.ParticleSystem = ParticleSystem;
    exports.PointCloudMaterial = PointCloudMaterial;
    exports.ParticleBasicMaterial = ParticleBasicMaterial;
    exports.ParticleSystemMaterial = ParticleSystemMaterial;
    exports.Vertex = Vertex;
    exports.EdgesHelper = EdgesHelper;
    exports.WireframeHelper = WireframeHelper;
    exports.GeometryUtils = GeometryUtils;
    exports.ImageUtils = ImageUtils;
    exports.Projector = Projector;
    exports.CanvasRenderer = CanvasRenderer;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.EffectComposer = function ( renderer, renderTarget ) {

	this.renderer = renderer;

	if ( renderTarget === undefined ) {

		var parameters = {
			minFilter: THREE.LinearFilter,
			magFilter: THREE.LinearFilter,
			format: THREE.RGBAFormat,
			stencilBuffer: false
		};
		var size = renderer.getSize();
		renderTarget = new THREE.WebGLRenderTarget( size.width, size.height, parameters );

	}

	this.renderTarget1 = renderTarget;
	this.renderTarget2 = renderTarget.clone();

	this.writeBuffer = this.renderTarget1;
	this.readBuffer = this.renderTarget2;

	this.passes = [];

	if ( THREE.CopyShader === undefined )
		console.error( "THREE.EffectComposer relies on THREE.CopyShader" );

	this.copyPass = new THREE.ShaderPass( THREE.CopyShader );

};

Object.assign( THREE.EffectComposer.prototype, {

	swapBuffers: function() {

		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;

	},

	addPass: function ( pass ) {

		this.passes.push( pass );

		var size = this.renderer.getSize();
		pass.setSize( size.width, size.height );

	},

	insertPass: function ( pass, index ) {

		this.passes.splice( index, 0, pass );

	},

	render: function ( delta ) {

		var maskActive = false;

		var pass, i, il = this.passes.length;

		for ( i = 0; i < il; i ++ ) {

			pass = this.passes[ i ];

			if ( pass.enabled === false ) continue;

			pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

			if ( pass.needsSwap ) {

				if ( maskActive ) {

					var context = this.renderer.context;

					context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

					context.stencilFunc( context.EQUAL, 1, 0xffffffff );

				}

				this.swapBuffers();

			}

			if ( THREE.MaskPass !== undefined ) {

				if ( pass instanceof THREE.MaskPass ) {

					maskActive = true;

				} else if ( pass instanceof THREE.ClearMaskPass ) {

					maskActive = false;

				}

			}

		}

	},

	reset: function ( renderTarget ) {

		if ( renderTarget === undefined ) {

			var size = this.renderer.getSize();

			renderTarget = this.renderTarget1.clone();
			renderTarget.setSize( size.width, size.height );

		}

		this.renderTarget1.dispose();
		this.renderTarget2.dispose();
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

	},

	setSize: function ( width, height ) {

		this.renderTarget1.setSize( width, height );
		this.renderTarget2.setSize( width, height );

		for ( var i = 0; i < this.passes.length; i ++ ) {

			this.passes[i].setSize( width, height );

		}

	}

} );


THREE.Pass = function () {

	// if set to true, the pass is processed by the composer
	this.enabled = true;

	// if set to true, the pass indicates to swap read and write buffer after rendering
	this.needsSwap = true;

	// if set to true, the pass clears its buffer before rendering
	this.clear = false;

	// if set to true, the result of the pass is rendered to screen
	this.renderToScreen = false;

};

Object.assign( THREE.Pass.prototype, {

	setSize: function( width, height ) {},

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		console.error( "THREE.Pass: .render() must be implemented in derived pass." );

	}

} );

/**
 * @author miibond
 * Generate a texture that represents the luminosity of the current scene, adapted over time
 * to simulate the optic nerve responding to the amount of light it is receiving.
 * Based on a GDC2007 presentation by Wolfgang Engel titled "Post-Processing Pipeline"
 *
 * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf
 */

THREE.AdaptiveToneMappingPass = function ( adaptive, resolution ) {

	THREE.Pass.call( this );

	this.resolution = ( resolution !== undefined ) ? resolution : 256;
	this.needsInit = true;
	this.adaptive = adaptive !== undefined ? !! adaptive : true;

	this.luminanceRT = null;
	this.previousLuminanceRT = null;
	this.currentLuminanceRT = null;

	if ( THREE.CopyShader === undefined )
		console.error( "THREE.AdaptiveToneMappingPass relies on THREE.CopyShader" );

	var copyShader = THREE.CopyShader;

	this.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );

	this.materialCopy = new THREE.ShaderMaterial( {

		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader,
		blending: THREE.NoBlending,
		depthTest: false

	} );

	if ( THREE.LuminosityShader === undefined )
		console.error( "THREE.AdaptiveToneMappingPass relies on THREE.LuminosityShader" );

	this.materialLuminance = new THREE.ShaderMaterial( {

		uniforms: THREE.UniformsUtils.clone( THREE.LuminosityShader.uniforms ),
		vertexShader: THREE.LuminosityShader.vertexShader,
		fragmentShader: THREE.LuminosityShader.fragmentShader,
		blending: THREE.NoBlending,
	} );

	this.adaptLuminanceShader = {
		defines: {
			"MIP_LEVEL_1X1" : ( Math.log( this.resolution ) / Math.log( 2.0 ) ).toFixed( 1 ),
		},
		uniforms: {
			"lastLum": { value: null },
			"currentLum": { value: null },
			"delta": { value: 0.016 },
			"tau": { value: 1.0 }
		},
		vertexShader: [
			"varying vec2 vUv;",

			"void main() {",

				"vUv = uv;",
				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"
		].join( '\n' ),
		fragmentShader: [
			"varying vec2 vUv;",

			"uniform sampler2D lastLum;",
			"uniform sampler2D currentLum;",
			"uniform float delta;",
			"uniform float tau;",

			"void main() {",

				"vec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );",
				"vec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );",

				"float fLastLum = lastLum.r;",
				"float fCurrentLum = currentLum.r;",

				//The adaption seems to work better in extreme lighting differences
				//if the input luminance is squared.
				"fCurrentLum *= fCurrentLum;",

				// Adapt the luminance using Pattanaik's technique
				"float fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));",
				// "fAdaptedLum = sqrt(fAdaptedLum);",
				"gl_FragColor = vec4( vec3( fAdaptedLum ), 1.0 );",
			"}",
		].join( '\n' )
	};

	this.materialAdaptiveLum = new THREE.ShaderMaterial( {

		uniforms: THREE.UniformsUtils.clone( this.adaptLuminanceShader.uniforms ),
		vertexShader: this.adaptLuminanceShader.vertexShader,
		fragmentShader: this.adaptLuminanceShader.fragmentShader,
		defines: this.adaptLuminanceShader.defines,
		blending: THREE.NoBlending
	} );

	if ( THREE.ToneMapShader === undefined )
		console.error( "THREE.AdaptiveToneMappingPass relies on THREE.ToneMapShader" );

	this.materialToneMap = new THREE.ShaderMaterial( {

		uniforms: THREE.UniformsUtils.clone( THREE.ToneMapShader.uniforms ),
		vertexShader: THREE.ToneMapShader.vertexShader,
		fragmentShader: THREE.ToneMapShader.fragmentShader,
		blending: THREE.NoBlending
	} );

	this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene  = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

THREE.AdaptiveToneMappingPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.AdaptiveToneMappingPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		if ( this.needsInit ) {

			this.reset( renderer );

			this.luminanceRT.texture.type = readBuffer.texture.type;
			this.previousLuminanceRT.texture.type = readBuffer.texture.type;
			this.currentLuminanceRT.texture.type = readBuffer.texture.type;
			this.needsInit = false;

		}

		if ( this.adaptive ) {

			//Render the luminance of the current scene into a render target with mipmapping enabled
			this.quad.material = this.materialLuminance;
			this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;
			renderer.render( this.scene, this.camera, this.currentLuminanceRT );

			//Use the new luminance values, the previous luminance and the frame delta to
			//adapt the luminance over time.
			this.quad.material = this.materialAdaptiveLum;
			this.materialAdaptiveLum.uniforms.delta.value = delta;
			this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;
			this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;
			renderer.render( this.scene, this.camera, this.luminanceRT );

			//Copy the new adapted luminance value so that it can be used by the next frame.
			this.quad.material = this.materialCopy;
			this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;
			renderer.render( this.scene, this.camera, this.previousLuminanceRT );

		}

		this.quad.material = this.materialToneMap;
		this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;
		renderer.render( this.scene, this.camera, writeBuffer, this.clear );

	},

	reset: function( renderer ) {

		// render targets
		if ( this.luminanceRT ) {

			this.luminanceRT.dispose();

		}
		if ( this.currentLuminanceRT ) {

			this.currentLuminanceRT.dispose();

		}
		if ( this.previousLuminanceRT ) {

			this.previousLuminanceRT.dispose();

		}

		var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450

		this.luminanceRT = new THREE.WebGLRenderTarget( this.resolution, this.resolution, pars );
		this.luminanceRT.texture.generateMipmaps = false;

		this.previousLuminanceRT = new THREE.WebGLRenderTarget( this.resolution, this.resolution, pars );
		this.previousLuminanceRT.texture.generateMipmaps = false;

		// We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader
		pars.minFilter = THREE.LinearMipMapLinearFilter;
		this.currentLuminanceRT = new THREE.WebGLRenderTarget( this.resolution, this.resolution, pars );

		if ( this.adaptive ) {

			this.materialToneMap.defines[ "ADAPTED_LUMINANCE" ] = "";
			this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;

		}
		//Put something in the adaptive luminance texture so that the scene can render initially
		this.quad.material = new THREE.MeshBasicMaterial( { color: 0x777777 } );
		this.materialLuminance.needsUpdate = true;
		this.materialAdaptiveLum.needsUpdate = true;
		this.materialToneMap.needsUpdate = true;
		// renderer.render( this.scene, this.camera, this.luminanceRT );
		// renderer.render( this.scene, this.camera, this.previousLuminanceRT );
		// renderer.render( this.scene, this.camera, this.currentLuminanceRT );

	},

	setAdaptive: function( adaptive ) {

		if ( adaptive ) {

			this.adaptive = true;
			this.materialToneMap.defines[ "ADAPTED_LUMINANCE" ] = "";
			this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;

		} else {

			this.adaptive = false;
			delete this.materialToneMap.defines[ "ADAPTED_LUMINANCE" ];
			this.materialToneMap.uniforms.luminanceMap.value = null;

		}
		this.materialToneMap.needsUpdate = true;

	},

	setAdaptionRate: function( rate ) {

		if ( rate ) {

			this.materialAdaptiveLum.uniforms.tau.value = Math.abs( rate );

		}

	},

	setMaxLuminance: function( maxLum ) {

		if ( maxLum ) {

			this.materialToneMap.uniforms.maxLuminance.value = maxLum;

		}

	},

	setAverageLuminance: function( avgLum ) {

		if ( avgLum ) {

			this.materialToneMap.uniforms.averageLuminance.value = avgLum;

		}

	},

	setMiddleGrey: function( middleGrey ) {

		if ( middleGrey ) {

			this.materialToneMap.uniforms.middleGrey.value = middleGrey;

		}

	},

	dispose: function() {

		if ( this.luminanceRT ) {

			this.luminanceRT.dispose();

		}
		if ( this.previousLuminanceRT ) {

			this.previousLuminanceRT.dispose();

		}
		if ( this.currentLuminanceRT ) {

			this.currentLuminanceRT.dispose();

		}
		if ( this.materialLuminance ) {

			this.materialLuminance.dispose();

		}
		if ( this.materialAdaptiveLum ) {

			this.materialAdaptiveLum.dispose();

		}
		if ( this.materialCopy ) {

			this.materialCopy.dispose();

		}
		if ( this.materialToneMap ) {

			this.materialToneMap.dispose();

		}

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.BloomPass = function ( strength, kernelSize, sigma, resolution ) {

	THREE.Pass.call( this );

	strength = ( strength !== undefined ) ? strength : 1;
	kernelSize = ( kernelSize !== undefined ) ? kernelSize : 25;
	sigma = ( sigma !== undefined ) ? sigma : 4.0;
	resolution = ( resolution !== undefined ) ? resolution : 256;

	// render targets

	var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };

	this.renderTargetX = new THREE.WebGLRenderTarget( resolution, resolution, pars );
	this.renderTargetY = new THREE.WebGLRenderTarget( resolution, resolution, pars );

	// copy material

	if ( THREE.CopyShader === undefined )
		console.error( "THREE.BloomPass relies on THREE.CopyShader" );

	var copyShader = THREE.CopyShader;

	this.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );

	this.copyUniforms[ "opacity" ].value = strength;

	this.materialCopy = new THREE.ShaderMaterial( {

		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader,
		blending: THREE.AdditiveBlending,
		transparent: true

	} );

	// convolution material

	if ( THREE.ConvolutionShader === undefined )
		console.error( "THREE.BloomPass relies on THREE.ConvolutionShader" );

	var convolutionShader = THREE.ConvolutionShader;

	this.convolutionUniforms = THREE.UniformsUtils.clone( convolutionShader.uniforms );

	this.convolutionUniforms[ "uImageIncrement" ].value = THREE.BloomPass.blurX;
	this.convolutionUniforms[ "cKernel" ].value = THREE.ConvolutionShader.buildKernel( sigma );

	this.materialConvolution = new THREE.ShaderMaterial( {

		uniforms: this.convolutionUniforms,
		vertexShader:  convolutionShader.vertexShader,
		fragmentShader: convolutionShader.fragmentShader,
		defines: {
			"KERNEL_SIZE_FLOAT": kernelSize.toFixed( 1 ),
			"KERNEL_SIZE_INT": kernelSize.toFixed( 0 )
		}

	} );

	this.needsSwap = false;

	this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene  = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

THREE.BloomPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.BloomPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		if ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );

		// Render quad with blured scene into texture (convolution pass 1)

		this.quad.material = this.materialConvolution;

		this.convolutionUniforms[ "tDiffuse" ].value = readBuffer.texture;
		this.convolutionUniforms[ "uImageIncrement" ].value = THREE.BloomPass.blurX;

		renderer.render( this.scene, this.camera, this.renderTargetX, true );


		// Render quad with blured scene into texture (convolution pass 2)

		this.convolutionUniforms[ "tDiffuse" ].value = this.renderTargetX.texture;
		this.convolutionUniforms[ "uImageIncrement" ].value = THREE.BloomPass.blurY;

		renderer.render( this.scene, this.camera, this.renderTargetY, true );

		// Render original scene with superimposed blur to texture

		this.quad.material = this.materialCopy;

		this.copyUniforms[ "tDiffuse" ].value = this.renderTargetY.texture;

		if ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );

		renderer.render( this.scene, this.camera, readBuffer, this.clear );

	}

} );

THREE.BloomPass.blurX = new THREE.Vector2( 0.001953125, 0.0 );
THREE.BloomPass.blurY = new THREE.Vector2( 0.0, 0.001953125 );

/**
 * Depth-of-field post-process with bokeh shader
 */


THREE.BokehPass = function ( scene, camera, params ) {

	THREE.Pass.call( this );

	this.scene = scene;
	this.camera = camera;

	var focus = ( params.focus !== undefined ) ? params.focus : 1.0;
	var aspect = ( params.aspect !== undefined ) ? params.aspect : camera.aspect;
	var aperture = ( params.aperture !== undefined ) ? params.aperture : 0.025;
	var maxblur = ( params.maxblur !== undefined ) ? params.maxblur : 1.0;

	// render targets

	var width = params.width || window.innerWidth || 1;
	var height = params.height || window.innerHeight || 1;

	this.renderTargetColor = new THREE.WebGLRenderTarget( width, height, {
		minFilter: THREE.LinearFilter,
		magFilter: THREE.LinearFilter,
		format: THREE.RGBFormat
	} );

	this.renderTargetDepth = this.renderTargetColor.clone();

	// depth material

	this.materialDepth = new THREE.MeshDepthMaterial();

	// bokeh material

	if ( THREE.BokehShader === undefined ) {

		console.error( "THREE.BokehPass relies on THREE.BokehShader" );

	}

	var bokehShader = THREE.BokehShader;
	var bokehUniforms = THREE.UniformsUtils.clone( bokehShader.uniforms );

	bokehUniforms[ "tDepth" ].value = this.renderTargetDepth.texture;

	bokehUniforms[ "focus" ].value = focus;
	bokehUniforms[ "aspect" ].value = aspect;
	bokehUniforms[ "aperture" ].value = aperture;
	bokehUniforms[ "maxblur" ].value = maxblur;

	this.materialBokeh = new THREE.ShaderMaterial( {
		uniforms: bokehUniforms,
		vertexShader: bokehShader.vertexShader,
		fragmentShader: bokehShader.fragmentShader
	} );

	this.uniforms = bokehUniforms;
	this.needsSwap = false;

	this.camera2 = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene2  = new THREE.Scene();

	this.quad2 = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene2.add( this.quad2 );

};

THREE.BokehPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.BokehPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		this.quad2.material = this.materialBokeh;

		// Render depth into texture

		this.scene.overrideMaterial = this.materialDepth;

		renderer.render( this.scene, this.camera, this.renderTargetDepth, true );

		// Render bokeh composite

		this.uniforms[ "tColor" ].value = readBuffer.texture;

		if ( this.renderToScreen ) {

			renderer.render( this.scene2, this.camera2 );

		} else {

			renderer.render( this.scene2, this.camera2, writeBuffer, this.clear );

		}

		this.scene.overrideMaterial = null;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ClearPass = function ( clearColor, clearAlpha ) {

	THREE.Pass.call( this );

	this.needsSwap = false;

	this.clearColor = ( clearColor !== undefined ) ? clearColor : 0x000000;
	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

};

THREE.ClearPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.ClearPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		var oldClearColor, oldClearAlpha;

		if ( this.clearColor ) {

			oldClearColor = renderer.getClearColor().getHex();
			oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor( this.clearColor, this.clearAlpha );

		}

		renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );
		renderer.clear();

		if ( this.clearColor ) {

			renderer.setClearColor( oldClearColor, oldClearAlpha );

		}

	}

} );

/**
 * @author bhouston / http://clara.io/
 */

THREE.CubeTexturePass = function ( camera, envMap, opacity ) {

	THREE.Pass.call( this );

	this.camera = camera;

	this.needsSwap = false;

	this.cubeShader = THREE.ShaderLib[ 'cube' ];
	this.cubeMesh = new THREE.Mesh(
		new THREE.BoxBufferGeometry( 10, 10, 10 ),
		new THREE.ShaderMaterial( {
			uniforms: this.cubeShader.uniforms,
			vertexShader: this.cubeShader.vertexShader,
			fragmentShader: this.cubeShader.fragmentShader,
			depthTest: false,
			depthWrite: false,
			side: THREE.BackSide
		} )
	);

	this.envMap = envMap;
	this.opacity = ( opacity !== undefined ) ? opacity : 1.0;

	this.cubeScene = new THREE.Scene();
	this.cubeCamera = new THREE.PerspectiveCamera();
	this.cubeScene.add( this.cubeMesh );

};

THREE.CubeTexturePass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.CubeTexturePass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		this.cubeCamera.projectionMatrix.copy( this.camera.projectionMatrix );
		this.cubeCamera.quaternion.setFromRotationMatrix( this.camera.matrixWorld );

		this.cubeMesh.material.uniforms[ "tCube" ].value = this.envMap;
		this.cubeMesh.material.uniforms[ "opacity" ].value = this.opacity;
		this.cubeMesh.material.transparent = ( this.opacity < 1.0 );

		renderer.render( this.cubeScene, this.cubeCamera, this.renderToScreen ? null : readBuffer, this.clear );

		renderer.autoClear = oldAutoClear;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DotScreenPass = function ( center, angle, scale ) {

	THREE.Pass.call( this );

	if ( THREE.DotScreenShader === undefined )
		console.error( "THREE.DotScreenPass relies on THREE.DotScreenShader" );

	var shader = THREE.DotScreenShader;

	this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

	if ( center !== undefined ) this.uniforms[ "center" ].value.copy( center );
	if ( angle !== undefined ) this.uniforms[ "angle" ].value = angle;
	if ( scale !== undefined ) this.uniforms[ "scale" ].value = scale;

	this.material = new THREE.ShaderMaterial( {

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader

	} );

	this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene  = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

THREE.DotScreenPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.DotScreenPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		this.uniforms[ "tDiffuse" ].value = readBuffer.texture;
		this.uniforms[ "tSize" ].value.set( readBuffer.width, readBuffer.height );

		this.quad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.render( this.scene, this.camera );

		} else {

			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		}

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FilmPass = function ( noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale ) {

	THREE.Pass.call( this );

	if ( THREE.FilmShader === undefined )
		console.error( "THREE.FilmPass relies on THREE.FilmShader" );

	var shader = THREE.FilmShader;

	this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

	this.material = new THREE.ShaderMaterial( {

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader

	} );

	if ( grayscale !== undefined )	this.uniforms.grayscale.value = grayscale;
	if ( noiseIntensity !== undefined ) this.uniforms.nIntensity.value = noiseIntensity;
	if ( scanlinesIntensity !== undefined ) this.uniforms.sIntensity.value = scanlinesIntensity;
	if ( scanlinesCount !== undefined ) this.uniforms.sCount.value = scanlinesCount;

	this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene  = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

THREE.FilmPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.FilmPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		this.uniforms[ "tDiffuse" ].value = readBuffer.texture;
		this.uniforms[ "time" ].value += delta;

		this.quad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.render( this.scene, this.camera );

		} else {

			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		}

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.GlitchPass = function ( dt_size ) {

	THREE.Pass.call( this );

	if ( THREE.DigitalGlitch === undefined ) console.error( "THREE.GlitchPass relies on THREE.DigitalGlitch" );

	var shader = THREE.DigitalGlitch;
	this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

	if ( dt_size == undefined ) dt_size = 64;


	this.uniforms[ "tDisp" ].value = this.generateHeightmap( dt_size );


	this.material = new THREE.ShaderMaterial( {
		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader
	} );

	this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene  = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

	this.goWild = false;
	this.curF = 0;
	this.generateTrigger();

};

THREE.GlitchPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.GlitchPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		this.uniforms[ "tDiffuse" ].value = readBuffer.texture;
		this.uniforms[ 'seed' ].value = Math.random();//default seeding
		this.uniforms[ 'byp' ].value = 0;

		if ( this.curF % this.randX == 0 || this.goWild == true ) {

			this.uniforms[ 'amount' ].value = Math.random() / 30;
			this.uniforms[ 'angle' ].value = THREE.Math.randFloat( - Math.PI, Math.PI );
			this.uniforms[ 'seed_x' ].value = THREE.Math.randFloat( - 1, 1 );
			this.uniforms[ 'seed_y' ].value = THREE.Math.randFloat( - 1, 1 );
			this.uniforms[ 'distortion_x' ].value = THREE.Math.randFloat( 0, 1 );
			this.uniforms[ 'distortion_y' ].value = THREE.Math.randFloat( 0, 1 );
			this.curF = 0;
			this.generateTrigger();

		} else if ( this.curF % this.randX < this.randX / 5 ) {

			this.uniforms[ 'amount' ].value = Math.random() / 90;
			this.uniforms[ 'angle' ].value = THREE.Math.randFloat( - Math.PI, Math.PI );
			this.uniforms[ 'distortion_x' ].value = THREE.Math.randFloat( 0, 1 );
			this.uniforms[ 'distortion_y' ].value = THREE.Math.randFloat( 0, 1 );
			this.uniforms[ 'seed_x' ].value = THREE.Math.randFloat( - 0.3, 0.3 );
			this.uniforms[ 'seed_y' ].value = THREE.Math.randFloat( - 0.3, 0.3 );

		} else if ( this.goWild == false ) {

			this.uniforms[ 'byp' ].value = 1;

		}

		this.curF ++;
		this.quad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.render( this.scene, this.camera );

		} else {

			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		}

	},

	generateTrigger: function() {

		this.randX = THREE.Math.randInt( 120, 240 );

	},

	generateHeightmap: function( dt_size ) {

		var data_arr = new Float32Array( dt_size * dt_size * 3 );
		var length = dt_size * dt_size;

		for ( var i = 0; i < length; i ++ ) {

			var val = THREE.Math.randFloat( 0, 1 );
			data_arr[ i * 3 + 0 ] = val;
			data_arr[ i * 3 + 1 ] = val;
			data_arr[ i * 3 + 2 ] = val;

		}

		var texture = new THREE.DataTexture( data_arr, dt_size, dt_size, THREE.RGBFormat, THREE.FloatType );
		texture.needsUpdate = true;
		return texture;

	}

} );

/**
*
* Manual Multi-Sample Anti-Aliasing Render Pass
*
* @author bhouston / http://clara.io/
*
* This manual approach to MSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.
*
* References: https://en.wikipedia.org/wiki/Multisample_anti-aliasing
*
*/

THREE.ManualMSAARenderPass = function ( scene, camera, clearColor, clearAlpha ) {

	THREE.Pass.call( this );

	this.scene = scene;
	this.camera = camera;

	this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.
	this.unbiased = true;

	// as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.
	this.clearColor = ( clearColor !== undefined ) ? clearColor : 0x000000;
	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

	if ( THREE.CopyShader === undefined ) console.error( "THREE.ManualMSAARenderPass relies on THREE.CopyShader" );

	var copyShader = THREE.CopyShader;
	this.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );

	this.copyMaterial = new THREE.ShaderMaterial(	{
		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader,
		premultipliedAlpha: true,
		transparent: true,
		blending: THREE.AdditiveBlending,
		depthTest: false,
		depthWrite: false
	} );

	this.camera2 = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene2	= new THREE.Scene();
	this.quad2 = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), this.copyMaterial );
	this.scene2.add( this.quad2 );

};

THREE.ManualMSAARenderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.ManualMSAARenderPass,

	dispose: function() {

		if ( this.sampleRenderTarget ) {

			this.sampleRenderTarget.dispose();
			this.sampleRenderTarget = null;

		}

	},

	setSize: function ( width, height ) {

		if ( this.sampleRenderTarget )	this.sampleRenderTarget.setSize( width, height );

	},

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		if ( ! this.sampleRenderTarget ) {

			this.sampleRenderTarget = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height,
				{ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );

		}

		var jitterOffsets = THREE.ManualMSAARenderPass.JitterVectors[ Math.max( 0, Math.min( this.sampleLevel, 5 ) ) ];

		var autoClear = renderer.autoClear;
		renderer.autoClear = false;

		var oldClearColor = renderer.getClearColor().getHex();
		var oldClearAlpha = renderer.getClearAlpha();

		var baseSampleWeight = 1.0 / jitterOffsets.length;
		var roundingRange = 1 / 32;
		this.copyUniforms[ "tDiffuse" ].value = this.sampleRenderTarget.texture;

		var width = readBuffer.width, height = readBuffer.height;

		// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.
		for ( var i = 0; i < jitterOffsets.length; i ++ ) {

			var jitterOffset = jitterOffsets[i];
			if ( this.camera.setViewOffset ) {
				this.camera.setViewOffset( width, height,
					jitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625,   // 0.0625 = 1 / 16
					width, height );
			}

			var sampleWeight = baseSampleWeight;
			if( this.unbiased ) {
				// the theory is that equal weights for each sample lead to an accumulation of rounding errors.
				// The following equation varies the sampleWeight per sample so that it is uniformly distributed
				// across a range of values whose rounding errors cancel each other out.
				var uniformCenteredDistribution = ( -0.5 + ( i + 0.5 ) / jitterOffsets.length );
				sampleWeight += roundingRange * uniformCenteredDistribution;
			}

			this.copyUniforms[ "opacity" ].value = sampleWeight;
			renderer.setClearColor( this.clearColor, this.clearAlpha );
			renderer.render( this.scene, this.camera, this.sampleRenderTarget, true );
			if (i === 0) {
				renderer.setClearColor( 0x000000, 0.0 );
			}
			renderer.render( this.scene2, this.camera2, this.renderToScreen ? null : writeBuffer, (i === 0) );

		}

		if ( this.camera.clearViewOffset ) this.camera.clearViewOffset();

		renderer.autoClear = autoClear;
		renderer.setClearColor( oldClearColor, oldClearAlpha );

	}

} );


// These jitter vectors are specified in integers because it is easier.
// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)
// before being used, thus these integers need to be scaled by 1/16.
//
// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
THREE.ManualMSAARenderPass.JitterVectors = [
	[
		[ 0, 0 ]
	],
	[
		[ 4, 4 ], [ - 4, - 4 ]
	],
	[
		[ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]
	],
	[
		[ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],
		[ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]
	],
	[
		[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],
		[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],
		[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],
		[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]
	],
	[
		[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],
		[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],
		[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],
		[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],
		[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],
		[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],
		[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],
		[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]
	]
];

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MaskPass = function ( scene, camera ) {

	THREE.Pass.call( this );

	this.scene = scene;
	this.camera = camera;

	this.clear = true;
	this.needsSwap = false;

	this.inverse = false;

};

THREE.MaskPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.MaskPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		var context = renderer.context;
		var state = renderer.state;

		// don't update color or depth

		state.buffers.color.setMask( false );
		state.buffers.depth.setMask( false );

		// lock buffers

		state.buffers.color.setLocked( true );
		state.buffers.depth.setLocked( true );

		// set up stencil

		var writeValue, clearValue;

		if ( this.inverse ) {

			writeValue = 0;
			clearValue = 1;

		} else {

			writeValue = 1;
			clearValue = 0;

		}

		state.buffers.stencil.setTest( true );
		state.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );
		state.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );
		state.buffers.stencil.setClear( clearValue );

		// draw into the stencil buffer

		renderer.render( this.scene, this.camera, readBuffer, this.clear );
		renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		// unlock color and depth buffer for subsequent rendering

		state.buffers.color.setLocked( false );
		state.buffers.depth.setLocked( false );

		// only render where stencil is set to 1

		state.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
		state.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );

	}

} );


THREE.ClearMaskPass = function () {

	THREE.Pass.call( this );

	this.needsSwap = false;

};

THREE.ClearMaskPass.prototype = Object.create( THREE.Pass.prototype );

Object.assign( THREE.ClearMaskPass.prototype, {

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		renderer.state.buffers.stencil.setTest( false );

	}

} );

/**
 * @author spidersharma / http://eduperiment.com/
 */

THREE.OutlinePass = function ( resolution, scene, camera, selectedObjects ) {

	this.renderScene = scene;
	this.renderCamera = camera;
	this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];
	this.visibleEdgeColor = new THREE.Color(1, 1, 1);
	this.hiddenEdgeColor = new THREE.Color(0.1, 0.04, 0.02);
	this.edgeGlow = 0.0;
	this.usePatternTexture = false;
	this.edgeThickness = 1.0;
	this.edgeStrength = 3.0;
	this.downSampleRatio = 2;
	this.pulsePeriod = 0;

	THREE.Pass.call( this );

	this.resolution = ( resolution !== undefined ) ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);

	var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };

	var resx = Math.round(this.resolution.x/this.downSampleRatio);
	var resy = Math.round(this.resolution.y/this.downSampleRatio);

	this.maskBufferMaterial = new THREE.MeshBasicMaterial({color:0xffffff});
	this.maskBufferMaterial.side = THREE.DoubleSide;
	this.renderTargetMaskBuffer = new THREE.WebGLRenderTarget( this.resolution.x, this.resolution.y, pars );
	this.renderTargetMaskBuffer.texture.generateMipmaps = false;

	this.depthMaterial = new THREE.MeshDepthMaterial();
	this.depthMaterial.side = THREE.DoubleSide;
	this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
	this.depthMaterial.blending = THREE.NoBlending;

	this.prepareMaskMaterial = this.getPrepareMaskMaterial();
	this.prepareMaskMaterial.side = THREE.DoubleSide;

	this.renderTargetDepthBuffer = new THREE.WebGLRenderTarget( this.resolution.x, this.resolution.y, pars );
	this.renderTargetDepthBuffer.texture.generateMipmaps = false;

	this.renderTargetMaskDownSampleBuffer = new THREE.WebGLRenderTarget( resx, resy, pars );
	this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;

	this.renderTargetBlurBuffer1 = new THREE.WebGLRenderTarget( resx, resy, pars );
	this.renderTargetBlurBuffer1.texture.generateMipmaps = false;
	this.renderTargetBlurBuffer2 = new THREE.WebGLRenderTarget( Math.round(resx/2), Math.round(resy/2), pars );
	this.renderTargetBlurBuffer2.texture.generateMipmaps = false;

	this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();
	this.renderTargetEdgeBuffer1 = new THREE.WebGLRenderTarget( resx, resy, pars );
	this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;
	this.renderTargetEdgeBuffer2 = new THREE.WebGLRenderTarget( Math.round(resx/2), Math.round(resy/2), pars );
	this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;

	var MAX_EDGE_THICKNESS = 4;
	var MAX_EDGE_GLOW = 4;

	this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);
	this.separableBlurMaterial1.uniforms[ "texSize" ].value = new THREE.Vector2(resx, resy);
	this.separableBlurMaterial1.uniforms[ "kernelRadius" ].value = 1;
	this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);
	this.separableBlurMaterial2.uniforms[ "texSize" ].value = new THREE.Vector2(Math.round(resx/2), Math.round(resy/2));
	this.separableBlurMaterial2.uniforms[ "kernelRadius" ].value = MAX_EDGE_GLOW;

	// Overlay material
	this.overlayMaterial = this.getOverlayMaterial();

	// copy material
	if ( THREE.CopyShader === undefined )
		console.error( "THREE.OutlinePass relies on THREE.CopyShader" );

	var copyShader = THREE.CopyShader;

	this.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );
	this.copyUniforms[ "opacity" ].value = 1.0;

	this.materialCopy = new THREE.ShaderMaterial( {
		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader,
		blending: THREE.NoBlending,
		depthTest: false,
		depthWrite: false,
		transparent: true
	} );

	this.enabled = true;
	this.needsSwap = false;

	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;

	this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene  = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

	this.tempPulseColor1 = new THREE.Color();
	this.tempPulseColor2 = new THREE.Color();
	this.textureMatrix = new THREE.Matrix4();
};

THREE.OutlinePass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.OutlinePass,

	dispose: function() {
		this.renderTargetMaskBuffer.dispose();
		this.renderTargetDepthBuffer.dispose();
		this.renderTargetMaskDownSampleBuffer.dispose();
		this.renderTargetBlurBuffer1.dispose();
		this.renderTargetBlurBuffer2.dispose();
		this.renderTargetEdgeBuffer1.dispose();
		this.renderTargetEdgeBuffer2.dispose();
	},

	setSize: function ( width, height ) {

		this.renderTargetMaskBuffer.setSize(width, height );

		var resx = Math.round(width/this.downSampleRatio);
		var resy = Math.round(height/this.downSampleRatio);
		this.renderTargetMaskDownSampleBuffer.setSize(resx, resy );
		this.renderTargetBlurBuffer1.setSize(resx, resy );
		this.renderTargetEdgeBuffer1.setSize(resx, resy );
		this.separableBlurMaterial1.uniforms[ "texSize" ].value = new THREE.Vector2(resx, resy);

	  resx = Math.round(resx/2);
	  resy = Math.round(resy/2);

		this.renderTargetBlurBuffer2.setSize(resx, resy );
		this.renderTargetEdgeBuffer2.setSize(resx, resy );

		this.separableBlurMaterial2.uniforms[ "texSize" ].value = new THREE.Vector2(resx, resy);
	},

	changeVisibilityOfSelectedObjects: function( bVisible ) {

		var gatherSelectedMeshesCallBack = function( object ) {

			if( object instanceof THREE.Mesh ) {
				object.visible = bVisible;
			}
		}

		for( var i=0; i<this.selectedObjects.length; i++ ) {

			var selectedObject = this.selectedObjects[i];

			selectedObject.traverse( gatherSelectedMeshesCallBack );
		}
	},

	changeVisibilityOfNonSelectedObjects: function( bVisible ) {

		var selectedMeshes = [];

		var gatherSelectedMeshesCallBack = function( object ) {

			if( object instanceof THREE.Mesh ) {

				selectedMeshes.push(object);

			}
		}

		for( var i=0; i<this.selectedObjects.length; i++ ) {

			var selectedObject = this.selectedObjects[i];

			selectedObject.traverse( gatherSelectedMeshesCallBack );
		}

		var VisibilityChangeCallBack = function( object ) {

			if( object instanceof THREE.Mesh ) {

				var bFound = false;

				for( var i=0; i<selectedMeshes.length; i++ ) {

					var selectedObjectId = selectedMeshes[i].id;

					if(selectedObjectId === object.id) {
						bFound = true;
						break;
					}

				}
				if(!bFound) {
					var visibility = object.visible;
					if( !bVisible || object.bVisible )
						object.visible = bVisible;
					object.bVisible = visibility;
				}
			}
		}
		this.renderScene.traverse( VisibilityChangeCallBack );
	},

	updateTextureMatrix: function() {

		this.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,
														0.0, 0.5, 0.0, 0.5,
														0.0, 0.0, 0.5, 0.5,
														0.0, 0.0, 0.0, 1.0 );
		this.textureMatrix.multiply( this.renderCamera.projectionMatrix );
		this.textureMatrix.multiply( this.renderCamera.matrixWorldInverse );

	},

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		if(this.selectedObjects.length === 0 )
			return;

		this.oldClearColor.copy( renderer.getClearColor() );
		this.oldClearAlpha = renderer.getClearAlpha();
		var oldAutoClear = renderer.autoClear;

		renderer.autoClear = false;

		if ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );

		renderer.setClearColor( 0xffffff, 1 );

		// Make selected objects invisible
		this.changeVisibilityOfSelectedObjects(false);

		// 1. Draw Non Selected objects in the depth buffer
		this.renderScene.overrideMaterial = this.depthMaterial;
		renderer.render( this.renderScene, this.renderCamera, this.renderTargetDepthBuffer, true );

		// Make selected objects visible
		this.changeVisibilityOfSelectedObjects(true);

		// Update Texture Matrix for Depth compare
		this.updateTextureMatrix();

		// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects
		this.changeVisibilityOfNonSelectedObjects(false);
		this.renderScene.overrideMaterial = this.prepareMaskMaterial;
		this.prepareMaskMaterial.uniforms[ "cameraNearFar" ].value = new THREE.Vector2(this.renderCamera.near, this.renderCamera.far);
		this.prepareMaskMaterial.uniforms[ "depthTexture" ].value = this.renderTargetDepthBuffer.texture;
		this.prepareMaskMaterial.uniforms[ "textureMatrix" ].value = this.textureMatrix;
		renderer.render( this.renderScene, this.renderCamera, this.renderTargetMaskBuffer, true );
		this.renderScene.overrideMaterial = null;
		this.changeVisibilityOfNonSelectedObjects(true);

		// 2. Downsample to Half resolution
		this.quad.material = this.materialCopy;
		this.copyUniforms[ "tDiffuse" ].value = this.renderTargetMaskBuffer.texture;
		renderer.render( this.scene, this.camera, this.renderTargetMaskDownSampleBuffer, true );

		this.tempPulseColor1.copy( this.visibleEdgeColor );
		this.tempPulseColor2.copy( this.hiddenEdgeColor );
		if( this.pulsePeriod > 0 ) {
			var scalar = ( 1 + 0.25 ) / 2 + Math.cos( performance.now() * 0.01/ this.pulsePeriod ) * ( 1.0 - 0.25 )/2
			this.tempPulseColor1.multiplyScalar( scalar );
			this.tempPulseColor2.multiplyScalar( scalar );
		}

		// 3. Apply Edge Detection Pass
		this.quad.material = this.edgeDetectionMaterial;
		this.edgeDetectionMaterial.uniforms[ "maskTexture" ].value = this.renderTargetMaskDownSampleBuffer.texture;
		this.edgeDetectionMaterial.uniforms[ "texSize" ].value = new THREE.Vector2(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);
		this.edgeDetectionMaterial.uniforms[ "visibleEdgeColor" ].value = this.tempPulseColor1;
		this.edgeDetectionMaterial.uniforms[ "hiddenEdgeColor" ].value = this.tempPulseColor2;
		renderer.render( this.scene, this.camera, this.renderTargetEdgeBuffer1, true );

		// 4. Apply Blur on Half res
		this.quad.material = this.separableBlurMaterial1;
		this.separableBlurMaterial1.uniforms[ "colorTexture" ].value = this.renderTargetEdgeBuffer1.texture;
		this.separableBlurMaterial1.uniforms[ "direction" ].value = THREE.OutlinePass.BlurDirectionX;
		this.separableBlurMaterial1.uniforms[ "kernelRadius" ].value = this.edgeThickness;
		renderer.render( this.scene, this.camera, this.renderTargetBlurBuffer1, true );
		this.separableBlurMaterial1.uniforms[ "colorTexture" ].value = this.renderTargetBlurBuffer1.texture;
		this.separableBlurMaterial1.uniforms[ "direction" ].value = THREE.OutlinePass.BlurDirectionY;
		renderer.render( this.scene, this.camera, this.renderTargetEdgeBuffer1, true );

		// Apply Blur on quarter res
		this.quad.material = this.separableBlurMaterial2;
		this.separableBlurMaterial2.uniforms[ "colorTexture" ].value = this.renderTargetEdgeBuffer1.texture;
		this.separableBlurMaterial2.uniforms[ "direction" ].value = THREE.OutlinePass.BlurDirectionX;
		renderer.render( this.scene, this.camera, this.renderTargetBlurBuffer2, true );
		this.separableBlurMaterial2.uniforms[ "colorTexture" ].value = this.renderTargetBlurBuffer2.texture;
		this.separableBlurMaterial2.uniforms[ "direction" ].value = THREE.OutlinePass.BlurDirectionY;
		renderer.render( this.scene, this.camera, this.renderTargetEdgeBuffer2, true );

		// Blend it additively over the input texture
		this.quad.material = this.overlayMaterial;
		this.overlayMaterial.uniforms[ "maskTexture" ].value = this.renderTargetMaskBuffer.texture;
		this.overlayMaterial.uniforms[ "edgeTexture1" ].value = this.renderTargetEdgeBuffer1.texture;
		this.overlayMaterial.uniforms[ "edgeTexture2" ].value = this.renderTargetEdgeBuffer2.texture;
		this.overlayMaterial.uniforms[ "patternTexture" ].value = this.patternTexture;
		this.overlayMaterial.uniforms[ "edgeStrength" ].value = this.edgeStrength;
		this.overlayMaterial.uniforms[ "edgeGlow" ].value = this.edgeGlow;
		this.overlayMaterial.uniforms[ "usePatternTexture" ].value = this.usePatternTexture;


		if ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );

		renderer.render( this.scene, this.camera, readBuffer, false );

		renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );
		renderer.autoClear = oldAutoClear;
	},

	getPrepareMaskMaterial: function() {

		return new THREE.ShaderMaterial( {

			uniforms: {
				"depthTexture": { value: null },
				"cameraNearFar": { value: new THREE.Vector2( 0.5, 0.5 ) },
				"textureMatrix" : { value: new THREE.Matrix4() }
			},

			vertexShader:
				"varying vec2 vUv;\
				varying vec4 projTexCoord;\
				varying vec4 vPosition;\
				uniform mat4 textureMatrix;\
				void main() {\
					vUv = uv;\
					vPosition = modelViewMatrix * vec4( position, 1.0 );\
					vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\
					projTexCoord = textureMatrix * worldPosition;\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader:
				"#include <packing>\
				varying vec2 vUv;\
				varying vec4 vPosition;\
				varying vec4 projTexCoord;\
				uniform sampler2D depthTexture;\
				uniform vec2 cameraNearFar;\
				\
				void main() {\
					float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\
					float viewZ = -perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );\
					float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\
					gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\
				}"
		} );
	},

	getEdgeDetectionMaterial: function() {

		return new THREE.ShaderMaterial( {

			uniforms: {
				"maskTexture": { value: null },
				"texSize": { value: new THREE.Vector2( 0.5, 0.5 ) },
				"visibleEdgeColor": { value: new THREE.Vector3( 1.0, 1.0, 1.0 ) },
				"hiddenEdgeColor":  { value: new THREE.Vector3( 1.0, 1.0, 1.0 ) },
			},

			vertexShader:
				"varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader:
				"varying vec2 vUv;\
				uniform sampler2D maskTexture;\
				uniform vec2 texSize;\
				uniform vec3 visibleEdgeColor;\
				uniform vec3 hiddenEdgeColor;\
				\
				void main() {\n\
					vec2 invSize = 1.0 / texSize;\
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\
					float diff1 = (c1.r - c2.r)*0.5;\
					float diff2 = (c3.r - c4.r)*0.5;\
					float d = length( vec2(diff1, diff2) );\
					float a1 = min(c1.g, c2.g);\
					float a2 = min(c3.g, c4.g);\
					float visibilityFactor = min(a1, a2);\
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\
				}"
		} );
	},

	getSeperableBlurMaterial: function(maxRadius) {

		return new THREE.ShaderMaterial( {

			defines: {
				"MAX_RADIUS" : maxRadius,
			},

			uniforms: {
				"colorTexture": { value: null },
				"texSize": 	{ value: new THREE.Vector2( 0.5, 0.5 ) },
				"direction": { value: new THREE.Vector2( 0.5, 0.5 ) },
				"kernelRadius": { value: 1.0 }
			},

			vertexShader:
				"varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader:
				"#include <common>\
				varying vec2 vUv;\
				uniform sampler2D colorTexture;\
				uniform vec2 texSize;\
				uniform vec2 direction;\
				uniform float kernelRadius;\
				\
				float gaussianPdf(in float x, in float sigma) {\
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\
				}\
				void main() {\
					vec2 invSize = 1.0 / texSize;\
					float weightSum = gaussianPdf(0.0, kernelRadius);\
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\
					vec2 uvOffset = delta;\
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {\
						float w = gaussianPdf(uvOffset.x, kernelRadius);\
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\
						diffuseSum += ((sample1 + sample2) * w);\
						weightSum += (2.0 * w);\
						uvOffset += delta;\
					}\
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\
				}"
		} );
	},

	getOverlayMaterial: function() {

		return new THREE.ShaderMaterial( {

			uniforms: {
				"maskTexture": { value: null },
				"edgeTexture1": { value: null },
				"edgeTexture2": { value: null },
				"patternTexture": { value: null },
				"edgeStrength" : { value: 1.0 },
				"edgeGlow" : { value: 1.0 },
				"usePatternTexture" : { value: 0.0 }
			},

			vertexShader:
				"varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader:
				"varying vec2 vUv;\
				uniform sampler2D maskTexture;\
				uniform sampler2D edgeTexture1;\
				uniform sampler2D edgeTexture2;\
				uniform sampler2D patternTexture;\
				uniform float edgeStrength;\
				uniform float edgeGlow;\
				uniform bool usePatternTexture;\
				\
				void main() {\
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);\
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);\
					vec4 maskColor = texture2D(maskTexture, vUv);\
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;\
					if(usePatternTexture)\
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\
					gl_FragColor = finalColor;\
				}",

				blending: THREE.AdditiveBlending,
				depthTest: false,
				depthWrite: false,
				transparent: true
		} );
	}

} );

THREE.OutlinePass.BlurDirectionX = new THREE.Vector2( 1.0, 0.0 );
THREE.OutlinePass.BlurDirectionY = new THREE.Vector2( 0.0, 1.0 );

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

	THREE.Pass.call( this );

	this.scene = scene;
	this.camera = camera;

	this.overrideMaterial = overrideMaterial;

	this.clearColor = clearColor;
	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

	this.clear = true;
	this.needsSwap = false;

};

THREE.RenderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.RenderPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		this.scene.overrideMaterial = this.overrideMaterial;

		var oldClearColor, oldClearAlpha;

		if ( this.clearColor ) {

			oldClearColor = renderer.getClearColor().getHex();
			oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor( this.clearColor, this.clearAlpha );

		}

		renderer.render( this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear );

		if ( this.clearColor ) {

			renderer.setClearColor( oldClearColor, oldClearAlpha );

		}

		this.scene.overrideMaterial = null;
		renderer.autoClear = oldAutoClear;
	}

} );

/**
 * @author mpk / http://polko.me/
 */

THREE.SMAAPass = function ( width, height ) {

	THREE.Pass.call( this );

	// render targets

	this.edgesRT = new THREE.WebGLRenderTarget( width, height, {
		depthBuffer: false,
		stencilBuffer: false,
		generateMipmaps: false,
		minFilter: THREE.LinearFilter,
		format: THREE.RGBFormat
	} );

	this.weightsRT = new THREE.WebGLRenderTarget( width, height, {
		depthBuffer: false,
		stencilBuffer: false,
		generateMipmaps: false,
		minFilter: THREE.LinearFilter,
		format: THREE.RGBAFormat
	} );

	// textures

	var areaTextureImage = new Image();
	areaTextureImage.src = this.getAreaTexture();

	this.areaTexture = new THREE.Texture();
	this.areaTexture.image = areaTextureImage;
	this.areaTexture.format = THREE.RGBFormat;
	this.areaTexture.minFilter = THREE.LinearFilter;
	this.areaTexture.generateMipmaps = false;
	this.areaTexture.needsUpdate = true;
	this.areaTexture.flipY = false;

	var searchTextureImage = new Image();
	searchTextureImage.src = this.getSearchTexture();

	this.searchTexture = new THREE.Texture();
	this.searchTexture.image = searchTextureImage;
	this.searchTexture.magFilter = THREE.NearestFilter;
	this.searchTexture.minFilter = THREE.NearestFilter;
	this.searchTexture.generateMipmaps = false;
	this.searchTexture.needsUpdate = true;
	this.searchTexture.flipY = false;

	// materials - pass 1

	if ( THREE.SMAAShader === undefined ) {
		console.error( "THREE.SMAAPass relies on THREE.SMAAShader" );
	}

	this.uniformsEdges = THREE.UniformsUtils.clone( THREE.SMAAShader[0].uniforms );

	this.uniformsEdges[ "resolution" ].value.set( 1 / width, 1 / height );

	this.materialEdges = new THREE.ShaderMaterial( {
		defines: THREE.SMAAShader[0].defines,
		uniforms: this.uniformsEdges,
		vertexShader: THREE.SMAAShader[0].vertexShader,
		fragmentShader: THREE.SMAAShader[0].fragmentShader
	} );

	// materials - pass 2

	this.uniformsWeights = THREE.UniformsUtils.clone( THREE.SMAAShader[1].uniforms );

	this.uniformsWeights[ "resolution" ].value.set( 1 / width, 1 / height );
	this.uniformsWeights[ "tDiffuse" ].value = this.edgesRT.texture;
	this.uniformsWeights[ "tArea" ].value = this.areaTexture;
	this.uniformsWeights[ "tSearch" ].value = this.searchTexture;

	this.materialWeights = new THREE.ShaderMaterial( {
		defines: THREE.SMAAShader[1].defines,
		uniforms: this.uniformsWeights,
		vertexShader: THREE.SMAAShader[1].vertexShader,
		fragmentShader: THREE.SMAAShader[1].fragmentShader
	} );

	// materials - pass 3

	this.uniformsBlend = THREE.UniformsUtils.clone( THREE.SMAAShader[2].uniforms );

	this.uniformsBlend[ "resolution" ].value.set( 1 / width, 1 / height );
	this.uniformsBlend[ "tDiffuse" ].value = this.weightsRT.texture;

	this.materialBlend = new THREE.ShaderMaterial( {
		uniforms: this.uniformsBlend,
		vertexShader: THREE.SMAAShader[2].vertexShader,
		fragmentShader: THREE.SMAAShader[2].fragmentShader
	} );

	this.needsSwap = false;

	this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
	this.scene  = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

THREE.SMAAPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.SMAAPass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		// pass 1

		this.uniformsEdges[ "tDiffuse" ].value = readBuffer.texture;

		this.quad.material = this.materialEdges;

		renderer.render( this.scene, this.camera, this.edgesRT, this.clear );

		// pass 2

		this.quad.material = this.materialWeights;

		renderer.render( this.scene, this.camera, this.weightsRT, this.clear );

		// pass 3

		this.uniformsBlend[ "tColor" ].value = readBuffer.texture;

		this.quad.material = this.materialBlend;

		if ( this.renderToScreen ) {

			renderer.render( this.scene, this.camera );

		} else {

			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		}

	},

	setSize: function ( width, height ) {

		this.edgesRT.setSize( width, height );
		this.weightsRT.setSize( width, height );

		this.materialEdges.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );
		this.materialWeights.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );
		this.materialBlend.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );

	},

	getAreaTexture: function () {
		return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=';
	},

	getSearchTexture: function () {
		return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=';
	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SavePass = function ( renderTarget ) {

	THREE.Pass.call( this );

	if ( THREE.CopyShader === undefined )
		console.error( "THREE.SavePass relies on THREE.CopyShader" );

	var shader = THREE.CopyShader;

	this.textureID = "tDiffuse";

	this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

	this.material = new THREE.ShaderMaterial( {

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader

	} );

	this.renderTarget = renderTarget;

	if ( this.renderTarget === undefined ) {

		this.renderTargetParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };
		this.renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, this.renderTargetParameters );

	}

	this.needsSwap = false;

	this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene  = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

THREE.SavePass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.SavePass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer.texture;

		}

		this.quad.material = this.material;

		renderer.render( this.scene, this.camera, this.renderTarget, this.clear );

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShaderPass = function ( shader, textureID ) {

	THREE.Pass.call( this );

	this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

	if ( shader instanceof THREE.ShaderMaterial ) {

		this.uniforms = shader.uniforms;

		this.material = shader;

	} else if ( shader ) {

		this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

		this.material = new THREE.ShaderMaterial( {

			defines: shader.defines || {},
			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader

		} );

	}

	this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

THREE.ShaderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.ShaderPass,

	render: function( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer.texture;

		}

		this.quad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.render( this.scene, this.camera );

		} else {

			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		}

	}

} );

/**
 *
 * Temporal Anti-Aliasing Render Pass
 *
 * @author bhouston / http://clara.io/
 *
 * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.
 *
 * References:
 *
 * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.
 *
 */

THREE.TAARenderPass = function ( scene, camera, params ) {

	if ( THREE.ManualMSAARenderPass === undefined ) {

		console.error( "THREE.TAARenderPass relies on THREE.ManualMSAARenderPass" );

	}
	THREE.ManualMSAARenderPass.call( this, scene, camera, params );

	this.sampleLevel = 0;
	this.accumulate = false;

};

THREE.TAARenderPass.JitterVectors = THREE.ManualMSAARenderPass.JitterVectors;

THREE.TAARenderPass.prototype = Object.assign( Object.create( THREE.ManualMSAARenderPass.prototype ), {

	constructor: THREE.TAARenderPass,

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		if( ! this.accumulate ) {

				THREE.ManualMSAARenderPass.prototype.render.call( this, renderer, writeBuffer, readBuffer, delta );

				this.accumulateIndex = -1;
				return;

		}

		var jitterOffsets = THREE.TAARenderPass.JitterVectors[ 5 ];

		if ( ! this.sampleRenderTarget ) {

			this.sampleRenderTarget = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height, this.params );

		}

		if ( ! this.holdRenderTarget ) {

			this.holdRenderTarget = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height, this.params );

		}

		if( this.accumulate && this.accumulateIndex === -1 ) {

				THREE.ManualMSAARenderPass.prototype.render.call( this, renderer, this.holdRenderTarget, readBuffer, delta );

				this.accumulateIndex = 0;

		}

		var autoClear = renderer.autoClear;
		renderer.autoClear = false;

		var sampleWeight = 1.0 / ( jitterOffsets.length );

		if( this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length ) {

			this.copyUniforms[ "opacity" ].value = sampleWeight;
			this.copyUniforms[ "tDiffuse" ].value = writeBuffer.texture;

			// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.
			var numSamplesPerFrame = Math.pow( 2, this.sampleLevel );
			for ( var i = 0; i < numSamplesPerFrame; i ++ ) {

				var j = this.accumulateIndex;
				var jitterOffset = jitterOffsets[j];
				if ( this.camera.setViewOffset ) {
					this.camera.setViewOffset( readBuffer.width, readBuffer.height,
						jitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625,   // 0.0625 = 1 / 16
						readBuffer.width, readBuffer.height );
				}

				renderer.render( this.scene, this.camera, writeBuffer, true );
				renderer.render( this.scene2, this.camera2, this.sampleRenderTarget, ( this.accumulateIndex === 0 ) );

				this.accumulateIndex ++;
				if( this.accumulateIndex >= jitterOffsets.length ) break;
			}

			if ( this.camera.clearViewOffset ) this.camera.clearViewOffset();

		}

		var accumulationWeight = this.accumulateIndex * sampleWeight;

		if( accumulationWeight > 0 ) {
			this.copyUniforms[ "opacity" ].value = 1.0;
			this.copyUniforms[ "tDiffuse" ].value = this.sampleRenderTarget.texture;
			renderer.render( this.scene2, this.camera2, writeBuffer, true );
		}
		if( accumulationWeight < 1.0 ) {
			this.copyUniforms[ "opacity" ].value = 1.0 - accumulationWeight;
			this.copyUniforms[ "tDiffuse" ].value = this.holdRenderTarget.texture;
			renderer.render( this.scene2, this.camera2, writeBuffer, ( accumulationWeight === 0 ) );
		}

		renderer.autoClear = autoClear;

	}

});

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.TexturePass = function ( map, opacity ) {

	THREE.Pass.call( this );

	if ( THREE.CopyShader === undefined )
		console.error( "THREE.TexturePass relies on THREE.CopyShader" );

	var shader = THREE.CopyShader;

	this.map = map;
	this.opacity = ( opacity !== undefined ) ? opacity : 1.0;

	this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

	this.material = new THREE.ShaderMaterial( {

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader,
		depthTest: false,
		depthWrite: false

	} );

	this.needsSwap = false;

	this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene  = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

THREE.TexturePass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.TexturePass,

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		this.quad.material = this.material;

		this.uniforms[ "opacity" ].value = this.opacity;
		this.uniforms[ "tDiffuse" ].value = this.map;
		this.material.transparent = ( this.opacity < 1.0 );

		renderer.render( this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear );

		renderer.autoClear = oldAutoClear;
	}

} );

/**
 * @author spidersharma / http://eduperiment.com/
 Inspired from Unreal Engine::
 https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/
 */

THREE.UnrealBloomPass = function ( resolution, strength, radius, threshold ) {

	THREE.Pass.call( this );

	this.strength = ( strength !== undefined ) ? strength : 1;
	this.radius = radius;
	this.threshold = threshold;
	this.resolution = ( resolution !== undefined ) ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);

	// render targets
	var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };
	this.renderTargetsHorizontal = [];
	this.renderTargetsVertical = [];
	this.nMips = 5;
	var resx = Math.round(this.resolution.x/2);
	var resy = Math.round(this.resolution.y/2);

	this.renderTargetBright = new THREE.WebGLRenderTarget( resx, resy, pars );
	this.renderTargetBright.texture.generateMipmaps = false;

	for( var i=0; i<this.nMips; i++) {

		var renderTarget = new THREE.WebGLRenderTarget( resx, resy, pars );

		renderTarget.texture.generateMipmaps = false;

		this.renderTargetsHorizontal.push(renderTarget);

		var renderTarget = new THREE.WebGLRenderTarget( resx, resy, pars );

		renderTarget.texture.generateMipmaps = false;

		this.renderTargetsVertical.push(renderTarget);

		resx = Math.round(resx/2);

		resy = Math.round(resy/2);
	}

	// luminosity high pass material

	if ( THREE.LuminosityHighPassShader === undefined )
		console.error( "THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader" );

	var highPassShader = THREE.LuminosityHighPassShader;
	this.highPassUniforms = THREE.UniformsUtils.clone( highPassShader.uniforms );

	this.highPassUniforms[ "luminosityThreshold" ].value = threshold;
	this.highPassUniforms[ "smoothWidth" ].value = 0.01;

	this.materialHighPassFilter = new THREE.ShaderMaterial( {
		uniforms: this.highPassUniforms,
		vertexShader:  highPassShader.vertexShader,
		fragmentShader: highPassShader.fragmentShader,
		defines: {}
	} );

	// Gaussian Blur Materials
	this.separableBlurMaterials = [];
	var kernelSizeArray = [3, 5, 7, 9, 11];
	var resx = Math.round(this.resolution.x/2);
	var resy = Math.round(this.resolution.y/2);

	for( var i=0; i<this.nMips; i++) {

		this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));

		this.separableBlurMaterials[i].uniforms[ "texSize" ].value = new THREE.Vector2(resx, resy);

		resx = Math.round(resx/2);

		resy = Math.round(resy/2);
	}

	// Composite material
	this.compositeMaterial = this.getCompositeMaterial(this.nMips);
	this.compositeMaterial.uniforms["blurTexture1"].value = this.renderTargetsVertical[0].texture;
	this.compositeMaterial.uniforms["blurTexture2"].value = this.renderTargetsVertical[1].texture;
	this.compositeMaterial.uniforms["blurTexture3"].value = this.renderTargetsVertical[2].texture;
	this.compositeMaterial.uniforms["blurTexture4"].value = this.renderTargetsVertical[3].texture;
	this.compositeMaterial.uniforms["blurTexture5"].value = this.renderTargetsVertical[4].texture;
	this.compositeMaterial.uniforms["bloomStrength"].value = strength;
	this.compositeMaterial.uniforms["bloomRadius"].value = 0.1;
	this.compositeMaterial.needsUpdate = true;

	var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];
	this.compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
	this.bloomTintColors = [new THREE.Vector3(1,1,1), new THREE.Vector3(1,1,1), new THREE.Vector3(1,1,1)
												,new THREE.Vector3(1,1,1), new THREE.Vector3(1,1,1)];
	this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;

	// copy material
	if ( THREE.CopyShader === undefined )
		console.error( "THREE.BloomPass relies on THREE.CopyShader" );

	var copyShader = THREE.CopyShader;

	this.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );
	this.copyUniforms[ "opacity" ].value = 1.0;

	this.materialCopy = new THREE.ShaderMaterial( {
		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader,
		blending: THREE.AdditiveBlending,
		depthTest: false,
		depthWrite: false,
		transparent: true
	} );

	this.enabled = true;
	this.needsSwap = false;

	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;

	this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene  = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

THREE.UnrealBloomPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.UnrealBloomPass,

	dispose: function() {
		for( var i=0; i< this.renderTargetsHorizontal.length(); i++) {
			this.renderTargetsHorizontal[i].dispose();
		}
		for( var i=0; i< this.renderTargetsVertical.length(); i++) {
			this.renderTargetsVertical[i].dispose();
		}
		this.renderTargetBright.dispose();
	},

	setSize: function ( width, height ) {

		var resx = Math.round(width/2);
		var resy = Math.round(height/2);

		this.renderTargetBright.setSize(resx, resy);

		for( var i=0; i<this.nMips; i++) {

			this.renderTargetsHorizontal[i].setSize(resx, resy);
			this.renderTargetsVertical[i].setSize(resx, resy);

			this.separableBlurMaterials[i].uniforms[ "texSize" ].value = new THREE.Vector2(resx, resy);

			resx = Math.round(resx/2);
			resy = Math.round(resy/2);
		}
	},

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		this.oldClearColor.copy( renderer.getClearColor() );
		this.oldClearAlpha = renderer.getClearAlpha();
		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		renderer.setClearColor( new THREE.Color( 0, 0, 0 ), 0 );

		if ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );

		// 1. Extract Bright Areas
		this.highPassUniforms[ "tDiffuse" ].value = readBuffer.texture;
		this.highPassUniforms[ "luminosityThreshold" ].value = this.threshold;
		this.quad.material = this.materialHighPassFilter;
		renderer.render( this.scene, this.camera, this.renderTargetBright, true );

		// 2. Blur All the mips progressively
		var inputRenderTarget = this.renderTargetBright;

		for(var i=0; i<this.nMips; i++) {

			this.quad.material = this.separableBlurMaterials[i];

			this.separableBlurMaterials[i].uniforms[ "colorTexture" ].value = inputRenderTarget.texture;

			this.separableBlurMaterials[i].uniforms[ "direction" ].value = THREE.UnrealBloomPass.BlurDirectionX;

			renderer.render( this.scene, this.camera, this.renderTargetsHorizontal[i], true );

			this.separableBlurMaterials[i].uniforms[ "colorTexture" ].value = this.renderTargetsHorizontal[i].texture;

			this.separableBlurMaterials[i].uniforms[ "direction" ].value = THREE.UnrealBloomPass.BlurDirectionY;

			renderer.render( this.scene, this.camera, this.renderTargetsVertical[i], true );

			inputRenderTarget = this.renderTargetsVertical[i];
		}

		// Composite All the mips
		this.quad.material = this.compositeMaterial;
		this.compositeMaterial.uniforms["bloomStrength"].value = this.strength;
		this.compositeMaterial.uniforms["bloomRadius"].value = this.radius;
		this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
		renderer.render( this.scene, this.camera, this.renderTargetsHorizontal[0], true );

		// Blend it additively over the input texture
		this.quad.material = this.materialCopy;
		this.copyUniforms[ "tDiffuse" ].value = this.renderTargetsHorizontal[0].texture;

		if ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );

		renderer.render( this.scene, this.camera, readBuffer, false );

		renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );
		renderer.autoClear = oldAutoClear;
	},

	getSeperableBlurMaterial: function(kernelRadius) {

		return new THREE.ShaderMaterial( {

			defines: {
				"KERNEL_RADIUS" : kernelRadius,
				"SIGMA" : kernelRadius
			},

			uniforms: {
				"colorTexture": { value: null },
				"texSize": 				{ value: new THREE.Vector2( 0.5, 0.5 ) },
				"direction": 				{ value: new THREE.Vector2( 0.5, 0.5 ) },
			},

			vertexShader:
				"varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader:
				"#include <common>\
				varying vec2 vUv;\n\
				uniform sampler2D colorTexture;\n\
				uniform vec2 texSize;\
				uniform vec2 direction;\
				\
				float gaussianPdf(in float x, in float sigma) {\
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\
				}\
				void main() {\n\
					vec2 invSize = 1.0 / texSize;\
					float fSigma = float(SIGMA);\
					float weightSum = gaussianPdf(0.0, fSigma);\
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {\
						float x = float(i);\
						float w = gaussianPdf(x, fSigma);\
						vec2 uvOffset = direction * invSize * x;\
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\
						diffuseSum += (sample1 + sample2) * w;\
						weightSum += 2.0 * w;\
					}\
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\
				}"
		} );
	},

	getCompositeMaterial: function(nMips) {

		return new THREE.ShaderMaterial( {

			defines:{
				"NUM_MIPS" : nMips
			},

			uniforms: {
				"blurTexture1": { value: null },
				"blurTexture2": { value: null },
				"blurTexture3": { value: null },
				"blurTexture4": { value: null },
				"blurTexture5": { value: null },
				"dirtTexture": { value: null },
				"bloomStrength" : { value: 1.0 },
				"bloomFactors" : { value: null },
				"bloomTintColors" : { value: null },
				"bloomRadius" : { value: 0.0 }
			},

			vertexShader:
				"varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader:
				"varying vec2 vUv;\
				uniform sampler2D blurTexture1;\
				uniform sampler2D blurTexture2;\
				uniform sampler2D blurTexture3;\
				uniform sampler2D blurTexture4;\
				uniform sampler2D blurTexture5;\
				uniform sampler2D dirtTexture;\
				uniform float bloomStrength;\
				uniform float bloomRadius;\
				uniform float bloomFactors[NUM_MIPS];\
				uniform vec3 bloomTintColors[NUM_MIPS];\
				\
				float lerpBloomFactor(const in float factor) { \
					float mirrorFactor = 1.2 - factor;\
					return mix(factor, mirrorFactor, bloomRadius);\
				}\
				\
				void main() {\
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \
					 							 lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \
												 lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \
												 lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \
												 lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\
				}"
		} );
	}

} );

THREE.UnrealBloomPass.BlurDirectionX = new THREE.Vector2( 1.0, 0.0 );
THREE.UnrealBloomPass.BlurDirectionY = new THREE.Vector2( 0.0, 1.0 );

/**
 * @author mrdoob / http://www.mrdoob.com
 *
 * Simple test shader
 */

THREE.BasicShader = {

	uniforms: {},

	vertexShader: [

		"void main() {",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"void main() {",

			"gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]
 * - based on Nvidia example
 * http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass
 */

THREE.BleachBypassShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"opacity":  { value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 base = texture2D( tDiffuse, vUv );",

			"vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );",
			"float lum = dot( lumCoeff, base.rgb );",
			"vec3 blend = vec3( lum );",

			"float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );",

			"vec3 result1 = 2.0 * base.rgb * blend;",
			"vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );",

			"vec3 newColor = mix( result1, result2, L );",

			"float A2 = opacity * base.a;",
			"vec3 mixRGB = A2 * newColor.rgb;",
			"mixRGB += ( ( 1.0 - A2 ) * base.rgb );",

			"gl_FragColor = vec4( mixRGB, base.a );",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Blend two textures
 */

THREE.BlendShader = {

	uniforms: {

		"tDiffuse1": { value: null },
		"tDiffuse2": { value: null },
		"mixRatio":  { value: 0.5 },
		"opacity":   { value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float opacity;",
		"uniform float mixRatio;",

		"uniform sampler2D tDiffuse1;",
		"uniform sampler2D tDiffuse2;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel1 = texture2D( tDiffuse1, vUv );",
			"vec4 texel2 = texture2D( tDiffuse2, vUv );",
			"gl_FragColor = opacity * mix( texel1, texel2, mixRatio );",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Depth-of-field shader with bokeh
 * ported from GLSL shader by Martins Upitis
 * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html
 */

THREE.BokehShader = {

	uniforms: {

		"tColor":   { value: null },
		"tDepth":   { value: null },
		"focus":    { value: 1.0 },
		"aspect":   { value: 1.0 },
		"aperture": { value: 0.025 },
		"maxblur":  { value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"varying vec2 vUv;",

		"uniform sampler2D tColor;",
		"uniform sampler2D tDepth;",

		"uniform float maxblur;",  // max blur amount
		"uniform float aperture;", // aperture - bigger values for shallower depth of field

		"uniform float focus;",
		"uniform float aspect;",

		"void main() {",

			"vec2 aspectcorrect = vec2( 1.0, aspect );",

			"vec4 depth1 = texture2D( tDepth, vUv );",

			"float factor = depth1.x - focus;",

			"vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );",

			"vec2 dofblur9 = dofblur * 0.9;",
			"vec2 dofblur7 = dofblur * 0.7;",
			"vec2 dofblur4 = dofblur * 0.4;",

			"vec4 col = vec4( 0.0 );",

			"col += texture2D( tColor, vUv.xy );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );",

			"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",

			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );",

			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );",

			"gl_FragColor = col / 41.0;",
			"gl_FragColor.a = 1.0;",

		"}"

	].join( "\n" )

};

/**
 * @author zz85 / https://github.com/zz85 | twitter.com/blurspline
 *
 * Depth-of-field shader with bokeh
 * ported from GLSL shader by Martins Upitis
 * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)
 *
 * Requires #define RINGS and SAMPLES integers
 */



THREE.BokehShader = {

	uniforms: {

		"textureWidth":  { value: 1.0 },
		"textureHeight":  { value: 1.0 },

		"focalDepth":   { value: 1.0 },
		"focalLength":   { value: 24.0 },
		"fstop": { value: 0.9 },

		"tColor":   { value: null },
		"tDepth":   { value: null },

		"maxblur":  { value: 1.0 },

		"showFocus":   { value: 0 },
		"manualdof":   { value: 0 },
		"vignetting":   { value: 0 },
		"depthblur":   { value: 0 },

		"threshold":  { value: 0.5 },
		"gain":  { value: 2.0 },
		"bias":  { value: 0.5 },
		"fringe":  { value: 0.7 },

		"znear":  { value: 0.1 },
		"zfar":  { value: 100 },

		"noise":  { value: 1 },
		"dithering":  { value: 0.0001 },
		"pentagon": { value: 0 },

		"shaderFocus":  { value: 1 },
		"focusCoords":  { value: new THREE.Vector2() },


	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"#include <common>",

		"varying vec2 vUv;",

		"uniform sampler2D tColor;",
		"uniform sampler2D tDepth;",
		"uniform float textureWidth;",
		"uniform float textureHeight;",

		"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below",
		"uniform float focalLength; //focal length in mm",
		"uniform float fstop; //f-stop value",
		"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)",

		"/*",
		"make sure that these two values are the same for your camera, otherwise distances will be wrong.",
		"*/",

		"uniform float znear; // camera clipping start",
		"uniform float zfar; // camera clipping end",

		"//------------------------------------------",
		"//user variables",

		"const int samples = SAMPLES; //samples on the first ring",
		"const int rings = RINGS; //ring count",

		"const int maxringsamples = rings * samples;",

		"uniform bool manualdof; // manual dof calculation",
		"float ndofstart = 1.0; // near dof blur start",
		"float ndofdist = 2.0; // near dof blur falloff distance",
		"float fdofstart = 1.0; // far dof blur start",
		"float fdofdist = 3.0; // far dof blur falloff distance",

		"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)",

		"uniform bool vignetting; // use optical lens vignetting",

		"float vignout = 1.3; // vignetting outer border",
		"float vignin = 0.0; // vignetting inner border",
		"float vignfade = 22.0; // f-stops till vignete fades",

		"uniform bool shaderFocus;",
		"// disable if you use external focalDepth value",

		"uniform vec2 focusCoords;",
		"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)",
		"// if center of screen use vec2(0.5, 0.5);",

		"uniform float maxblur;",
		"//clamp value of max blur (0.0 = no blur, 1.0 default)",

		"uniform float threshold; // highlight threshold;",
		"uniform float gain; // highlight gain;",

		"uniform float bias; // bokeh edge bias",
		"uniform float fringe; // bokeh chromatic aberration / fringing",

		"uniform bool noise; //use noise instead of pattern for sample dithering",

		"uniform float dithering;",

		"uniform bool depthblur; // blur the depth buffer",
		"float dbsize = 1.25; // depth blur size",

		"/*",
		"next part is experimental",
		"not looking good with small sample and ring count",
		"looks okay starting from samples = 4, rings = 4",
		"*/",

		"uniform bool pentagon; //use pentagon as bokeh shape?",
		"float feather = 0.4; //pentagon shape feather",

		"//------------------------------------------",

		"float penta(vec2 coords) {",
			"//pentagonal shape",
			"float scale = float(rings) - 1.3;",
			"vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);",
			"vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);",
			"vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);",
			"vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);",
			"vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);",
			"vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);",

			"vec4  one = vec4( 1.0 );",

			"vec4 P = vec4((coords),vec2(scale, scale));",

			"vec4 dist = vec4(0.0);",
			"float inorout = -4.0;",

			"dist.x = dot( P, HS0 );",
			"dist.y = dot( P, HS1 );",
			"dist.z = dot( P, HS2 );",
			"dist.w = dot( P, HS3 );",

			"dist = smoothstep( -feather, feather, dist );",

			"inorout += dot( dist, one );",

			"dist.x = dot( P, HS4 );",
			"dist.y = HS5.w - abs( P.z );",

			"dist = smoothstep( -feather, feather, dist );",
			"inorout += dist.x;",

			"return clamp( inorout, 0.0, 1.0 );",
		"}",

		"float bdepth(vec2 coords) {",
			"// Depth buffer blur",
			"float d = 0.0;",
			"float kernel[9];",
			"vec2 offset[9];",

			"vec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;",

			"offset[0] = vec2(-wh.x,-wh.y);",
			"offset[1] = vec2( 0.0, -wh.y);",
			"offset[2] = vec2( wh.x -wh.y);",

			"offset[3] = vec2(-wh.x,  0.0);",
			"offset[4] = vec2( 0.0,   0.0);",
			"offset[5] = vec2( wh.x,  0.0);",

			"offset[6] = vec2(-wh.x, wh.y);",
			"offset[7] = vec2( 0.0,  wh.y);",
			"offset[8] = vec2( wh.x, wh.y);",

			"kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;",
			"kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;",
			"kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;",


			"for( int i=0; i<9; i++ ) {",
				"float tmp = texture2D(tDepth, coords + offset[i]).r;",
				"d += tmp * kernel[i];",
			"}",

			"return d;",
		"}",


		"vec3 color(vec2 coords,float blur) {",
			"//processing the sample",

			"vec3 col = vec3(0.0);",
			"vec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);",

			"col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;",
			"col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;",
			"col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;",

			"vec3 lumcoeff = vec3(0.299,0.587,0.114);",
			"float lum = dot(col.rgb, lumcoeff);",
			"float thresh = max((lum-threshold)*gain, 0.0);",
			"return col+mix(vec3(0.0),col,thresh*blur);",
		"}",

		"vec3 debugFocus(vec3 col, float blur, float depth) {",
			"float edge = 0.002*depth; //distance based edge smoothing",
			"float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);",
			"float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);",

			"col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);",
			"col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);",

			"return col;",
		"}",

		"float linearize(float depth) {",
			"return -zfar * znear / (depth * (zfar - znear) - zfar);",
		"}",


		"float vignette() {",
			"float dist = distance(vUv.xy, vec2(0.5,0.5));",
			"dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);",
			"return clamp(dist,0.0,1.0);",
		"}",

		"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {",
			"float rings2 = float(rings);",
			"float step = PI*2.0 / float(ringsamples);",
			"float pw = cos(j*step)*i;",
			"float ph = sin(j*step)*i;",
			"float p = 1.0;",
			"if (pentagon) {",
				"p = penta(vec2(pw,ph));",
			"}",
			"col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;",
			"return 1.0 * mix(1.0, i /rings2, bias) * p;",
		"}",

		"void main() {",
			"//scene depth calculation",

			"float depth = linearize(texture2D(tDepth,vUv.xy).x);",

			"// Blur depth?",
			"if (depthblur) {",
				"depth = linearize(bdepth(vUv.xy));",
			"}",

			"//focal plane calculation",

			"float fDepth = focalDepth;",

			"if (shaderFocus) {",

				"fDepth = linearize(texture2D(tDepth,focusCoords).x);",

			"}",

			"// dof blur factor calculation",

			"float blur = 0.0;",

			"if (manualdof) {",
				"float a = depth-fDepth; // Focal plane",
				"float b = (a-fdofstart)/fdofdist; // Far DoF",
				"float c = (-a-ndofstart)/ndofdist; // Near Dof",
				"blur = (a>0.0) ? b : c;",
			"} else {",
				"float f = focalLength; // focal length in mm",
				"float d = fDepth*1000.0; // focal plane in mm",
				"float o = depth*1000.0; // depth in mm",

				"float a = (o*f)/(o-f);",
				"float b = (d*f)/(d-f);",
				"float c = (d-f)/(d*fstop*CoC);",

				"blur = abs(a-b)*c;",
			"}",

			"blur = clamp(blur,0.0,1.0);",

			"// calculation of pattern for dithering",

			"vec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;",

			"// getting blur x and y step factor",

			"float w = (1.0/textureWidth)*blur*maxblur+noise.x;",
			"float h = (1.0/textureHeight)*blur*maxblur+noise.y;",

			"// calculation of final color",

			"vec3 col = vec3(0.0);",

			"if(blur < 0.05) {",
				"//some optimization thingy",
				"col = texture2D(tColor, vUv.xy).rgb;",
			"} else {",
				"col = texture2D(tColor, vUv.xy).rgb;",
				"float s = 1.0;",
				"int ringsamples;",

				"for (int i = 1; i <= rings; i++) {",
					"/*unboxstart*/",
					"ringsamples = i * samples;",

					"for (int j = 0 ; j < maxringsamples ; j++) {",
						"if (j >= ringsamples) break;",
						"s += gather(float(i), float(j), ringsamples, col, w, h, blur);",
					"}",
					"/*unboxend*/",
				"}",

				"col /= s; //divide by sample count",
			"}",

			"if (showFocus) {",
				"col = debugFocus(col, blur, depth);",
			"}",

			"if (vignetting) {",
				"col *= vignette();",
			"}",

			"gl_FragColor.rgb = col;",
			"gl_FragColor.a = 1.0;",
		"} "

	].join( "\n" )

};

/**
 * @author tapio / http://tapio.github.com/
 *
 * Brightness and contrast adjustment
 * https://github.com/evanw/glfx.js
 * brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)
 * contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)
 */

THREE.BrightnessContrastShader = {

	uniforms: {

		"tDiffuse":   { value: null },
		"brightness": { value: 0 },
		"contrast":   { value: 0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float brightness;",
		"uniform float contrast;",

		"varying vec2 vUv;",

		"void main() {",

			"gl_FragColor = texture2D( tDiffuse, vUv );",

			"gl_FragColor.rgb += brightness;",

			"if (contrast > 0.0) {",
				"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;",
			"} else {",
				"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;",
			"}",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Color correction
 */

THREE.ColorCorrectionShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"powRGB":   { value: new THREE.Vector3( 2, 2, 2 ) },
		"mulRGB":   { value: new THREE.Vector3( 1, 1, 1 ) },
		"addRGB":   { value: new THREE.Vector3( 0, 0, 0 ) }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform vec3 powRGB;",
		"uniform vec3 mulRGB;",
		"uniform vec3 addRGB;",

		"varying vec2 vUv;",

		"void main() {",

			"gl_FragColor = texture2D( tDiffuse, vUv );",
			"gl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Colorify shader
 */

THREE.ColorifyShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"color":    { value: new THREE.Color( 0xffffff ) }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform vec3 color;",
		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",

			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",
			"float v = dot( texel.xyz, luma );",

			"gl_FragColor = vec4( v * color, texel.w );",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Convolution shader
 * ported from o3d sample to WebGL / GLSL
 * http://o3d.googlecode.com/svn/trunk/samples/convolution.html
 */

THREE.ConvolutionShader = {

	defines: {

		"KERNEL_SIZE_FLOAT": "25.0",
		"KERNEL_SIZE_INT": "25",

	},

	uniforms: {

		"tDiffuse":        { value: null },
		"uImageIncrement": { value: new THREE.Vector2( 0.001953125, 0.0 ) },
		"cKernel":         { value: [] }

	},

	vertexShader: [

		"uniform vec2 uImageIncrement;",

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float cKernel[ KERNEL_SIZE_INT ];",

		"uniform sampler2D tDiffuse;",
		"uniform vec2 uImageIncrement;",

		"varying vec2 vUv;",

		"void main() {",

			"vec2 imageCoord = vUv;",
			"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );",

			"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {",

				"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];",
				"imageCoord += uImageIncrement;",

			"}",

			"gl_FragColor = sum;",

		"}"


	].join( "\n" ),

	buildKernel: function ( sigma ) {

		// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.

		function gauss( x, sigma ) {

			return Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );

		}

		var i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;

		if ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;
		halfWidth = ( kernelSize - 1 ) * 0.5;

		values = new Array( kernelSize );
		sum = 0.0;
		for ( i = 0; i < kernelSize; ++ i ) {

			values[ i ] = gauss( i - halfWidth, sigma );
			sum += values[ i ];

		}

		// normalize the kernel

		for ( i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;

		return values;

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

THREE.CopyShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"opacity":  { value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			"gl_FragColor = opacity * texel;",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Depth-of-field shader using mipmaps
 * - from Matt Handley @applmak
 * - requires power-of-2 sized render target with enabled mipmaps
 */

THREE.DOFMipMapShader = {

	uniforms: {

		"tColor":   { value: null },
		"tDepth":   { value: null },
		"focus":    { value: 1.0 },
		"maxblur":  { value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float focus;",
		"uniform float maxblur;",

		"uniform sampler2D tColor;",
		"uniform sampler2D tDepth;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 depth = texture2D( tDepth, vUv );",

			"float factor = depth.x - focus;",

			"vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );",

			"gl_FragColor = col;",
			"gl_FragColor.a = 1.0;",

		"}"

	].join( "\n" )

};

/**
 * @author felixturner / http://airtight.cc/
 *
 * RGB Shift Shader
 * Shifts red and blue channels from center in opposite directions
 * Ported from http://kriss.cx/tom/2009/05/rgb-shift/
 * by Tom Butterworth / http://kriss.cx/tom/
 *
 * amount: shift distance (1 is width of input)
 * angle: shift angle in radians
 */

THREE.DigitalGlitch = {

	uniforms: {

		"tDiffuse":		{ value: null },//diffuse texture
		"tDisp":		{ value: null },//displacement texture for digital glitch squares
		"byp":			{ value: 0 },//apply the glitch ?
		"amount":		{ value: 0.08 },
		"angle":		{ value: 0.02 },
		"seed":			{ value: 0.02 },
		"seed_x":		{ value: 0.02 },//-1,1
		"seed_y":		{ value: 0.02 },//-1,1
		"distortion_x":	{ value: 0.5 },
		"distortion_y":	{ value: 0.6 },
		"col_s":		{ value: 0.05 }
	},

	vertexShader: [

		"varying vec2 vUv;",
		"void main() {",
			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
		"}"
	].join( "\n" ),

	fragmentShader: [
		"uniform int byp;",//should we apply the glitch ?
		
		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tDisp;",
		
		"uniform float amount;",
		"uniform float angle;",
		"uniform float seed;",
		"uniform float seed_x;",
		"uniform float seed_y;",
		"uniform float distortion_x;",
		"uniform float distortion_y;",
		"uniform float col_s;",
			
		"varying vec2 vUv;",
		
		
		"float rand(vec2 co){",
			"return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);",
		"}",
				
		"void main() {",
			"if(byp<1) {",
				"vec2 p = vUv;",
				"float xs = floor(gl_FragCoord.x / 0.5);",
				"float ys = floor(gl_FragCoord.y / 0.5);",
				//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch
				"vec4 normal = texture2D (tDisp, p*seed*seed);",
				"if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {",
					"if(seed_x>0.){",
						"p.y = 1. - (p.y + distortion_y);",
					"}",
					"else {",
						"p.y = distortion_y;",
					"}",
				"}",
				"if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {",
					"if(seed_y>0.){",
						"p.x=distortion_x;",
					"}",
					"else {",
						"p.x = 1. - (p.x + distortion_x);",
					"}",
				"}",
				"p.x+=normal.x*seed_x*(seed/5.);",
				"p.y+=normal.y*seed_y*(seed/5.);",
				//base from RGB shift shader
				"vec2 offset = amount * vec2( cos(angle), sin(angle));",
				"vec4 cr = texture2D(tDiffuse, p + offset);",
				"vec4 cga = texture2D(tDiffuse, p);",
				"vec4 cb = texture2D(tDiffuse, p - offset);",
				"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",
				//add noise
				"vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);",
				"gl_FragColor = gl_FragColor+ snow;",
			"}",
			"else {",
				"gl_FragColor=texture2D (tDiffuse, vUv);",
			"}",
		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Dot screen shader
 * based on glfx.js sepia shader
 * https://github.com/evanw/glfx.js
 */

THREE.DotScreenShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"tSize":    { value: new THREE.Vector2( 256, 256 ) },
		"center":   { value: new THREE.Vector2( 0.5, 0.5 ) },
		"angle":    { value: 1.57 },
		"scale":    { value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform vec2 center;",
		"uniform float angle;",
		"uniform float scale;",
		"uniform vec2 tSize;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"float pattern() {",

			"float s = sin( angle ), c = cos( angle );",

			"vec2 tex = vUv * tSize - center;",
			"vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;",

			"return ( sin( point.x ) * sin( point.y ) ) * 4.0;",

		"}",

		"void main() {",

			"vec4 color = texture2D( tDiffuse, vUv );",

			"float average = ( color.r + color.g + color.b ) / 3.0;",

			"gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );",

		"}"

	].join( "\n" )

};

/**
 * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog
 *
 * Edge Detection Shader using Frei-Chen filter
 * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector
 *
 * aspect: vec2 of (1/width, 1/height)
 */

THREE.EdgeShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"aspect":    { value: new THREE.Vector2( 512, 512 ) },
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"varying vec2 vUv;",

		"uniform vec2 aspect;",

		"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);",


		"mat3 G[9];",

		// hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45

		"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );",
		"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );",
		"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );",
		"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );",
		"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );",
		"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );",
		"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );",
		"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );",
		"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );",

		"void main(void)",
		"{",

			"G[0] = g0,",
			"G[1] = g1,",
			"G[2] = g2,",
			"G[3] = g3,",
			"G[4] = g4,",
			"G[5] = g5,",
			"G[6] = g6,",
			"G[7] = g7,",
			"G[8] = g8;",

			"mat3 I;",
			"float cnv[9];",
			"vec3 sample;",

			/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */
			"for (float i=0.0; i<3.0; i++) {",
				"for (float j=0.0; j<3.0; j++) {",
					"sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;",
					"I[int(i)][int(j)] = length(sample);",
				"}",
			"}",

			/* calculate the convolution values for all the masks */
			"for (int i=0; i<9; i++) {",
				"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);",
				"cnv[i] = dp3 * dp3;",
			"}",

			"float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);",
			"float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);",

			"gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);",
		"}",

	].join( "\n" )
};

/**
 * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog
 *
 * Edge Detection Shader using Sobel filter
 * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector
 *
 * aspect: vec2 of (1/width, 1/height)
 */

THREE.EdgeShader2 = {

	uniforms: {

		"tDiffuse": { value: null },
		"aspect":    { value: new THREE.Vector2( 512, 512 ) },
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"varying vec2 vUv;",
		"uniform vec2 aspect;",


		"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);",

		"mat3 G[2];",

		"const mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );",
		"const mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );",


		"void main(void)",
		"{",
			"mat3 I;",
			"float cnv[2];",
			"vec3 sample;",

			"G[0] = g0;",
			"G[1] = g1;",

			/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */
			"for (float i=0.0; i<3.0; i++)",
			"for (float j=0.0; j<3.0; j++) {",
				"sample = texture2D( tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;",
				"I[int(i)][int(j)] = length(sample);",
			"}",

			/* calculate the convolution values for all the masks */
			"for (int i=0; i<2; i++) {",
				"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);",
				"cnv[i] = dp3 * dp3; ",
			"}",

			"gl_FragColor = vec4(0.5 * sqrt(cnv[0]*cnv[0]+cnv[1]*cnv[1]));",
		"} ",

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author davidedc / http://www.sketchpatch.net/
 *
 * NVIDIA FXAA by Timothy Lottes
 * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html
 * - WebGL port by @supereggbert
 * http://www.glge.org/demos/fxaa/
 */

THREE.FXAAShader = {

	uniforms: {

		"tDiffuse":   { value: null },
		"resolution": { value: new THREE.Vector2( 1 / 1024, 1 / 512 ) }

	},

	vertexShader: [

		"void main() {",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform vec2 resolution;",

		"#define FXAA_REDUCE_MIN   (1.0/128.0)",
		"#define FXAA_REDUCE_MUL   (1.0/8.0)",
		"#define FXAA_SPAN_MAX     8.0",

		"void main() {",

			"vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;",
			"vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;",
			"vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;",
			"vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;",
			"vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );",
			"vec3 rgbM  = rgbaM.xyz;",
			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",

			"float lumaNW = dot( rgbNW, luma );",
			"float lumaNE = dot( rgbNE, luma );",
			"float lumaSW = dot( rgbSW, luma );",
			"float lumaSE = dot( rgbSE, luma );",
			"float lumaM  = dot( rgbM,  luma );",
			"float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );",
			"float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );",

			"vec2 dir;",
			"dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));",
			"dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));",

			"float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );",

			"float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );",
			"dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),",
				  "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),",
						"dir * rcpDirMin)) * resolution;",
			"vec4 rgbA = (1.0/2.0) * (",
        	"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (1.0/3.0 - 0.5)) +",
			"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (2.0/3.0 - 0.5)));",
    		"vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (",
			"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (0.0/3.0 - 0.5)) +",
      		"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (3.0/3.0 - 0.5)));",
    		"float lumaB = dot(rgbB, vec4(luma, 0.0));",

			"if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {",

				"gl_FragColor = rgbA;",

			"} else {",
				"gl_FragColor = rgbB;",

			"}",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Film grain & scanlines shader
 *
 * - ported from HLSL to WebGL / GLSL
 * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html
 *
 * Screen Space Static Postprocessor
 *
 * Produces an analogue noise overlay similar to a film grain / TV static
 *
 * Original implementation and noise algorithm
 * Pat 'Hawthorne' Shearon
 *
 * Optimized scanlines + noise version with intensity scaling
 * Georg 'Leviathan' Steinrohder
 *
 * This version is provided under a Creative Commons Attribution 3.0 License
 * http://creativecommons.org/licenses/by/3.0/
 */

THREE.FilmShader = {

	uniforms: {

		"tDiffuse":   { value: null },
		"time":       { value: 0.0 },
		"nIntensity": { value: 0.5 },
		"sIntensity": { value: 0.05 },
		"sCount":     { value: 4096 },
		"grayscale":  { value: 1 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"#include <common>",
		
		// control parameter
		"uniform float time;",

		"uniform bool grayscale;",

		// noise effect intensity value (0 = no effect, 1 = full effect)
		"uniform float nIntensity;",

		// scanlines effect intensity value (0 = no effect, 1 = full effect)
		"uniform float sIntensity;",

		// scanlines effect count value (0 = no effect, 4096 = full effect)
		"uniform float sCount;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			// sample the source
			"vec4 cTextureScreen = texture2D( tDiffuse, vUv );",

			// make some noise
			"float dx = rand( vUv + time );",

			// add noise
			"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );",

			// get us a sine and cosine
			"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );",

			// add scanlines
			"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;",

			// interpolate between source and result by intensity
			"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );",

			// convert to grayscale if desired
			"if( grayscale ) {",

				"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );",

			"}",

			"gl_FragColor =  vec4( cResult, cTextureScreen.a );",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Focus shader
 * based on PaintEffect postprocess from ro.me
 * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js
 */

THREE.FocusShader = {

	uniforms : {

		"tDiffuse":       { value: null },
		"screenWidth":    { value: 1024 },
		"screenHeight":   { value: 1024 },
		"sampleDistance": { value: 0.94 },
		"waveFactor":     { value: 0.00125 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float screenWidth;",
		"uniform float screenHeight;",
		"uniform float sampleDistance;",
		"uniform float waveFactor;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 color, org, tmp, add;",
			"float sample_dist, f;",
			"vec2 vin;",
			"vec2 uv = vUv;",

			"add = color = org = texture2D( tDiffuse, uv );",

			"vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );",
			"sample_dist = dot( vin, vin ) * 2.0;",

			"f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;",

			"vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );",
			"color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );",

			"gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );",

		"}"


	].join( "\n" )
};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Based on Nvidia Cg tutorial
 */

THREE.FresnelShader = {

	uniforms: {

		"mRefractionRatio": { value: 1.02 },
		"mFresnelBias": { value: 0.1 },
		"mFresnelPower": { value: 2.0 },
		"mFresnelScale": { value: 1.0 },
		"tCube": { value: null }

	},

	vertexShader: [

		"uniform float mRefractionRatio;",
		"uniform float mFresnelBias;",
		"uniform float mFresnelScale;",
		"uniform float mFresnelPower;",

		"varying vec3 vReflect;",
		"varying vec3 vRefract[3];",
		"varying float vReflectionFactor;",

		"void main() {",

			"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
			"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",

			"vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );",

			"vec3 I = worldPosition.xyz - cameraPosition;",

			"vReflect = reflect( I, worldNormal );",
			"vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );",
			"vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );",
			"vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );",
			"vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );",

			"gl_Position = projectionMatrix * mvPosition;",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform samplerCube tCube;",

		"varying vec3 vReflect;",
		"varying vec3 vRefract[3];",
		"varying float vReflectionFactor;",

		"void main() {",

			"vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",
			"vec4 refractedColor = vec4( 1.0 );",

			"refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;",
			"refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;",
			"refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;",

			"gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );",

		"}"

	].join( "\n" )

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * Gamma Correction Shader
 * http://en.wikipedia.org/wiki/gamma_correction
 */

THREE.GammaCorrectionShader = {

	uniforms: {

		"tDiffuse": { value: null },

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );",

			"gl_FragColor = LinearToGamma( tex, float( GAMMA_FACTOR ) );",

		"}"

	].join( "\n" )

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Two pass Gaussian blur filter (horizontal and vertical blur shaders)
 * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
 *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 */

THREE.HorizontalBlurShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"h":        { value: 1.0 / 512.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float h;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 sum = vec4( 0.0 );",

			"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;",

			"gl_FragColor = sum;",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 * - "r" parameter control where "focused" horizontal line lies
 */

THREE.HorizontalTiltShiftShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"h":        { value: 1.0 / 512.0 },
		"r":        { value: 0.35 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float h;",
		"uniform float r;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 sum = vec4( 0.0 );",

			"float hh = h * abs( r - vUv.y );",

			"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;",

			"gl_FragColor = sum;",

		"}"

	].join( "\n" )

};

/**
 * @author tapio / http://tapio.github.com/
 *
 * Hue and saturation adjustment
 * https://github.com/evanw/glfx.js
 * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.
 * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)
 */

THREE.HueSaturationShader = {

	uniforms: {

		"tDiffuse":   { value: null },
		"hue":        { value: 0 },
		"saturation": { value: 0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float hue;",
		"uniform float saturation;",

		"varying vec2 vUv;",

		"void main() {",

			"gl_FragColor = texture2D( tDiffuse, vUv );",

			// hue
			"float angle = hue * 3.14159265;",
			"float s = sin(angle), c = cos(angle);",
			"vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;",
			"float len = length(gl_FragColor.rgb);",
			"gl_FragColor.rgb = vec3(",
				"dot(gl_FragColor.rgb, weights.xyz),",
				"dot(gl_FragColor.rgb, weights.zxy),",
				"dot(gl_FragColor.rgb, weights.yzx)",
			");",

			// saturation
			"float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;",
			"if (saturation > 0.0) {",
				"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));",
			"} else {",
				"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);",
			"}",

		"}"

	].join( "\n" )

};

/**
 * @author felixturner / http://airtight.cc/
 *
 * Kaleidoscope Shader
 * Radial reflection around center point
 * Ported from: http://pixelshaders.com/editor/
 * by Toby Schachman / http://tobyschachman.com/
 *
 * sides: number of reflections
 * angle: initial angle in radians
 */

THREE.KaleidoShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"sides":    { value: 6.0 },
		"angle":    { value: 0.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float sides;",
		"uniform float angle;",
		
		"varying vec2 vUv;",

		"void main() {",

			"vec2 p = vUv - 0.5;",
			"float r = length(p);",
			"float a = atan(p.y, p.x) + angle;",
			"float tau = 2. * 3.1416 ;",
			"a = mod(a, tau/sides);",
			"a = abs(a - tau/sides/2.) ;",
			"p = r * vec2(cos(a), sin(a));",
			"vec4 color = texture2D(tDiffuse, p + 0.5);",
			"gl_FragColor = color;",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Luminosity
 * http://en.wikipedia.org/wiki/Luminosity
 */

THREE.LuminosityShader = {

	uniforms: {

		"tDiffuse": { value: null }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",

			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",

			"float v = dot( texel.xyz, luma );",

			"gl_FragColor = vec4( v, v, v, texel.w );",

		"}"

	].join( "\n" )

};

/**
 * @author felixturner / http://airtight.cc/
 *
 * Mirror Shader
 * Copies half the input to the other half
 *
 * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)
 */

THREE.MirrorShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"side":     { value: 1 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform int side;",
		
		"varying vec2 vUv;",

		"void main() {",

			"vec2 p = vUv;",
			"if (side == 0){",
				"if (p.x > 0.5) p.x = 1.0 - p.x;",
			"}else if (side == 1){",
				"if (p.x < 0.5) p.x = 1.0 - p.x;",
			"}else if (side == 2){",
				"if (p.y < 0.5) p.y = 1.0 - p.y;",
			"}else if (side == 3){",
				"if (p.y > 0.5) p.y = 1.0 - p.y;",
			"} ",
			"vec4 color = texture2D(tDiffuse, p);",
			"gl_FragColor = color;",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Normal map shader
 * - compute normals from heightmap
 */

THREE.NormalMapShader = {

	uniforms: {

		"heightMap":  { value: null },
		"resolution": { value: new THREE.Vector2( 512, 512 ) },
		"scale":      { value: new THREE.Vector2( 1, 1 ) },
		"height":     { value: 0.05 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float height;",
		"uniform vec2 resolution;",
		"uniform sampler2D heightMap;",

		"varying vec2 vUv;",

		"void main() {",

			"float val = texture2D( heightMap, vUv ).x;",

			"float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;",
			"float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;",

			"gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );",

		"}"

	].join( "\n" )

};

// Author: Aleksandr Albert
// Website: www.routter.co.tt

// Description: A deep water ocean shader set
// based on an implementation of a Tessendorf Waves
// originally presented by David Li ( www.david.li/waves )

// The general method is to apply shaders to simulation Framebuffers
// and then sample these framebuffers when rendering the ocean mesh

// The set uses 7 shaders:

// -- Simulation shaders
// [1] ocean_sim_vertex         -> Vertex shader used to set up a 2x2 simulation plane centered at (0,0)
// [2] ocean_subtransform       -> Fragment shader used to subtransform the mesh (generates the displacement map)
// [3] ocean_initial_spectrum   -> Fragment shader used to set intitial wave frequency at a texel coordinate
// [4] ocean_phase              -> Fragment shader used to set wave phase at a texel coordinate
// [5] ocean_spectrum           -> Fragment shader used to set current wave frequency at a texel coordinate
// [6] ocean_normal             -> Fragment shader used to set face normals at a texel coordinate

// -- Rendering Shader
// [7] ocean_main               -> Vertex and Fragment shader used to create the final render


THREE.ShaderLib[ 'ocean_sim_vertex' ] = {
	vertexShader: [
		'varying vec2 vUV;',

		'void main (void) {',
			'vUV = position.xy * 0.5 + 0.5;',
			'gl_Position = vec4(position, 1.0 );',
		'}'
	].join( '\n' )
};
THREE.ShaderLib[ 'ocean_subtransform' ] = {
	uniforms: {
		"u_input": { value: null },
		"u_transformSize": { value: 512.0 },
		"u_subtransformSize": { value: 250.0 }
	},
	fragmentShader: [
		//GPU FFT using a Stockham formulation

		'precision highp float;',
		'#include <common>',

		'uniform sampler2D u_input;',
		'uniform float u_transformSize;',
		'uniform float u_subtransformSize;',

		'varying vec2 vUV;',

		'vec2 multiplyComplex (vec2 a, vec2 b) {',
			'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);',
		'}',

		'void main (void) {',
			'#ifdef HORIZONTAL',
			'float index = vUV.x * u_transformSize - 0.5;',
			'#else',
			'float index = vUV.y * u_transformSize - 0.5;',
			'#endif',

			'float evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);',

			//transform two complex sequences simultaneously
			'#ifdef HORIZONTAL',
			'vec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;',
			'vec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;',
			'#else',
			'vec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;',
			'vec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;',
			'#endif',

			'float twiddleArgument = -2.0 * PI * (index / u_subtransformSize);',
			'vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));',

			'vec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);',
			'vec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);',

			'gl_FragColor = vec4(outputA, outputB);',
		'}'
	].join( '\n' )
};
THREE.ShaderLib[ 'ocean_initial_spectrum' ] = {
	uniforms: {
		"u_wind": { value: new THREE.Vector2( 10.0, 10.0 ) },
		"u_resolution": { value: 512.0 },
		"u_size": { value: 250.0 },
	},
	fragmentShader: [
		'precision highp float;',
		'#include <common>',

		'const float G = 9.81;',
		'const float KM = 370.0;',
		'const float CM = 0.23;',

		'uniform vec2 u_wind;',
		'uniform float u_resolution;',
		'uniform float u_size;',

		'float omega (float k) {',
			'return sqrt(G * k * (1.0 + pow2(k / KM)));',
		'}',

		'float tanh (float x) {',
			'return (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));',
		'}',

		'void main (void) {',
			'vec2 coordinates = gl_FragCoord.xy - 0.5;',

			'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',
			'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',

			'vec2 K = (2.0 * PI * vec2(n, m)) / u_size;',
			'float k = length(K);',

			'float l_wind = length(u_wind);',

			'float Omega = 0.84;',
			'float kp = G * pow2(Omega / l_wind);',

			'float c = omega(k) / k;',
			'float cp = omega(kp) / kp;',

			'float Lpm = exp(-1.25 * pow2(kp / k));',
			'float gamma = 1.7;',
			'float sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));',
			'float Gamma = exp(-pow2(sqrt(k / kp) - 1.0) / 2.0 * pow2(sigma));',
			'float Jp = pow(gamma, Gamma);',
			'float Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));',
			'float alphap = 0.006 * sqrt(Omega);',
			'float Bl = 0.5 * alphap * cp / c * Fp;',

			'float z0 = 0.000037 * pow2(l_wind) / G * pow(l_wind / cp, 0.9);',
			'float uStar = 0.41 * l_wind / log(10.0 / z0);',
			'float alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));',
			'float Fm = exp(-0.25 * pow2(k / KM - 1.0));',
			'float Bh = 0.5 * alpham * CM / c * Fm * Lpm;',

			'float a0 = log(2.0) / 4.0;',
			'float am = 0.13 * uStar / CM;',
			'float Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));',

			'float cosPhi = dot(normalize(u_wind), normalize(K));',

			'float S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));',

			'float dk = 2.0 * PI / u_size;',
			'float h = sqrt(S / 2.0) * dk;',

			'if (K.x == 0.0 && K.y == 0.0) {',
				'h = 0.0;', //no DC term
			'}',
			'gl_FragColor = vec4(h, 0.0, 0.0, 0.0);',
		'}'
	].join( '\n' )
};
THREE.ShaderLib[ 'ocean_phase' ] = {
	uniforms: {
		"u_phases": { value: null },
		"u_deltaTime": { value: null },
		"u_resolution": { value: null },
		"u_size": { value: null },
	},
	fragmentShader: [
		'precision highp float;',
		'#include <common>',

		'const float G = 9.81;',
		'const float KM = 370.0;',

		'varying vec2 vUV;',

		'uniform sampler2D u_phases;',
		'uniform float u_deltaTime;',
		'uniform float u_resolution;',
		'uniform float u_size;',

		'float omega (float k) {',
			'return sqrt(G * k * (1.0 + k * k / KM * KM));',
		'}',

		'void main (void) {',
			'float deltaTime = 1.0 / 60.0;',
			'vec2 coordinates = gl_FragCoord.xy - 0.5;',
			'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',
			'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',
			'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;',

			'float phase = texture2D(u_phases, vUV).r;',
			'float deltaPhase = omega(length(waveVector)) * u_deltaTime;',
			'phase = mod(phase + deltaPhase, 2.0 * PI);',

			'gl_FragColor = vec4(phase, 0.0, 0.0, 0.0);',
		'}'
	].join( '\n' )
};
THREE.ShaderLib[ 'ocean_spectrum' ] = {
	uniforms: {
		"u_size": { value: null },
		"u_resolution": { value: null },
		"u_choppiness": { value: null },
		"u_phases": { value: null },
		"u_initialSpectrum": { value: null },
	},
	fragmentShader: [
		'precision highp float;',
		'#include <common>',

		'const float G = 9.81;',
		'const float KM = 370.0;',

		'varying vec2 vUV;',

		'uniform float u_size;',
		'uniform float u_resolution;',
		'uniform float u_choppiness;',
		'uniform sampler2D u_phases;',
		'uniform sampler2D u_initialSpectrum;',

		'vec2 multiplyComplex (vec2 a, vec2 b) {',
			'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);',
		'}',

		'vec2 multiplyByI (vec2 z) {',
			'return vec2(-z[1], z[0]);',
		'}',

		'float omega (float k) {',
			'return sqrt(G * k * (1.0 + k * k / KM * KM));',
		'}',

		'void main (void) {',
			'vec2 coordinates = gl_FragCoord.xy - 0.5;',
			'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',
			'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',
			'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;',

			'float phase = texture2D(u_phases, vUV).r;',
			'vec2 phaseVector = vec2(cos(phase), sin(phase));',

			'vec2 h0 = texture2D(u_initialSpectrum, vUV).rg;',
			'vec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;',
			'h0Star.y *= -1.0;',

			'vec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));',

			'vec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;',
			'vec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;',

			//no DC term
			'if (waveVector.x == 0.0 && waveVector.y == 0.0) {',
				'h = vec2(0.0);',
				'hX = vec2(0.0);',
				'hZ = vec2(0.0);',
			'}',

			'gl_FragColor = vec4(hX + multiplyByI(h), hZ);',
		'}'
	].join( '\n' )
};
THREE.ShaderLib[ 'ocean_normals' ] = {
	uniforms: {
		"u_displacementMap": { value: null },
		"u_resolution": { value: null },
		"u_size": { value: null },
	},
	fragmentShader: [
		'precision highp float;',

		'varying vec2 vUV;',

		'uniform sampler2D u_displacementMap;',
		'uniform float u_resolution;',
		'uniform float u_size;',

		'void main (void) {',
			'float texel = 1.0 / u_resolution;',
			'float texelSize = u_size / u_resolution;',

			'vec3 center = texture2D(u_displacementMap, vUV).rgb;',
			'vec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;',
			'vec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;',
			'vec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;',
			'vec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;',

			'vec3 topRight = cross(right, top);',
			'vec3 topLeft = cross(top, left);',
			'vec3 bottomLeft = cross(left, bottom);',
			'vec3 bottomRight = cross(bottom, right);',

			'gl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);',
		'}'
	].join( '\n' )
};
THREE.ShaderLib[ 'ocean_main' ] = {
	uniforms: {
		"u_displacementMap": { value: null },
		"u_normalMap": { value: null },
		"u_geometrySize": { value: null },
		"u_size": { value: null },
		"u_projectionMatrix": { value: null },
		"u_viewMatrix": { value: null },
		"u_cameraPosition": { value: null },
		"u_skyColor": { value: null },
		"u_oceanColor": { value: null },
		"u_sunDirection": { value: null },
		"u_exposure": { value: null },
	},
	vertexShader: [
		'precision highp float;',

		'varying vec3 vPos;',
		'varying vec2 vUV;',

		'uniform mat4 u_projectionMatrix;',
		'uniform mat4 u_viewMatrix;',
		'uniform float u_size;',
		'uniform float u_geometrySize;',
		'uniform sampler2D u_displacementMap;',

		'void main (void) {',
			'vec3 newPos = position + texture2D(u_displacementMap, uv).rgb * (u_geometrySize / u_size);',
			'vPos = newPos;',
			'vUV = uv;',
			'gl_Position = u_projectionMatrix * u_viewMatrix * vec4(newPos, 1.0);',
		'}'
	].join( '\n' ),
	fragmentShader: [
		'precision highp float;',

		'varying vec3 vPos;',
		'varying vec2 vUV;',

		'uniform sampler2D u_displacementMap;',
		'uniform sampler2D u_normalMap;',
		'uniform vec3 u_cameraPosition;',
		'uniform vec3 u_oceanColor;',
		'uniform vec3 u_skyColor;',
		'uniform vec3 u_sunDirection;',
		'uniform float u_exposure;',

		'vec3 hdr (vec3 color, float exposure) {',
			'return 1.0 - exp(-color * exposure);',
		'}',

		'void main (void) {',
			'vec3 normal = texture2D(u_normalMap, vUV).rgb;',

			'vec3 view = normalize(u_cameraPosition - vPos);',
			'float fresnel = 0.02 + 0.98 * pow(1.0 - dot(normal, view), 5.0);',
			'vec3 sky = fresnel * u_skyColor;',

			'float diffuse = clamp(dot(normal, normalize(u_sunDirection)), 0.0, 1.0);',
			'vec3 water = (1.0 - fresnel) * u_oceanColor * u_skyColor * diffuse;',

			'vec3 color = sky + water;',

			'gl_FragColor = vec4(hdr(color, u_exposure), 1.0);',
		'}'
	].join( '\n' )
};

// Parallax Occlusion shaders from
//    http://sunandblackcat.com/tipFullView.php?topicid=28
// No tangent-space transforms logic based on
//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html

THREE.ParallaxShader = {
	// Ordered from fastest to best quality.
	modes: {
		none:  'NO_PARALLAX',
		basic: 'USE_BASIC_PARALLAX',
		steep: 'USE_STEEP_PARALLAX',
		occlusion: 'USE_OCLUSION_PARALLAX', // a.k.a. POM
		relief: 'USE_RELIEF_PARALLAX',
	},

	uniforms: {
		"bumpMap": { value: null },
		"map": { value: null },
		"parallaxScale": { value: null },
		"parallaxMinLayers": { value: null },
		"parallaxMaxLayers": { value: null }
	},

	vertexShader: [
		"varying vec2 vUv;",
		"varying vec3 vViewPosition;",
		"varying vec3 vNormal;",

		"void main() {",

			"vUv = uv;",
			"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
			"vViewPosition = -mvPosition.xyz;",
			"vNormal = normalize( normalMatrix * normal );",
			"gl_Position = projectionMatrix * mvPosition;",

		"}"

  ].join( "\n" ),

	fragmentShader: [
		"uniform sampler2D bumpMap;",
		"uniform sampler2D map;",

		"uniform float parallaxScale;",
		"uniform float parallaxMinLayers;",
		"uniform float parallaxMaxLayers;",

		"varying vec2 vUv;",
		"varying vec3 vViewPosition;",
		"varying vec3 vNormal;",

		"#ifdef USE_BASIC_PARALLAX",

			"vec2 parallaxMap( in vec3 V ) {",

				"float initialHeight = texture2D( bumpMap, vUv ).r;",

				// No Offset Limitting: messy, floating output at grazing angles.
				//"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;",

				// Offset Limiting
				"vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;",
				"return vUv - texCoordOffset;",

			"}",

		"#else",

			"vec2 parallaxMap( in vec3 V ) {",

				// Determine number of layers from angle between V and N
				"float numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );",

				"float layerHeight = 1.0 / numLayers;",
				"float currentLayerHeight = 0.0;",
				// Shift of texture coordinates for each iteration
				"vec2 dtex = parallaxScale * V.xy / V.z / numLayers;",

				"vec2 currentTextureCoords = vUv;",

				"float heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",

				// while ( heightFromTexture > currentLayerHeight )
				// Infinite loops are not well supported. Do a "large" finite
				// loop, but not too large, as it slows down some compilers.
				"for ( int i = 0; i < 30; i += 1 ) {",
					"if ( heightFromTexture <= currentLayerHeight ) {",
						"break;",
					"}",
					"currentLayerHeight += layerHeight;",
					// Shift texture coordinates along vector V
					"currentTextureCoords -= dtex;",
					"heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
				"}",

				"#ifdef USE_STEEP_PARALLAX",

					"return currentTextureCoords;",

				"#elif defined( USE_RELIEF_PARALLAX )",

					"vec2 deltaTexCoord = dtex / 2.0;",
					"float deltaHeight = layerHeight / 2.0;",

					// Return to the mid point of previous layer
					"currentTextureCoords += deltaTexCoord;",
					"currentLayerHeight -= deltaHeight;",

					// Binary search to increase precision of Steep Parallax Mapping
					"const int numSearches = 5;",
					"for ( int i = 0; i < numSearches; i += 1 ) {",

						"deltaTexCoord /= 2.0;",
						"deltaHeight /= 2.0;",
						"heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
						// Shift along or against vector V
						"if( heightFromTexture > currentLayerHeight ) {", // Below the surface

							"currentTextureCoords -= deltaTexCoord;",
							"currentLayerHeight += deltaHeight;",

						"} else {", // above the surface

							"currentTextureCoords += deltaTexCoord;",
							"currentLayerHeight -= deltaHeight;",

						"}",

					"}",
					"return currentTextureCoords;",

				"#elif defined( USE_OCLUSION_PARALLAX )",

					"vec2 prevTCoords = currentTextureCoords + dtex;",

					// Heights for linear interpolation
					"float nextH = heightFromTexture - currentLayerHeight;",
					"float prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;",

					// Proportions for linear interpolation
					"float weight = nextH / ( nextH - prevH );",

					// Interpolation of texture coordinates
					"return prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );",

				"#else", // NO_PARALLAX

					"return vUv;",

				"#endif",

			"}",
		"#endif",

		"vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {",

 			"vec2 texDx = dFdx( vUv );",
			"vec2 texDy = dFdy( vUv );",

			"vec3 vSigmaX = dFdx( surfPosition );",
			"vec3 vSigmaY = dFdy( surfPosition );",
			"vec3 vR1 = cross( vSigmaY, surfNormal );",
			"vec3 vR2 = cross( surfNormal, vSigmaX );",
			"float fDet = dot( vSigmaX, vR1 );",

			"vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );",
			"vec3 vProjVtex;",
			"vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;",
			"vProjVtex.z = dot( surfNormal, viewPosition );",

			"return parallaxMap( vProjVtex );",
		"}",

		"void main() {",

			"vec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );",
			"gl_FragColor = texture2D( map, mapUv );",

		"}",

  ].join( "\n" )

};

/**
 * @author felixturner / http://airtight.cc/
 *
 * RGB Shift Shader
 * Shifts red and blue channels from center in opposite directions
 * Ported from http://kriss.cx/tom/2009/05/rgb-shift/
 * by Tom Butterworth / http://kriss.cx/tom/
 *
 * amount: shift distance (1 is width of input)
 * angle: shift angle in radians
 */

THREE.RGBShiftShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"amount":   { value: 0.005 },
		"angle":    { value: 0.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float amount;",
		"uniform float angle;",

		"varying vec2 vUv;",

		"void main() {",

			"vec2 offset = amount * vec2( cos(angle), sin(angle));",
			"vec4 cr = texture2D(tDiffuse, vUv + offset);",
			"vec4 cga = texture2D(tDiffuse, vUv);",
			"vec4 cb = texture2D(tDiffuse, vUv - offset);",
			"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",

		"}"

	].join( "\n" )

};

/**
 * @author mpk / http://polko.me/
 *
 * WebGL port of Subpixel Morphological Antialiasing (SMAA) v2.8
 * Preset: SMAA 1x Medium (with color edge detection)
 * https://github.com/iryoku/smaa/releases/tag/v2.8
 */

THREE.SMAAShader = [ {

	defines: {

		"SMAA_THRESHOLD": "0.1"

	},

	uniforms: {

		"tDiffuse":		{ value: null },
		"resolution":	{ value: new THREE.Vector2( 1 / 1024, 1 / 512 ) }

	},

	vertexShader: [

		"uniform vec2 resolution;",

		"varying vec2 vUv;",
		"varying vec4 vOffset[ 3 ];",

		"void SMAAEdgeDetectionVS( vec2 texcoord ) {",
			"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );", // WebGL port note: Changed sign in W component
			"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );", // WebGL port note: Changed sign in W component
			"vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );", // WebGL port note: Changed sign in W component
		"}",

		"void main() {",

			"vUv = uv;",

			"SMAAEdgeDetectionVS( vUv );",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",
		"varying vec4 vOffset[ 3 ];",

		"vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {",
			"vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );",

			// Calculate color deltas:
			"vec4 delta;",
			"vec3 C = texture2D( colorTex, texcoord ).rgb;",

			"vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;",
			"vec3 t = abs( C - Cleft );",
			"delta.x = max( max( t.r, t.g ), t.b );",

			"vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;",
			"t = abs( C - Ctop );",
			"delta.y = max( max( t.r, t.g ), t.b );",

			// We do the usual threshold:
			"vec2 edges = step( threshold, delta.xy );",

			// Then discard if there is no edge:
			"if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )",
				"discard;",

			// Calculate right and bottom deltas:
			"vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;",
			"t = abs( C - Cright );",
			"delta.z = max( max( t.r, t.g ), t.b );",

			"vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;",
			"t = abs( C - Cbottom );",
			"delta.w = max( max( t.r, t.g ), t.b );",

			// Calculate the maximum delta in the direct neighborhood:
			"float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );",

			// Calculate left-left and top-top deltas:
			"vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;",
			"t = abs( C - Cleftleft );",
			"delta.z = max( max( t.r, t.g ), t.b );",

			"vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;",
			"t = abs( C - Ctoptop );",
			"delta.w = max( max( t.r, t.g ), t.b );",

			// Calculate the final maximum delta:
			"maxDelta = max( max( maxDelta, delta.z ), delta.w );",

			// Local contrast adaptation in action:
			"edges.xy *= step( 0.5 * maxDelta, delta.xy );",

			"return vec4( edges, 0.0, 0.0 );",
		"}",

		"void main() {",

			"gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );",

		"}"

	].join("\n")

}, {

	defines: {

		"SMAA_MAX_SEARCH_STEPS":		"8",
		"SMAA_AREATEX_MAX_DISTANCE":	"16",
		"SMAA_AREATEX_PIXEL_SIZE":		"( 1.0 / vec2( 160.0, 560.0 ) )",
		"SMAA_AREATEX_SUBTEX_SIZE":		"( 1.0 / 7.0 )"

	},

	uniforms: {

		"tDiffuse":		{ value: null },
		"tArea":		{ value: null },
		"tSearch":		{ value: null },
		"resolution":	{ value: new THREE.Vector2( 1 / 1024, 1 / 512 ) }

	},

	vertexShader: [

		"uniform vec2 resolution;",

		"varying vec2 vUv;",
		"varying vec4 vOffset[ 3 ];",
		"varying vec2 vPixcoord;",

		"void SMAABlendingWeightCalculationVS( vec2 texcoord ) {",
			"vPixcoord = texcoord / resolution;",

			// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):
			"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );", // WebGL port note: Changed sign in Y and W components
			"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );", // WebGL port note: Changed sign in Y and W components

			// And these for the searches, they indicate the ends of the loops:
			"vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );",

		"}",

		"void main() {",

			"vUv = uv;",

			"SMAABlendingWeightCalculationVS( vUv );",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )",

		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tArea;",
		"uniform sampler2D tSearch;",
		"uniform vec2 resolution;",

		"varying vec2 vUv;",
		"varying vec4 vOffset[3];",
		"varying vec2 vPixcoord;",

		"vec2 round( vec2 x ) {",
			"return sign( x ) * floor( abs( x ) + 0.5 );",
		"}",

		"float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {",
			// Not required if searchTex accesses are set to point:
			// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);
			// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +
			//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;
			"e.r = bias + e.r * scale;",
			"return 255.0 * texture2D( searchTex, e, 0.0 ).r;",
		"}",

		"float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
			/**
			* @PSEUDO_GATHER4
			* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to
			* sample between edge, thus fetching four edges in a row.
			* Sampling with different offsets in each direction allows to disambiguate
			* which edges are active from the four fetched ones.
			*/
			"vec2 e = vec2( 0.0, 1.0 );",

			"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
				"e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
				"texcoord -= vec2( 2.0, 0.0 ) * resolution;",
				"if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;",
			"}",

			// We correct the previous (-0.25, -0.125) offset we applied:
			"texcoord.x += 0.25 * resolution.x;",

			// The searches are bias by 1, so adjust the coords accordingly:
			"texcoord.x += resolution.x;",

			// Disambiguate the length added by the last step:
			"texcoord.x += 2.0 * resolution.x;", // Undo last step
			"texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);",

			"return texcoord.x;",
		"}",

		"float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
			"vec2 e = vec2( 0.0, 1.0 );",

			"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
				"e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
				"texcoord += vec2( 2.0, 0.0 ) * resolution;",
				"if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;",
			"}",

			"texcoord.x -= 0.25 * resolution.x;",
			"texcoord.x -= resolution.x;",
			"texcoord.x -= 2.0 * resolution.x;",
			"texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );",

			"return texcoord.x;",
		"}",

		"float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
			"vec2 e = vec2( 1.0, 0.0 );",

			"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
				"e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
				"texcoord += vec2( 0.0, 2.0 ) * resolution;", // WebGL port note: Changed sign
				"if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;",
			"}",

			"texcoord.y -= 0.25 * resolution.y;", // WebGL port note: Changed sign
			"texcoord.y -= resolution.y;", // WebGL port note: Changed sign
			"texcoord.y -= 2.0 * resolution.y;", // WebGL port note: Changed sign
			"texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );", // WebGL port note: Changed sign

			"return texcoord.y;",
		"}",

		"float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
			"vec2 e = vec2( 1.0, 0.0 );",

			"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
				"e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
				"texcoord -= vec2( 0.0, 2.0 ) * resolution;", // WebGL port note: Changed sign
				"if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;",
			"}",

			"texcoord.y += 0.25 * resolution.y;", // WebGL port note: Changed sign
			"texcoord.y += resolution.y;", // WebGL port note: Changed sign
			"texcoord.y += 2.0 * resolution.y;", // WebGL port note: Changed sign
			"texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );", // WebGL port note: Changed sign

			"return texcoord.y;",
		"}",

		"vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {",
			// Rounding prevents precision errors of bilinear filtering:
			"vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;",

			// We do a scale and bias for mapping to texel space:
			"texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );",

			// Move to proper place, according to the subpixel offset:
			"texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;",

			"return texture2D( areaTex, texcoord, 0.0 ).rg;",
		"}",

		"vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {",
			"vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );",

			"vec2 e = texture2D( edgesTex, texcoord ).rg;",

			"if ( e.g > 0.0 ) {", // Edge at north
				"vec2 d;",

				// Find the distance to the left:
				"vec2 coords;",
				"coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );",
				"coords.y = offset[ 1 ].y;", // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)
				"d.x = coords.x;",

				// Now fetch the left crossing edges, two at a time using bilinear
				// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
				// discern what value each edge has:
				"float e1 = texture2D( edgesTex, coords, 0.0 ).r;",

				// Find the distance to the right:
				"coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );",
				"d.y = coords.x;",

				// We want the distances to be in pixel units (doing this here allow to
				// better interleave arithmetic and memory accesses):
				"d = d / resolution.x - pixcoord.x;",

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				"vec2 sqrt_d = sqrt( abs( d ) );",

				// Fetch the right crossing edges:
				"coords.y -= 1.0 * resolution.y;", // WebGL port note: Added
				"float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;",

				// Ok, we know how this pattern looks like, now it is time for getting
				// the actual area:
				"weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );",
			"}",

			"if ( e.r > 0.0 ) {", // Edge at west
				"vec2 d;",

				// Find the distance to the top:
				"vec2 coords;",

				"coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );",
				"coords.x = offset[ 0 ].x;", // offset[1].x = texcoord.x - 0.25 * resolution.x;
				"d.x = coords.y;",

				// Fetch the top crossing edges:
				"float e1 = texture2D( edgesTex, coords, 0.0 ).g;",

				// Find the distance to the bottom:
				"coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );",
				"d.y = coords.y;",

				// We want the distances to be in pixel units:
				"d = d / resolution.y - pixcoord.y;",

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				"vec2 sqrt_d = sqrt( abs( d ) );",

				// Fetch the bottom crossing edges:
				"coords.y -= 1.0 * resolution.y;", // WebGL port note: Added
				"float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;",

				// Get the area for this direction:
				"weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );",
			"}",

			"return weights;",
		"}",

		"void main() {",

			"gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );",

		"}"

	].join("\n")

}, {

	uniforms: {

		"tDiffuse":		{ value: null },
		"tColor":		{ value: null },
		"resolution":	{ value: new THREE.Vector2( 1 / 1024, 1 / 512 ) }

	},

	vertexShader: [

		"uniform vec2 resolution;",

		"varying vec2 vUv;",
		"varying vec4 vOffset[ 2 ];",

		"void SMAANeighborhoodBlendingVS( vec2 texcoord ) {",
			"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );", // WebGL port note: Changed sign in W component
			"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );", // WebGL port note: Changed sign in W component
		"}",

		"void main() {",

			"vUv = uv;",

			"SMAANeighborhoodBlendingVS( vUv );",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tColor;",
		"uniform vec2 resolution;",

		"varying vec2 vUv;",
		"varying vec4 vOffset[ 2 ];",

		"vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {",
			// Fetch the blending weights for current pixel:
			"vec4 a;",
			"a.xz = texture2D( blendTex, texcoord ).xz;",
			"a.y = texture2D( blendTex, offset[ 1 ].zw ).g;",
			"a.w = texture2D( blendTex, offset[ 1 ].xy ).a;",

			// Is there any blending weight with a value greater than 0.0?
			"if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {",
				"return texture2D( colorTex, texcoord, 0.0 );",
			"} else {",
				// Up to 4 lines can be crossing a pixel (one through each edge). We
				// favor blending by choosing the line with the maximum weight for each
				// direction:
				"vec2 offset;",
				"offset.x = a.a > a.b ? a.a : -a.b;", // left vs. right
				"offset.y = a.g > a.r ? -a.g : a.r;", // top vs. bottom // WebGL port note: Changed signs

				// Then we go in the direction that has the maximum weight:
				"if ( abs( offset.x ) > abs( offset.y )) {", // horizontal vs. vertical
					"offset.y = 0.0;",
				"} else {",
					"offset.x = 0.0;",
				"}",

				// Fetch the opposite color and lerp by hand:
				"vec4 C = texture2D( colorTex, texcoord, 0.0 );",
				"texcoord += sign( offset ) * resolution;",
				"vec4 Cop = texture2D( colorTex, texcoord, 0.0 );",
				"float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );",

				// WebGL port note: Added gamma correction
				"C.xyz = pow(C.xyz, vec3(2.2));",
				"Cop.xyz = pow(Cop.xyz, vec3(2.2));",
				"vec4 mixed = mix(C, Cop, s);",
				"mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));",

				"return mixed;",
			"}",
		"}",

		"void main() {",

			"gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );",

		"}"

	].join("\n")

} ];

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Screen-space ambient occlusion shader
 * - ported from
 *   SSAO GLSL shader v1.2
 *   assembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)
 *   original technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)
 * - modifications
 * - modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)
 * - refactoring and optimizations
 */

THREE.SSAOShader = {

	uniforms: {

		"tDiffuse":     { value: null },
		"tDepth":       { value: null },
		"size":         { value: new THREE.Vector2( 512, 512 ) },
		"cameraNear":   { value: 1 },
		"cameraFar":    { value: 100 },
		"onlyAO":       { value: 0 },
		"aoClamp":      { value: 0.5 },
		"lumInfluence": { value: 0.5 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float cameraNear;",
		"uniform float cameraFar;",

		"uniform bool onlyAO;",      // use only ambient occlusion pass?

		"uniform vec2 size;",        // texture width, height
		"uniform float aoClamp;",    // depth clamp - reduces haloing at screen edges

		"uniform float lumInfluence;",  // how much luminance affects occlusion

		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tDepth;",

		"varying vec2 vUv;",

		// "#define PI 3.14159265",
		"#define DL 2.399963229728653",  // PI * ( 3.0 - sqrt( 5.0 ) )
		"#define EULER 2.718281828459045",

		// user variables

		"const int samples = 8;",     // ao sample count
		"const float radius = 5.0;",  // ao radius

		"const bool useNoise = false;",      // use noise instead of pattern for sample dithering
		"const float noiseAmount = 0.0003;", // dithering amount

		"const float diffArea = 0.4;",   // self-shadowing reduction
		"const float gDisplace = 0.4;",  // gauss bell center


		// RGBA depth

		"#include <packing>",

		// generating noise / pattern texture for dithering

		"vec2 rand( const vec2 coord ) {",

			"vec2 noise;",

			"if ( useNoise ) {",

				"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );",
				"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );",

				"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );",

			"} else {",

				"float ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );",
				"float gg = fract( coord.t * ( size.y / 2.0 ) );",

				"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;",

			"}",

			"return ( noise * 2.0  - 1.0 ) * noiseAmount;",

		"}",

		"float readDepth( const in vec2 coord ) {",

			"float cameraFarPlusNear = cameraFar + cameraNear;",
			"float cameraFarMinusNear = cameraFar - cameraNear;",
			"float cameraCoef = 2.0 * cameraNear;",

			// "return ( 2.0 * cameraNear ) / ( cameraFar + cameraNear - unpackDepth( texture2D( tDepth, coord ) ) * ( cameraFar - cameraNear ) );",
			"return cameraCoef / ( cameraFarPlusNear - unpackRGBAToDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );",


		"}",

		"float compareDepths( const in float depth1, const in float depth2, inout int far ) {",

			"float garea = 2.0;",                         // gauss bell width
			"float diff = ( depth1 - depth2 ) * 100.0;",  // depth difference (0-100)

			// reduce left bell width to avoid self-shadowing

			"if ( diff < gDisplace ) {",

				"garea = diffArea;",

			"} else {",

				"far = 1;",

			"}",

			"float dd = diff - gDisplace;",
			"float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );",
			"return gauss;",

		"}",

		"float calcAO( float depth, float dw, float dh ) {",

			"float dd = radius - depth * radius;",
			"vec2 vv = vec2( dw, dh );",

			"vec2 coord1 = vUv + dd * vv;",
			"vec2 coord2 = vUv - dd * vv;",

			"float temp1 = 0.0;",
			"float temp2 = 0.0;",

			"int far = 0;",
			"temp1 = compareDepths( depth, readDepth( coord1 ), far );",

			// DEPTH EXTRAPOLATION

			"if ( far > 0 ) {",

				"temp2 = compareDepths( readDepth( coord2 ), depth, far );",
				"temp1 += ( 1.0 - temp1 ) * temp2;",

			"}",

			"return temp1;",

		"}",

		"void main() {",

			"vec2 noise = rand( vUv );",
			"float depth = readDepth( vUv );",

			"float tt = clamp( depth, aoClamp, 1.0 );",

			"float w = ( 1.0 / size.x )  / tt + ( noise.x * ( 1.0 - noise.x ) );",
			"float h = ( 1.0 / size.y ) / tt + ( noise.y * ( 1.0 - noise.y ) );",

			"float ao = 0.0;",

			"float dz = 1.0 / float( samples );",
			"float z = 1.0 - dz / 2.0;",
			"float l = 0.0;",

			"for ( int i = 0; i <= samples; i ++ ) {",

				"float r = sqrt( 1.0 - z );",

				"float pw = cos( l ) * r;",
				"float ph = sin( l ) * r;",
				"ao += calcAO( depth, pw * w, ph * h );",
				"z = z - dz;",
				"l = l + DL;",

			"}",

			"ao /= float( samples );",
			"ao = 1.0 - ao;",

			"vec3 color = texture2D( tDiffuse, vUv ).rgb;",

			"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );",
			"float lum = dot( color.rgb, lumcoeff );",
			"vec3 luminance = vec3( lum );",

			"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );",  // mix( color * ao, white, luminance )

			"if ( onlyAO ) {",

				"final = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );",  // ambient occlusion only

			"}",

			"gl_FragColor = vec4( final, 1.0 );",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Sepia tone shader
 * based on glfx.js sepia shader
 * https://github.com/evanw/glfx.js
 */

THREE.SepiaShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"amount":   { value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float amount;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 color = texture2D( tDiffuse, vUv );",
			"vec3 c = color.rgb;",

			"color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );",
			"color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );",
			"color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );",

			"gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );",

		"}"

	].join( "\n" )

};

/**
 * @author flimshaw / http://charliehoey.com
 *
 * Technicolor Shader
 * Simulates the look of the two-strip technicolor process popular in early 20th century films.
 * More historical info here: http://www.widescreenmuseum.com/oldcolor/technicolor1.htm
 * Demo here: http://charliehoey.com/technicolor_shader/shader_test.html
 */

THREE.TechnicolorShader = {

	uniforms: {

		"tDiffuse": { value: null },

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"varying vec2 vUv;",

		"void main() {",

			"vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );",
			"vec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);",

			"gl_FragColor = newTex;",

		"}"

	].join( "\n" )

};

/**
 * @author miibond
 *
 * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf
 */

THREE.ToneMapShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"averageLuminance":  { value: 1.0 },
		"luminanceMap":  { value: null },
		"maxLuminance":  { value: 16.0 },
		"middleGrey":  { value: 0.6 }
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"uniform float middleGrey;",
		"uniform float maxLuminance;",
		"#ifdef ADAPTED_LUMINANCE",
			"uniform sampler2D luminanceMap;",
		"#else",
			"uniform float averageLuminance;",
		"#endif",
		
		"const vec3 LUM_CONVERT = vec3(0.299, 0.587, 0.114);",

		"vec3 ToneMap( vec3 vColor ) {",
			"#ifdef ADAPTED_LUMINANCE",
				// Get the calculated average luminance 
				"float fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;",
			"#else",
				"float fLumAvg = averageLuminance;",
			"#endif",
			
			// Calculate the luminance of the current pixel
			"float fLumPixel = dot(vColor, LUM_CONVERT);",

			// Apply the modified operator (Eq. 4)
			"float fLumScaled = (fLumPixel * middleGrey) / fLumAvg;",

			"float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);",
			"return fLumCompressed * vColor;",
		"}",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			
			"gl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );",

		"}"

	].join( "\n" )

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Triangle blur shader
 * based on glfx.js triangle blur shader
 * https://github.com/evanw/glfx.js
 *
 * A basic blur filter, which convolves the image with a
 * pyramid filter. The pyramid filter is separable and is applied as two
 * perpendicular triangle filters.
 */

THREE.TriangleBlurShader = {

	uniforms : {

		"texture": { value: null },
		"delta":   { value: new THREE.Vector2( 1, 1 ) }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"#include <common>",

		"#define ITERATIONS 10.0",

		"uniform sampler2D texture;",
		"uniform vec2 delta;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 color = vec4( 0.0 );",

			"float total = 0.0;",

			// randomize the lookup values to hide the fixed number of samples

			"float offset = rand( vUv );",

			"for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {",

				"float percent = ( t + offset - 0.5 ) / ITERATIONS;",
				"float weight = 1.0 - abs( percent );",

				"color += texture2D( texture, vUv + delta * percent ) * weight;",
				"total += weight;",

			"}",

			"gl_FragColor = color / total;",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Unpack RGBA depth shader
 * - show RGBA encoded depth as monochrome color
 */

THREE.UnpackDepthRGBAShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"opacity":  { value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"#include <packing>",

		"void main() {",

			"float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );",
			"gl_FragColor = opacity * vec4( vec3( depth ), 1.0 );",

		"}"

	].join( "\n" )

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Two pass Gaussian blur filter (horizontal and vertical blur shaders)
 * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
 *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 */

THREE.VerticalBlurShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"v":        { value: 1.0 / 512.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float v;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 sum = vec4( 0.0 );",

			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;",

			"gl_FragColor = sum;",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 * - "r" parameter control where "focused" horizontal line lies
 */

THREE.VerticalTiltShiftShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"v":        { value: 1.0 / 512.0 },
		"r":        { value: 0.35 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float v;",
		"uniform float r;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 sum = vec4( 0.0 );",

			"float vv = v * abs( r - vUv.y );",

			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;",

			"gl_FragColor = sum;",

		"}"

	].join( "\n" )

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Vignette shader
 * based on PaintEffect postprocess from ro.me
 * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js
 */

THREE.VignetteShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"offset":   { value: 1.0 },
		"darkness": { value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float offset;",
		"uniform float darkness;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			// Eskil's vignette

			"vec4 texel = texture2D( tDiffuse, vUv );",
			"vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );",
			"gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );",

			/*
			// alternative version from glfx.js
			// this one makes more "dusty" look (as opposed to "burned")

			"vec4 color = texture2D( tDiffuse, vUv );",
			"float dist = distance( vUv, vec2( 0.5 ) );",
			"color.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );",
			"gl_FragColor = color;",
			*/

		"}"

	].join( "\n" )

};

/*! Hammer.JS - v2.0.6 - 2016-02-25
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the  license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.allow = true; // used by Input.TouchMouse to disable mouse events
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
        if (!this.pressed || !this.allow) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        // when we're in a touch event, so  block all upcoming mouse events
        // most mobile browser also emit mouseevents, right after touchstart
        if (isTouch) {
            this.mouse.allow = false;
        } else if (isMouse && !this.mouse.allow) {
            return;
        }

        // reset the allowMouse when we're done
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.6';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    each(manager.options.cssProps, function(value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (typeof define === 'function' && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = dat || {};

/** @namespace */
dat.gui = dat.gui || {};

/** @namespace */
dat.utils = dat.utils || {};

/** @namespace */
dat.controllers = dat.controllers || {};

/** @namespace */
dat.dom = dat.dom || {};

/** @namespace */
dat.color = dat.color || {};

dat.utils.css = (function () {
  return {
    load: function (url, doc) {
      doc = doc || document;
      var link = doc.createElement('link');
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.href = url;
      doc.getElementsByTagName('head')[0].appendChild(link);
    },
    inject: function(css, doc) {
      doc = doc || document;
      var injected = document.createElement('style');
      injected.type = 'text/css';
      injected.innerHTML = css;
      doc.getElementsByTagName('head')[0].appendChild(injected);
    }
  }
})();


dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      if (!obj) return;

      if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.controllers.Controller = (function (common) {

  /**
   * @class An "abstract" class that represents a given property of an object.
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var Controller = function(object, property) {

    this.initialValue = object[property];

    /**
     * Those who extend this class will put their DOM elements in here.
     * @type {DOMElement}
     */
    this.domElement = document.createElement('div');

    /**
     * The object to manipulate
     * @type {Object}
     */
    this.object = object;

    /**
     * The name of the property to manipulate
     * @type {String}
     */
    this.property = property;

    /**
     * The function to be called on change.
     * @type {Function}
     * @ignore
     */
    this.__onChange = undefined;

    /**
     * The function to be called on finishing change.
     * @type {Function}
     * @ignore
     */
    this.__onFinishChange = undefined;

  };

  common.extend(

      Controller.prototype,

      /** @lends dat.controllers.Controller.prototype */
      {

        /**
         * Specify that a function fire every time someone changes the value with
         * this Controller.
         *
         * @param {Function} fnc This function will be called whenever the value
         * is modified via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onChange: function(fnc) {
          this.__onChange = fnc;
          return this;
        },

        /**
         * Specify that a function fire every time someone "finishes" changing
         * the value wih this Controller. Useful for values that change
         * incrementally like numbers or strings.
         *
         * @param {Function} fnc This function will be called whenever
         * someone "finishes" changing the value via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onFinishChange: function(fnc) {
          this.__onFinishChange = fnc;
          return this;
        },

        /**
         * Change the value of <code>object[property]</code>
         *
         * @param {Object} newValue The new value of <code>object[property]</code>
         */
        setValue: function(newValue) {
          this.object[this.property] = newValue;
          if (this.__onChange) {
            this.__onChange.call(this, newValue);
          }
          this.updateDisplay();
          return this;
        },

        /**
         * Gets the value of <code>object[property]</code>
         *
         * @returns {Object} The current value of <code>object[property]</code>
         */
        getValue: function() {
          return this.object[this.property];
        },

        /**
         * Refreshes the visual display of a Controller in order to keep sync
         * with the object's current value.
         * @returns {dat.controllers.Controller} this
         */
        updateDisplay: function() {
          return this;
        },

        /**
         * @returns {Boolean} true if the value has deviated from initialValue
         */
        isModified: function() {
          return this.initialValue !== this.getValue()
        }

      }

  );

  return Controller;


})(dat.utils.common);


dat.dom.dom = (function (common) {

  var EVENT_MAP = {
    'HTMLEvents': ['change'],
    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],
    'KeyboardEvents': ['keydown']
  };

  var EVENT_MAP_INV = {};
  common.each(EVENT_MAP, function(v, k) {
    common.each(v, function(e) {
      EVENT_MAP_INV[e] = k;
    });
  });

  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

  function cssValueToPixels(val) {

    if (val === '0' || common.isUndefined(val)) return 0;

    var match = val.match(CSS_VALUE_PIXELS);

    if (!common.isNull(match)) {
      return parseFloat(match[1]);
    }

    // TODO ...ems? %?

    return 0;

  }

  /**
   * @namespace
   * @member dat.dom
   */
  var dom = {

    /**
     * 
     * @param elem
     * @param selectable
     */
    makeSelectable: function(elem, selectable) {

      if (elem === undefined || elem.style === undefined) return;

      elem.onselectstart = selectable ? function() {
        return false;
      } : function() {
      };

      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
      elem.unselectable = selectable ? 'on' : 'off';

    },

    /**
     *
     * @param elem
     * @param horizontal
     * @param vertical
     */
    makeFullscreen: function(elem, horizontal, vertical) {

      if (common.isUndefined(horizontal)) horizontal = true;
      if (common.isUndefined(vertical)) vertical = true;

      elem.style.position = 'absolute';

      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }
      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }

    },

    /**
     *
     * @param elem
     * @param eventType
     * @param params
     */
    fakeEvent: function(elem, eventType, params, aux) {
      params = params || {};
      var className = EVENT_MAP_INV[eventType];
      if (!className) {
        throw new Error('Event type ' + eventType + ' not supported.');
      }
      var evt = document.createEvent(className);
      switch (className) {
        case 'MouseEvents':
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false,
              params.cancelable || true, window, params.clickCount || 1,
              0, //screen X
              0, //screen Y
              clientX, //client X
              clientY, //client Y
              false, false, false, false, 0, null);
          break;
        case 'KeyboardEvents':
          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
          common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false,
              params.cancelable, window,
              params.ctrlKey, params.altKey,
              params.shiftKey, params.metaKey,
              params.keyCode, params.charCode);
          break;
        default:
          evt.initEvent(eventType, params.bubbles || false,
              params.cancelable || true);
          break;
      }
      common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    bind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.addEventListener)
        elem.addEventListener(event, func, bool);
      else if (elem.attachEvent)
        elem.attachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    unbind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.removeEventListener)
        elem.removeEventListener(event, func, bool);
      else if (elem.detachEvent)
        elem.detachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    addClass: function(elem, className) {
      if (elem.className === undefined) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);
        if (classes.indexOf(className) == -1) {
          classes.push(className);
          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
        }
      }
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    removeClass: function(elem, className) {
      if (className) {
        if (elem.className === undefined) {
          // elem.className = className;
        } else if (elem.className === className) {
          elem.removeAttribute('class');
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);
          if (index != -1) {
            classes.splice(index, 1);
            elem.className = classes.join(' ');
          }
        }
      } else {
        elem.className = undefined;
      }
      return dom;
    },

    hasClass: function(elem, className) {
      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
    },

    /**
     *
     * @param elem
     */
    getWidth: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-left-width']) +
          cssValueToPixels(style['border-right-width']) +
          cssValueToPixels(style['padding-left']) +
          cssValueToPixels(style['padding-right']) +
          cssValueToPixels(style['width']);
    },

    /**
     *
     * @param elem
     */
    getHeight: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-top-width']) +
          cssValueToPixels(style['border-bottom-width']) +
          cssValueToPixels(style['padding-top']) +
          cssValueToPixels(style['padding-bottom']) +
          cssValueToPixels(style['height']);
    },

    /**
     *
     * @param elem
     */
    getOffset: function(elem) {
      var offset = {left: 0, top:0};
      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
        } while (elem = elem.offsetParent);
      }
      return offset;
    },

    // http://stackoverflow.com/posts/2684561/revisions
    /**
     * 
     * @param elem
     */
    isActive: function(elem) {
      return elem === document.activeElement && ( elem.type || elem.href );
    }

  };

  return dom;

})(dat.utils.common);


dat.controllers.OptionController = (function (Controller, dom, common) {

  /**
   * @class Provides a select input to alter the property of an object, using a
   * list of accepted values.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object|string[]} options A map of labels to acceptable values, or
   * a list of acceptable string values.
   *
   * @member dat.controllers
   */
  var OptionController = function(object, property, options) {

    OptionController.superclass.call(this, object, property);

    var _this = this;

    /**
     * The drop down menu
     * @ignore
     */
    this.__select = document.createElement('select');

    if (common.isArray(options)) {
      var map = {};
      common.each(options, function(element) {
        map[element] = element;
      });
      options = map;
    }

    common.each(options, function(value, key) {

      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);

    });

    // Acknowledge original value
    this.updateDisplay();

    dom.bind(this.__select, 'change', function() {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });

    this.domElement.appendChild(this.__select);

  };

  OptionController.superclass = Controller;

  common.extend(

      OptionController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          return toReturn;
        },

        updateDisplay: function() {
          this.__select.value = this.getValue();
          return OptionController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return OptionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberController = (function (Controller, common) {

  /**
   * @class Represents a given property of an object that is a number.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberController = function(object, property, params) {

    NumberController.superclass.call(this, object, property);

    params = params || {};

    this.__min = params.min;
    this.__max = params.max;
    this.__step = params.step;

    if (common.isUndefined(this.__step)) {

      if (this.initialValue == 0) {
        this.__impliedStep = 1; // What are we, psychics?
      } else {
        // Hey Doug, check this out.
        this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(this.initialValue))/Math.LN10))/10;
      }

    } else {

        this.__impliedStep = this.__step;

    }

    this.__precision = numDecimals(this.__impliedStep);


  };

  NumberController.superclass = Controller;

  common.extend(

      NumberController.prototype,
      Controller.prototype,

      /** @lends dat.controllers.NumberController.prototype */
      {

        setValue: function(v) {

          if (this.__min !== undefined && v < this.__min) {
            v = this.__min;
          } else if (this.__max !== undefined && v > this.__max) {
            v = this.__max;
          }

          if (this.__step !== undefined && v % this.__step != 0) {
            v = Math.round(v / this.__step) * this.__step;
          }

          return NumberController.superclass.prototype.setValue.call(this, v);

        },

        /**
         * Specify a minimum value for <code>object[property]</code>.
         *
         * @param {Number} minValue The minimum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        min: function(v) {
          this.__min = v;
          return this;
        },

        /**
         * Specify a maximum value for <code>object[property]</code>.
         *
         * @param {Number} maxValue The maximum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        max: function(v) {
          this.__max = v;
          return this;
        },

        /**
         * Specify a step value that dat.controllers.NumberController
         * increments by.
         *
         * @param {Number} stepValue The step value for
         * dat.controllers.NumberController
         * @default if minimum and maximum specified increment is 1% of the
         * difference otherwise stepValue is 1
         * @returns {dat.controllers.NumberController} this
         */
        step: function(v) {
          this.__step = v;
          this.__impliedStep = v;
          this.__precision = numDecimals(v);
          return this;
        }

      }

  );

  function numDecimals(x) {
    x = x.toString();
    if (x.indexOf('.') > -1) {
      return x.length - x.indexOf('.') - 1;
    } else {
      return 0;
    }
  }

  return NumberController;

})(dat.controllers.Controller,
dat.utils.common);


dat.controllers.NumberControllerBox = (function (NumberController, dom, common) {

  /**
   * @class Represents a given property of an object that is a number and
   * provides an input element with which to manipulate it.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerBox = function(object, property, params) {

    this.__truncationSuspended = false;

    NumberControllerBox.superclass.call(this, object, property, params);

    var _this = this;

    /**
     * {Number} Previous mouse y position
     * @ignore
     */
    var prev_y;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    // Makes it so manually specified values are not truncated.

    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'mousedown', onMouseDown);
    dom.bind(this.__input, 'keydown', function(e) {

      // When pressing entire, you can be as precise as you want.
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
      }

    });

    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!common.isNaN(attempted)) _this.setValue(attempted);
    }

    function onBlur() {
      onChange();
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prev_y = e.clientY;
    }

    function onMouseDrag(e) {

      var diff = prev_y - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);

      prev_y = e.clientY;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  NumberControllerBox.superclass = NumberController;

  common.extend(

      NumberControllerBox.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {

          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }

  return NumberControllerBox;

})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {

  /**
   * @class Represents a given property of an object that is a number, contains
   * a minimum and maximum, and provides a slider element with which to
   * manipulate it. It should be noted that the slider element is made up of
   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
   * <code>&lt;slider&gt;</code> element.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   * 
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Number} minValue Minimum allowed value
   * @param {Number} maxValue Maximum allowed value
   * @param {Number} stepValue Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerSlider = function(object, property, min, max, step) {

    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });

    var _this = this;

    this.__background = document.createElement('div');
    this.__foreground = document.createElement('div');
    


    dom.bind(this.__background, 'mousedown', onMouseDown);
    
    dom.addClass(this.__background, 'slider');
    dom.addClass(this.__foreground, 'slider-fg');

    function onMouseDown(e) {

      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);

      onMouseDrag(e);
    }

    function onMouseDrag(e) {

      e.preventDefault();

      var offset = dom.getOffset(_this.__background);
      var width = dom.getWidth(_this.__background);
      
      _this.setValue(
        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)
      );

      return false;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.__background.appendChild(this.__foreground);
    this.domElement.appendChild(this.__background);

  };

  NumberControllerSlider.superclass = NumberController;

  /**
   * Injects default stylesheet for slider elements.
   */
  NumberControllerSlider.useDefaultStyles = function() {
    css.inject(styleSheet);
  };

  common.extend(

      NumberControllerSlider.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {
          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);
          this.__foreground.style.width = pct*100+'%';
          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);
        }

      }



  );

    function map(v, i1, i2, o1, o2) {
        return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
    }

  return NumberControllerSlider;
  
})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.css,
dat.utils.common,
"/**\n * dat-gui JavaScript Controller Library\n * http://code.google.com/p/dat-gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\n.slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");


dat.controllers.FunctionController = (function (Controller, dom, common) {

  /**
   * @class Provides a GUI interface to fire a specified method, a property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var FunctionController = function(object, property, text) {

    FunctionController.superclass.call(this, object, property);

    var _this = this;

    this.__button = document.createElement('div');
    this.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(this.__button, 'click', function(e) {
      e.preventDefault();
      _this.fire();
      return false;
    });

    dom.addClass(this.__button, 'button');

    this.domElement.appendChild(this.__button);


  };

  FunctionController.superclass = Controller;

  common.extend(

      FunctionController.prototype,
      Controller.prototype,
      {
        
        fire: function() {
          if (this.__onChange) {
            this.__onChange.call(this);
          }
          this.getValue().call(this.object);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
        }
      }

  );

  return FunctionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.BooleanController = (function (Controller, dom, common) {

  /**
   * @class Provides a checkbox input to alter the boolean property of an object.
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var BooleanController = function(object, property) {

    BooleanController.superclass.call(this, object, property);

    var _this = this;
    this.__prev = this.getValue();

    this.__checkbox = document.createElement('input');
    this.__checkbox.setAttribute('type', 'checkbox');


    dom.bind(this.__checkbox, 'change', onChange, false);

    this.domElement.appendChild(this.__checkbox);

    // Match original value
    this.updateDisplay();

    function onChange() {
      _this.setValue(!_this.__prev);
    }

  };

  BooleanController.superclass = Controller;

  common.extend(

      BooleanController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.__prev = this.getValue();
          return toReturn;
        },

        updateDisplay: function() {
          
          if (this.getValue() === true) {
            this.__checkbox.setAttribute('checked', 'checked');
            this.__checkbox.checked = true;    
          } else {
              this.__checkbox.checked = false;
          }

          return BooleanController.superclass.prototype.updateDisplay.call(this);

        }


      }

  );

  return BooleanController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common);


dat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {

  css.inject(styleSheet);

  /** Outer-most className for GUI's */
  var CSS_NAMESPACE = 'dg';

  var HIDE_KEY_CODE = 72;

  /** The only value shared between the JS and SCSS. Use caution. */
  var CLOSE_BUTTON_HEIGHT = 20;

  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

  var SUPPORTS_LOCAL_STORAGE = (function() {
    try {
      return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
      return false;
    }
  })();

  var SAVE_DIALOGUE;

  /** Have we yet to create an autoPlace GUI? */
  var auto_place_virgin = true;

  /** Fixed position div that auto place GUI's go inside */
  var auto_place_container;

  /** Are we hiding the GUI's ? */
  var hide = false;

  /** GUI's which should be hidden */
  var hideable_guis = [];

  /**
   * A lightweight controller library for JavaScript. It allows you to easily
   * manipulate variables and fire functions on the fly.
   * @class
   *
   * @member dat.gui
   *
   * @param {Object} [params]
   * @param {String} [params.name] The name of this GUI.
   * @param {Object} [params.load] JSON object representing the saved state of
   * this GUI.
   * @param {Boolean} [params.auto=true]
   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
   * @param {Boolean} [params.closed] If true, starts closed
   */
  var GUI = function(params) {

    var _this = this;

    /**
     * Outermost DOM Element
     * @type DOMElement
     */
    this.domElement = document.createElement('div');
    this.__ul = document.createElement('ul');
    this.domElement.appendChild(this.__ul);

    dom.addClass(this.domElement, CSS_NAMESPACE);

    /**
     * Nested GUI's by name
     * @ignore
     */
    this.__folders = {};

    this.__controllers = [];

    /**
     * List of objects I'm remembering for save, only used in top level GUI
     * @ignore
     */
    this.__rememberedObjects = [];

    /**
     * Maps the index of remembered objects to a map of controllers, only used
     * in top level GUI.
     *
     * @private
     * @ignore
     *
     * @example
     * [
     *  {
     *    propertyName: Controller,
     *    anotherPropertyName: Controller
     *  },
     *  {
     *    propertyName: Controller
     *  }
     * ]
     */
    this.__rememberedObjectIndecesToControllers = [];

    this.__listening = [];

    params = params || {};

    // Default parameters
    params = common.defaults(params, {
      autoPlace: true,
      width: GUI.DEFAULT_WIDTH
    });

    params = common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });


    if (!common.isUndefined(params.load)) {

      // Explicit preset
      if (params.preset) params.load.preset = params.preset;

    } else {

      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };

    }

    if (common.isUndefined(params.parent) && params.hideable) {
      hideable_guis.push(this);
    }

    // Only root level GUI's are resizable.
    params.resizable = common.isUndefined(params.parent) && params.resizable;


    if (params.autoPlace && common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }
//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;

    // Not part of params because I don't want people passing this in via
    // constructor. Should be a 'remembered' value.
    var use_local_storage =
        SUPPORTS_LOCAL_STORAGE &&
            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';

    var saveToLocalStorage;

    Object.defineProperties(this,

        /** @lends dat.gui.GUI.prototype */
        {

          /**
           * The parent <code>GUI</code>
           * @type dat.gui.GUI
           */
          parent: {
            get: function() {
              return params.parent;
            }
          },

          scrollable: {
            get: function() {
              return params.scrollable;
            }
          },

          /**
           * Handles <code>GUI</code>'s element placement for you
           * @type Boolean
           */
          autoPlace: {
            get: function() {
              return params.autoPlace;
            }
          },

          /**
           * The identifier for a set of saved values
           * @type String
           */
          preset: {

            get: function() {
              if (_this.parent) {
                return _this.getRoot().preset;
              } else {
                return params.load.preset;
              }
            },

            set: function(v) {
              if (_this.parent) {
                _this.getRoot().preset = v;
              } else {
                params.load.preset = v;
              }
              setPresetSelectIndex(this);
              _this.revert();
            }

          },

          /**
           * The width of <code>GUI</code> element
           * @type Number
           */
          width: {
            get: function() {
              return params.width;
            },
            set: function(v) {
              params.width = v;
              setWidth(_this, v);
            }
          },

          /**
           * The name of <code>GUI</code>. Used for folders. i.e
           * a folder's name
           * @type String
           */
          name: {
            get: function() {
              return params.name;
            },
            set: function(v) {
              // TODO Check for collisions among sibling folders
              params.name = v;
              if (title_row_name) {
                title_row_name.innerHTML = params.name;
              }
            }
          },

          /**
           * Whether the <code>GUI</code> is collapsed or not
           * @type Boolean
           */
          closed: {
            get: function() {
              return params.closed;
            },
            set: function(v) {
              params.closed = v;
              if (params.closed) {
                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
              } else {
                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
              }
              // For browsers that aren't going to respect the CSS transition,
              // Lets just check our height against the window height right off
              // the bat.
              this.onResize();

              if (_this.__closeButton) {
                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
              }
            }
          },

          /**
           * Contains all presets
           * @type Object
           */
          load: {
            get: function() {
              return params.load;
            }
          },

          /**
           * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
           * <code>remember</code>ing
           * @type Boolean
           */
          useLocalStorage: {

            get: function() {
              return use_local_storage;
            },
            set: function(bool) {
              if (SUPPORTS_LOCAL_STORAGE) {
                use_local_storage = bool;
                if (bool) {
                  dom.bind(window, 'unload', saveToLocalStorage);
                } else {
                  dom.unbind(window, 'unload', saveToLocalStorage);
                }
                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
              }
            }

          }

        });

    // Are we a root level GUI?
    if (common.isUndefined(params.parent)) {

      params.closed = false;

      dom.addClass(this.domElement, GUI.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);

      // Are we supposed to be loading locally?
      if (SUPPORTS_LOCAL_STORAGE) {

        if (use_local_storage) {

          _this.useLocalStorage = true;

          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

          if (saved_gui) {
            params.load = JSON.parse(saved_gui);
          }

        }

      }

      this.__closeButton = document.createElement('div');
      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
      this.domElement.appendChild(this.__closeButton);

      dom.bind(this.__closeButton, 'click', function() {

        _this.closed = !_this.closed;


      });


      // Oh, you're a nested GUI!
    } else {

      if (params.closed === undefined) {
        params.closed = true;
      }

      var title_row_name = document.createTextNode(params.name);
      dom.addClass(title_row_name, 'controller-name');

      var title_row = addRow(_this, title_row_name);

      var on_click_title = function(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };

      dom.addClass(this.__ul, GUI.CLASS_CLOSED);

      dom.addClass(title_row, 'title');
      dom.bind(title_row, 'click', on_click_title);

      if (!params.closed) {
        this.closed = false;
      }

    }

    if (params.autoPlace) {

      if (common.isUndefined(params.parent)) {

        if (auto_place_virgin) {
          auto_place_container = document.createElement('div');
          dom.addClass(auto_place_container, CSS_NAMESPACE);
          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(auto_place_container);
          auto_place_virgin = false;
        }

        // Put it in the dom for you.
        auto_place_container.appendChild(this.domElement);

        // Apply the auto styles
        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);

      }


      // Make it not elastic.
      if (!this.parent) setWidth(_this, params.width);

    }

    dom.bind(window, 'resize', function() { _this.onResize() });
    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });
    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });
    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });
    this.onResize();


    if (params.resizable) {
      addResizeHandle(this);
    }

    saveToLocalStorage = function () {
      if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
        localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
      }
    }

    // expose this method publicly
    this.saveToLocalStorageIfPossible = saveToLocalStorage;

    var root = _this.getRoot();
    function resetWidth() {
          var root = _this.getRoot();
          root.width += 1;
          common.defer(function() {
            root.width -= 1;
          });
        }

        if (!params.parent) {
          resetWidth();
        }

  };

  GUI.toggleHide = function() {

    hide = !hide;
    common.each(hideable_guis, function(gui) {
      gui.domElement.style.zIndex = hide ? -999 : 999;
      gui.domElement.style.opacity = hide ? 0 : 1;
    });
  };

  GUI.CLASS_AUTO_PLACE = 'a';
  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
  GUI.CLASS_MAIN = 'main';
  GUI.CLASS_CONTROLLER_ROW = 'cr';
  GUI.CLASS_TOO_TALL = 'taller-than-window';
  GUI.CLASS_CLOSED = 'closed';
  GUI.CLASS_CLOSE_BUTTON = 'close-button';
  GUI.CLASS_DRAG = 'drag';

  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = 'Close Controls';
  GUI.TEXT_OPEN = 'Open Controls';

  dom.bind(window, 'keydown', function(e) {

    if (document.activeElement.type !== 'text' &&
        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }

  }, false);

  common.extend(

      GUI.prototype,

      /** @lends dat.gui.GUI */
      {

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.Controller} The new controller that was added.
         * @instance
         */
        add: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
              }
          );

        },

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.ColorController} The new controller that was added.
         * @instance
         */
        addColor: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                color: true
              }
          );

        },

        /**
         * @param controller
         * @instance
         */
        remove: function(controller) {

          // TODO listening?
          this.__ul.removeChild(controller.__li);
          this.__controllers.splice(this.__controllers.indexOf(controller), 1);
          var _this = this;
          common.defer(function() {
            _this.onResize();
          });

        },

        destroy: function() {

          if (this.autoPlace) {
            auto_place_container.removeChild(this.domElement);
          }

        },

        /**
         * @param name
         * @returns {dat.gui.GUI} The new folder.
         * @throws {Error} if this GUI already has a folder by the specified
         * name
         * @instance
         */
        addFolder: function(name) {

          // We have to prevent collisions on names in order to have a key
          // by which to remember saved values
          if (this.__folders[name] !== undefined) {
            throw new Error('You already have a folder in this GUI by the' +
                ' name "' + name + '"');
          }

          var new_gui_params = { name: name, parent: this };

          // We need to pass down the autoPlace trait so that we can
          // attach event listeners to open/close folder actions to
          // ensure that a scrollbar appears if the window is too short.
          new_gui_params.autoPlace = this.autoPlace;

          // Do we have saved appearance data for this folder?

          if (this.load && // Anything loaded?
              this.load.folders && // Was my parent a dead-end?
              this.load.folders[name]) { // Did daddy remember me?

            // Start me closed if I was closed
            new_gui_params.closed = this.load.folders[name].closed;

            // Pass down the loaded data
            new_gui_params.load = this.load.folders[name];

          }

          var gui = new GUI(new_gui_params);
          this.__folders[name] = gui;

          var li = addRow(this, gui.domElement);
          dom.addClass(li, 'folder');
          return gui;

        },

        open: function() {
          this.closed = false;
        },

        close: function() {
          this.closed = true;
        },

        onResize: function() {

          var root = this.getRoot();

          if (root.scrollable) {

            var top = dom.getOffset(root.__ul).top;
            var h = 0;

            common.each(root.__ul.childNodes, function(node) {
              if (! (root.autoPlace && node === root.__save_row))
                h += dom.getHeight(node);
            });

            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
            } else {
              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = 'auto';
            }

          }

          if (root.__resize_handle) {
            common.defer(function() {
              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
            });
          }

          if (root.__closeButton) {
            root.__closeButton.style.width = root.width + 'px';
          }

        },

        /**
         * Mark objects for saving. The order of these objects cannot change as
         * the GUI grows. When remembering new objects, append them to the end
         * of the list.
         *
         * @param {Object...} objects
         * @throws {Error} if not called on a top level GUI.
         * @instance
         */
        remember: function() {

          if (common.isUndefined(SAVE_DIALOGUE)) {
            SAVE_DIALOGUE = new CenteredDiv();
            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;
          }

          if (this.parent) {
            throw new Error("You can only call remember on a top level GUI.");
          }

          var _this = this;

          common.each(Array.prototype.slice.call(arguments), function(object) {
            if (_this.__rememberedObjects.length == 0) {
              addSaveMenu(_this);
            }
            if (_this.__rememberedObjects.indexOf(object) == -1) {
              _this.__rememberedObjects.push(object);
            }
          });

          if (this.autoPlace) {
            // Set save row width
            setWidth(this, this.width);
          }

        },

        /**
         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
         * @instance
         */
        getRoot: function() {
          var gui = this;
          while (gui.parent) {
            gui = gui.parent;
          }
          return gui;
        },

        /**
         * @returns {Object} a JSON object representing the current state of
         * this GUI as well as its remembered properties.
         * @instance
         */
        getSaveObject: function() {

          var toReturn = this.load;

          toReturn.closed = this.closed;

          // Am I remembering any values?
          if (this.__rememberedObjects.length > 0) {

            toReturn.preset = this.preset;

            if (!toReturn.remembered) {
              toReturn.remembered = {};
            }

            toReturn.remembered[this.preset] = getCurrentPreset(this);

          }

          toReturn.folders = {};
          common.each(this.__folders, function(element, key) {
            toReturn.folders[key] = element.getSaveObject();
          });

          return toReturn;

        },

        save: function() {

          if (!this.load.remembered) {
            this.load.remembered = {};
          }

          this.load.remembered[this.preset] = getCurrentPreset(this);
          markPresetModified(this, false);
          this.saveToLocalStorageIfPossible();

        },

        saveAs: function(presetName) {

          if (!this.load.remembered) {

            // Retain default values upon first save
            this.load.remembered = {};
            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);

          }

          this.load.remembered[presetName] = getCurrentPreset(this);
          this.preset = presetName;
          addPresetOption(this, presetName, true);
          this.saveToLocalStorageIfPossible();

        },

        revert: function(gui) {

          common.each(this.__controllers, function(controller) {
            // Make revert work on Default.
            if (!this.getRoot().load.remembered) {
              controller.setValue(controller.initialValue);
            } else {
              recallSavedValue(gui || this.getRoot(), controller);
            }
          }, this);

          common.each(this.__folders, function(folder) {
            folder.revert(folder);
          });

          if (!gui) {
            markPresetModified(this.getRoot(), false);
          }


        },

        listen: function(controller) {

          var init = this.__listening.length == 0;
          this.__listening.push(controller);
          if (init) updateDisplays(this.__listening);

        }

      }

  );

  function add(gui, object, property, params) {

    if (object[property] === undefined) {
      throw new Error("Object " + object + " has no property \"" + property + "\"");
    }

    var controller;

    if (params.color) {

      controller = new ColorController(object, property);

    } else {

      var factoryArgs = [object,property].concat(params.factoryArgs);
      controller = controllerFactory.apply(gui, factoryArgs);

    }

    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }

    recallSavedValue(gui, controller);

    dom.addClass(controller.domElement, 'c');

    var name = document.createElement('span');
    dom.addClass(name, 'property-name');
    name.innerHTML = controller.property;

    var container = document.createElement('div');
    container.appendChild(name);
    container.appendChild(controller.domElement);

    var li = addRow(gui, container, params.before);

    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
    dom.addClass(li, typeof controller.getValue());

    augmentController(gui, li, controller);

    gui.__controllers.push(controller);

    return controller;

  }

  /**
   * Add a row to the end of the GUI or before another row.
   *
   * @param gui
   * @param [dom] If specified, inserts the dom content in the new row
   * @param [liBefore] If specified, places the new row before another row
   */
  function addRow(gui, dom, liBefore) {
    var li = document.createElement('li');
    if (dom) li.appendChild(dom);
    if (liBefore) {
      gui.__ul.insertBefore(li, params.before);
    } else {
      gui.__ul.appendChild(li);
    }
    gui.onResize();
    return li;
  }

  function augmentController(gui, li, controller) {

    controller.__li = li;
    controller.__gui = gui;

    common.extend(controller, {

      options: function(options) {

        if (arguments.length > 1) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [common.toArray(arguments)]
              }
          );

        }

        if (common.isArray(options) || common.isObject(options)) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [options]
              }
          );

        }

      },

      name: function(v) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = v;
        return controller;
      },

      listen: function() {
        controller.__gui.listen(controller);
        return controller;
      },

      remove: function() {
        controller.__gui.remove(controller);
        return controller;
      }

    });

    // All sliders should be accompanied by a box.
    if (controller instanceof NumberControllerSlider) {

      var box = new NumberControllerBox(controller.object, controller.property,
          { min: controller.__min, max: controller.__max, step: controller.__step });

      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {
        var pc = controller[method];
        var pb = box[method];
        controller[method] = box[method] = function() {
          var args = Array.prototype.slice.call(arguments);
          pc.apply(controller, args);
          return pb.apply(box, args);
        }
      });

      dom.addClass(li, 'has-slider');
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);

    }
    else if (controller instanceof NumberControllerBox) {

      var r = function(returned) {

        // Have we defined both boundaries?
        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {

          // Well, then lets just replace this with a slider.
          controller.remove();
          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [controller.__min, controller.__max, controller.__step]
              });

        }

        return returned;

      };

      controller.min = common.compose(r, controller.min);
      controller.max = common.compose(r, controller.max);

    }
    else if (controller instanceof BooleanController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__checkbox, 'click');
      });

      dom.bind(controller.__checkbox, 'click', function(e) {
        e.stopPropagation(); // Prevents double-toggle
      })

    }
    else if (controller instanceof FunctionController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__button, 'click');
      });

      dom.bind(li, 'mouseover', function() {
        dom.addClass(controller.__button, 'hover');
      });

      dom.bind(li, 'mouseout', function() {
        dom.removeClass(controller.__button, 'hover');
      });

    }
    else if (controller instanceof ColorController) {

      dom.addClass(li, 'color');
      controller.updateDisplay = common.compose(function(r) {
        li.style.borderLeftColor = controller.__color.toString();
        return r;
      }, controller.updateDisplay);

      controller.updateDisplay();

    }

    controller.setValue = common.compose(function(r) {
      if (gui.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui.getRoot(), true);
      }
      return r;
    }, controller.setValue);

  }

  function recallSavedValue(gui, controller) {

    // Find the topmost GUI, that's where remembered objects live.
    var root = gui.getRoot();

    // Does the object we're controlling match anything we've been told to
    // remember?
    var matched_index = root.__rememberedObjects.indexOf(controller.object);

    // Why yes, it does!
    if (matched_index != -1) {

      // Let me fetch a map of controllers for thcommon.isObject.
      var controller_map =
          root.__rememberedObjectIndecesToControllers[matched_index];

      // Ohp, I believe this is the first controller we've created for this
      // object. Lets make the map fresh.
      if (controller_map === undefined) {
        controller_map = {};
        root.__rememberedObjectIndecesToControllers[matched_index] =
            controller_map;
      }

      // Keep track of this controller
      controller_map[controller.property] = controller;

      // Okay, now have we saved any values for this controller?
      if (root.load && root.load.remembered) {

        var preset_map = root.load.remembered;

        // Which preset are we trying to load?
        var preset;

        if (preset_map[gui.preset]) {

          preset = preset_map[gui.preset];

        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {

          // Uhh, you can have the default instead?
          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];

        } else {

          // Nada.

          return;

        }


        // Did the loaded object remember thcommon.isObject?
        if (preset[matched_index] &&

          // Did we remember this particular property?
            preset[matched_index][controller.property] !== undefined) {

          // We did remember something for this guy ...
          var value = preset[matched_index][controller.property];

          // And that's what it is.
          controller.initialValue = value;
          controller.setValue(value);

        }

      }

    }

  }

  function getLocalStorageHash(gui, key) {
    // TODO how does this deal with multiple GUI's?
    return document.location.href + '.' + key;

  }

  function addSaveMenu(gui) {

    var div = gui.__save_row = document.createElement('li');

    dom.addClass(gui.domElement, 'has-save');

    gui.__ul.insertBefore(div, gui.__ul.firstChild);

    dom.addClass(div, 'save-row');

    var gears = document.createElement('span');
    gears.innerHTML = '&nbsp;';
    dom.addClass(gears, 'button gears');

    // TODO replace with FunctionController
    var button = document.createElement('span');
    button.innerHTML = 'Save';
    dom.addClass(button, 'button');
    dom.addClass(button, 'save');

    var button2 = document.createElement('span');
    button2.innerHTML = 'New';
    dom.addClass(button2, 'button');
    dom.addClass(button2, 'save-as');

    var button3 = document.createElement('span');
    button3.innerHTML = 'Revert';
    dom.addClass(button3, 'button');
    dom.addClass(button3, 'revert');

    var select = gui.__preset_select = document.createElement('select');

    if (gui.load && gui.load.remembered) {

      common.each(gui.load.remembered, function(value, key) {
        addPresetOption(gui, key, key == gui.preset);
      });

    } else {
      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
    }

    dom.bind(select, 'change', function() {


      for (var index = 0; index < gui.__preset_select.length; index++) {
        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
      }

      gui.preset = this.value;

    });

    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);

    if (SUPPORTS_LOCAL_STORAGE) {

      var saveLocally = document.getElementById('dg-save-locally');
      var explain = document.getElementById('dg-local-explain');

      saveLocally.style.display = 'block';

      var localStorageCheckBox = document.getElementById('dg-local-storage');

      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
        localStorageCheckBox.setAttribute('checked', 'checked');
      }

      function showHideExplain() {
        explain.style.display = gui.useLocalStorage ? 'block' : 'none';
      }

      showHideExplain();

      // TODO: Use a boolean controller, fool!
      dom.bind(localStorageCheckBox, 'change', function() {
        gui.useLocalStorage = !gui.useLocalStorage;
        showHideExplain();
      });

    }

    var newConstructorTextArea = document.getElementById('dg-new-constructor');

    dom.bind(newConstructorTextArea, 'keydown', function(e) {
      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {
        SAVE_DIALOGUE.hide();
      }
    });

    dom.bind(gears, 'click', function() {
      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });

    dom.bind(button, 'click', function() {
      gui.save();
    });

    dom.bind(button2, 'click', function() {
      var presetName = prompt('Enter a new preset name.');
      if (presetName) gui.saveAs(presetName);
    });

    dom.bind(button3, 'click', function() {
      gui.revert();
    });

//    div.appendChild(button2);

  }

  function addResizeHandle(gui) {

    gui.__resize_handle = document.createElement('div');

    common.extend(gui.__resize_handle.style, {

      width: '6px',
      marginLeft: '-3px',
      height: '200px',
      cursor: 'ew-resize',
      position: 'absolute'
//      border: '1px solid blue'

    });

    var pmouseX;

    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
    dom.bind(gui.__closeButton, 'mousedown', dragStart);

    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);

    function dragStart(e) {

      e.preventDefault();

      pmouseX = e.clientX;

      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, 'mousemove', drag);
      dom.bind(window, 'mouseup', dragStop);

      return false;

    }

    function drag(e) {

      e.preventDefault();

      gui.width += pmouseX - e.clientX;
      gui.onResize();
      pmouseX = e.clientX;

      return false;

    }

    function dragStop() {

      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, 'mousemove', drag);
      dom.unbind(window, 'mouseup', dragStop);

    }

  }

  function setWidth(gui, w) {
    gui.domElement.style.width = w + 'px';
    // Auto placed save-rows are position fixed, so we have to
    // set the width manually if we want it to bleed to the edge
    if (gui.__save_row && gui.autoPlace) {
      gui.__save_row.style.width = w + 'px';
    }if (gui.__closeButton) {
      gui.__closeButton.style.width = w + 'px';
    }
  }

  function getCurrentPreset(gui, useInitialValues) {

    var toReturn = {};

    // For each object I'm remembering
    common.each(gui.__rememberedObjects, function(val, index) {

      var saved_values = {};

      // The controllers I've made for thcommon.isObject by property
      var controller_map =
          gui.__rememberedObjectIndecesToControllers[index];

      // Remember each value for each property
      common.each(controller_map, function(controller, property) {
        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });

      // Save the values for thcommon.isObject
      toReturn[index] = saved_values;

    });

    return toReturn;

  }

  function addPresetOption(gui, name, setSelected) {
    var opt = document.createElement('option');
    opt.innerHTML = name;
    opt.value = name;
    gui.__preset_select.appendChild(opt);
    if (setSelected) {
      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
    }
  }

  function setPresetSelectIndex(gui) {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      if (gui.__preset_select[index].value == gui.preset) {
        gui.__preset_select.selectedIndex = index;
      }
    }
  }

  function markPresetModified(gui, modified) {
    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
//    console.log('mark', modified, opt);
    if (modified) {
      opt.innerHTML = opt.value + "*";
    } else {
      opt.innerHTML = opt.value;
    }
  }

  function updateDisplays(controllerArray) {


    if (controllerArray.length != 0) {

      requestAnimationFrame(function() {
        updateDisplays(controllerArray);
      });

    }

    common.each(controllerArray, function(c) {
      c.updateDisplay();
    });

  }

  return GUI;

})(dat.utils.css,
"<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>",
".dg {\n  /** Clear list styles */\n  /* Auto-place container */\n  /* Auto-placed GUI's */\n  /* Line items that don't contain folders. */\n  /** Folder names */\n  /** Hides closed items */\n  /** Controller row */\n  /** Name-half (left) */\n  /** Controller-half (right) */\n  /** Controller placement */\n  /** Shorter number boxes when slider is present. */\n  /** Ensure the entire boolean and function row shows a hand */ }\n  .dg ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    width: 100%;\n    clear: both; }\n  .dg.ac {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 0;\n    z-index: 0; }\n  .dg:not(.ac) .main {\n    /** Exclude mains in ac so that we don't hide close button */\n    overflow: hidden; }\n  .dg.main {\n    -webkit-transition: opacity 0.1s linear;\n    -o-transition: opacity 0.1s linear;\n    -moz-transition: opacity 0.1s linear;\n    transition: opacity 0.1s linear; }\n    .dg.main.taller-than-window {\n      overflow-y: auto; }\n      .dg.main.taller-than-window .close-button {\n        opacity: 1;\n        /* TODO, these are style notes */\n        margin-top: -1px;\n        border-top: 1px solid #2c2c2c; }\n    .dg.main ul.closed .close-button {\n      opacity: 1 !important; }\n    .dg.main:hover .close-button,\n    .dg.main .close-button.drag {\n      opacity: 1; }\n    .dg.main .close-button {\n      /*opacity: 0;*/\n      -webkit-transition: opacity 0.1s linear;\n      -o-transition: opacity 0.1s linear;\n      -moz-transition: opacity 0.1s linear;\n      transition: opacity 0.1s linear;\n      border: 0;\n      position: absolute;\n      line-height: 19px;\n      height: 20px;\n      /* TODO, these are style notes */\n      cursor: pointer;\n      text-align: center;\n      background-color: #000; }\n      .dg.main .close-button:hover {\n        background-color: #111; }\n  .dg.a {\n    float: right;\n    margin-right: 15px;\n    overflow-x: hidden; }\n    .dg.a.has-save > ul {\n      margin-top: 27px; }\n      .dg.a.has-save > ul.closed {\n        margin-top: 0; }\n    .dg.a .save-row {\n      position: fixed;\n      top: 0;\n      z-index: 1002; }\n  .dg li {\n    -webkit-transition: height 0.1s ease-out;\n    -o-transition: height 0.1s ease-out;\n    -moz-transition: height 0.1s ease-out;\n    transition: height 0.1s ease-out; }\n  .dg li:not(.folder) {\n    cursor: auto;\n    height: 27px;\n    line-height: 27px;\n    overflow: hidden;\n    padding: 0 4px 0 5px; }\n  .dg li.folder {\n    padding: 0;\n    border-left: 4px solid rgba(0, 0, 0, 0); }\n  .dg li.title {\n    cursor: pointer;\n    margin-left: -4px; }\n  .dg .closed li:not(.title),\n  .dg .closed ul li,\n  .dg .closed ul li > * {\n    height: 0;\n    overflow: hidden;\n    border: 0; }\n  .dg .cr {\n    clear: both;\n    padding-left: 3px;\n    height: 27px; }\n  .dg .property-name {\n    cursor: default;\n    float: left;\n    clear: left;\n    width: 40%;\n    overflow: hidden;\n    text-overflow: ellipsis; }\n  .dg .c {\n    float: left;\n    width: 60%; }\n  .dg .c input[type=text] {\n    border: 0;\n    margin-top: 4px;\n    padding: 3px;\n    width: 100%;\n    float: right; }\n  .dg .has-slider input[type=text] {\n    width: 30%;\n    /*display: none;*/\n    margin-left: 0; }\n  .dg .slider {\n    float: left;\n    width: 66%;\n    margin-left: -5px;\n    margin-right: 0;\n    height: 19px;\n    margin-top: 4px; }\n  .dg .slider-fg {\n    height: 100%; }\n  .dg .c input[type=checkbox] {\n    margin-top: 9px; }\n  .dg .c select {\n    margin-top: 5px; }\n  .dg .cr.function,\n  .dg .cr.function .property-name,\n  .dg .cr.function *,\n  .dg .cr.boolean,\n  .dg .cr.boolean * {\n    cursor: pointer; }\n  .dg .selector {\n    display: none;\n    position: absolute;\n    margin-left: -9px;\n    margin-top: 23px;\n    z-index: 10; }\n  .dg .c:hover .selector,\n  .dg .selector.drag {\n    display: block; }\n  .dg li.save-row {\n    padding: 0; }\n    .dg li.save-row .button {\n      display: inline-block;\n      padding: 0px 6px; }\n  .dg.dialogue {\n    background-color: #222;\n    width: 460px;\n    padding: 15px;\n    font-size: 13px;\n    line-height: 15px; }\n\n/* TODO Separate style and structure */\n#dg-new-constructor {\n  padding: 10px;\n  color: #222;\n  font-family: Monaco, monospace;\n  font-size: 10px;\n  border: 0;\n  resize: none;\n  box-shadow: inset 1px 1px 1px #888;\n  word-wrap: break-word;\n  margin: 12px 0;\n  display: block;\n  width: 440px;\n  overflow-y: scroll;\n  height: 100px;\n  position: relative; }\n\n#dg-local-explain {\n  display: none;\n  font-size: 11px;\n  line-height: 17px;\n  border-radius: 3px;\n  background-color: #333;\n  padding: 8px;\n  margin-top: 10px; }\n  #dg-local-explain code {\n    font-size: 10px; }\n\n#dat-gui-save-locally {\n  display: none; }\n\n/** Main type */\n.dg {\n  color: #eee;\n  font: 11px 'Lucida Grande', sans-serif;\n  text-shadow: 0 -1px 0 #111;\n  /** Auto place */\n  /* Controller row, <li> */\n  /** Controllers */ }\n  .dg.main {\n    /** Scrollbar */ }\n    .dg.main::-webkit-scrollbar {\n      width: 5px;\n      background: #1a1a1a; }\n    .dg.main::-webkit-scrollbar-corner {\n      height: 0;\n      display: none; }\n    .dg.main::-webkit-scrollbar-thumb {\n      border-radius: 5px;\n      background: #676767; }\n  .dg li:not(.folder) {\n    background: #1a1a1a;\n    border-bottom: 1px solid #2c2c2c; }\n  .dg li.save-row {\n    line-height: 25px;\n    background: #dad5cb;\n    border: 0; }\n    .dg li.save-row select {\n      margin-left: 5px;\n      width: 108px; }\n    .dg li.save-row .button {\n      margin-left: 5px;\n      margin-top: 1px;\n      border-radius: 2px;\n      font-size: 9px;\n      line-height: 7px;\n      padding: 4px 4px 5px 4px;\n      background: #c5bdad;\n      color: #fff;\n      text-shadow: 0 1px 0 #b0a58f;\n      box-shadow: 0 -1px 0 #b0a58f;\n      cursor: pointer; }\n      .dg li.save-row .button.gears {\n        background: #c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;\n        height: 7px;\n        width: 8px; }\n      .dg li.save-row .button:hover {\n        background-color: #bab19e;\n        box-shadow: 0 -1px 0 #b0a58f; }\n  .dg li.folder {\n    border-bottom: 0; }\n  .dg li.title {\n    padding-left: 16px;\n    background: black url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;\n    cursor: pointer;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2); }\n  .dg .closed li.title {\n    background-image: url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==); }\n  .dg .cr.boolean {\n    border-left: 3px solid #806787; }\n  .dg .cr.function {\n    border-left: 3px solid #e61d5f; }\n  .dg .cr.number {\n    border-left: 3px solid #2fa1d6; }\n    .dg .cr.number input[type=text] {\n      color: #2fa1d6; }\n  .dg .cr.string {\n    border-left: 3px solid #1ed36f; }\n    .dg .cr.string input[type=text] {\n      color: #1ed36f; }\n  .dg .cr.function:hover, .dg .cr.boolean:hover {\n    background: #111; }\n  .dg .c input[type=text] {\n    background: #303030;\n    outline: none; }\n    .dg .c input[type=text]:hover {\n      background: #3c3c3c; }\n    .dg .c input[type=text]:focus {\n      background: #494949;\n      color: #fff; }\n  .dg .c .slider {\n    background: #303030;\n    cursor: ew-resize; }\n  .dg .c .slider-fg {\n    background: #2fa1d6; }\n  .dg .c .slider:hover {\n    background: #3c3c3c; }\n    .dg .c .slider:hover .slider-fg {\n      background: #44abda; }\n",
dat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {

      return function(object, property) {

        var initialValue = object[property];

        // Providing options?
        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {
          return new OptionController(object, property, arguments[2]);
        }

        // Providing a map?

        if (common.isNumber(initialValue)) {

          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {

            // Has min and max.
            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);

          } else {

            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });

          }

        }

        if (common.isString(initialValue)) {
          return new StringController(object, property);
        }

        if (common.isFunction(initialValue)) {
          return new FunctionController(object, property, '');
        }

        if (common.isBoolean(initialValue)) {
          return new BooleanController(object, property);
        }

      }

    })(dat.controllers.OptionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.StringController = (function (Controller, dom, common) {

  /**
   * @class Provides a text input to alter the string property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var StringController = function(object, property) {

    StringController.superclass.call(this, object, property);

    var _this = this;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    dom.bind(this.__input, 'keyup', onChange);
    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    

    function onChange() {
      _this.setValue(_this.__input.value);
    }

    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  StringController.superclass = Controller;

  common.extend(

      StringController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {
          // Stops the caret from moving on account of:
          // keyup -> setValue -> updateDisplay
          if (!dom.isActive(this.__input)) {
            this.__input.value = this.getValue();
          }
          return StringController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return StringController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common),
dat.controllers.FunctionController,
dat.controllers.BooleanController,
dat.utils.common),
dat.controllers.Controller,
dat.controllers.BooleanController,
dat.controllers.FunctionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.OptionController,
dat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {

  var ColorController = function(object, property) {

    ColorController.superclass.call(this, object, property);

    this.__color = new Color(this.getValue());
    this.__temp = new Color(0);

    var _this = this;

    this.domElement = document.createElement('div');

    dom.makeSelectable(this.domElement, false);

    this.__selector = document.createElement('div');
    this.__selector.className = 'selector';

    this.__saturation_field = document.createElement('div');
    this.__saturation_field.className = 'saturation-field';

    this.__field_knob = document.createElement('div');
    this.__field_knob.className = 'field-knob';
    this.__field_knob_border = '2px solid ';

    this.__hue_knob = document.createElement('div');
    this.__hue_knob.className = 'hue-knob';

    this.__hue_field = document.createElement('div');
    this.__hue_field.className = 'hue-field';

    this.__input = document.createElement('input');
    this.__input.type = 'text';
    this.__input_textShadow = '0 1px 1px ';

    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) { // on enter
        onBlur.call(this);
      }
    });

    dom.bind(this.__input, 'blur', onBlur);

    dom.bind(this.__selector, 'mousedown', function(e) {

      dom
        .addClass(this, 'drag')
        .bind(window, 'mouseup', function(e) {
          dom.removeClass(_this.__selector, 'drag');
        });

    });

    var value_field = document.createElement('div');

    common.extend(this.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });

    common.extend(this.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    
    common.extend(this.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });

    common.extend(this.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });

    common.extend(value_field.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    
    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');

    common.extend(this.__hue_field.style, {
      width: '15px',
      height: '100px',
      display: 'inline-block',
      border: '1px solid #555',
      cursor: 'ns-resize'
    });

    hueGradient(this.__hue_field);

    common.extend(this.__input.style, {
      outline: 'none',
//      width: '120px',
      textAlign: 'center',
//      padding: '4px',
//      marginBottom: '6px',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'
    });

    dom.bind(this.__saturation_field, 'mousedown', fieldDown);
    dom.bind(this.__field_knob, 'mousedown', fieldDown);

    dom.bind(this.__hue_field, 'mousedown', function(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'mouseup', unbindH);
    });

    function fieldDown(e) {
      setSV(e);
      // document.body.style.cursor = 'none';
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'mouseup', unbindSV);
    }

    function unbindSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'mouseup', unbindSV);
      // document.body.style.cursor = 'default';
    }

    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }

    function unbindH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'mouseup', unbindH);
    }

    this.__saturation_field.appendChild(value_field);
    this.__selector.appendChild(this.__field_knob);
    this.__selector.appendChild(this.__saturation_field);
    this.__selector.appendChild(this.__hue_field);
    this.__hue_field.appendChild(this.__hue_knob);

    this.domElement.appendChild(this.__input);
    this.domElement.appendChild(this.__selector);

    this.updateDisplay();

    function setSV(e) {

      e.preventDefault();

      var w = dom.getWidth(_this.__saturation_field);
      var o = dom.getOffset(_this.__saturation_field);
      var s = (e.clientX - o.left + document.body.scrollLeft) / w;
      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;

      if (v > 1) v = 1;
      else if (v < 0) v = 0;

      if (s > 1) s = 1;
      else if (s < 0) s = 0;

      _this.__color.v = v;
      _this.__color.s = s;

      _this.setValue(_this.__color.toOriginal());


      return false;

    }

    function setH(e) {

      e.preventDefault();

      var s = dom.getHeight(_this.__hue_field);
      var o = dom.getOffset(_this.__hue_field);
      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;

      if (h > 1) h = 1;
      else if (h < 0) h = 0;

      _this.__color.h = h * 360;

      _this.setValue(_this.__color.toOriginal());

      return false;

    }

  };

  ColorController.superclass = Controller;

  common.extend(

      ColorController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {

          var i = interpret(this.getValue());

          if (i !== false) {

            var mismatch = false;

            // Check for mismatch on the interpreted value.

            common.each(Color.COMPONENTS, function(component) {
              if (!common.isUndefined(i[component]) &&
                  !common.isUndefined(this.__color.__state[component]) &&
                  i[component] !== this.__color.__state[component]) {
                mismatch = true;
                return {}; // break
              }
            }, this);

            // If nothing diverges, we keep our previous values
            // for statefulness, otherwise we recalculate fresh
            if (mismatch) {
              common.extend(this.__color.__state, i);
            }

          }

          common.extend(this.__temp.__state, this.__color.__state);

          this.__temp.a = 1;

          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;
          var _flip = 255 - flip;

          common.extend(this.__field_knob.style, {
            marginLeft: 100 * this.__color.s - 7 + 'px',
            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
            backgroundColor: this.__temp.toString(),
            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'
          });

          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'

          this.__temp.s = 1;
          this.__temp.v = 1;

          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());

          common.extend(this.__input.style, {
            backgroundColor: this.__input.value = this.__color.toString(),
            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',
            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'
          });

        }

      }

  );
  
  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];
  
  function linearGradient(elem, x, a, b) {
    elem.style.background = '';
    common.each(vendors, function(vendor) {
      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';
    });
  }
  
  function hueGradient(elem) {
    elem.style.background = '';
    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'
    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
  }


  return ColorController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret,
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common),
dat.color.interpret,
dat.utils.common),
dat.utils.requestAnimationFrame = (function () {

  /**
   * requirejs version of Paul Irish's RequestAnimationFrame
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   */

  return window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function(callback, element) {

        window.setTimeout(callback, 1000 / 60);

      };
})(),
dat.dom.CenteredDiv = (function (dom, common) {


  var CenteredDiv = function() {

    this.backgroundElement = document.createElement('div');
    common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear'
    });

    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';

    this.domElement = document.createElement('div');
    common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
    });


    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);

    var _this = this;
    dom.bind(this.backgroundElement, 'click', function() {
      _this.hide();
    });


  };

  CenteredDiv.prototype.show = function() {

    var _this = this;

    this.backgroundElement.style.display = 'block';

    this.domElement.style.display = 'block';
    this.domElement.style.opacity = 0;
//    this.domElement.style.top = '52%';
    this.domElement.style.webkitTransform = 'scale(1.1)';

    this.layout();

    common.defer(function() {
      _this.backgroundElement.style.opacity = 1;
      _this.domElement.style.opacity = 1;
      _this.domElement.style.webkitTransform = 'scale(1)';
    });

  };

  CenteredDiv.prototype.hide = function() {

    var _this = this;

    var hide = function() {

      _this.domElement.style.display = 'none';
      _this.backgroundElement.style.display = 'none';

      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
      dom.unbind(_this.domElement, 'transitionend', hide);
      dom.unbind(_this.domElement, 'oTransitionEnd', hide);

    };

    dom.bind(this.domElement, 'webkitTransitionEnd', hide);
    dom.bind(this.domElement, 'transitionend', hide);
    dom.bind(this.domElement, 'oTransitionEnd', hide);

    this.backgroundElement.style.opacity = 0;
//    this.domElement.style.top = '48%';
    this.domElement.style.opacity = 0;
    this.domElement.style.webkitTransform = 'scale(1.1)';

  };

  CenteredDiv.prototype.layout = function() {
    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';
    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';
  };
  
  function lockScroll(e) {
    console.log(e);
  }

  return CenteredDiv;

})(dat.dom.dom,
dat.utils.common),
dat.dom.dom,
dat.utils.common);

/**
 * Namespace for KolorEyesNext alias KEN 
 * @namespace KEN
 * @type {Object}
 */
var KEN = KEN || {

    /**
     * Version number of KEN.
     * @name KEN.VERSION
     * @type {string}
     * @const
     */
    VERSION: '0.1.0',

    /**
     * Array of {@link KEN.Viewer} uids.
     * @name KEN.VIEWERS
     * @type {Array<string>}
     */
    VIEWERS: [],

    /**
     * Global debug switch.
     * @name KEN.DEBUG
     * @type {boolean}
     */
    DEBUG: false,

    /**
     * Global warning switch.
     * @name  KEN.WARNING
     * @type {boolean}
     */
    WARNING: false
};

/**
 * This KEN.BaseObject is the from most of KEN classes inherits.<br>
 * Its main purpose is to name objects with a class name (a type) and to have a destroy method that handles an "alive" flag.
 *
 * @constructor KEN.BaseObject
 * @param {string} className - The class name of the object.
 *
 * @todo  See if we can trace inheritance.
 */
KEN.BaseObject = function(className)
{
    /**
     * The unique identifier of this object.
     * @name  KEN.BaseObject#_uid
     * @type {string}
     * @private
     */
    this._uid = "";

    /**
     * Array of tags that can be used to identify / classify this object.
     * @name  KEN.BaseObject#_tags
     * @type {?Array<string>}
     * @private
     */
    this._tags = null;

    /**
     * Custom data associated to this object.
     * @name  KEN.BaseObject#_data
     * @type {?*}
     * @private
     */
    this._data = null;

    /**
     * Internal refernce to the onDestroy {@link KEN.EventDispatcher}.
     * @name KEN.BaseObject#_onDestroy
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onDestroy = null;

    /**
     * Internal reference to the alive flag.
     * @name KEN.BaseObject#_alive
     * @type {boolean}
     * @private
     */
    this._alive = true;

    /**
     * Internal reference to the debug flag.
     * @name KEN.BaseObject#_debug
     * @type {boolean}
     * @private
     */
    this._debug = false;

    /**
     * Internal reference to the warning flag.
     * @name  KEN.BaseObject#_warning
     * @type {boolean}
     * @private
     */
    this._warning = false;

    /**
     * Array to store log if debug is enabled.
     * @name KEN.BaseObject#_logs
     * @type {?Array}
     * @private
     */
    this._logs = null;

    /**
     * Internal reference to the class name of the object that extends this base object.
     * @name KEN.BaseObject#_className
     * @type {string}
     * @private
     */
    this._className = className || "BaseObject";

    /**
     * Inheritance chain.
     * @name KEN.BaseObject#_inheritance
     * @type {Array<String>}
     * @private
     * @todo  Code this mechanism of type chain inheritance
     */
    this._inheritance = ["BaseObject"];
};

KEN.BaseObject.prototype.constructor = KEN.BaseObject;


/**
 * Registers the object in the uid index and bind to tag manager if tags set.
 * If no uid set, use a generated one.
 * @method KEN.BaseObject#_register
 * @private
 */
KEN.BaseObject.prototype._register = function()
{
    //Generate a uid if undefined
    if(typeof this._uid !== "string" || this._uid === "")
    {
        this._uid = KEN.UID.generate();
    }
    //Register in UID table
    var registered = KEN.UID.register(this);

    //If this object have tags associated to it.
    if(this._tags !== null)
    {
        //Maybe there is a single string typed tag, convert it to an array.
        if(typeof this._tags === "string")
        {
            this._tags = [this._tags];
        }

        //Register tags if it is an Array
        if(Array.isArray(this._tags) === true)
        {
            KEN.Tags.register(this);
        }
    }

    return registered;
};

/**
 * Unregisters the object in the uid index.
 * @method KEN.BaseObject#_unregister
 * @private
 */
KEN.BaseObject.prototype._unregister = function()
{
    if(this._uid !== "" && KEN.UID.exists(this._uid) === true)
    {
        KEN.UID.unregister(this);
    }
};

/**
 * That method describe how to output the log, can be overwritted by a debug plugin for example.
 * @method KEN.BaseObject#_stdout
 * @private
 * @param {*} value - The value you want to stdout.
 * @param {string} mode - The console method to use (default is log)
 */
KEN.BaseObject.prototype._stdout = function(value, mode)
{
    var m = mode || "log";
    console[m]("KEN."+this._className+" : "+value);

    if(typeof value === "object" && value !== null)
    {
        console[m](value);
    }
};

/**
 * Basic log method, log a string in the console if debug is enabled.
 * @method KEN.BaseObject#log
 * @param {*} value - The value you want to log in the console.
 */
KEN.BaseObject.prototype.log = function(value)
{
    if(KEN.DEBUG === true || KEN[this._className]["DEBUG"] === true || this._debug === true)
    {
        this._stdout(value, "log");

        if(this._logs === null)
        {
            this._logs = [];
        }

        this._logs.push(value);
    }
};

/**
 * Basic warn method, log a warn string in the console if warning is enabled.
 * @method KEN.BaseObject#warn
 * @param {?(string|Object)} value - The value you want to warn in the console.
 */
KEN.BaseObject.prototype.warn = function(value)
{
    if(KEN.WARNING === true || KEN[this._className]["WARNING"] === true || this._warning === true)
    {
        this._stdout(value, "warn");
    }
};

/**
 * Basic destroy method, prevent double destroy, change the alive flag.
 * @method KEN.BaseObject#destroy
 */
KEN.BaseObject.prototype.destroy = function()
{
    if(this._alive === false)
    {
        return;
    }

    this._unregister();

    if(this._onDestroy !== null)
    {
        this._onDestroy.dispatch();
        this._onDestroy.destroy();
        this._onDestroy = null;
    }

    this._data = null;

    this._alive = false;
};

/**
 * Get the class name of the object.
 * @name KEN.BaseObject#className
 * @readonly
 * @type {string}
 */
KEN.BaseObject.prototype.className;
Object.defineProperty(KEN.BaseObject.prototype, "className",
{
    /** @this {KEN.BaseObject} */
    get: function()
    {
        return this._className;
    }

});

/**
 * Get the uid of the object.
 * @name KEN.BaseObject#uid
 * @readonly
 * @type {string}
 */
KEN.BaseObject.prototype.uid;
Object.defineProperty(KEN.BaseObject.prototype, "uid",
{
    /** @this {KEN.BaseObject} */
    get: function()
    {
        return this._uid;
    }
});

/**
 * Get the tags associated to this object.
 * @name KEN.BaseObject#tags
 * @readonly
 * @type {Array}
 */
KEN.BaseObject.prototype.tags;
Object.defineProperty(KEN.BaseObject.prototype, "tags",
{
    /** @this {KEN.BaseObject} */
    get: function()
    {
        return this._tags;
    }
});

/**
 * Get the alive flag value of the object.
 * @name KEN.BaseObject#alive
 * @readonly
 * @type {boolean}
 */
KEN.BaseObject.prototype.alive;
Object.defineProperty(KEN.BaseObject.prototype, "alive",
{
    /** @this {KEN.BaseObject} */
    get: function()
    {
        return this._alive;
    }
});

/**
* Get and set any custom data you want to associate to this object.
* @name KEN.BaseObject#data
* @type {*}
*/
KEN.BaseObject.prototype.data;
Object.defineProperty(KEN.BaseObject.prototype, "data",
{
    /** @this {KEN.BaseObject} */
    get: function()
    {
        return this._data;
    },

    /** @this {KEN.BaseObject} */
    set: function(value)
    {
        this._data = value;
    }
});

/**
 * Get and set the debug flag.
 * @name KEN.BaseObject#debug
 * @type {boolean}
 */
KEN.BaseObject.prototype.debug;
Object.defineProperty(KEN.BaseObject.prototype, "debug",
{
    /** @this {KEN.BaseObject} */
    get: function()
    {
        return this._debug;
    },

    /** @this {KEN.BaseObject} */
    set: function(value)
    {
        this._debug = Boolean(value);

        if(this._debug === true)
        {
            console.log("Enabling debug for a KEN."+this._className+" instance :");
            console.log(this);
        }
    }
});

/**
 * Get and set the warning flag.
 * @name KEN.BaseObject#warning
 * @type {boolean}
 */
KEN.BaseObject.prototype.warning;
Object.defineProperty(KEN.BaseObject.prototype, "warning",
{
    /** @this {KEN.BaseObject} */
    get: function()
    {
        return this._warning;
    },

    /** @this {KEN.BaseObject} */
    set: function(value)
    {
        this._warning = Boolean(value);

        if(this._warning === true)
        {
            console.log("Enabling warning for a KEN."+this._className+" instance :");
            console.log(this);
        }
    }
});

/**
 * Get the onDestroy {@link KEN.EventDispatcher}, this event is emitted at the end of the destroy sequence.
 * @name KEN.BaseObject#onDestroy
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.BaseObject.prototype.onDestroy;
Object.defineProperty(KEN.BaseObject.prototype, "onDestroy",
{
    /** @this {KEN.BaseObject} */
    get: function()
    {
        if(this._onDestroy === null)
        {
            this._onDestroy = new KEN.EventDispatcher(this);
        }

        return this._onDestroy;
    }
});


/**
 * The main viewer class.
 *
 * @constructor KEN.Viewer
 * @param {ViewerConfig} config - Object that represents the viewer configuration.
 * @param {HTMLElement|string} parent - The parent element.
 * @param {?ViewerCallbacks} callbacks - On boot callbacks
 * @extends {KEN.BaseObject}
 *
 * @todo Create a KEN.Config Object to define default values, that can be overrided by the config param.
 */
KEN.Viewer = function(config, parent, callbacks)
{
    KEN.BaseObject.call(this, "Viewer");

    /**
     * The viewer configuration.
     * @name KEN.Viewer#_config
     * @type {?ViewerConfig}
     * @private
     */
    this._config = config || {};

    /**
     * Either the parent id or the parent DOM Element of the viewer.
     * @name KEN.Viewer#_parent
     * @type {Element|HTMLElement|string}
     * @private
     */
    this._parent = parent;

    /**
     * Reference to the DisplayList manager
     * @name KEN.DispalyList
     * @type {KEN.DisplayList}
     * @private
     */
    this._display = null;

    /**
     * The viewer container reference.
     * @name KEN.Viewer#_container
     * @type {KEN.DisplayObjectContainer}
     * @private
     */
    this._container = null;

    /**
     * The canvas container reference.
     * @name KEN.Viewer#_canvasContainer
     * @type {KEN.DisplayObjectContainer}
     * @private
     */
    this._canvasContainer = null;

    /**
     * The DOM hotspot container reference.
     * @name KEN.Viewer#_domHotspotContainer
     * @type {KEN.DisplayObjectContainer}
     * @private
     */
    this._domHotspotContainer = null;

    /**
     * The plugins container reference.
     * @name KEN.Viewer#_pluginContainer
     * @type {KEN.DisplayObjectContainer}
     * @private
     */
    this._pluginContainer = null;

    /**
     * The canvas reference.
     * @name KEN.Viewer#_canvas
     * @type {KEN.Canvas}
     * @private
     */
    this._canvas = null;

    /**
     * Audio / mixer interface reference.
     * @name KEN.Viewer#_audio
     * @type {KEN.SoundManager}
     * @private
     */
    this._audio = null;

    /**
     * Playlists interface reference.
     * @name KEN.Viewer#_playlists
     * @type {KEN.PlaylistManager}
     * @private
     */
    this._playlists = null;

    /**
     * Hotspots interface reference.
     * @name  KEN.Viewer#_hotspots
     * @type {KEN.HotspotManager}
     * @private
     */
    this._hotspots = null;

    /**
     * Action manager reference.
     * @name KEN.Viewer#_actions
     * @type {KEN.ActionManager}
     * @private
     */
    this._actions = null;

    /**
     * Dependencies interface reference.
     * @name  KEN.Viewer#_dependencies
     * @type {KEN.DependencyManager}
     * @private
     */
    this._dependencies = null;

    /**
     * Director's cut track manager
     * @name  KEN.Viewer#_director
     * @type {KEN.Director}
     * @private
     */
    this._director = null;

    /**
     * Controller manager.
     * @name KEN.Viewer#_controls
     * @type {KEN.ControllerManager}
     * @private
     */
    this._controls = null;

    /**
     * Post processing.
     * @name  KEN.Viewer#_postProcessing
     * @type {KEN.PostProcessing}
     * @private
     */
    this._postProcessing = null;

    /**
     * Tour reference.
     * @name KEN.Viewer#_tour
     * @type {KEN.Tour}
     * @private
     */
    this._tour = null;

    /**
     * History manager reference.
     * @name KEN.Viewer#_history
     * @type {KEN.History}
     * @private
     */
    this._history = null;

    /**
     * Loader reference.
     * @name KEN.Viewer#_load
     * @type {KEN.Loader}
     * @private
     */
    this._load = null;

    /**
     * Cache reference.
     * @name KEN.Viewer#_cache
     * @type {KEN.Cache}
     * @private
     */
    this._cache = null;

    /**
     * Keyboard interface.
     * @name KEN.Viewer#_keyboard
     * @type {KEN.Keyboard}
     * @private
     */
    this._keyboard = null;

    /**
     * Plugins interface reference.
     * @name KEN.Viewer#_plugins
     * @type {KEN.PluginManager}
     * @private
     */
    this._plugins = null;

    /**
     * Main loop reference.
     * @name KEN.Viewer#_raf
     * @type {KEN.RequestAnimationFrame}
     * @private
     */
    this._raf = null;

    /**
     * Handle viewer clock reference.
     * @name KEN.Viewer#_clock
     * @type {KEN.Clock}
     * @private
     */
    this._clock = null;

    /**
     * Tween Manager reference.
     * @name KEN.Viewer#_tween
     * @type {KEN.TweenManager}
     * @private
     */
    this._tween = null;

    /**
     * i18n and locales interface reference.
     * @name KEN.Viewer#_i18n
     * @type {KEN.LocaleManager}
     * @private
     */
    this._i18n = null;

    /**
     * Renderer reference.
     * @name KEN.Viewer#_renderManager
     * @type {KEN.RenderManager}
     * @private
     */
    this._renderManager = null;

    /**
     * Raycaster.
     * @name KEN.Viewer#_raycaster
     * @type {KEN.Raycaster}
     * @private
     */
    this._raycaster = null;

    /**
     * Paused state of the main loop.
     * @name KEN.Viewer#_paused
     * @type {boolean}
     * @private
     */
    this._paused = false;

    /**
     * Flag to know if the viewer is ready
     * @name  KEN.Viewer#_ready
     * @type {boolean}
     * @private
     */
    this._ready = false;

    /**
     * Is this instance is booted?
     * @name KEN.Viewer#_isBooted
     * @type {boolean}
     * @private
     */
    this._isBooted = false;

    /**
     * Event dispatcher for the viewer on ready event. Dispatched after the boot sequence.
     * @name  KEN.Viewer#_onReady
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onReady = null;

    /**
     * Event dispatcher for the on pause event.
     * @name  KEN.Viewer#_onPause
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * Event dispatcher for the on resume event.
     * @name  KEN.Viewer#_onResume
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onResume = null;

    /**
     * Callback function for the viewer.
     * @name KEN.Viewer#_callbacks
     * @type {?ViewerCallbacks}
     * @private
     */
    this._callbacks = callbacks || null;
};

KEN.Viewer.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Viewer.prototype.constructor = KEN.Viewer;

/**
 * Boot sequence.
 * @method KEN.Viewer#boot
 * @param {Function} callback - Callback function.
 */
KEN.Viewer.prototype.boot = function(callback)
{
    if(this._isBooted === true)
    {
        return;
    }

    /**
     * WARNING THE ORDER OF THE BOOT SEQUENCE MATTERS A LOT!
     * DO NOT CHANGE ANYTHING UNLESS YOU ARE SURE OF WHAT YOURE DOING
     */

    this._uid = "KEN-instance-"+String(KEN.VIEWERS.length);
    KEN.VIEWERS.push(this._uid);
    this._register();

    this.log("KEN.Viewer.boot();");

    this._display = new KEN.DisplayList(this);

    this._createContainers();
    this._createCanvas();

    this._dependencies = new KEN.DependencyManager(this);
    this._clock = new KEN.Clock(this);
    this._audio = new KEN.SoundManager(this);
    this._raf = new KEN.RequestAnimationFrame(this);
    this._i18n = new KEN.LocaleManager(this);
    this._tour = new KEN.Tour(this);
    this._history = new KEN.History(this);
    this._renderManager = new KEN.RenderManager(this);
    this._controls = new KEN.ControllerManager(this);
    this._playlists = new KEN.PlaylistManager(this);
    this._plugins = new KEN.PluginManager(this);
    this._hotspots = new KEN.HotspotManager(this);
    this._actions = new KEN.ActionManager(this);
    this._director = new KEN.Director(this);
    this._postProcessing = new KEN.PostProcessing(this);
    this._raycaster = new KEN.Raycaster(this);

    this._keyboard = new KEN.Keyboard(this);
    this._cache = new KEN.Cache(this);
    this._load = new KEN.Loader(this);
    this._tween = new KEN.TweenManager(this);

    this._audio.boot();
    this._raf.boot();
    this._i18n.boot();
    this._tour.boot();
    this._playlists.boot();
    this._plugins.boot();
    this._hotspots.boot();
    this._actions.boot();
    this._controls.boot();

    this._isBooted = true;

    this.log("KEN is alive !");

    //Call the boot method argument callback
    if(typeof callback === "function")
    {
        callback.call();
    }

    //Call the viewer constructor callback
    if(this._callbacks !== null && typeof this._callbacks.boot === "function")
    {
        this._callbacks.boot.call();
    }

    this._raf.start();

    this._ready = true;

    if(this._onReady !== null)
    {
        this._onReady.dispatch();
    }
};

/**
 * Create all containers into the DOM.
 * @method KEN.Viewer#_createContainers
 * @private
 */
KEN.Viewer.prototype._createContainers = function()
{
    if(typeof this._parent === "string" && this._parent !== "")
    {
        this._parent = document.getElementById(this._parent);
    }

    if(typeof this._parent === "undefined" || this._parent === null || KEN.Dom.isHtmlElement(this._parent) === false)
    {
        throw "KEN.Viewer.boot : Viewer parent is invalid";
    }

    this._container = new KEN.DisplayObjectContainer(this, null, null, /** @type {Element} */ (this._parent));
    this._container["id"] = "KEN-main-container-"+this._uid;
    this._container["background"] = (typeof this._config["background"] === "string") ? this._config["background"] : "#000";

    this._canvasContainer = new KEN.DisplayObjectContainer(this);
    this._canvasContainer["id"] = "KEN-canvas-container-"+this._uid;
    this._container["index"] = 0;
    this._canvasContainer.maximize(true);
    this._container.addChild(this._canvasContainer);

    this._domHotspotContainer = new KEN.DisplayObjectContainer(this);
    this._domHotspotContainer["id"] = "KEN-dom-hotspot-container-"+this._uid;
    this._container["index"] = 0;
    this._domHotspotContainer.maximize(true);
    this._container.addChild(this._domHotspotContainer);

    this._pluginContainer = new KEN.DisplayObjectContainer(this);
    this._pluginContainer["id"] = "KEN-plugin-container-"+this._uid;
    this._container["index"] = 0;
    this._pluginContainer.maximize(true);
    this._container.addChild(this._pluginContainer);
};

/**
 * Create the canvas into the DOM.
 * @method KEN.Viewer#_createCanvas
 * @private
 */
KEN.Viewer.prototype._createCanvas = function()
{
    this._canvas = new KEN.Canvas(this);
    this._canvas.maximize(true);
    this._canvasContainer.addChild(this._canvas);
};

/**
 * Update class informations on main loop.
 * @method KEN.Viewer#_updateLogic
 * @private
 */
KEN.Viewer.prototype._updateLogic = function()
{
    this._display.update();
    this._keyboard.update();
    this._audio.update();
    this._plugins.update();
    this._tween.update();
    this._hotspots.update();
    this._controls.update();

    if(this._callbacks !== null && typeof this._callbacks.update === "function")
    {
        this._callbacks.update.call();
    }
};

/**
 * Update scene rendering on main loop.
 * @method KEN.Viewer#_updateRendering
 * @private
 */
KEN.Viewer.prototype._updateRendering = function()
{
    if (this._renderManager !== null)
    {
        this._renderManager.render();
    }
};



/**
 * Update method called by the viewer main loop.
 * @method KEN.Viewer#update
 * @param  {number} time - Time in ms
 */
KEN.Viewer.prototype.update = function(time)
{
    if(this._paused === true)
    {
        return;
    }

    //Update the global clock
    this._clock.update(time);

    this._updateLogic();
    this._updateRendering();
};

/**
 * Pause the refresh on the main loop.
 * @method KEN.Viewer#pause
 */
KEN.Viewer.prototype.pause = function()
{
    this._paused = true;

    if(this._onPause !== null)
    {
        this._onPause.dispatch();
    }
};

/**
 * Resume the refresh on the main loop.
 * @method KEN.Viewer#resume
 */
KEN.Viewer.prototype.resume = function()
{
    this._paused = false;

    if(this._onResume !== null)
    {
        this._onResume.dispatch();
    }
};

/**
 * Destroy method.
 * @method KEN.Viewer#destroy
 */
KEN.Viewer.prototype.destroy = function()
{

    /**
     * WARNING THE ORDER OF THE DESTROY SEQUENCE MATTERS A LOT!
     * DO NOT CHANGE ANYTHING UNLESS YOU ARE SURE OF WHAT YOURE DOING
     */

    this._raf.stop();

    this._config = null;

    this._parent = null;

    this._plugins.destroy();
    this._plugins = null;

    this._raf.destroy();
    this._raf = null;

    this._load.destroy();
    this._load = null;

    this._history.destroy();
    this._history = null;

    this._clock.destroy();
    this._clock = null;

    this._keyboard.destroy();
    this._keyboard = null;

    this._renderManager.destroy();
    this._renderManager = null;

    this._canvas.destroy();
    this._canvas = null;

    this._canvasContainer.destroy();
    this._canvasContainer = null;

    this._domHotspotContainer.destroy();
    this._domHotspotContainer = null;

    this._hotspots.destroy();
    this._hotspots = null;

    this._director.destroy();
    this._director = null;

    this._postProcessing.destroy();
    this._postProcessing = null;

    this._pluginContainer.destroy();
    this._pluginContainer = null;

    this._actions.destroy();
    this._actions = null;

    this._container.destroy();
    this._container = null;

    this._display.destroy();
    this._display = null;

    this._playlists.destroy();
    this._playlists = null;

    this._audio.destroy();
    this._audio = null;

    this._tour.destroy();
    this._tour = null;

    this._cache.destroy();
    this._cache = null;

    this._tween.destroy();
    this._tween = null;

    this._i18n.destroy();
    this._i18n = null;

    this._raycaster.destroy();
    this._raycaster = null;

    this._controls.destroy();
    this._controls = null;

    this._callbacks = null;

    if(this._onReady !== null)
    {
        this._onReady.destroy();
        this._onReady = null;
    }

    if(this._onPause !== null)
    {
        this._onPause.destroy();
        this._onPause = null;
    }

    if(this._onResume !== null)
    {
        this._onResume.destroy();
        this._onResume = null;
    }

    KEN.VIEWERS.splice(this._uid, 1);

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the viewer ready status.
 * @name KEN.Viewer#ready
 * @type {boolean}
 * @readonly
 */
KEN.Viewer.prototype.ready;
Object.defineProperty(KEN.Viewer.prototype, "ready",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._ready;
    }
});

/**
 * Get the viewer configuration.
 * @name KEN.Viewer#config
 * @type {ViewerConfig}
 * @readonly
 */
KEN.Viewer.prototype.config;
Object.defineProperty(KEN.Viewer.prototype, "config",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._config;
    }
});

/**
 * Get the viewer parent element.
 * @name KEN.Viewer#parent
 * @type {HTMLElement|String}
 * @readonly
 */
KEN.Viewer.prototype.parent;
Object.defineProperty(KEN.Viewer.prototype, "parent",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._parent;
    }
});

/**
 * Get the viewer display list manager.
 * @name KEN.Viewer#display
 * @type {KEN.DisplayList}
 * @readonly
 */
KEN.Viewer.prototype.display;
Object.defineProperty(KEN.Viewer.prototype, "display",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._display;
    }
});

/**
 * Get and set the fullscreen property of the viewer main container.
 * @name KEN.Viewer#fullscreen
 * @type {boolean}
 */
KEN.Viewer.prototype.fullscreen;
Object.defineProperty(KEN.Viewer.prototype, "fullscreen",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._container.isFullscreen();
    },

    /** @this {KEN.Viewer} */
    set: function(value)
    {
        if(typeof value !== "boolean" || this._container.isFullscreen() === value)
        {
            return;
        }

        this._container["fullscreen"] = value;
    }
});

/**
 * Get the viewer container.
 * @name KEN.Viewer#container
 * @type {KEN.DisplayObjectContainer}
 * @readonly
 */
KEN.Viewer.prototype.container;
Object.defineProperty(KEN.Viewer.prototype, "container",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._container;
    }
});

/**
 * Get the viewer canvas container.
 * @name KEN.Viewer#canvasContainer
 * @type {KEN.DisplayObjectContainer}
 * @readonly
 */
KEN.Viewer.prototype.canvasContainer;
Object.defineProperty(KEN.Viewer.prototype, "canvasContainer",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._canvasContainer;
    }
});

/**
 * Get the viewer canvas.
 * @name KEN.Viewer#canvas
 * @type {KEN.Canvas}
 * @readonly
 */
KEN.Viewer.prototype.canvas;
Object.defineProperty(KEN.Viewer.prototype, "canvas",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._canvas;
    }
});

/**
 * Get the viewer DOM hotspot container.
 * @name KEN.Viewer#domHotspotContainer
 * @type {KEN.DisplayObjectContainer}
 * @readonly
 */
KEN.Viewer.prototype.domHotspotContainer;
Object.defineProperty(KEN.Viewer.prototype, "domHotspotContainer",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._domHotspotContainer;
    }
});

/**
 * Get the viewer plugin container.
 * @name KEN.Viewer#pluginContainer
 * @type {KEN.DisplayObjectContainer}
 * @readonly
 */
KEN.Viewer.prototype.pluginContainer;
Object.defineProperty(KEN.Viewer.prototype, "pluginContainer",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._pluginContainer;
    }
});

/**
 * Get the viewer request animation frame interface.
 * @name KEN.Viewer#raf
 * @type {KEN.RequestAnimationFrame}
 * @readonly
 */
KEN.Viewer.prototype.raf;
Object.defineProperty(KEN.Viewer.prototype, "raf",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._raf;
    }
});

/**
 * Get the viewer audio/sound interface.
 * @name KEN.Viewer#audio
 * @type {KEN.SoundManager}
 * @readonly
 */
KEN.Viewer.prototype.audio;
Object.defineProperty(KEN.Viewer.prototype, "audio",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._audio;
    }
});

/**
 * Get the viewer playlists for sounds.
 * @name KEN.Viewer#playlists
 * @type {KEN.PlaylistManager}
 * @readonly
 */
KEN.Viewer.prototype.playlists;
Object.defineProperty(KEN.Viewer.prototype, "playlists",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._playlists;
    }
});

/**
 * Get the viewer hotspots module.
 * @name KEN.Viewer#hotspots
 * @type {KEN.HotspotManager}
 * @readonly
 */
KEN.Viewer.prototype.hotspots;
Object.defineProperty(KEN.Viewer.prototype, "hotspots",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._hotspots;
    }
});

/**
 * Get the viewer action manager.
 * @name KEN.Viewer#actions
 * @type {KEN.ActionManager}
 * @readonly
 */
KEN.Viewer.prototype.actions;
Object.defineProperty(KEN.Viewer.prototype, "actions",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._actions;
    }
});

/**
 * Get the viewer dependencies module.
 * @name  KEN.Viewer#dependencies
 * @type {KEN.DependencyManager}
 * @readonly
 */
KEN.Viewer.prototype.dependencies;
Object.defineProperty(KEN.Viewer.prototype, "dependencies",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._dependencies;
    }
});

/**
 * Get the director's cut track manager.
 * @name KEN.Viewer#director
 * @type {KEN.Director}
 * @readonly
 */
KEN.Viewer.prototype.director;
Object.defineProperty(KEN.Viewer.prototype, "director",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._director;
    }
});

/**
 * Get the viewer tour data.
 * @name KEN.Viewer#tour
 * @type {KEN.Tour}
 * @readonly
 */
KEN.Viewer.prototype.tour;
Object.defineProperty(KEN.Viewer.prototype, "tour",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._tour;
    }
});

/**
 * Get the history module.
 * @name KEN.Viewer#history
 * @type {KEN.History}
 * @readonly
 */
KEN.Viewer.prototype.history;
Object.defineProperty(KEN.Viewer.prototype, "history",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._history;
    }
});

/**
 * Get the viewer loader.
 * @name KEN.Viewer#load
 * @type {KEN.Loader}
 * @readonly
 */
KEN.Viewer.prototype.load;
Object.defineProperty(KEN.Viewer.prototype, "load",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._load;
    }
});

/**
 * Get the viewer cache.
 * @name KEN.Viewer#cache
 * @type {KEN.Cache}
 * @readonly
 */
KEN.Viewer.prototype.cache;
Object.defineProperty(KEN.Viewer.prototype, "cache",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._cache;
    }
});

/**
 * Get the viewer plugins interface.
 * @name KEN.Viewer#plugins
 * @type {KEN.PluginManager}
 * @readonly
 */
KEN.Viewer.prototype.plugins;
Object.defineProperty(KEN.Viewer.prototype, "plugins",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._plugins;
    }
});

/**
 * Get the raycaster instance.
 * @name KEN.Viewer#raycaster
 * @type {KEN.Raycaster}
 * @readonly
 */
KEN.Viewer.prototype.raycaster;
Object.defineProperty(KEN.Viewer.prototype, "raycaster",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._raycaster;
    }
});

/**
 * Get the viewer clock interface.
 * @name KEN.Viewer#clock
 * @type {KEN.Clock}
 * @readonly
 */
KEN.Viewer.prototype.clock;
Object.defineProperty(KEN.Viewer.prototype, "clock",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._clock;
    }
});

/**
 * Get the viewer tween interface.
 * @name KEN.Viewer#tween
 * @type {KEN.TweenManager}
 * @readonly
 */
KEN.Viewer.prototype.tween;
Object.defineProperty(KEN.Viewer.prototype, "tween",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._tween;
    }
});

/**
 * Get the viewer i18n and locales interface.
 * @name KEN.Viewer#i18n
 * @type {KEN.LocaleManager}
 * @readonly
 */
KEN.Viewer.prototype.i18n;
Object.defineProperty(KEN.Viewer.prototype, "i18n",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._i18n;
    }
});

/**
 * Get the viewer render manager.
 * @name KEN.Viewer#renderer
 * @type {KEN.RenderManager}
 * @readonly
 */
KEN.Viewer.prototype.renderer;
Object.defineProperty(KEN.Viewer.prototype, "renderer",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._renderManager;
    }
});

/**
 * Get controller manager.
 * @name KEN.Viewer#controllers
 * @readonly
 * @type {KEN.ControllerManager}
 */
KEN.Viewer.prototype.controllers;
Object.defineProperty(KEN.Viewer.prototype, "controllers",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._controls;
    }
});

/**
 * Get the postProcessing object.
 * @name KEN.Viewer#postProcessing
 * @type {KEN.PostProcessing}
 * @readonly
 */
KEN.Viewer.prototype.postProcessing;
Object.defineProperty(KEN.Viewer.prototype, "postProcessing",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._postProcessing;
    }
});

/**
 * Get the controller manager object.
 * @name KEN.Viewer#controls
 * @type {KEN.ControllerManager}
 * @readonly
 */
KEN.Viewer.prototype.controls;
Object.defineProperty(KEN.Viewer.prototype, "controls",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._controls;
    }
});

// /**
//  * Get the viewer camera interface.
//  * @name KEN.Viewer#camera
//  * @type {KEN.Camera}
//  * @readonly
//  */
// Object.defineProperty(KEN.Viewer.prototype, "camera",
// {
//     /** @this {KEN.Viewer} */
//     get: function()
//     {
//         return this._camera;
//     }
// });

/**
 * Get the viewer keyboard interface.
 * @name KEN.Viewer#keyboard
 * @type {KEN.Keyboard}
 * @readonly
 */
KEN.Viewer.prototype.keyboard;
Object.defineProperty(KEN.Viewer.prototype, "keyboard",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._keyboard;
    }
});

/**
 * Get and set the viewer width.
 * @name KEN.Viewer#width
 * @type {number}
 */
KEN.Viewer.prototype.width;
Object.defineProperty(KEN.Viewer.prototype, "width",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._container["width"];
    },

    /** @this {KEN.Viewer} */
    set: function(value)
    {
        this._container["width"] = value;
    }
});

/**
 * Get and set the viewer height.
 * @name KEN.Viewer#height
 * @type {number}
 */
KEN.Viewer.prototype.height;
Object.defineProperty(KEN.Viewer.prototype, "height",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        return this._container["height"];
    },

    /** @this {KEN.Viewer} */
    set: function(value)
    {
        this._container["height"] = value;
    }
});


/**
 * Get the "onReady" {@link KEN.EventDispatcher} of the viewer.
 * @name KEN.Viewer#onReady
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Viewer.prototype.onReady;
Object.defineProperty(KEN.Viewer.prototype, "onReady",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        if(this._onReady === null)
        {
            this._onReady = new KEN.EventDispatcher(this);
        }

        return this._onReady;
    }
});

/**
 * Get the "onPause" {@link KEN.EventDispatcher} of the viewer.
 * @name KEN.Viewer#onPause
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Viewer.prototype.onPause;
Object.defineProperty(KEN.Viewer.prototype, "onPause",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        if(this._onPause === null)
        {
            this._onPause = new KEN.EventDispatcher(this);
        }

        return this._onPause;
    }
});

/**
 * Get the "onResume" {@link KEN.EventDispatcher} of the viewer.
 * @name KEN.Viewer#onResume
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Viewer.prototype.onResume;
Object.defineProperty(KEN.Viewer.prototype, "onResume",
{
    /** @this {KEN.Viewer} */
    get: function()
    {
        if(this._onResume === null)
        {
            this._onResume = new KEN.EventDispatcher(this);
        }

        return this._onResume;
    }
});
/**
 * Manage Tags inside KEN.
 * Tags is singleton, so if you have multiple instances in the same page you MUST avoid Tags conflict.
 * @constructor
 * @extends {KEN.BaseObject}
 */
KEN.Tags = (function(c)
{
    var Tmp = c();
    Tmp.prototype = Object.create(KEN.BaseObject.prototype);
    Tmp.prototype.constructor = Tmp;

    /**
     * Register a tagged object.
     * @method KEN.Tags.register
     * @param  {Object} object - The object you want to register into the tag index.
     */
    Tmp.prototype.register = function(object)
    {
        if(typeof object === "object" && typeof object["uid"] === "string" && Array.isArray(object["tags"]))
        {
            var uid = object["uid"];
            var tags = object["tags"];
            var tag;

            if(KEN.UID.exists(uid) === true)
            {
                //this._objects[uid] = object;
                for(var i = 0, ii = tags.length; i < ii; i++)
                {
                    tag = tags[i];

                    //Skip if a tag is not a string, this is an error!
                    if(typeof tag !== "string")
                    {
                        this.warn("Tags: An object has a tag that isn't a string!");
                        continue;
                    }

                    //If the tag is unknow, add an entry to the tags array
                    if(typeof this._allTags[tag] === "undefined")
                    {
                        this._allTags[tag] = [];

                        if(this._onRegister !== null)
                        {
                            this._onRegister.dispatch({"tag": tag});
                        }
                    }

                    if(this._allTags[tag].indexOf(uid) === -1)
                    {
                        this._allTags[tag].push(uid);
                    }
                }
            }
            else
            {
                this.warn("Tags: The object you want to register in tags is not known by UID!");
                this.warn(object);
            }
        }
        else
        {
            this.warn("Tags: No uid or no tags on the object you try to register!");
            this.warn(object);
        }
    };

    /**
     * Get uids associated to a tag or to an array of tags.<br>
     * You can filter the className of objets to get.
     * @method KEN.Tags.getUids
     * @param  {string|Array} value - The uid or array of uids of object(s) you want to get.
     * @param  {string} className  - Filter you result by className of objects.
     * @return {Array<string>}  Returns an array of uids that matches the request.
     */
    Tmp.prototype.getUids = function(value, className)
    {
        var uids = [];

        if(typeof value === "string")
        {
            uids = this._allTags[value];
        }
        else if(Array.isArray(value))
        {
            var tag;
            for(var i = 0, ii = value.length; i < ii; i++)
            {
                tag = value[i];
                if(this.exists(tag) === true)
                {
                    uids.concat(this.get[tag]);
                }
            }
        }

        if(typeof className === "string")
        {
            uids = KEN.UID.filterType(uids, className);
        }

        return uids;
    };

    /**
     * Get objects associated to a tag or to an array of tags.<br>
     * You can filter the className of objets to get.
     * @method KEN.Tags.get
     * @param  {(string|Array)} value - The uid or array of uids of object(s) you want to get.
     * @param {string} className - Filter you result by className of objects.
     * @return {(Object|Array|undefined)} Returns an object or an array of objects that matches the request.
     */
    Tmp.prototype.get = function(value, className)
    {
        if(typeof value === "string")
        {
            return KEN.UID.get(this._allTags[value], className);
        }
        else if(Array.isArray(value))
        {
            var uids = [];
            var tag;
            for(var i = 0, ii = value.length; i < ii; i++)
            {
                tag = value[i];
                if(this.exists(tag) === true)
                {
                    uids.concat(this.get[tag]);
                }
            }

            return KEN.UID.get(uids, className);
        }

        return undefined;
    };

    /**
     * Tell if this tag have at least an object of a specific className.
     * @method  KEN.Tags.hasTypeOf
     * @param  {string}  tag - The tag you want to check if it reference an onbject of specified className.
     * @param {string} className - The className you want to check.
     * @return {boolean} Returns true if the tag have at least an object of the asked className.
     */
    Tmp.prototype.hasTypeOf = function(tag, className)
    {
        if(this.exists(tag) === true)
        {
            var uids = this._allTags[tag];

            for (var i = 0, ii = this._allTags.length; i < ii; i++)
            {
                if(KEN.UID.isTypeOf(uids[i], className) === true)
                {
                    return true;
                }
            }
        }

        return false;
    };

    /**
     * Does a tag exists ?
     * @method KEN.Tags.exists
     * @param  {string} tag - The tag you want to check.
     * @return {boolean} Returns true if uid is already registered, false if not.
     */
    Tmp.prototype.exists = function(tag)
    {
        return (typeof this._allTags[tag] !== "undefined" && this._allTags[tag] !== null);
    };

    /**
     * Get the list of all existing tags.
     * @name  KEN.Tags#list
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "list",
    {
        get: function()
        {
            return Object.keys(this._allTags);
        }
    });

    /**
     * Get the on add event dispatcher.
     * @name  KEN.Tags#onRegister
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "onRegister",
    {
        get: function()
        {
            if(this._onRegister === null)
            {
                this._onRegister = new KEN.EventDispatcher(this);
            }

            return this._onRegister;
        }
    });

    return new Tmp();
})(function()
{
    return function()
    {
        /**
         * The object that reference all tags objects couples.
         * @name KEN.Tags#_allTags
         * @type {Object}
         * @private
         */
        this._allTags = {};

        /**
         * Event dispatcher for add tag event.
         * @name  KEN.Tags#_onRegister
         * @type {KEN.EventDispatcher}
         * @private
         */
        this._onRegister = null;

        KEN.BaseObject.call(this, "Tags");
    };
});
/**
 * Manage UIDs inside KEN.<br>
 * UID is singleton, so if you have multiple instances in the same page you MUST avoid UID conflict.
 * @constructor
 * @extends {KEN.BaseObject}
 */
KEN.UID = (function(c)
{
    var Tmp = c();
    Tmp.prototype = Object.create(KEN.BaseObject.prototype);
    Tmp.prototype.constructor = Tmp;

    /**
     * Generate a uid.
     * @method KEN.UID.generate
     * @param {string=} prefix - a prefix can be added to the UID, by default it will be 'ken-uid'
     * @return {string} Return a UID string.
     */
    Tmp.prototype.generate = function(prefix)
    {
        var p = prefix || "ken-uid";
        var uid = p + "-" + this._uidIncrement;
        this._uidIncrement++;

        if (KEN.UID.exists(uid) === false)
        {
            return uid;
        }
        else
        {
            return KEN.UID.generate(prefix);
        }
    };

    /**
     * Validate recursively a uid.
     * @method KEN.UID.validate
     * @param  {Object} object - The object you want to validate into the index.
     * @return {boolean} Returns the validate status.
     */
    Tmp.prototype.validate = function(object)
    {
        var uids = [];

        var validateRecursive = function(object)
        {
            var uid;

            for (var i in object)
            {
                if (i === "uid")
                {
                    uid = object[i];

                    if (typeof uid === "string")
                    {
                        if (KEN.UID.exists(uid))
                        {
                            throw "UID configuration not valid, uid " + uid + " already have an object binded to!";
                        }
                        else if (uids.indexOf(uid) !== -1)
                        {
                            throw "UID configuration not valid, uid " + uid + " is in double in config file!";
                        }
                        else
                        {
                            uids.push(object[i]);
                        }
                    }
                    else
                    {
                        throw "Found a uid in configuration that is not a string!";
                    }
                }
                else if (typeof(object[i]) === "object")
                {
                    validateRecursive(object[i]);
                }
            }

            return true;
        };

        return validateRecursive(object);
    };


    /**
     * Register an object into the uid index.
     * @method KEN.UID.register
     * @param  {Object} object - The object you want to register into the index.
     * @return {boolean} Return true if the object is added to UID, false if not.
     */
    Tmp.prototype.register = function(object)
    {
        if (typeof object === "object" && typeof object["uid"] === "string")
        {
            var uid = object["uid"];

            if (KEN.UID.exists(uid) === false)
            {
                this._objects[uid] = object;
                return true;
            }
            else
            {
                this.warn("The uid you want to register already exists!");
                this.warn(object);
            }
        }
        else
        {
            this.warn("No uid on the object you try to register!");
            this.warn(object);
        }

        return false;
    };

    /**
     * Unregister an object from the uid index.
     * @method KEN.UID.unregister
     * @param  {Object} object - The object you want to unregister from the index.
     */
    Tmp.prototype.unregister = function(object)
    {
        if (typeof object === "object" && typeof object["uid"] === "string")
        {
            var uid = object["uid"];
            this._objects[uid] = null;
            delete this._objects[uid];
            return;
        }

        this.warn("No uid on the object you try to unregister!");
    };

    /**
     * Get all uids or uids of a specific className.
     * @method  KEN.UID.getuids
     * @param  {string} className - Type of uids you want to get, if undefined this will return all the uids.
     * @return {Array<string>} Returns an array of uids.
     */
    Tmp.prototype.getUids = function(className)
    {
        if (typeof className === "undefined" || className === null)
        {
            return Object.keys(this._objects);
        }
        else
        {
            return KEN.UID.filterType(Object.keys(this._objects), className);
        }
    };

    /**
     * Filter an array of uids and return only uids of a specific className.
     * @method KEN.UID.filterType
     * @param  {Array<string>} uids - Array of uids to filter by className.
     * @param  {string} className - Class name of object to filter.
     * @return {Array<string>} Returns an array of uids filtered by className.
     */
    Tmp.prototype.filterType = function(uids, className)
    {
        var filter = function(uid)
        {
            if (KEN.UID.isTypeOf(uid, className))
            {
                return true;
            }

            return false;
        };

        return uids.filter(filter);
    };

    /**
     * Get a registered object from its uid.
     * @method KEN.UID.get
     * @param  {string|Array} value - The uid or array of uids of object(s) you want to get.
     * @param  {string=} className - The className of the object you want
     * @return {*} Returns the object(s) related to the filters.
     */
    Tmp.prototype.get = function(value, className)
    {
        //If no value is passed, the whole uids array is used as values
        if (typeof value === "undefined" || value === null)
        {
            //If no value and no className, return all the objects.
            if (typeof className !== "string")
            {
                return this._objects;
            }

            value = Object.keys(this._objects);
        }

        if (typeof value === "string")
        {
            return this._objects[value];
        }
        else if (Array.isArray(value))
        {
            if (typeof className === "string")
            {
                value = KEN.UID.filterType(value, className);
            }

            var result = [];
            var uid;
            for (var i = 0, ii = value.length; i < ii; i++)
            {
                uid = value[i];
                if (KEN.UID.exists(uid) === true)
                {
                    result.push(this._objects[uid]);
                }
            }

            return result;
        }

        return undefined;
    };

    /**
     * Tell if this uid matches an object of a specific className.
     * @method  KEN.UID.isTypeOf
     * @param {string}  uid - uid of the object you want to check the className of.
     * @param {string} className - The className you want to check.
     * @return {boolean} Returns true if the object is of the asked className.
     */
    Tmp.prototype.isTypeOf = function(uid, className)
    {
        var object = KEN.UID.get(uid);
        return KEN.Utils.isTypeOf(object, className);
    };

    /**
     * Does a uid exists?
     * @method KEN.UID.exists
     * @param  {string} uid - The uid you want to check.
     * @return {boolean} Return true if uid is already registered, false if not.
     */
    Tmp.prototype.exists = function(uid)
    {
        return (typeof this._objects[uid] !== "undefined" && this._objects[uid] !== null);
    };

    return new Tmp();

})(function()
{
    return function()
    {
        /**
         * The prefix used to generate uids. 
         * @name KEN.UID#_prefix
         * @type {string}
         * @private
         */
        this._prefix = "ken-uid";

        /**
         * The current uid increment used to generate uids. 
         * @name KEN.UID#_uidIncrement
         * @type {number}
         * @private
         */
        this._uidIncrement = 0;

        /**
         * The object that reference all uids objects couples. 
         * @name KEN.UID#_objects
         * @type {Object}
         * @private
         */
        this._objects = {};

        KEN.BaseObject.call(this, "UID");
    };
});
/**
 * The KEN.Tour manages groups and scenes, the logic and the data of the virtual tour.
 *
 * @constructor KEN.Tour
 * @param {KEN.Viewer} viewer {@link KEN.Viewer} reference.
 * @extends {KEN.BaseObject}
 */
KEN.Tour = function(viewer)
{
    /**
    * The viewer reference.
    * @name KEN.Tour#_viewer
    * @type {KEN.Viewer}
    * @private
    */
    this._viewer = viewer;

    /**
     * The config object.
     * @name KEN.Tour#_config
     * @type {?TourConfig}
     * @private
     */
    this._config = null;

    /**
     * The internationalizable name of the tour.
     * @name KEN.Tour#_name
     * @type {?KEN.LocaleString}
     * @private
     */
    this._name = null;

    /**
     * The internationalizable slug name of the tour.
     * @name KEN.Tour#_slug
     * @type {?KEN.LocaleString}
     * @private
     */
    this._slug = null;

    /**
     * The internationalizable description of the tour.
     * @name KEN.Tour#_description
     * @type {?KEN.LocaleString}
     * @private
     */
    this._description = null;

    /**
     * The default uid to load, this can be a scene or a group uid.
     * @name KEN.Tour#_default
     * @type {string}
     * @private
     */
    this._default = "";

    /**
     * Array of {@link KEN.Scene} uid of the tour.
     * @name KEN.Tour#_scenes
     * @type {?Array<string>}
     * @private
     */
    this._scenes = null;

    /**
     * Uid of the current scene.
     * @name  KEN.Tour#_sceneUid
     * @type {string}
     * @private
     */
    this._sceneUid = "";

    /**
     * Array of {@link KEN.Group} uid of the tour.
     * @name KEN.Tour#_groups
     * @type {?Array<string>}
     * @private
     */
    this._groups = null;

    /**
     * Uid of the current group.
     * @name  KEN.Tour#_groupUid
     * @type {?string}
     * @private
     */
    this._groupUid = "";

    /**
     * On ready event dispatcher
     * @name  KEN.Tour#_onReady
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onReady = null;

    /**
     * On scene load start event dispatcher.
     * @name  KEN.Tour#_onSceneLoadStart
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onSceneLoadStart = null;

    /**
     * On scene load progress event dispatcher.
     * @name  KEN.Tour#_onSceneLoadProgress
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onSceneLoadProgress = null;

    /**
     * On scene load complete event dispatcher.
     * @name  KEN.Tour#_onSceneLoadComplete
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onSceneLoadComplete = null;

    /**
     * On scene load error event dispatcher.
     * @name  KEN.Tour#_onSceneLoadError
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onSceneLoadError = null;

    /**
     * On scene preview event dispatcher.
     * @name  KEN.Tour#_onScenePreview
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onScenePreview = null;

    /**
     * On group change event dispatcher.
     * @name  KEN.Tour#_onGroupChange
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onGroupChange = null;

    KEN.BaseObject.call(this, "Tour");

};

KEN.Tour.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Tour.prototype.constructor = KEN.Tour;

/**
 * Boot sequence.
 * @method KEN.Tour#boot
 */
KEN.Tour.prototype.boot = function()
{
    this.log("KEN.Tour.boot();");

    this._scenes = [];
    this._groups = [];

    this._name = new KEN.LocaleString(this._viewer);
    this._slug = new KEN.LocaleString(this._viewer);
    this._description = new KEN.LocaleString(this._viewer);
};

/**
 * Load a JSON tour configuration.
 * @method KEN.Tour#load
 * @param  {(string|TourConfig)} config - The URL of the configuration JSON file to load or a tour configuration object.
 */
KEN.Tour.prototype.load = function(config)
{
    this.log("KEN.Tour.load();");

    if(typeof config === "string")
    {
        this._viewer["load"].json("tour.config", config, this._configLoadComplete, this);
    }
    else if (typeof config === "object")
    {
        this._parseConfig(config);
    }
};

/**
 * Know if the tour have any {@link KEN.Scene}.
 * @method KEN.Tour#hasScenes
 * @return {boolean} Returns true if the tour have at least a {@link KEN.Scene}, false if not.
 */
KEN.Tour.prototype.hasScenes = function()
{
    return this._scenes.length !== 0;
};

/**
 * Know if the tour have any {@link KEN.Group}.
 * @method KEN.Tour#hasGroups
 * @return {boolean} Returns true if the tour have at least a {@link KEN.Group}, false if not.
 */
KEN.Tour.prototype.hasGroups = function()
{
    return this._groups.length !== 0;
};

/**
 * Load the next scene of the tour.
 * @method KEN.Tour#nextScene
 */
KEN.Tour.prototype.nextScene = function()
{
    var index = this._scenes.indexOf(this._sceneUid);
    var uid;

    if(index + 1 < this._scenes.length)
    {
        uid = this._scenes[index + 1];
    }
    else
    {
        uid = this._scenes[0];
    }

    this.loadScene(uid);
};

/**
 * Load the previous scene of the tour.
 * @method KEN.Tour#previousScene
 */
KEN.Tour.prototype.previousScene = function()
{
    var index = this._scenes.indexOf(this._sceneUid);
    var uid;

    if(index - 1 >= 0)
    {
        uid = this._scenes[index - 1];
    }
    else
    {
        uid = this._scenes[this._scenes.length - 1];
    }

    this.loadScene(uid);
};

/**
 * Event handler for the configuration JSON load complete.
 * @method KEN.Tour#_configLoadComplete
 * @private
 * @param  {KEN.File} file - The {@link KEN.File} that describes the loaded JSON file.
 */
KEN.Tour.prototype._configLoadComplete = function(file)
{
    this.log("KEN.Tour.loadComplete();");

    var json = this._viewer["cache"].get(KEN.Cache.types.JSON, file["key"]);
    var config = /** @type {TourConfig} */ (json["data"]);

    this._parseConfig(config);
};

/**
 * Parse the tour configuration.
 * @method KEN.Tour#_parseConfig
 * @private
 * @param  {TourConfig} config - The tour configuration to parse.
 */
KEN.Tour.prototype._parseConfig = function(config)
{
    if(KEN.UID.validate(config) !== true)
    {
        throw "Tour configuration is not valid!";
    }

    this._config = config;

    this._uid = this._config["uid"];
    this._register();

    this._default = this._config["default"];

    if (typeof this._config["i18n"] !== "undefined")
    {
        this._viewer["i18n"].addConfig(this._config["i18n"], true); //force the parse of the main config
    }

    // Set the keys for the locale strings
    this._name["key"] = this._config["name"];
    this._slug["key"] = this._config["slug"];
    this._description["key"] = this._config["description"];

    if(typeof this._config["scenes"] !== "undefined" && this._config["scenes"].length > 0)
    {
        this._createScenes(this._config["scenes"]);
    }

    if(typeof this._config["groups"] !== "undefined" && this._config["groups"].length > 0)
    {
        this._createGroups(this._config["groups"]);
    }

    if(typeof this._config["actions"] !== "undefined")
    {
        this._viewer["actions"].addConfig(this._config["actions"]);
    }

    if(typeof this._config["audio"] !== "undefined")
    {
        this._viewer["audio"].addConfig(this._config["audio"]);
    }

    if(typeof this._config["playlists"] !== "undefined")
    {
        this._viewer["playlists"].addConfig(this._config["playlists"]);
    }

    if(typeof this._config["director"] !== "undefined")
    {
        this._viewer["director"].addConfig(this._config["director"]);
    }

    if(typeof this._config["postProcessing"] !== "undefined")
    {
        this._viewer["postProcessing"].addConfig(this._config["postProcessing"]);
    }

    if(typeof this._config["controls"] !== "undefined")
    {
        this._viewer["controls"].addConfig(this._config["controls"]);
    }

    this._checkTourScenes();
};

/**
 * Check if all scenes have been loaded.
 * @method KEN.Tour#_checkTourScenes
 * @private
 */
KEN.Tour.prototype._checkTourScenes = function()
{
    if(typeof this._config["scenes"] === "undefined" || this._scenes.length === this._config["scenes"].length)
    {
        this._setTourReady();
    }
};

/**
 * Activate the tour and load the first scene.
 * @method KEN.Tour#_setTourReady
 * @private
 */
KEN.Tour.prototype._setTourReady = function()
{
    if(this._onReady !== null)
    {
        this._onReady.dispatch();
    }

    // If slug name in URL load the associated object
    // NB: I couldn't find another way to correctly access the property without minification
    var hashParameters = KEN.URL.parse()["hashParameters"];

    if(hashParameters !== null && typeof hashParameters["uid"] === "string")
    {
        this._loadUid(hashParameters["uid"]);

        // this._viewer["i18n"]["onLocaleChangeComplete"].addOnce(this._localeChangeCompleteHandler, this);
    }
    //Else if default uid
    else if(this._default !== "" && this._default !== null && KEN.UID.exists(this._default))
    {
        this._loadUid(this._default);
    }
    //Else load scene index 0
    else
    {
        this.loadScene(0);
    }
};

/**
 * Load an object by its uid. It can be a scene uid or a group uid.
 * @method KEN.Tour._loadUid
 * @private
 * @param  {string} uid - Uid of the object you want to load.
 */
KEN.Tour.prototype._loadUid = function(uid)
{
    if(KEN.UID.isTypeOf(uid, "Scene") === true || KEN.UID.isTypeOf(uid, "Group") === true)
    {
        KEN.UID.get(uid).load();
    }
};

/**
 * Create {@link KEN.Scene}s from scenes configuration object.
 * @method KEN.Tour#_createScenes
 * @private
 * @param  {Object} config - The object that describes the scenes, issued from the main configuration.
 */
KEN.Tour.prototype._createScenes = function(config)
{
    var scene;
    for(var i = 0, ii = config.length; i < ii; i++)
    {
        scene = new KEN.Scene(this._viewer, config[i]);

        //Scene is not booted at creation if the scene config is in an external file
        if(scene["booted"] === true)
        {
            this._addScene(scene);
        }
    }
};

/**
 * Event handler for scene loaded from an external json file into config.
 * @method  KEN.Tour#_sceneConfigComplete
 * @param  {KEN.Scene} scene - The scene that has finish to load its configuration.
 * @private
 */
KEN.Tour.prototype.notifySceneConfigLoadComplete = function(scene)
{
    this._addScene(scene);

    //check if all scenes are loaded
    this._checkTourScenes();
};

/**
 * Add a scene into the scenes array.
 * @param {KEN.Scene} scene - The scene to add.
 * @private
 */
KEN.Tour.prototype._addScene = function(scene)
{
    scene["onLoadStart"].add(this._sceneLoadStart, this);
    scene["onLoadComplete"].add(this._sceneLoadComplete, this);

    this._scenes.push(scene["uid"]);
};

/**
 * Internal method to load a {@link KEN.Scene}.
 * @method KEN.Tour#loadScene
 * @param  {(KEN.Scene|number|string)} value - Either the {@link KEN.Scene} itself its index in the main _scenes Array or its uid.
 */
KEN.Tour.prototype.loadScene = function(value)
{
    var uid;

    // use the index of the group array
    if (typeof value === "number")
    {
        if(value >= 0 && value < this._scenes.length)
        {
            uid = this._scenes[value];
        }
        else
        {
            this.warn("Load scene, index "+value+" is out of bounds");
        }
    }
    // use the uid
    else if (typeof value === "string" && KEN.UID.isTypeOf(value, "Scene"))
    {
        uid = value;
    }
    // use a Group object directly
    else if (typeof value === "object" && KEN.Utils.isTypeOf(value, "Scene"))
    {
        uid = value["uid"];
    }

    //If uid is defined and if it's not the current scene
    if(typeof uid !== "undefined" && uid !== this._sceneUid)
    {
        this._loadUid(uid);
    }
};

/**
 * Internal envent handler for scene load start, updates the group index, re-dispatch scene load start at the tour level.
 * @method KEN.Tour#_sceneLoadStart
 * @private
 * @param  {KEN.Event} event - The {@link KEN.Event} emitted by the scene that starts to load.
 */
KEN.Tour.prototype._sceneLoadStart = function(event)
{
    //Unload the previous scene
    if(this._sceneUid !== "" && this._sceneUid !== null)
    {
        this["scene"].unload();
    }

    var scene = event["emitter"];
    this._sceneUid = scene["uid"];

    //The scene has no group so nullify the _groupUid
    if(scene.hasGroups() === false)
    {
        this._groupUid = null;

        if(this._onGroupChange !== null)
        {
            this._onGroupChange.dispatch();
        }

    }
    else if (scene.hasGroups() === true && scene.hasGroup(this._groupUid) === false)
    {
        this._setGroupUid(scene["groups"][0]["uid"]);
    }

    if(this._onSceneLoadStart !== null)
    {
        this._onSceneLoadStart.dispatch({ uid: scene["uid"] });
    }

};

/**
 * Internal event handmer for scene load complete, re-dispatch the load complete event at the tour level.
 * @method KEN.Tour#_sceneLoadComplete
 * @private
 */
KEN.Tour.prototype._sceneLoadComplete = function()
{
    if(this._onSceneLoadComplete !== null)
    {
        this._onSceneLoadComplete.dispatch();
    }
};

/**
 * Create {@link KEN.Group}s from groups configuration object.
 * @method KEN.Tour#_createGroups
 * @private
 * @param  {Object} config - The object that describes the groups, issued from the main configuration.
 */
KEN.Tour.prototype._createGroups = function(config)
{
    var group;
    for(var i = 0, ii = config.length; i < ii; i++)
    {
        group = new KEN.Group(this._viewer, config[i]);
        this._groups.push(group["uid"]);
    }
};

/**
 * Internal method to set the current {@link KEN.Group} uid. Dispatch "onGroupChange" if its a valid operation.
 * @method KEN.Tour#_setGroupUid
 * @private
 * @param {string} uid - Uid of the group to set
 */
KEN.Tour.prototype._setGroupUid = function(uid)
{
    if(KEN.UID.isTypeOf(uid, "Group") === true && uid !== this._groupUid)
    {
        this._groupUid = uid;

        if(this._onGroupChange !== null)
        {
            this._onGroupChange.dispatch();
        }
    }
};

/**
 * Internal method to load a {@link KEN.Group}.
 * @method KEN.Tour#loadGroup
 * @param  {(KEN.Group|number|string)} value - Either the {@link KEN.Group} itself its index in the main _groups Array or its uid.
 */
KEN.Tour.prototype.loadGroup = function(value)
{
    var uid;

    // use the index of the group array
    if (typeof value === "number")
    {
        if(value >= 0 && value < this._groups.length)
        {
            uid = this._groups[value];
        }
        else
        {
            this.warn("Load group, index "+value+" is out of bounds");
        }
    }
    // use the uid
    else if (typeof value === "string" && KEN.UID.isTypeOf(value, "Group"))
    {
        uid = value;
    }
    // use a Group object directly
    else if (typeof value === "object" && KEN.Utils.isTypeOf(value, "Group"))
    {
        uid = value["uid"];
    }

    //If uid is defined and if it's not the current scene
    if(typeof uid !== "undefined" && uid !== this._groupUid)
    {
        this._setGroupUid(uid);
        this._loadUid(uid);
    }
};

/**
 * Destroy method.
 * @method KEN.Tour#destroy
 */
KEN.Tour.prototype.destroy = function()
{
    this._viewer = null;
    this._config = null;

    this._name.destroy();
    this._name = null;

    this._slug.destroy();
    this._slug = null;

    this._description.destroy();
    this._description = null;

    for(var i = 0, ii = this._scenes.length; i < ii; i++)
    {
        KEN.UID.get(this._scenes[i]).destroy();
    }
    this._scenes = null;

    for(var j = 0, jj = this._groups.length; j < jj; j++)
    {
        KEN.UID.get(this._groups[j]).destroy();
    }
    this._groups = null;

    // Events
    if(this._onReady !== null)
    {
        this._onReady.destroy();
        this._onReady = null;
    }

    if(this._onSceneLoadStart !== null)
    {
        this._onSceneLoadStart.destroy();
        this._onSceneLoadStart = null;
    }

    if(this._onSceneLoadProgress !== null)
    {
        this._onSceneLoadProgress.destroy();
        this._onSceneLoadProgress = null;
    }

    if(this._onSceneLoadComplete !== null)
    {
        this._onSceneLoadComplete.destroy();
        this._onSceneLoadComplete = null;
    }

    if(this._onSceneLoadError !==null)
    {
        this._onSceneLoadError.destroy();
        this._onSceneLoadError = null;
    }

    if(this._onScenePreview !== null)
    {
        this._onScenePreview.destroy();
        this._onScenePreview = null;
    }

    if(this._onGroupChange !== null)
    {
        this._onGroupChange.destroy();
        this._onGroupChange = null;
    }

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
* Get the tour config object.
* @name KEN.Tour#config
* @readonly
* @type {Object}
*/
KEN.Tour.prototype.config;
Object.defineProperty(KEN.Tour.prototype, "config",
{
    /** @this {KEN.Tour} */
    get: function ()
    {
        return this._config;
    }
});

/**
* Get the name of the tour.
* @name KEN.Tour#name
* @readonly
* @type {string}
*/
KEN.Tour.prototype.name;
Object.defineProperty(KEN.Tour.prototype, "name",
{
    /** @this {KEN.Tour} */
    get: function ()
    {
        return this._name["value"];
    }
});

/**
* Get the slug name of the tour.
* @name KEN.Tour#slug
* @readonly
* @type {string}
*/
KEN.Tour.prototype.slug;
Object.defineProperty(KEN.Tour.prototype, "slug",
{
    /** @this {KEN.Tour} */
    get: function()
    {
        return this._slug["value"];
    }
});

/**
* Get the description of the tour.
* @name KEN.Tour#description
* @readonly
* @type {string}
*/
KEN.Tour.prototype.description;
Object.defineProperty(KEN.Tour.prototype, "description",
{
    /** @this {KEN.Tour} */
    get: function()
    {
        return this._description["value"];
    }
});


/**
* Get the Array of {@link KEN.Scene} that compose the tour.
* @name KEN.Tour#scenes
* @readonly
* @type {?Array<KEN.Scene>}
*/
KEN.Tour.prototype.scenes;
Object.defineProperty(KEN.Tour.prototype, "scenes",
{
    /** @this {KEN.Tour} */
    get: function ()
    {
        return KEN.UID.get(this._scenes);
    }
});

/**
 * Get the current {@link KEN.Scene} object, or set the current scene passing the {@link KEN.Scene} object itself, its index or uid.
 * @name KEN.Tour#scene
 * @type  {KEN.Scene}
 */
KEN.Tour.prototype.scene;
Object.defineProperty(KEN.Tour.prototype, "scene",
{
    /** @this {KEN.Tour} */
    get: function ()
    {
        if(this._sceneUid === null || this._sceneUid === "")
        {
            return null;
        }

        return KEN.UID.get(this._sceneUid);
    },

    /** @this {KEN.Tour} */
    set: function(value)
    {
        this.loadScene(value);
    }
});

/**
* Get the current sceneUid.
* @name KEN.Tour#sceneUid
* @readonly
* @type {string}
*/
KEN.Tour.prototype.sceneUid;
Object.defineProperty(KEN.Tour.prototype, "sceneUid",
{
    /** @this {KEN.Tour} */
    get: function ()
    {
        return this._sceneUid;
    }
});

/**
* Get the Array of {@link KEN.Group} that compose the tour.
* @name KEN.Tour#groups
* @readonly
* @type {?Array<KEN.Group>}
*/
KEN.Tour.prototype.groups;
Object.defineProperty(KEN.Tour.prototype, "groups",
{
    /** @this {KEN.Tour} */
    get: function ()
    {
        return KEN.UID.get(this._groups);
    }
});

/**
 * Get the current {@link KEN.Group} object, or set the current scene passing the {@link KEN.Group} object itself, its index or uid.
 * @name KEN.Tour#group
 * @type  {(KEN.Group)}
 */
KEN.Tour.prototype.group;
Object.defineProperty(KEN.Tour.prototype, "group",
{
    /** @this {KEN.Tour} */
    get: function ()
    {
        if(this._groupUid === null || this._groupUid === "")
        {
            return null;
        }

        return KEN.UID.get(this._groupUid);
    },

    /** @this {KEN.Tour} */
    set: function(value)
    {
        this.loadGroup(value);
    }
});

/**
* Get the current groupUid.
* @name KEN.Tour#groupUid
* @readonly
* @type {string}
*/
KEN.Tour.prototype.groupUid;
Object.defineProperty(KEN.Tour.prototype, "groupUid",
{
    /** @this {KEN.Tour} */
    get: function ()
    {
        return this._groupUid;
    }
});

/**
 * Get the onReady {@link KEN.EventDispatcher}.
 * @name  KEN.Tour#onReady
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Tour.prototype.onReady;
Object.defineProperty(KEN.Tour.prototype, "onReady",
{
    /** @this {KEN.Tour} */
    get: function()
    {
        if(this._onReady === null)
        {
            this._onReady = new KEN.EventDispatcher(this);
        }

        return this._onReady;
    }
});

/**
 * Get the onSceneLoadStart {@link KEN.EventDispatcher}.
 * @name  KEN.Tour#onSceneLoadStart
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Tour.prototype.onSceneLoadStart;
Object.defineProperty(KEN.Tour.prototype, "onSceneLoadStart",
{
    /** @this {KEN.Tour} */
    get: function()
    {
        if(this._onSceneLoadStart === null)
        {
            this._onSceneLoadStart = new KEN.EventDispatcher(this);
        }

        return this._onSceneLoadStart;
    }
});

/**
 * Get the onSceneLoadProgress {@link KEN.EventDispatcher}.
 * @name  KEN.Tour#onSceneLoadProgress
 * @readonly
 * @type {KEN.EventDispatcher}
 * @todo  This event is currently not dispatched
 */
KEN.Tour.prototype.onSceneLoadProgress;
Object.defineProperty(KEN.Tour.prototype, "onSceneLoadProgress",
{
    /** @this {KEN.Tour} */
    get: function()
    {
        if(this._onSceneLoadProgress === null)
        {
            this._onSceneLoadProgress = new KEN.EventDispatcher(this);
        }

        return this._onSceneLoadProgress;
    }
});

/**
 * Get the onSceneLoadComplete {@link KEN.EventDispatcher}.
 * @name  KEN.Tour#onSceneLoadComplete
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Tour.prototype.onSceneLoadComplete;
Object.defineProperty(KEN.Tour.prototype, "onSceneLoadComplete",
{
    /** @this {KEN.Tour} */
    get: function()
    {
        if(this._onSceneLoadComplete === null)
        {
            this._onSceneLoadComplete = new KEN.EventDispatcher(this);
        }

        return this._onSceneLoadComplete;
    }
});

/**
 * Get the onSceneLoadError {@link KEN.EventDispatcher}.
 * @name  KEN.Tour#onSceneLoadError
 * @readonly
 * @type {KEN.EventDispatcher}
 * @todo  This event is currently not dispatched
 */
KEN.Tour.prototype.onSceneLoadError;
Object.defineProperty(KEN.Tour.prototype, "onSceneLoadError",
{
    /** @this {KEN.Tour} */
    get: function()
    {
        if(this._onSceneLoadError === null)
        {
            this._onSceneLoadError = new KEN.EventDispatcher(this);
        }

        return this._onSceneLoadError;
    }
});

/**
 * Get the onScenePreview {@link KEN.EventDispatcher}.
 * @name  KEN.Tour#onScenePreview
 * @readonly
 * @type {KEN.EventDispatcher}
 * @todo  This event is currently not dispatched
 */
KEN.Tour.prototype.onScenePreview;
Object.defineProperty(KEN.Tour.prototype, "onScenePreview",
{
    /** @this {KEN.Tour} */
    get: function()
    {
        if(this._onScenePreview === null)
        {
            this._onScenePreview = new KEN.EventDispatcher(this);
        }

        return this._onScenePreview;
    }
});

/**
 * Get the onGroupChange {@link KEN.EventDispatcher}.
 * @name  KEN.Tour#onGroupChange
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Tour.prototype.onGroupChange;
Object.defineProperty(KEN.Tour.prototype, "onGroupChange",
{
    /** @this {KEN.Tour} */
    get: function()
    {
        if(this._onGroupChange === null)
        {
            this._onGroupChange = new KEN.EventDispatcher(this);
        }

        return this._onGroupChange;
    }
});


/**
 * A KEN.Group is an object that represents a group of {@link KEN.Scene} objects.
 *
 * @constructor KEN.Group
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @param {GroupConfig} config - The group config object.
 * @extends {KEN.BaseObject}
 */
KEN.Group = function(viewer, config)
{
    /**
     * The viewer reference.
     * @name KEN.Group#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The config object.
     * @name KEN.Group#_config
     * @type {GroupConfig}
     * @private
     */
    this._config = config;

    /**
     * The internationalizable name of the group.
     * @name KEN.Group#_name
     * @type {?KEN.LocaleString}
     * @private
     */
    this._name = null;

    /**
     * The color associated to this group (hexa code like #ffffff).<br>
     * Default value is the white code #ffffff.
     * @name  KEN.Group#_color
     * @type {string}
     * @private
     */
    this._color = "#ffffff";

    /**
     * The color alpha associated to this group is a number between 0 and 1.<br>
     * Default value is 1.
     * @name  KEN.Group#_alpha
     * @type {number}
     * @private
     */
    this._alpha = 1;

    /**
     * The internationalizable slug name of the group.
     * @name KEN.Group#_slug
     * @type {?KEN.LocaleString}
     * @private
     */
    this._slug = null;

    /**
     * The internationalizable description of the group.
     * @name KEN.Group#_description
     * @type {?KEN.LocaleString}
     * @private
     */
    this._description = null;

    /**
     * Array of children that can be {@link KEN.Scene} or {@link KEN.Group}.
     * @name KEN.Group#children
     * @type {Array<string>}
     * @private
     */
    this._children = null;

    /**
     * The default child uid to load.
     * @name  KEN["group"]#_default
     * @type {string}
     * @private
     */
    this._default = "";

    /**
     * Parents of this group, these are {@link KEN.Group}.
     * @name  KEN.Group#parents
     * @type {Array<KEN.Group>}
     * @private
     */
    this._parents = null;

    KEN.BaseObject.call(this, "Group");

    this._boot();

};

KEN.Group.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Group.prototype.constructor = KEN.Group;

/**
 * Boot sequence.
 * @method KEN.Group#_boot
 * @private
 */
KEN.Group.prototype._boot = function()
{
    this.log("KEN.Group._boot();");

    this._uid = this._config["uid"];
    this._tags = this._config["tags"];
    this._register();

    this._parents = [];
    this._children = [];

    this._name = new KEN.LocaleString(this._viewer, this._config["name"]);
    this._slug = new KEN.LocaleString(this._viewer, this._config["slug"]);
    this._description = new KEN.LocaleString(this._viewer, this._config["description"]);

    if(typeof this._config["color"] === "string")
    {
        this._color = this._config["color"];
    }

    if(typeof this._config["alpha"] === "number")
    {
        this._alpha = this._config["alpha"];
    }

    this._parseChildren(this._config);
};

/**
 * Parse scenes in config.
 * @method KEN.Group#_parseChildren
 * @private
 * @param  {GroupConfig} config - The object that describes the scenes config.
 */
KEN.Group.prototype._parseChildren = function(config)
{

    if(typeof config["children"] !== "undefined" && KEN.Utils.isArrayOf(config["children"], "string") === true)
    {
        this._children = config["children"];
    }
    else
    {
        this.warn("A group has no children in its configuration, or configuration is not valid!");
    }

    //Parse the default child of the group
    if(typeof config["default"] === "string")
    {
        if(this._children.indexOf(config["default"]) !== -1)
        {
            this._default = config["default"];
        }
        else
        {
            this.warn("A group has a default child that is not in its children array!");
        }
    }
};

/**
 * Load the group with a specific scene, by default the scene is scene index 0.
 * @method KEN.Group#load
 * @param {number|string|KEN.Scene|KEN.Group=} value - The numeric index of the child or the uid of the child you want to load.<br>
 * If no value passed in arguments, the group will load its default child if it is set.<br>
 * If no default child set, it will load its first child no matter the type of this child
 */
KEN.Group.prototype.load = function(value)
{
    this.log("KEN.Group.load();");

    if(this._children === null || this._children.length === 0)
    {
        throw "Group.load() : can't load a group that have no children";
    }

    var uid;

    //If no value passed in arguments, the group will load its default child if it is set.
    if (typeof value === "undefined" || value === null)
    {
        if(typeof this._default === "string" && this._default !== "")
        {
            uid = this._default;
        }
        else
        {
            uid = this._children[0];
        }
    }
    else if (typeof value === "number" && value >= 0 && value < this._children.length)
    {
        uid = this._children[value];
    }
    else if (typeof value === "string")
    {
        uid = value;
    }
    else if (typeof value === "object" && this.hasChild(value) === true)
    {
        uid = value["uid"];
    }

    if(this._children.indexOf(uid) === -1)
    {
        throw "Group.load() : uid \""+uid+"\" is not in children of the group!";
    }

    if(KEN.UID.isTypeOf(uid, "Scene") === true || KEN.UID.isTypeOf(uid, "Group") === true)
    {
        var child = KEN.UID.get(uid);
        child.load();
    }
    else
    {
        throw "Impossible to load group child with uid "+uid+", it seems to be neither a scene or a group!";
    }

};

/**
 * Know if a {@link KEN.Scene}, a {@link KEN.Group} or a uid is part of this group?
 * @method KEN.Group#hasScene
 * @param {(KEN.Scene|KEN.Group|string)} value - Either the {@link KEN.Scene} or a {@link KEN.Group} or a uid string.
 * @return {boolean} Returns true if the child is part of this group, false if not.
 */
KEN.Group.prototype.hasChild = function(value)
{
    if(typeof value === "string")
    {
        return this._children.indexOf(value) !== -1;
    }
    else if(KEN.Utils.isTypeOf(value, "Scene") === true || KEN.Utils.isTypeOf(value, "Group") === true)
    {
        return this.hasChild(value["uid"]);
    }

    return false;
};


/**
 * Know if a {@link KEN.Scene} is part of this group?
 * @method KEN.Group#hasScene
 * @param {(KEN.Scene|string)} value - Either the {@link KEN.Scene} or a uid string.
 * @return {boolean} Returns true if the scene is part of this group, false if not.
 */
KEN.Group.prototype.hasScene = function(value)
{
    if(typeof value === "string" && KEN.UID.isTypeOf(value, "Scene"))
    {
        return this._children.indexOf(value) !== -1;
    }
    else if(KEN.Utils.isTypeOf(value, "Scene") === true)
    {
        return this.hasScene(value["uid"]);
    }

    return false;
};

/**
 * Know if a {@link KEN.Group} is part of this group?
 * @method KEN.Group#hasGroup
 * @param {(KEN.Group|string)} value - Either the {@link KEN.Group} or a uid string.
 * @return {boolean} Returns true if the group is part of this group, false if not.
 */
KEN.Group.prototype.hasGroup = function(value)
{
    if(typeof value === "string" && KEN.UID.isTypeOf(value, "Group"))
    {
        return this._children.indexOf(value) !== -1;
    }
    else if(KEN.Utils.isTypeOf(value, "Group") === true)
    {
        return this.hasGroup(value["uid"]);
    }

    return false;
};

/**
 * Know if this group have any children.
 * @method KEN.Group#hasChildren
 * @return {boolean} Returns true if this group have at least a children, false if not.
 */
KEN.Group.prototype.hasChildren = function()
{
    return this._children.length !== 0;
};

/**
 * Know if this group have any object of a specified className.
 * @method KEN.Group#hasTypeOfChild
 * @param {string} className - the className of the object you want to know if this group has in its children array.
 * @return {boolean} Returns true if this group have at least an object of the requested className in its children, false if not.
 */
KEN.Group.prototype.hasTypeOfChild = function(className)
{
    var uid;
    for(var i = 0, ii = this._children.length; i < ii; i++)
    {
        uid = this._children[i];
        if(KEN.UID.isTypeOf(uid, className))
        {
            return true;
        }
    }

    return false;
};

/**
 * Know if this group have any {@link KEN.Scene}.
 * @method KEN.Group#hasScenes
 * @return {boolean} Returns true if this group have at least a {@link KEN.Scene}, false if not.
 */
KEN.Group.prototype.hasScenes = function()
{
    return this.hasTypeOfChild("Scene");
};

/**
 * Know if this group have any {@link KEN.Group}.
 * @method KEN.Group#hasGroups
 * @return {boolean} Returns true if this group have at least a {@link KEN.Group}, false if not.
 */
KEN.Group.prototype.hasGroups = function()
{
    return this.hasTypeOfChild("Group");
};

/**
 * Get children uids of a specified className (or not).
 * @method KEN.Group#getChildrenUids
 * @param {string=} className - the className of the object uids you want to get.
 * @return {Array} Returns array of children uids of the specified className.
 */
KEN.Group.prototype.getChildrenUids = function(className)
{
    //If no className specified, return the complete array of children uids.
    if(typeof className !== "string")
    {
        return this._children;
    }

    var children = [];
    //var child;

    for(var i = 0, ii = this._children.length; i < ii; i++)
    {
        /*
        child = KEN.UID.get(this._children[i]);

        if(typeof child === "undefined" || child === null)
        {
            continue;
        }

        if(child["className"] === className)
        {
            children.push(this._children[i]);
        }*/

        if(KEN.UID.isTypeOf(this._children[i], className))
        {
            children.push(this._children[i]);
        }
    }

    return children;
};

/**
 * Get children objects of a specified className.<br>
 * If you do not specify className this method will return all the children objects.
 * @method KEN.Group#getChildren
 * @param {string=} className - the className of the object you want to get.
 * @return {Array} Returns array of children objects of the specified className.
 */
KEN.Group.prototype.getChildren = function(className)
{
    var uids = this.getChildrenUids(className);
    return KEN.UID.get(uids);
};

/**
 * Load the next scene of this group.<br>
 * If this group has no scene, you can't use this method.<br>
 * If the current scene of the tour is not one of this group, the group will load either the default child or its first found scene.<br>
 * If the current scene is part of this group, nextScene will loop forward through its scenes.
 * @method KEN.Group#nextScene
 */
KEN.Group.prototype.nextScene = function()
{
    if(this.hasScenes() === false)
    {
        this.warn("Can't do Group.nextScene() on this group that have no scenes!");
        return;
    }

    var scenesUids = this["scenesUids"];
    var index = scenesUids.indexOf(this._viewer["tour"]["sceneUid"]);
    var uid; //Default uid to load is the first scene.

    if(index === -1)
    {
        if(KEN.UID.isTypeOf(this._default, "Scene"))
        {
            uid = this._default;
        }
        else
        {
            uid = scenesUids[0];
        }
    }

    if(index + 1 < scenesUids.length)
    {
        uid = scenesUids[index + 1];
    }
    else if(index !== -1)
    {
        uid = scenesUids[0];
    }

    this.load(uid);
};

/**
 * Load the previous scene of this group.<br>
 * If this group has no scene, you can't use this method.<br>
 * If the current scene of the tour is not one of this group, the group will load either the default child or its first found scene.<br>
 * If the current scene is part of this group, previousScene will loop backward through its scenes.
 * @method KEN.Group#previousScene
 */
KEN.Group.prototype.previousScene = function()
{
    if(this.hasScenes() === false)
    {
        this.warn("Can't do Group.previousScene() on this group that have no scenes!");
        return;
    }

    var scenesUids = this["scenesUids"];
    var index = scenesUids.indexOf(this._viewer["tour"]["sceneUid"]);
    var uid; //Default uid to load is the first scene.

    if(index === -1)
    {
        if(KEN.UID.isTypeOf(this._default, "Scene"))
        {
            uid = this._default;
        }
        else
        {
            uid = scenesUids[0];
        }
    }

    if(index - 1 >= 0)
    {
        uid = scenesUids[index - 1];
    }
    else if(index !== -1)
    {
        uid = scenesUids[scenesUids.length - 1];
    }

    this.load(uid);
};

/**
 * Destroy method.
 * @method KEN.Group#destroy
 */
KEN.Group.prototype.destroy = function()
{
    this._viewer = null;

    this._children = null;

    this._name.destroy();
    this._name = null;

    this._slug.destroy();
    this._slug = null;

    this._description.destroy();
    this._description = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
* Get the group config object.
* @name KEN.Group#config
* @readonly
* @type {Object}
*/
KEN.Group.prototype.config;
Object.defineProperty(KEN.Group.prototype, "config",
{
    /** @this {KEN.Group} */
    get: function()
    {
        return this._config;
    }
});

/**
* Get the count of how many times this group has been viewed.
* @name KEN.Group#viewCount
* @readonly
* @type {number}
*/
// Object.defineProperty(KEN.Group.prototype, "viewCount",
// {
//     /** @this {KEN.Group} */
//     get: function()
//     {
//         var count = 0;

//         for(var i = 0, ii = this._scenes.length; i < ii; i++)
//         {
//             count += this._scenes[i]["viewCount"];
//         }
//         return count;
//     }
// });

/**
* Know if this group has been viewed at least one time.
* @name KEN.Group#viewed
* @readonly
* @type {boolean}
*/
// Object.defineProperty(KEN.Group.prototype, "viewed",
// {
//     /** @this {KEN.Group} */
//     get: function()
//     {
//         return this["viewCount"] !== 0;
//     }
// });


/**
* Get the name of this group.
* @name KEN.Group#name
* @readonly
* @type {string}
*/
KEN.Group.prototype.name;
Object.defineProperty(KEN.Group.prototype, "name",
{
    /** @this {KEN.Group} */
    get: function()
    {
        return this._name["value"];
    }
});

/**
* Get the color associated to this group.
* @name KEN.Group#color
* @readonly
* @type {string}
*/
KEN.Group.prototype.color;
Object.defineProperty(KEN.Group.prototype, "color",
{
    /** @this {KEN.Group} */
    get: function()
    {
        return this._color;
    }
});

/**
* Get the alpha associated to this group.
* @name KEN.Group#alpha
* @readonly
* @type {number}
*/
KEN.Group.prototype.alpha;
Object.defineProperty(KEN.Group.prototype, "alpha",
{
    /** @this {KEN.Group} */
    get: function()
    {
        return this._alpha;
    }
});

/**
* Get the slug name of this group.
* @name KEN.Group#slug
* @readonly
* @type {string}
*/
KEN.Group.prototype.slug;
Object.defineProperty(KEN.Group.prototype, "slug",
{
    /** @this {KEN.Group} */
    get: function()
    {
        return this._slug["value"];
    }
});

/**
* Get the description of this group.
* @name KEN.Group#description
* @readonly
* @type {string}
*/
KEN.Group.prototype.description;
Object.defineProperty(KEN.Group.prototype, "description",
{
    /** @this {KEN.Group} */
    get: function()
    {
        return this._description["value"];
    }
});

/**
* Get the Array of children uids that compose this group.
* @name KEN.Group#childrenUids
* @readonly
* @type {?Array<string>}
*/
KEN.Group.prototype.childrenUids;
Object.defineProperty(KEN.Group.prototype, "childrenUids",
{
    /** @this {KEN.Group} */
    get: function()
    {
        return this.getChildrenUids();
    }
});

/**
* Get the Array of children objects that compose this group.
* @name KEN.Group#children
* @readonly
* @type {?Array<Object>}
*/
KEN.Group.prototype.children;
Object.defineProperty(KEN.Group.prototype, "children",
{
    /** @this {KEN.Group} */
    get: function()
    {
        return this.getChildren();
    }
});

/**
* Get the Array of {@link KEN.Scene} uids that compose this group.
* @name KEN.Group#scenesUids
* @readonly
* @type {?Array<string>}
*/
KEN.Group.prototype.scenesUids;
Object.defineProperty(KEN.Group.prototype, "scenesUids",
{
    /** @this {KEN.Group} */
    get: function()
    {
        return this.getChildrenUids("Scene");
    }
});

/**
* Get the Array of {@link KEN.Scene} objects that compose this group.
* @name KEN.Group#scenes
* @readonly
* @type {?Array<KEN.Scene>}
*/
KEN.Group.prototype.scenes;
Object.defineProperty(KEN.Group.prototype, "scenes",
{
    /** @this {KEN.Group} */
    get: function()
    {
        return this.getChildren("Scene");
    }
});

/**
* Get the Array of {@link KEN.Group} uids that compose this group.
* @name KEN.Group#groupsUids
* @readonly
* @type {?Array<string>}
*/
KEN.Group.prototype.groupsUids;
Object.defineProperty(KEN.Group.prototype, "groupsUids",
{
    /** @this {KEN.Group} */
    get: function()
    {
        return this.getChildrenUids("Group");
    }
});

/**
* Get the Array of {@link KEN.Group} uids that compose this group.
* @name KEN.Group#groups
* @readonly
* @type {?Array<KEN.Group>}
*/
KEN.Group.prototype.groups;
Object.defineProperty(KEN.Group.prototype, "groups",
{
    /** @this {KEN.Group} */
    get: function()
    {
        return this.getChildren("Group");
    }
});

/**
 * A KEN.Scene is an object that represents a scene of a {@link KEN.Tour}.
 *
 * @constructor KEN.Scene
 * @param {KEN.Viewer} viewer {@link KEN.Viewer} reference.
 * @param {SceneConfig} config The scene config object.
 * @extends {KEN.BaseObject}
 */
KEN.Scene = function(viewer, config)
{
    /**
     * The viewer reference.
     * @name KEN.Scene#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The config object.
     * @name KEN.Scene#_config
     * @type {SceneConfig}
     * @private
     */
    this._config = config;

    /**
     * The internationalizable name of the scene.
     * @name KEN.Scene#_name
     * @type {?KEN.LocaleString}
     * @private
     */
    this._name = null;

    /**
     * The internationalizable slug name of the scene.
     * @name KEN.Scene#_slug
     * @type {?KEN.LocaleString}
     * @private
     */
    this._slug = null;

    /**
     * The internationalizable description of the scene.
     * @name KEN.Scene#_description
     * @type {?KEN.LocaleString}
     * @private
     */
    this._description = null;

    /**
     * The number of times this has been viewed.
     * @name  KEN.Scene#_viewCount
     * @type {number}
     * @private
     */
    this._viewCount = 0;

    /**
     * Array of group uids this scene belongs to. aka "parents".
     * @name KEN.Scene#_groups
     * @type {?Array<string>}
     * @private
     */
    this._groups = null;

    /**
     * Is booted flag.
     * @name KEN.Scene#_booted
     * @type {boolean}
     * @private
     */
    this._booted = false;

    /**
     * Use external config file flag.
     * @name KEN.Scene#_useExternalConfig
     * @type {boolean}
     * @private
     */
    this._useExternalConfig = false;

    /**
     * Load start event dispatcher.
     * @name  KEN.Scene#_onLoadStart
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onLoadStart = null;

    /**
     * Load complete event dispatcher.
     * @name  KEN.Scene#_onLoadComplete
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onLoadComplete = null;

    /**
     * Unload start event dispatcher.
     * @name  KEN.Scene#_onUnloadStart
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onUnloadStart = null;

    /**
     * Unload complete event dispatcher.
     * @name  KEN.Scene#_onUnloadComplete
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onUnloadComplete = null;

    /**
     * Load complete event dispatcher for scene configuration file.
     * @name  KEN.Scene#_onConfigLoadComplete
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onConfigLoadComplete = null;

    KEN.BaseObject.call(this, "Scene");

    this._boot();
};

KEN.Scene.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Scene.prototype.constructor = KEN.Scene;

/**
 * Boot sequence.
 * @method KEN.Scene#_boot
 * @private
 */
KEN.Scene.prototype._boot = function()
{
    if (this._booted === true)
    {
        return;
    }

    this.log("KEN.Scene._boot();");

    this._uid = this._config["uid"];
    this._tags = this._config["tags"];
    this._register();
    this._name = new KEN.LocaleString(this._viewer, this._config["name"]);
    this._slug = new KEN.LocaleString(this._viewer, this._config["slug"]);
    this._description = new KEN.LocaleString(this._viewer, this._config["description"]);

    if (typeof this._config["url"] === "string" && this._config["url"] !== "")
    {
        //use an external config json file
        this._useExternalConfig = true;
        this._viewer["load"].json(this._uid, this._config["url"], this._configLoadComplete, this);
    }
    else
    {
        this._booted = true;
    }
};

/**
 * Event handler for the load of the scene config json file.
 * @method KEN.Scene#_configLoadComplete
 * @param {KEN.File} file - The file data.
 * @private
 *
 * @todo the "tour.config" cache file is not updated in this case, a cache entry is added for each scene UID.
 */
KEN.Scene.prototype._configLoadComplete = function(file)
{
    this._booted = true;

    //extend the config
    if (typeof file["data"] === "string")
    {
        file["data"] = /** @type {Object} */ (JSON.parse(file["data"]));
    }

    this._config = /** @type {SceneConfig} */ (KEN.Utils.extendSimpleObject(this._config, file["data"]));

    this._viewer["tour"].notifySceneConfigLoadComplete(this);

    if (this._onConfigLoadComplete !== null)
    {
        this._onConfigLoadComplete.dispatch();
    }
};

/**
 * Load the scene.
 * @method KEN.Scene#load
 */
KEN.Scene.prototype.load = function()
{
    this.log("KEN.Scene.load();");

    if (this._viewer["tour"]["scene"] === this)
    {
        return;
    }

    if (this._onLoadStart !== null)
    {
        this._onLoadStart.dispatch();
    }

    this._viewCount++;

    if (this._onLoadComplete !== null)
    {
        this._onLoadComplete.dispatch();
    }
};

/**
 * Unload the scene.
 * @method KEN.Scene#unload
 * @todo cleanup if useless
 */
KEN.Scene.prototype.unload = function()
{
    if (this._onUnloadStart !== null)
    {
        this._onUnloadStart.dispatch();
    }

    if (this._onUnloadComplete !== null)
    {
        this._onUnloadComplete.dispatch();
    }
};

/**
 * Know if a {@link KEN.Group} is related to this scene?
 * @method KEN.Scene#hasGroup
 * @param {(KEN.Group|string)} value - Either the {@link KEN.Group} itself or its index or its uid.
 * @return {boolean} Returns true if the {@link KEN.Group} is related to this scene, false if not.
 */
KEN.Scene.prototype.hasGroup = function(value)
{
    if (typeof value === "string" && KEN.UID.isTypeOf(value, "Group") === true)
    {
        return KEN.UID.get( /** @type {string} */ (value)).hasScene(this);
    }
    else if (KEN.Utils.isTypeOf(value, "Group") === true)
    {
        return value.hasScene(this);
    }

    return false;
};

/**
 * Know if this scene is related to any {@link KEN.Group}.
 * @method KEN.Scene#hasGroups
 * @return {boolean} Returns true if this scene is related to at least a {@link KEN.Group}, false if not.
 */
KEN.Scene.prototype.hasGroups = function()
{
    var groups = this._viewer["tour"]["groups"];
    var group;
    for (var i = 0, ii = groups.length; i < ii; i++)
    {
        group = groups[i];
        if (group.hasScene(this) === true)
        {
            return true;
        }
    }

    return false;
};

/**
 * Destroy method
 * @method KEN.Scene#destroy
 */
KEN.Scene.prototype.destroy = function()
{
    this._viewer = null;

    this._name.destroy();
    this._name = null;

    this._slug.destroy();
    this._slug = null;

    this._description.destroy();
    this._description = null;

    if (this._onLoadStart !== null)
    {
        this._onLoadStart.destroy();
        this._onLoadStart = null;
    }

    if (this._onLoadComplete !== null)
    {
        this._onLoadComplete.destroy();
        this._onLoadComplete = null;
    }

    if (this._onUnloadStart !== null)
    {
        this._onUnloadStart.destroy();
        this._onUnloadStart = null;
    }

    if (this._onUnloadComplete !== null)
    {
        this._onUnloadComplete.destroy();
        this._onUnloadComplete = null;
    }

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
* Get the booted status of the scene.
* @name KEN.Scene#booted
* @type {SceneConfig}
* @readonly
*/
KEN.Scene.prototype.booted;
Object.defineProperty(KEN.Scene.prototype, "booted",
{
    /** @this {KEN.Scene} */
    get: function()
    {
        return this._booted;
    }
});

/**
* Get the group config object.
* @name KEN.Scene#config
* @readonly
* @type {SceneConfig}
*/
KEN.Scene.prototype.config;
Object.defineProperty(KEN.Scene.prototype, "config",
{
    /** @this {KEN.Scene} */
    get: function()
    {
        return this._config;
    }
});

/**
 * Get the count of how many times this group has been viewed.
 * @name KEN.Scene#viewCount
 * @readonly
 * @type {number}
 */
KEN.Scene.prototype.viewCount;
Object.defineProperty(KEN.Scene.prototype, "viewCount",
{
    /** @this {KEN.Scene} */
    get: function()
    {
        return this._viewCount;
    }
});

/**
 * Know if this scene has been viewed at least one time.
 * @name KEN.Scene#viewed
 * @readonly
 * @type {boolean}
 */
KEN.Scene.prototype.viewed;
Object.defineProperty(KEN.Scene.prototype, "viewed",
{
    /** @this {KEN.Scene} */
    get: function()
    {
        return this._viewCount !== 0;
    }
});

/**
 * Get the name of this scene.
 * @name KEN.Scene#name
 * @readonly
 * @type {string}
 */
KEN.Scene.prototype.name;
Object.defineProperty(KEN.Scene.prototype, "name",
{
    /** @this {KEN.Scene} */
    get: function()
    {
        return this._name["value"];
    }
});

/**
 * Get the slug name of this scene.
 * @name KEN.Scene#slug
 * @readonly
 * @type {string}
 */
KEN.Scene.prototype.slug;
Object.defineProperty(KEN.Scene.prototype, "slug",
{
    /** @this {KEN.Scene} */
    get: function()
    {
        return this._slug["value"];
    }
});

/**
 * Get the description of this scene.
 * @name KEN.Scene#description
 * @readonly
 * @type {string}
 */
KEN.Scene.prototype.description;
Object.defineProperty(KEN.Scene.prototype, "description",
{
    /** @this {KEN.Scene} */
    get: function()
    {
        return this._description["value"];
    }
});

/**
 * Get the Array of groups uids to which this scene belongs to.
 * @name KEN.Scene#groupsUid
 * @readonly
 * @type {?Array<KEN.Group>}
 */
KEN.Scene.prototype.groupsUid;
Object.defineProperty(KEN.Scene.prototype, "groupsUid",
{
    /** @this {KEN.Scene} */
    get: function()
    {
        var groups = this._viewer["tour"]["groups"];
        var group;
        var result = [];

        for (var i = 0, ii = groups.length; i < ii; i++)
        {
            group = groups[i];

            if (group.hasScene(this) === true)
            {
                result.push(group["uid"]);
            }
        }

        return result;
    }
});

/**
 * Get the Array of {@link KEN.Group} to which this scene belongs to.
 * @name KEN.Scene#groups
 * @readonly
 * @type {?Array<KEN.Group>}
 */
KEN.Scene.prototype.groups;
Object.defineProperty(KEN.Scene.prototype, "groups",
{
    /** @this {KEN.Scene} */
    get: function()
    {
        return KEN.UID.get(this["groupsUid"]);
    }
});

/**
 * Get the thumbnails Array.
 * @name  KEN.Scene#thumbnails
 * @readonly
 * @type {Array}
 *
 * @todo  Define what is a thumbnail array, maybe with a thumbnail object descriptor
 */
KEN.Scene.prototype.thumbnails;
Object.defineProperty(KEN.Scene.prototype, "thumbnails",
{
    /** @this {KEN.Scene} */
    get: function()
    {
        return this._config["thumbnails"];
    }
});

/**
 * Get the onLoadStart {@link KEN.EventDispatcher}.
 * @name  KEN.Scene#onLoadStart
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Scene.prototype.onLoadStart;
Object.defineProperty(KEN.Scene.prototype, "onLoadStart",
{
    /** @this {KEN.Scene} */
    get: function()
    {
        if (this._onLoadStart === null)
        {
            this._onLoadStart = new KEN.EventDispatcher(this);
        }

        return this._onLoadStart;
    }
});

/**
 * Get the onLoadComplete {@link KEN.EventDispatcher}.
 * @name  KEN.Scene#onLoadComplete
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Scene.prototype.onLoadComplete;
Object.defineProperty(KEN.Scene.prototype, "onLoadComplete",
{
    /** @this {KEN.Scene} */
    get: function()
    {
        if (this._onLoadComplete === null)
        {
            this._onLoadComplete = new KEN.EventDispatcher(this);
        }

        return this._onLoadComplete;
    }
});

/**
 * Get the onUnloadStart {@link KEN.EventDispatcher}.
 * @name  KEN.Scene#onUnloadStart
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Scene.prototype.onUnloadStart;
Object.defineProperty(KEN.Scene.prototype, "onUnloadStart",
{
    /** @this {KEN.Scene} */
    get: function()
    {
        if (this._onUnloadStart === null)
        {
            this._onUnloadStart = new KEN.EventDispatcher(this);
        }

        return this._onUnloadStart;
    }
});

/**
 * Get the onUnloadComplete {@link KEN.EventDispatcher}.
 * @name  KEN.Scene#onUnloadComplete
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Scene.prototype.onUnloadComplete;
Object.defineProperty(KEN.Scene.prototype, "onUnloadComplete",
{
    /** @this {KEN.Scene} */
    get: function()
    {
        if (this._onUnloadComplete === null)
        {
            this._onUnloadComplete = new KEN.EventDispatcher(this);
        }

        return this._onUnloadComplete;
    }
});

/**
 * Get the onConfigLoadComplete {@link KEN.EventDispatcher}.
 * @name  KEN.Scene#onConfigLoadComplete
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Scene.prototype.onConfigLoadComplete;
Object.defineProperty(KEN.Scene.prototype, "onConfigLoadComplete",
{
    /** @this {KEN.Scene} */
    get: function()
    {
        if (this._onConfigLoadComplete === null)
        {
            this._onConfigLoadComplete = new KEN.EventDispatcher(this);
        }

        return this._onConfigLoadComplete;
    }
});

/**
 * Math helper
 * @namespace KEN.Math
 * @type {Object}
 */
KEN.Math = {};

/**
 * @name KEN.Math.DEGREES
 * @type {string}
 * @const
 */
KEN.Math.DEGREES = "degrees";

/**
 * @name KEN.Math.RADIANS
 * @type {string}
 * @const
 */
KEN.Math.RADIANS = "radians";

/**
 * KEN.Math.DEG2RAD
 * @type {number}
 * @const
 */
KEN.Math.DEG2RAD = Math.PI / 180.0;

/**
 * KEN.Math.RAD2DEG
 * @type {number}
 * @const
 */
KEN.Math.RAD2DEG = 180.0 / Math.PI;


/**
 * Converts angle unit degrees to radians
 *
 * @method KEN.Math.degToRad
 * @param  {number} deg - angle in degrees
 * @return {number} Return the angle in radians
 */
KEN.Math.degToRad = function(deg)
{
    return deg * KEN.Math.DEG2RAD;
};

/**
 * Converts angle unit radians to degrees
 *
 * @method KEN.Math.radToDeg
 * @param  {number} rad - angle in radians
 * @return {number} Return the angle in degrees
 */
KEN.Math.radToDeg = function(rad)
{
    return rad * KEN.Math.RAD2DEG;
};

/**
 * Returns the value of a number rounded to the nearest decimal value
 *
 * @method KEN.Math.round10
 * @param  {number} value - Value to round
 * @return {number} Return the rounded value
 */
KEN.Math.round10 = function(value)
{
    return Math.round(value * 10) / 10;
};

/**
 * Clamp a value between a min and a max value
 *
 * @method KEN.Math.clamp
 * @param  {number} value - Value to clamp
 * @param  {?number=} min - The min value
 * @param  {?number=} max - The max value
 * @return {number} Return the clamped value
 */
KEN.Math.clamp = function(value, min, max)
{
    min = (typeof min === "number" && isNaN(min) === false) ? min : -Infinity;
    max = (typeof max === "number" && isNaN(max) === false) ? max : Infinity;

    return Math.min(Math.max(value, min), max);
};

/**
 * Wrap a value between a min and a max value
 *
 * @method KEN.Math.wrap
 * @param  {number} value - Value to wrap
 * @param  {number} min - The min value
 * @param  {number} max - The max value
 * @return {number} Return the wrapped value
 */
KEN.Math.wrap = function(value, min, max)
{
    var range = max - min;
    return (value < min) ? (value + range) : ((value > max) ? (value - range) : value);
};

/**
 * Linear mix function
 *
 * @method KEN.Math.mix
 * @param  {number} a - first value
 * @param  {number} b - second value
 * @param  {number} mix - factor
 * @return {number} linear mix of a and b
 */
KEN.Math.mix = function(a, b, mix)
{
    return a * mix + b * (1 - mix);
};

/**
 * Smoothstep function
 *
 * @method KEN.Math.smoothStep
 * @param  {number} value - Value to smooth
 * @param  {number} edge0 - low edge
 * @param  {number} edge1 - high edge
 * @return {number} smooth step result
 */
KEN.Math.smoothStep = function(value, edge0, edge1)
{
    value = KEN.Math.clamp((value - edge0) / (edge1 - edge0), 0.0, 1.0);
    return value * value * (3 - 2 * value);
};

/**
 * Get euler angles from rotation matrix
 *
 * @method KEN.Math.rotationMatrixToEuler
 * @param  {THREE.Matrix4} mat - rotation matrix
 * @return {TEuler} object with keys {yaw, pitch, roll} and euler angles as values [radians]
 */
KEN.Math.rotationMatrixToEuler = function(mat)
{
    return {
        yaw: Math.atan2(-mat.elements[2 + 0 * 4], mat.elements[2 + 2 * 4]),
        pitch: Math.asin(-mat.elements[2 + 1 * 4]),
        roll: Math.atan2(-mat.elements[0 + 1 * 4], mat.elements[1 + 1 * 4])
    };
};

/**
 * Get rotation matrix from euler angles
 *
 * @method KEN.Math.eulerToRotationMatrix
 * @param  {number} yaw - yaw angle [rad]
 * @param  {number} pitch - pitch angle [rad]
 * @param  {number} roll - roll angle [rad]
 * @param  {boolean=} orderYPR
 * @return {THREE.Matrix4} rotation matrix
 */
KEN.Math.eulerToRotationMatrix = function(yaw, pitch, roll, orderYPR)
{
    var cy = Math.cos(yaw);
    var sy = Math.sin(yaw);
    var cp = Math.cos(-pitch);
    var sp = Math.sin(-pitch);
    var cr = Math.cos(roll);
    var sr = Math.sin(roll);

    if (typeof orderYPR === "undefined")
    {
        orderYPR = false;
    }

    //jscs:disable
    if (orderYPR)
    {
        // M(yaw) * M(pitch) * M(roll)
        return new THREE.Matrix4().set(
             cy * cr + sy * sp * sr, -cy * sr + sy * sp * cr, sy * cp, 0,
                            cp * sr,                 cp * cr,     -sp, 0,
            -sy * cr + cy * sp * sr,  sy * sr + cy * sp * cr, cy * cp, 0,
                                  0,                       0,       0, 1
        );
    }

    // M(roll) * M(pitch) *  M(yaw)
    return new THREE.Matrix4().set(
        cr * cy - sr * sp * sy, -sr * cp, cr * sy + sr * sp * cy, 0,
        sr * cy + cr * sp * sy,  cr * cp, sr * sy - cr * sp * cy, 0,
                      -sy * cp,       sp,                cp * cy, 0,
                             0,        0,                      0, 1
     );
    //jscs:enable
};


/**
 * Quaternion helper.
 * @namespace {Object} KEN.Quaternion
 */
KEN.Quaternion = {};

/**
 * Get euler angles from a quaternion.
 *
 * @method KEN.Quaternion.toEuler
 * @param {THREE.Quaternion} quat - rotation quaternion
 * @return {TEuler} euler angle object
 */
KEN.Quaternion.toEuler = function(quat)
{
    var euler = new THREE.Euler().setFromQuaternion (quat, "XYZ");

    var result =
    {
        yaw: euler.x,
        pitch: -euler.y,
        roll: euler.z
    };

    return result;
};

/**
 * Get a quaternion from euler angles.
 *
 * @method KEN.Quaternion.fromEuler
 * @param {TEuler|number} yaw - yaw euler angle (y axis) [radians]
 * @param {number=} pitch - pitch euler angle (x axis) [radians]
 * @param {number=} roll - roll euler angle (z axis) [radians]
 * @return {THREE.Quaternion} resulting rotation quaternion
 */
KEN.Quaternion.fromEuler = function(yaw, pitch, roll)
{
    if(typeof yaw === "object")
    {
        pitch = yaw["pitch"];
        roll = yaw["roll"];
        yaw = yaw["yaw"];
    }

    return new THREE.Quaternion().setFromEuler(new THREE.Euler(yaw, -pitch, roll, "ZXY"));
};

/**
 * Get a rotation matrix from a quaternion.
 *
 * @method KEN.Quaternion.toRotationMatrix
 * @param {THREE.Quaternion} quat - quaternion
 * @return {THREE.Matrix4} rotation matrix
 */
KEN.Quaternion.toRotationMatrix = function(quat)
{
    var euler = KEN.Quaternion.toEuler(quat);
    return KEN.Math.eulerToRotationMatrix(euler["yaw"], euler["pitch"], euler["roll"]);
};

/**
 * Get a quaternion from a rotation matrix.
 *
 * @method KEN.Quaternion.fromRotationMatrix
 * @param {THREE.Matrix4} mat - rotation matrix
 * @return {THREE.Quaternion} quat quaternion
 */
KEN.Quaternion.fromRotationMatrix = function(mat)
{
    var euler = KEN.Math.rotationMatrixToEuler(mat);
    return KEN.Quaternion.fromEuler(euler);
};

/**
 * Cancel roll and return new quaternion.
 *
 * @method KEN.Quaternion.cancelRoll
 * @param  {THREE.Quaternion} quat - input quaternion
 * @return {THREE.Quaternion} quaternion without roll
 */
KEN.Quaternion.cancelRoll = function(quat)
{
    var euler = KEN.Quaternion.toEuler(quat);
    return KEN.Quaternion.fromEuler(euler["yaw"], euler["pitch"], 0);
};

/**
 * Get difference quaternion between two rotation quaternions.
 *
 * @method KEN.Quaternion.diffBetweenQuaternions
 * @param {THREE.Quaternion} q0 - start quaternion
 * @param {THREE.Quaternion} q1 - end quaternion
 * @return {THREE.Quaternion}
 */
KEN.Quaternion.diffBetweenQuaternions = function(q0, q1)
{
    return new THREE.Quaternion().copy(q0).inverse().multiply(q1);
};

/**
 * Get rotation angle between two quaternions.
 *
 * @method KEN.Quaternion.angularDistance
 * @param {THREE.Quaternion} q0 - interval start quaternion
 * @param {THREE.Quaternion} q1 - interval end quaternion
 * @return {number} angle in radians
 */
KEN.Quaternion.angularDistance = function(q0, q1)
{
    var d = Math.abs(q0.dot(q1));

    if (d >= 1.0)
    {
        return 0;
    }

    return 2 * Math.acos(d);
};

/**
 * Multiply a quaternion with a scalar.
 *
 * @method KEN.Quaternion.multiplyScalar
 * @param {number} scalar scalar - multiplyScalar
 * @param {THREE.Quaternion} quat - quaternion
 * @return {THREE.Quaternion} result quaternion
 */
KEN.Quaternion.multiplyScalar = function (scalar, quat)
{
    return new THREE.Quaternion(scalar * quat.x, scalar * quat.y, scalar * quat.z, scalar * quat.w);
};

/**
 * Add quaternions.
 *
 * @method KEN.Quaternion.add
 * @param {THREE.Quaternion} q0 - first quaternion
 * @param {THREE.Quaternion} q1 - second quaternion
 * @return {THREE.Quaternion} result quaternion
 */
KEN.Quaternion.add = function (q0, q1)
{
    return new THREE.Quaternion(q0.x + q1.x, q0.y + q1.y, q0.z + q1.z, q0.w + q1.w);
};

/**
 * Quaternion log function.
 *
 * @method KEN.Quaternion.log
 * @param {THREE.Quaternion} quat - quaternion
 * @return {THREE.Quaternion} result quaternion
 */
KEN.Quaternion.log = function (quat)
{
    var angle = Math.acos(quat.w);
    var sin = Math.sin(angle);

    var qres = new THREE.Quaternion(0, 0, 0, 0);

    if (sin > 0)
    {
        qres.x = angle * quat.x / sin;
        qres.y = angle * quat.y / sin;
        qres.z = angle * quat.z / sin;
    }

    return qres;
};

/**
 * Quaternion exp function.
 *
 * @method KEN.Quaternion.exp
 * @param {THREE.Quaternion} quat - quaternion
 * @return {THREE.Quaternion} result quaternion
 */
KEN.Quaternion.exp = function (quat)
{
    var angle = Math.sqrt(quat.x * quat.x + quat.y * quat.y + quat.z * quat.z);
    var sin = Math.sin(angle);

    var qRes = new THREE.Quaternion().copy(quat);
    qRes.w = Math.cos(angle);

    if (Math.abs(sin) > Number.EPSILON)
    {
        qRes.x = sin * quat.x / angle;
        qRes.y = sin * quat.y / angle;
        qRes.z = sin * quat.z / angle;
    }

    return qRes;
};

/**
 * Quaternion slerp computation.
 *
 * @method KEN.Quaternion.slerp
 * @param {THREE.Quaternion} q0 - interval start quaternion
 * @param {THREE.Quaternion} q1 - interval end quaternion
 * @param {number} t - interpolation time
 * @return {THREE.Quaternion} result quaternion
 */
KEN.Quaternion.slerp = function(q0, q1, t)
{
    var qRes = new THREE.Quaternion();
    THREE.Quaternion.slerp(q0, q1, qRes, t);
    return qRes;
};

/**
 * Compute squad interpolation.
 *
 * @method KEN.Quaternion.squad
 * @param {THREE.Quaternion} q0 - interval start quaternion
 * @param {THREE.Quaternion} a0 - left quandrangle
 * @param {THREE.Quaternion} a1 - right quandrangle
 * @param {THREE.Quaternion} q1 - interval end quaternion
 * @param {THREE.Quaternion} qres - result quaternion
 * @param {number} t - interpolation time
 * @return {THREE.Quaternion} result quaternion
 */
KEN.Quaternion.squad = function(q0, a0, a1, q1, qres, t)
{
    var quat = KEN.Quaternion.slerp(q0, q1, t);
    var quadrangle = KEN.Quaternion.slerp(a0, a1, t);
    return KEN.Quaternion.slerp(quat, quadrangle, 2*t*(1-t));
};

/**
 * Compute NLERP interpolation without inversion
 *
 * @method KEN.Quaternion.nlerpNoInvert
 * @param {THREE.Quaternion} q0 interval start quaternion
 * @param {THREE.Quaternion} q1 interval end quaternion
 * @param {number} t interpolation time
 * @return {THREE.Quaternion} result quaternion
 */
KEN.Quaternion.nlerpNoInvert = function(q0, q1, t)
{
    return KEN.Quaternion.add(
        KEN.Quaternion.multiplyScalar(1 - t, q0),
        KEN.Quaternion.multiplyScalar(t, q1)
    ).normalize();
};

/**
 * Compute SLERP interpolation without inversion
 *
 * @method KEN.Quaternion.slerpNoInvert
 * @param {THREE.Quaternion} q0 interval start quaternion
 * @param {THREE.Quaternion} q1 interval end quaternion
 * @param {number} t interpolation time
 * @return {THREE.Quaternion} result quaternion
 */
KEN.Quaternion.slerpNoInvert = function(q0, q1, t)
{
    var dot = q0.dot(q1);

    if (Math.abs(dot) < 0.95)
    {
        var angle = Math.acos(dot);

        return KEN.Quaternion.multiplyScalar(1.0 / Math.sin(angle),
            KEN.Quaternion.add(
                KEN.Quaternion.multiplyScalar(Math.sin(angle * (1-t)), q0),
                KEN.Quaternion.multiplyScalar(Math.sin(angle * t), q1)
            )
        );
    }
    else
    {
        return KEN.Quaternion.nlerpNoInvert(q0, q1, t);
    }
};

/**
 * Compute SQUAD interpolation without inversion
 *
 * @method KEN.Quaternion.squadNoInvert
 * @param {THREE.Quaternion} q0 interval start quaternion
 * @param {THREE.Quaternion} a0 left quandrangle
 * @param {THREE.Quaternion} a1 right quandrangle
 * @param {THREE.Quaternion} q1 interval end quaternion
 * @param {number} t interpolation time
 * @return {THREE.Quaternion} result quaternion
 */
KEN.Quaternion.squadNoInvert = function(q0, a0, a1, q1, t)
{
    var qq = KEN.Quaternion.slerpNoInvert(q0, q1, t);
    var qa = KEN.Quaternion.slerpNoInvert(a0, a1, t);
    return KEN.Quaternion.slerpNoInvert(qq, qa, 2 * t * (1-t));
};

/**
 * Make a quadrangle from three quaternions.
 *
 * @method KEN.Quaternion.makeQuadrangle
 * @param {THREE.Quaternion} quatPrev previous quaternion
 * @param {THREE.Quaternion} quatCurr current quaternion
 * @param {THREE.Quaternion} quatNext next quaternion
 * @return {THREE.Quaternion}
 */
KEN.Quaternion.makeQuadrangle = function (quatPrev, quatCurr, quatNext)
{
    var qInv = new THREE.Quaternion().copy(quatCurr).conjugate();

    var pPrev = new THREE.Quaternion().copy(qInv).multiply(quatPrev);
    var pNext = new THREE.Quaternion().copy(qInv).multiply(quatNext);

    var qLogPrev = KEN.Quaternion.log(pPrev);
    var qLogNext = KEN.Quaternion.log(pNext);

    var qLogSum = KEN.Quaternion.add(qLogPrev, qLogNext);
    var qLogSumQuater = KEN.Quaternion.multiplyScalar(-0.25, qLogSum);
    var qExp = KEN.Quaternion.exp(qLogSumQuater);

    return new THREE.Quaternion().copy(quatCurr).multiply(qExp).normalize();
};

/**
 * Rectangle object.
 *
 * @constructor KEN.Rectangle
 * @param {number} x - horizontal coordinate of origin
 * @param {number} y - vertical coordinate of origin
 * @param {number} width - width of the rectangle
 * @param {number} height - height of the rectangle
 */
KEN.Rectangle = function(x, y, width, height)
{
    /**
     * Horizontal coordinate of origin
     * @name KEN.Rectangle#_x
     * @type {number}
     * @private
     */
    this._x = typeof x === "number" ? x : 0;

    /**
     * Vertical coordinate of origin
     * @name KEN.Rectangle#_y
     * @type {number}
     * @private
     */
    this._y = typeof y === "number" ? y : 0;

    /**
     * Width
     * @name KEN.Rectangle#_width
     * @type {number}
     * @private
     */
    this._width = typeof width === "number" ? width : 0;

    /**
     * Height
     * @name KEN.Rectangle#_height
     * @type {number}
     * @private
     */
    this._height = typeof height === "number" ? height : 0;

};

KEN.Rectangle.prototype.constructor = KEN.Rectangle;


/**
 * Get and set x origin coordinate.
 * @name KEN.Rectangle#x
 * @type {number}
 */
KEN.Rectangle.prototype.x;
Object.defineProperty(KEN.Rectangle.prototype, "x",
{
    /** @this {KEN.Rectangle} */
    get: function()
    {
        return this._x;
    },

    /** @this {KEN.Rectangle} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._x = value;
        }
    }
});

/**
 * Get and set y origin coordinate.
 * @name KEN.Rectangle#y
 * @type {number}
 */
KEN.Rectangle.prototype.y;
Object.defineProperty(KEN.Rectangle.prototype, "y",
{
    /** @this {KEN.Rectangle} */
    get: function()
    {
        return this._y;
    },

    /** @this {KEN.Rectangle} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._y = value;
        }
    }
});

/**
 * Get and set width of the rectangle.
 * @name KEN.Rectangle#width
 * @type {number}
 */
KEN.Rectangle.prototype.width;
Object.defineProperty(KEN.Rectangle.prototype, "width",
{
    /** @this {KEN.Rectangle} */
    get: function()
    {
        return this._width;
    },

    /** @this {KEN.Rectangle} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._width = value;
        }
    }
});

/**
 * Get and set height of the rectangle.
 * @name KEN.Rectangle#height
 * @type {number}
 */
KEN.Rectangle.prototype.height;
Object.defineProperty(KEN.Rectangle.prototype, "height",
{
    /** @this {KEN.Rectangle} */
    get: function()
    {
        return this._height;
    },

    /** @this {KEN.Rectangle} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._height = value;
        }
    }
});

/**
 * Get center point.
 * @name KEN.Rectangle#center
 * @type {THREE.Vector2}
 * @readonly
 */
KEN.Rectangle.prototype.center;
Object.defineProperty(KEN.Rectangle.prototype, "center",
{
    /** @this {KEN.Rectangle} */
    get: function()
    {
        return new THREE.Vector2(this._x + 0.5 * this._width, this._y + 0.5 * this._height);
    }
});

/**
 * Get origin.
 * @name KEN.Rectangle#origin
 * @type {THREE.Vector2}
 * @readonly
 */
KEN.Rectangle.prototype.origin;
Object.defineProperty(KEN.Rectangle.prototype, "origin",
{
    /** @this {KEN.Rectangle} */
    get: function()
    {
        return new THREE.Vector2(this._x, this._y);
    }
});

/**
 * Get size.
 * @name KEN.Rectangle#size
 * @type {KEN.Size}
 * @readonly
 */
KEN.Rectangle.prototype.size;
Object.defineProperty(KEN.Rectangle.prototype, "size",
{
    /** @this {KEN.Rectangle} */
    get: function()
    {
        return new KEN.Size(this._width, this._height);
    }
});



/**
 * Size object.
 *
 * @constructor KEN.Size
 * @param {number} width width property
 * @param {number} height height property
 */
KEN.Size = function(width, height)
{
    /**
     * Width.
     * @name KEN.Size#_width
     * @type {number}
     * @private
     */
    this._width = width || 0;

    /**
     * Height.
     * @name KEN.Size#_height
     * @type {number}
     * @private
     */
    this._height = height || 0;
};

KEN.Size.prototype.constructor = KEN.Size;


/**
 * Get width.
 * @name KEN.Size#width
 * @type {number}
 */
KEN.Size.prototype.width;
Object.defineProperty(KEN.Size.prototype, "width",
{
    /** @this {KEN.Size} */
    get: function()
    {
        return this._width;
    }
});

/**
 * Get height.
 * @name KEN.Size#height
 * @type {number}
 */
KEN.Size.prototype.height;
Object.defineProperty(KEN.Size.prototype, "height",
{
    /** @this {KEN.Size} */
    get: function()
    {
        return this._height;
    }
});

/**
 * Get ratio.
 * @name KEN.Size#ratio
 * @type {number}
 */
KEN.Size.prototype.ratio;
Object.defineProperty(KEN.Size.prototype, "ratio",
{
    /** @this {KEN.Size} */
    get: function()
    {
        return this._width / this._height;
    }
});


/**
 * KEN Base 3d object with a mesh and events mechanisms.
 * @constructor KEN.Object3D
 * @param {KEN.Viewer} viewer - Viewer reference.
 * @param {string=} className - Class name for objects that extends Object3D
 * @extends {KEN.BaseObject}
 */
KEN.Object3D = function(viewer, className)
{
    /**
     * Viewer reference
     * @name  KEN.Object3D#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * THREE Mesh
     * @name KEN.Object3D#_mesh
     * @type {THREE.Mesh}
     * @private
     */
    this._mesh = null;

    /**
     * The fx set id applied to the object
     * @name  KEN.Object3D#_fx
     * @type {string}
     * @private
     */
    this._fx = "";

    /**
     * Visibility flag
     * @name  KEN.Object3D#_visible
     * @type {boolean}
     * @private
     */
    this._visible = true;

    /**
     * Is this object is interactive / raycastable
     * @name KEN.Object3D#_interactive
     * @type {boolean}
     * @private
     */
    this._interactive = true;

    /**
     * Events object that will keep references of the ActionEventDispatcher
     * @name KEN.Object3D#_events
     * @type {Object<KEN.ActionEventDispatcher>}
     * @private
     */
    this._events = null;

    /**
     * The hovered flag is set to true when any pointer is over the object.
     * @name KEN.Object3D#_hovered
     * @type {boolean}
     * @private
     */
    this._hovered = false;

    /**
     * Is ready?
     * @name  KEN.Object3D#_ready
     * @type {boolean}
     * @private
     */
    this._ready = false;

    /**
     * Click event dispatcher
     * @name KEN.Object3D#_onClick
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onClick = null;

    /**
     * Over event dispatcher
     * @name KEN.Object3D#_onOver
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onOver = null;

    /**
     * Out event dispatcher
     * @name KEN.Object3D#_onOut
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onOut = null;

    /**
     * Event dispatcher for ready state.
     * @name KEN.Object3D#_onReady
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onReady = null;

    KEN.BaseObject.call(this, className || "Object3D");

    this._boot();
};

KEN.Object3D.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Object3D.prototype.constructor = KEN.Object3D;

/**
 * Boot sequence.
 * @method KEN.Object3D#_boot
 */
KEN.Object3D.prototype._boot = function()
{
    this._events = {};
    this._mesh = new THREE.Mesh();
    this._viewer["renderer"]["objects"].register(this);
};

/**
 * Create action events dispatchers.
 * @method KEN.Object3D#_createEvents
 * @private
 * @param {Object} events - The events config of the 3d object.
 */
KEN.Object3D.prototype._createEvents = function(events)
{
    var event;
    for(var e in events)
    {
        event = new KEN.ActionEventDispatcher(this._viewer, e);
        event.addActions(events[e]);
        this._events[e] = event;
    }
};

/**
 * Triggers actions for the click event
 * @method KEN.Object3D#click
 */
KEN.Object3D.prototype.click = function()
{
    this.log("click");

    // Actions defined from the json
    if(KEN.Utils.isTypeOf(this._events["onClick"], "ActionEventDispatcher") === true)
    {
        this._events["onClick"].dispatch();
    }

    // Classical event dispatcher
    if(this._onClick !== null)
    {
        this._onClick.dispatch();
    }
};

/**
 * Triggers actions for the over event
 * @method KEN.Object3D#over
 */
KEN.Object3D.prototype.over = function()
{
    this.log("over");

    // Actions defined from the json
    if(KEN.Utils.isTypeOf(this._events["onOver"], "ActionEventDispatcher") === true)
    {
        this._events["onOver"].dispatch();
    }

    // Classical event dispatcher
    if(this._onOver !== null)
    {
        this._onOver.dispatch();
    }
};

/**
 * Triggers actions for the out event
 * @method KEN.Object3D#out
 */
KEN.Object3D.prototype.out = function()
{
    this.log("out");

    // Actions defined from the json
    if(KEN.Utils.isTypeOf(this._events["onOut"], "ActionEventDispatcher") === true)
    {
        this._events["onOut"].dispatch();
    }

    // Classical event dispatcher
    if(this._onOut !== null)
    {
        this._onOut.dispatch();
    }
};

/**
 * Destroy sequence
 * @method KEN.Object3D#destroy
 */
KEN.Object3D.prototype.destroy = function()
{
    this._viewer["renderer"]["objects"].unregister(this);

    if (this._mesh !== null)
    {
        this._mesh.userData = null;

        if (this._mesh.geometry !== null)
        {
            this._mesh.geometry.dispose();
            this._mesh.geometry = null;
        }

        this._mesh = null;
    }

    if(this._onClick !== null)
    {
        this._onClick.destroy();
        this._onClick = null;
    }

    if(this._onOver !== null)
    {
        this._onOver.destroy();
        this._onOver = null;
    }

    if(this._onOut !== null)
    {
        this._onOut.destroy();
        this._onOut = null;
    }

    if(this._onReady !== null)
    {
        this._onReady.destroy();
        this._onReady = null;
    }

    this._viewer = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * 3D object mesh
 * @name KEN.Object3D#mesh
 * @readonly
 * @type {THREE.Mesh}
  */
KEN.Object3D.prototype.mesh;
Object.defineProperty(KEN.Object3D.prototype, "mesh",
{
    /** @this {KEN.Object3D} */
    get: function()
    {
        return this._mesh;
    }
});

/**
 * Get and set the visible flag
 * @name KEN.Object3D#visible
 * @type {boolean}
 */
KEN.Object3D.prototype.visible;
Object.defineProperty(KEN.Object3D.prototype, "visible",
{
    /** @this {KEN.Object3D} */
    get: function()
    {
        return this._visible;
    },
    /** @this {KEN.Object3D} */
    set: function(value)
    {
        this._visible = Boolean(value);

        if(this._mesh !== null)
        {
            this._mesh["visible"] = this._visible;
        }
    }
});

/**
 * Get and set the hovered flag
 * @name KEN.Object3D#hovered
 * @type {boolean}
 */
KEN.Object3D.prototype.hovered;
Object.defineProperty(KEN.Object3D.prototype, "hovered",
{
    /** @this {KEN.Object3D} */
    get: function()
    {
        return this._hovered;
    },
    /** @this {KEN.Object3D} */
    set: function(value)
    {
        this._hovered = Boolean(value);
    }
});


/**
 * Get and set the interactive flag
 * @name KEN.Object3D#interactive
 * @type {boolean}
 */
KEN.Object3D.prototype.interactive;
Object.defineProperty(KEN.Object3D.prototype, "interactive",
{
    /** @this {KEN.Object3D} */
    get: function()
    {
        return this._interactive;
    },
    /** @this {KEN.Object3D} */
    set: function(value)
    {
        this._interactive = Boolean(value);
    }
});

/**
 * Get the FX applied to this object
 * @name KEN.Object3D#fx
 * @readonly
 * @type {string}
 */
KEN.Object3D.prototype.fx;
Object.defineProperty(KEN.Object3D.prototype, "fx",
{
    /** @this {KEN.Object3D} */
    get: function()
    {
        return this._fx;
    }
});

/**
 * Get the events of this object
 * @name KEN.Object3D#events
 * @readonly
 * @type {Object}
 */
KEN.Object3D.prototype.events;
Object.defineProperty(KEN.Object3D.prototype, "events",
{
    /** @this {KEN.Object3D} */
    get: function()
    {
        return this._events;
    }
});

/**
 * Object3D ready flag
 * @name KEN.Object3D#ready
 * @readonly
 * @type boolean
  */
KEN.Object3D.prototype.ready;
Object.defineProperty(KEN.Object3D.prototype, "ready",
{
    /** @this {KEN.Object3D} */
    get: function()
    {
        return this._ready;
    }
});

/**
 * Get the onClick {@link KEN.EventDispatcher}.
 * @name KEN.Object3D#onClick
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Object3D.prototype.onClick;
Object.defineProperty(KEN.Object3D.prototype, "onClick",
{
    /** @this {KEN.Object3D} */
    get: function()
    {
        if (this._onClick === null)
        {
            this._onClick = new KEN.EventDispatcher(this);
        }

        return this._onClick;
    }
});

/**
 * Get the onOver {@link KEN.EventDispatcher}.
 * @name KEN.Object3D#onOver
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Object3D.prototype.onOver;
Object.defineProperty(KEN.Object3D.prototype, "onOver",
{
    /** @this {KEN.Object3D} */
    get: function()
    {
        if (this._onOver === null)
        {
            this._onOver = new KEN.EventDispatcher(this);
        }

        return this._onOver;
    }
});

/**
 * Get the onOut {@link KEN.EventDispatcher}.
 * @name KEN.Object3D#onOut
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Object3D.prototype.onOut;
Object.defineProperty(KEN.Object3D.prototype, "onOut",
{
    /** @this {KEN.Object3D} */
    get: function()
    {
        if (this._onOut === null)
        {
            this._onOut = new KEN.EventDispatcher(this);
        }

        return this._onOut;
    }
});

/**
 * Get the onReady {@link KEN.EventDispatcher}.
 * @name KEN.Object3D#onReady
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Object3D.prototype.onReady;
Object.defineProperty(KEN.Object3D.prototype, "onReady",
{
    /** @this {KEN.Object3D} */
    get: function()
    {
        if (this._onReady === null)
        {
            this._onReady = new KEN.EventDispatcher(this);
        }

        return this._onReady;
    }
});


/**
 * @constructor KEN.ObjectRenderer
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @extends {KEN.BaseObject}
 */
KEN.ObjectRenderer = function(viewer)
{
    /**
     * Viewer reference
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * List of object that have to be rendered
     * @name KEN.ObjectRenderer#_objects
     * @type {Array<KEN.Object3D>}
     * @private
     */
    this._objects = null;

    /**
     * Array of render passes
     * @type {Array<KEN.RenderScene>}
     * @private
     */
    this._renderScenes = null;

    KEN.BaseObject.call(this, "ObjectRenderer");

    this._boot();
};

KEN.ObjectRenderer.prototype = Object.create(KEN.BaseObject.prototype);
KEN.ObjectRenderer.prototype.constructor = KEN.ObjectRenderer;

/**
 * Init routine
 * @method KEN.ObjectRenderer#_boot
 * @private
 */
KEN.ObjectRenderer.prototype._boot = function()
{
    this._objects = [];
    this._renderScenes = [];
};

/**
 * Get 3d objects by FX
 * @method  KEN.ObjectRenderer#_getByFX
 * @param  {?string} fx - The fx name you want to use to filter 3d objects. If undefined or null, will return 3d objects without fx.
 * @return {Array<KEN.Object3D>}
 * @private
 */
KEN.ObjectRenderer.prototype._getByFX = function(fx)
{
    var result = [];

    if(typeof fx === "undefined" || fx === "" || fx === null)
    {
        result = this._objects.filter(function(hs)
        {
            return (typeof hs["fx"] === "undefined" || hs["fx"] === "" || hs["fx"] === null);
        });
    }
    else
    {
        result = this._objects.filter(function(hs)
        {
            return hs["fx"] === fx;
        });
    }

    return result;
};

/**
 * Get 3d objects that have no fx
 * @method  KEN.ObjectRenderer#_getWithoutFX
 * @return {Array<KEN.Object3D>}
 * @private
 */
KEN.ObjectRenderer.prototype._getWithoutFX = function()
{
    var result = this._getByFX(null);
    return result;
};

/**
 * Get 3d objects that have fx
 * @method  KEN.ObjectRenderer#_getWithFX
 * @return {Array<KEN.Object3D>}
 * @private
 */
KEN.ObjectRenderer.prototype._getWithFX = function()
{
    var withoutFX = this._getWithoutFX();
    var result = KEN.Utils.arrayByDifference(this._objects, withoutFX);
    return result;
};

/**
 * Get single fx list used by all objects
 * @method  KEN.ObjectRenderer#_getFX
 * @return {Array<string>}
 * @private
 */
KEN.ObjectRenderer.prototype._getFX = function()
{
    var withFX = this._getWithFX();

    var result = withFX.reduce(function(list, spot)
    {
        if (list.indexOf(spot["fx"]) < 0)
        {
            list.push(spot["fx"]);
        }

        return list;

    }, []);

    return result;
};

/**
 * Register an object to the object renderer
 * @method KEN.ObjectRenderer#register
 * @param  {KEN.Object3D} object - The object to register
 */
KEN.ObjectRenderer.prototype.register = function(object)
{
    this._objects.push(object);
};

/**
 * Unregister an object from the object renderer.
 * @method  KEN.ObjectRenderer#unregister
 * @param {KEN.Object3D} object - The object to unregister from the object renderer.
 */
KEN.ObjectRenderer.prototype.unregister = function(object)
{
    this._objects.splice(this._objects.indexOf(object), 1);
};

/**
 * @method KEN.ObjectRenderer#createRenderScenes
 */
KEN.ObjectRenderer.prototype.createRenderScenes = function()
{
    // First get all 3d objects without any FX and create a render pass for them
    // Then get all other 3d objects (with some FX), extract FX list and create
    // as many render passes as needed (one for each FX set).

    var camera = this._viewer["renderer"]["camera"]["perspectiveCamera"];

    // Get list of objects without any fx
    var withoutFX = this._getWithoutFX();

    // Create a render pass for them
    if (withoutFX.length > 0)
    {
        var scene = new THREE.Scene();

        for (var i = 0, ii = withoutFX.length; i < ii; i++)
        {
            scene.add(withoutFX[i]["mesh"]);
        }

        this._renderScenes.push(new KEN.RenderScene(this._viewer, scene, camera, null));
    }

    var fxList = this._getFX();

    // For each FX in the list, create a render scene and assign all 3d objects
    // with the FX to it
    for (var j = 0, jj = fxList.length; j < jj; j++)
    {
        var fx = fxList[j];
        var renderList = this._getByFX(fx);
        var sceneFx = new THREE.Scene();

        for (var k = 0, kk = renderList.length; k < kk; k++)
        {
            sceneFx.add(renderList[k]["mesh"]);
        }

        var fxSet = this._viewer["postProcessing"].getFxSetByUID(fx);
        this._renderScenes.push(new KEN.RenderScene(this._viewer, sceneFx, camera, fxSet));
    }
};

/**
 * Get 3d objects that are eligible to raycast (interactive)
 * @method  KEN.ObjectRenderer#getRaycastable
 * @return {Array<KEN.Object3D>}
 */
KEN.ObjectRenderer.prototype.getRaycastable = function()
{
    var result = this._objects.filter(function(object)
    {
        return (object["ready"] === true && object["interactive"] === true);
    });

    return result;
};

/**
 * Get a 3d object from it's mesh
 * @method  KEN.ObjectRenderer#getByMesh
 * @return {?KEN.Object3D}
 */
KEN.ObjectRenderer.prototype.getByMesh = function(mesh)
{
    for(var i = 0, ii = this._objects.length; i < ii; i++)
    {
        if(this._objects[i]["mesh"] === mesh)
        {
            return this._objects[i];
        }
    }

    return null;
};

/**
 * Clear all render scenes
 * @method KEN.ObjectRenderer#clear
 */
KEN.ObjectRenderer.prototype.clear = function()
{
    var count = this._renderScenes.length;
    while(count--)
    {
        var renderScene = this._renderScenes.pop();
        renderScene.destroy();
    }
};

/**
 * Destroy sequence
 * @method KEN.ObjectRenderer#destroy
 */
KEN.ObjectRenderer.prototype.destroy = function()
{
    this.clear();
    this._renderScenes = null;
    this._viewer = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get all the objects
 * @name KEN.ObjectRenderer#all
 * @type {Array<{KEN.Object3D}>}
 */
KEN.ObjectRenderer.prototype.all;
Object.defineProperty(KEN.ObjectRenderer.prototype, "all",
{
    /** @this {KEN.ObjectRenderer} */
    get: function()
    {
        return this._objects;
    }
});


/**
 * Get background renderer render items array.
 * @name KEN.ObjectRenderer#renderScenes
 * @type {Array<{THREE.RenderPass, Object}>}
 */
KEN.ObjectRenderer.prototype.renderScenes;
Object.defineProperty(KEN.ObjectRenderer.prototype, "renderScenes",
{
    /** @this {KEN.ObjectRenderer} */
    get: function()
    {
        return this._renderScenes;
    }
});



/**
 * Raycaster for mouse interaction with 3d objects of the scene
 * @constructor KEN.Raycaster
 * @param {KEN.Viewer} viewer - Viewer reference
 * @extends {KEN.BaseObject}
 */
KEN.Raycaster = function(viewer)
{
    /**
     * Viewer reference
     * @name KEN.Raycaster#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * THREE raycaster instance.
     * @name KEN.Raycaster#_raycaster
     * @type {THREE.Raycaster}
     * @private
     */
    this._raycaster = null;

    /**
     * The last hovered 3d object
     * @name KEN.Raycaster#_hoveredObject
     * @type {?KEN.Object3D}
     * @private
     */
    this._hoveredObject = null;

    KEN.BaseObject.call(this, "Raycaster");

    this._boot();
};

KEN.Raycaster.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Raycaster.prototype.constructor = KEN.Raycaster;

/**
 * Boot sequence
 * @method KEN.Raycaster#_boot
 * @private
 */
KEN.Raycaster.prototype._boot = function()
{
    this._viewer["tour"]["onSceneLoadComplete"].add(this._sceneLoadCompleteHandler, this);
};

/**
 * Event handler for scene load complete
 * @method KEN.Raycaster#_sceneLoadCompleteHandler
 * @param {KEN.Event} event - The event of the scene load complete.
 * @private
 */
KEN.Raycaster.prototype._sceneLoadCompleteHandler = function(event)
{
    var scene = event["emitter"]["scene"];
    scene["onUnloadStart"].addOnce(this._sceneUnloadStartHandler, this);

    this._start();
};

/**
 * Event handler for scene unload start
 * @method KEN.Raycaster#_sceneUnloadStartHandler
 * @private
 */
KEN.Raycaster.prototype._sceneUnloadStartHandler = function()
{
    this._stop();
};

/**
 * Start raycasting.
 * Add event on the main canvas for mouse interaction
 * @method KEN.Raycaster#_start
 * @private
 */
KEN.Raycaster.prototype._start = function()
{
    this.log("Raycating start");

    if (this._raycaster === null)
    {
        this._raycaster = new THREE.Raycaster();
    }

    if (this._viewer["canvas"]["pointer"]["onClick"].has(this._canvasPointerClickHandler, this) === false)
    {
        this._viewer["canvas"]["pointer"]["onClick"].add(this._canvasPointerClickHandler, this);
    }

    if (this._viewer["canvas"]["pointer"]["onMove"].has(this._canvasPointerMoveHandler, this) === false)
    {
        this._viewer["canvas"]["pointer"]["onMove"].add(this._canvasPointerMoveHandler, this);
    }
};

/**
 * Stop raycasting
 * @method KEN.Raycaster#_stop
 * @private
 */
KEN.Raycaster.prototype._stop = function()
{
    this.log("Raycating stop");

    // Remove pointer event listeners
    if (this._viewer["canvas"]["pointer"]["onClick"].has(this._canvasPointerClickHandler, this))
    {
        this._viewer["canvas"]["pointer"]["onClick"].remove(this._canvasPointerClickHandler, this);
    }

    if (this._viewer["canvas"]["pointer"]["onMove"].has(this._canvasPointerMoveHandler, this))
    {
        this._viewer["canvas"]["pointer"]["onMove"].remove(this._canvasPointerMoveHandler, this);
    }

    this._raycaster = null;
};

/**
 * Pointer click handler, launch raycasting
 * @method KEN.Raycaster#_canvasPointerClickHandler
 * @param {Object} event click event
 * @private
 */
KEN.Raycaster.prototype._canvasPointerClickHandler = function(event)
{
    event["data"]["center"] = event["data"]["center"] || {x:event["data"].x, y:event["data"].y};
    this._raycast("click", event["data"]["center"]);
};

/**
 * Pointer over handler, launch raycasting
 * @method KEN.Raycaster#_canvasPointerMoveHandler
 * @param {Object} event move event
 * @private
 */
KEN.Raycaster.prototype._canvasPointerMoveHandler = function(event)
{
    event["data"]["center"] = event["data"]["center"] || {x:event["data"].x, y:event["data"].y};
    this._raycast("move", event["data"]["center"]);
};

/**
 * Raycasting internal method
 * @method KEN.Raycaster#_raycast
 * @param {string} event - triggering event
 * @param {Object} screenPoint - raycasting point in screen coordinates
 * @private
 */
KEN.Raycaster.prototype._raycast = function(event, screenPoint)
{
    screenPoint = screenPoint || { x:0, y:0 };

    var resolution = this._viewer["renderer"]["canvasResolution"];
    var camera = this._viewer["renderer"]["camera"];
    var ndc = new THREE.Vector2(screenPoint.x / resolution["width"], 1.0 - screenPoint.y / resolution["height"]).multiplyScalar(2).addScalar(-1);

    // Get all objects of the object renderer that are ready and interactive
    var objects = this._viewer["renderer"]["objects"].getRaycastable();

    //Reset the hovered flag of all the objects
    this._setHovered(objects, false);

    // Get the first intersected object
    var intersected = this._intersect(objects, ndc, camera);

    if (intersected !== null)
    {
        if(event === "click")
        {
            intersected.click();
        }
        else if(event === "move")
        {
            if(intersected !== this._hoveredObject)
            {
                this._hoveredObject = intersected;
                intersected.over();
            }
        }
    }
    else
    {
        if(this._hoveredObject !== null)
        {
            this._hoveredObject.out();
            this._hoveredObject = null;
        }
    }
};

/**
 * Set the hovered flag to an array ok {@link KEN.Object3D}
 * @method KEN.Raycaster#_setHovered
 * @param {Array<KEN.Object3D>} objects - The array of 3d objects who'll be affected
 * @param {boolean} hovered - The hovered flag you want to set to all the 3d objects of the array
 * @private
 */
KEN.Raycaster.prototype._setHovered = function(objects, hovered)
{
    for(var i = 0, ii = objects.length; i < ii; i++)
    {
        objects[i]["hovered"] = hovered;
    }
};

/**
 * Intrsect 3d objects from a ndc point and a camera
 * @param  {Array<KEN.Object3D>} objects - Array of object to test
 * @param  {THREE.Vector2} ndc - Normalized device coordinate point
 * @param  {KEN.Camera} camera - Camera to use
 * @return {?KEN.Object3D} Return the first hitted 3d Object
 * @private
 */
KEN.Raycaster.prototype._intersect = function(objects, ndc, camera)
{
    var result = null;

    // Set the three raycaster with the ndc coordinates and the camera.
    this._raycaster.setFromCamera(ndc, camera["perspectiveCamera"]);

    // Make an array of meshes for the three raycaster
    var meshes = [];
    for(var i = 0, ii = objects.length; i < ii; i++)
    {
        meshes.push(objects[i]["mesh"]);
    }

    // Get all objects intersected by the ray
    var intersects = this._raycaster.intersectObjects(meshes);

    if(intersects.length > 0)
    {
        var mesh = intersects[0]["object"];
        var uv = intersects[0].uv;
        var object = this._viewer["renderer"]["objects"].getByMesh(mesh);

        if(mesh["material"]["transparent"] === true)
        {
            var color = this._getObjectColorFromUVCoords(object, uv);

            if(color !== null && color["alpha"] > 10)
            {
                result = object;
            }
        }
        else
        {
            result = object;
        }
    }

    return result;
};

/**
 * Get RGBA color at a given point on a texture
 * @method KEN.Raycaster#_getObjectColorFromUVCoords
 * @param {THREE.Vector2} uv point with normalized coordinates
 * @return {KEN.ColorRGBA} RGBA color at given point or null if image is not available
 * @private
 */
KEN.Raycaster.prototype._getObjectColorFromUVCoords = function(object, uv)
{
    var color = null;

    if(object["mesh"] !== null && object["mesh"]["material"] !== null && object["mesh"]["material"].map !== null)
    {
        var texture = object["mesh"]["material"].map;
        var canvas = null;

        if(texture.image !== null)
        {
            if(texture.image.nodeName.toLowerCase() === "img")
            {
                canvas = document.createElement("canvas");
                canvas["width"] = texture.image["width"];
                canvas["height"] = texture.image["height"];
                canvas.getContext("2d").drawImage(texture.image, 0, 0);
            }
            else if(texture.image.nodeName.toLowerCase() === "canvas")
            {
                canvas = texture.image;
            }

            if(canvas !== null)
            {
                var w = canvas["width"];
                var h = canvas["height"];
                var x = Math.floor(uv.x * w);
                var y = Math.floor(h - uv.y * h);
                var idx = 4 * (y * w + x);

                var data = canvas.getContext("2d").getImageData(0, 0, w, h).data;
                color = new KEN.ColorRGBA(data[idx + 0], data[idx + 1], data[idx + 2], data[idx + 3]);
            }
        }
    }

    return color;
};
/**
 * Media class.
 *
 * @constructor KEN.Media
 * @param {KEN.Viewer} viewer {@link KEN.Viewer} reference.
 * @param {Object} config input media configuration from json
 * @extends {KEN.BaseObject}
 *
 */
KEN.Media = function(viewer, config)
{
    /**
     * The viewer reference.
     * @name KEN.Media#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Input config
     * @name KEN.Media#_config
     * @type {Object}
     * @private
     */
    this._config = config;

    /**
     * Media options
     * @name  KEN.Media#_options
     * @type {Object}
     * @private
     */
    this._options = null;

    /**
     * Image reference.
     * @name KEN.Media#_displayObject
     * @type {KEN.DisplayObject}
     * @private
     */
    this._displayObject = null;

    /**
     * On load complete event dispatcher.
     * @name  KEN.Media#_onLoadComplete
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onLoadComplete = null;

    KEN.BaseObject.call(this, "Media");

    this._boot();
};

KEN.Media.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Media.prototype.constructor = KEN.Media;

/**
 * Init routine
 * @method KEN.Media#_boot
 * @private
 */
KEN.Media.prototype._boot = function()
{
    this._parseConfig(this._config);
};

/**
 * Configuration parsing.
 * @method KEN.Media#_parseConfig
 * @param {Object} config input media configuration
 * @private
 */
KEN.Media.prototype._parseConfig = function(config)
{
    this.warn("KEN.Media config validator not implemented");

    // Warning : UID is not registered and applied to the KEN.ImageScalable|KEN.Image|KEN.VideoHTML5|KEN.VideoDash objects for registration
    this._uid = config["uid"];

    if (config["type"] === "image")
    {
        var multiResolutions = ["cube", "sphere"];

        // If multiresolution: create a pyramid cache manager
        if (multiResolutions.indexOf(config.format) !== -1)
        {
            throw "Not implemented (parseConfig : multiresolution)";
        }
        // Else create an image
        else
        {
            // @todo add method to validate input
            var imageConfig =
            {
                key: config["uid"],
                url: config.source["url"]
            };

            if (config.format === "hotspot")
            {
                this._displayObject = new KEN.ImageScalable(this._viewer, imageConfig);
            }
            else
            {
                this._displayObject = new KEN.Image(this._viewer, imageConfig);
            }

            this._displayObject["onLoadComplete"].addOnce(this._onImageLoadComplete, this);
        }
    }
    else if (config["type"] === "video")
    {
        //hotspot specific Video class options
        if (config.format === "hotspot")
        {
            //force the first video source
            //@todo CHANGE when webm/ogg/mp4 support will be done !!!
            if(typeof config.source.format !== "undefined" && config.source.format === KEN.VideoFormat.DASH)
            {
                this._displayObject = new KEN.VideoDash(this._viewer, config["uid"], config.source.files[0]);
            }
            else
            {
                this._displayObject = new KEN.VideoHTML5(this._viewer, config["uid"], config.source.files[0]);
            }
        }
        else
        {
            if(typeof config.source.format !== "undefined" && config.source.format === KEN.VideoFormat.DASH)
            {
                this._displayObject = new KEN.VideoDash(this._viewer, config["uid"]);
            }
            else
            {
                this._displayObject = new KEN.VideoHTML5(this._viewer, config["uid"]);
            }
            this._displayObject.load(config.source.files);
        }

        this._displayObject["onLoadedMetaData"].addOnce(this._onLoadedMetaDataHandler, this);
        //this._displayObject.load(config.source.files);
    }

    this._options = (typeof config["options"] !== "undefined") ? config["options"] : null;
};

/**
 * Internal handler on image ready.
 * @method KEN.Media#_onImageLoadComplete
 * @private
 */
KEN.Media.prototype._onImageLoadComplete = function()
{
    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.dispatch();
    }
};

/**
 * Internal handler on video metadata loaded.
 * @method KEN.Media#_onLoadedMetaDataHandler
 * @private
 */
KEN.Media.prototype._onLoadedMetaDataHandler = function()
{
    if(this._options !== null)
    {
        this._displayObject["volume"] = (typeof this._options["volume"] === "number") ? this._options["volume"] : 1;
        this._displayObject["loop"] = (typeof this._options["loop"] === "boolean") ? this._options["loop"] : true;

        if(this._options["autoPlay"] !== false)
        {
            this._displayObject.play();
        }
    }

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.dispatch();
    }
};

/**
 * Media destroy sequence
 *
 * @method KEN.Media#destroy
 */
KEN.Media.prototype.destroy = function()
{
    if(this._displayObject !== null)
    {
        this._displayObject.destroy();
        this._displayObject = null;
    }

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.destroy();
        this._onLoadComplete = null;
    }

    this._viewer = null;
    this._config = null;
};


/**
 * Get the displayObject.
 * @name  KEN.Media#displayObject
 * @readonly
 * @type {KEN.DisplayObject}
 *
 * @todo  This is temporary
 */
KEN.Media.prototype.displayObject;
Object.defineProperty(KEN.Media.prototype, "displayObject",
{
    /** @this {KEN.Media} */
    get: function()
    {
        return this._displayObject;
    }
});

/**
* Get the onLoadComplete {@link KEN.EventDispatcher}.
* @name KEN.Media#onLoadComplete
* @readonly
* @type {KEN.EventDispatcher}
*/
KEN.Media.prototype.onLoadComplete;
Object.defineProperty(KEN.Media.prototype, "onLoadComplete",
{
    /** @this {KEN.Media} */
    get: function()
    {
        if(this._onLoadComplete === null)
        {
            this._onLoadComplete = new KEN.EventDispatcher(this);
        }

        return this._onLoadComplete;
    }
});

/**
 * RenderManager class.
 *
 * @constructor KEN.RenderManager
 * @param {KEN.Viewer} viewer reference on KEN viewer
 * @extends {KEN.BaseObject}
 *
 * @todo think about how to render multiple scene at the same time, with blending / overlap / viewport layouting...
 * maybe add a layer object encapsulating background / foreground renderings to ease the process
 */
KEN.RenderManager = function(viewer)
{
    /**
     * The viewer reference.
     * @name KEN.RenderManager#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * WebGL Renderer
     * @name KEN.RenderManager#_webGLRenderer
     * @type {?THREE.WebGLRenderer}
     * @private
     */
    this._webGLRenderer = null;

    /**
     * Render pipeline managing composers
     * @name KEN.RenderManager#_renderPipeline
     * @type {KEN.RenderPipeline}
     * @private
     */
    this._renderPipeline = null;

    /**
     * Object managing screen/VR display
     * @name KEN.RenderManager#_renderDisplay
     * @type {KEN.RenderDisplay}
     * @private
     */
    this._renderDisplay = null;

    /**
     * View reference.
     * @name KEN.RenderManager#_view
     * @type {?KEN.ViewBase}
     * @private
     */
    this._view = null;

    /**
     * The media reference.
     * @name KEN.RenderManager#_media
     * @type {?KEN.Media}
     * @private
     */
    this._media = null;

    /**
     * Background renderer.
     * @name KEN.RenderManager#_backgroundRenderer
     * @type {?KEN.BackgroundRenderer}
     * @private
     */
    this._backgroundRenderer = null;

    /**
     * Type of the background renderer.
     * @name KEN.RenderManager#_backgroundRendererType
     * @type {string}
     * @private
     */
    this._backgroundRendererType = KEN.BackgroundType.UNDEFINED;

    /**
     * Camera reference.
     * @name KEN.RenderManager#_camera
     * @type {?KEN.Camera}
     * @private
     */
    this._camera = null;

    /**
     * Camera scene used to render objects in camera space
     * @name KEN.RenderManager#_cameraScene
     * @type {THREE.Scene}
     * @private
     */
    this._cameraScene = null;

    /**
     * Ready flag. Renderer won't render anything while this is false.
     * @name KEN.RenderManager#_isReady
     * @type {boolean}
     * @private
     */
    this._isReady = false;

    /**
     * Canvas resolution (px)
     * @name KEN.RenderManager#_canvasResolution
     * @type {?KEN.Size}
     * @private
     */
    this._canvasResolution = null;

    /**
     * Display resolution (px)
     * @name KEN.RenderManager#_displayResolution
     * @type {?KEN.Size}
     * @private
     */
    this._displayResolution = null;

    /**
     * objects renderer
     * @name  KEN.RenderManager#_objectRenderer
     * @type {?KEN.ObjectRenderer}
     * @private
     */
    this._objectRenderer = null;

    /**
     * Global texture loader object
     * @name  KEN.RenderManager#_textureLoader
     * @type {?THREE.TextureLoader}
     * @private
     */
    this._textureLoader = null;

    /**
     * Scene configuration
     * @name  KEN.RenderManager#_sceneConfig
     * @type {Object}
     * @private
     */
    this._sceneConfig = null;

    /**
     * Background renderer ready flag
     * @name KEN.RenderManager#_backgroundReady
     * @type boolean
     * @private
     */
    this._backgroundReady = false;

    /**
     * Hotspot renderer ready flag
     * @name KEN.RenderManager#_hotspotsReady
     * @type boolean
     * @private
     */
    this._hotspotsReady = false;

    /**
     * Event dispatcher for background renderer ready.
     * @name KEN.RenderManager#_onBackgroundReady
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onBackgroundReady = null;

    /**
     * Event dispatcher for hotspot renderer ready.
     * @name KEN.RenderManager#_onHotspotsReady
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onHotspotsReady = null;

    /**
     * Event dispatcher for renderer ready.
     * @name KEN.RenderManager#_onReady
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onReady = null;

    /**
     * Event dispatcher for media ready status.
     * @name KEN.RenderManager#_onMediaReady
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onMediaReady = null;

    /**
     * Event dispatcher for media release.
     * @name KEN.RenderManager#_onMediaRelease
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onMediaRelease = null;

    KEN.BaseObject.call(this, "RenderManager");

    this._boot();
};

KEN.RenderManager.prototype = Object.create(KEN.BaseObject.prototype);
KEN.RenderManager.prototype.constructor = KEN.RenderManager;

/**
 * Boot sequence.
 * @method KEN.RenderManager#_boot
 * @private
 */
KEN.RenderManager.prototype._boot = function()
{
    if (this._isReady === true)
    {
        return;
    }

    this._viewer["onReady"].add(this._onViewerReady, this, 1000);
};

/**
 * Viewer ready handler
 * @method KEN.RenderManager#_onViewerReady
 * @private
 */
KEN.RenderManager.prototype._onViewerReady = function()
{
    var canvas = this._viewer["canvas"]["dom"];

    var options =
    {
        antialias: true,
        alpha: true,
        premultipliedAlpha: false,
        canvas: canvas
    };

    // WebGLRenderer will draw any component supported by WebGL
    try
    {
        this._webGLRenderer = new THREE.WebGLRenderer(options);
    }
    catch (error)
    {
        this.destroy();
        return;
    }

    this._webGLRenderer.autoClear = false;
    this._webGLRenderer.autoClearDepth = true;
    this._webGLRenderer.autoClearColor = true;

    this._textureLoader = new THREE.TextureLoader();

    this._renderPipeline = new KEN.RenderPipeline(this._viewer);

    this._renderDisplay = new KEN.RenderDisplay(this._viewer);
    this._renderDisplay["onDisplayChange"].add(this._renderDisplayChangeHandler, this);
    this._setRendererSize(this._renderDisplay["rendererSize"]);

    this._camera = new KEN.Camera(this._viewer);
    this._camera["viewfinder"]["visible"] = false;

    this._cameraScene = new THREE.Scene();
    this._cameraScene.add(this._camera["perspectiveCamera"]);

    this._objectRenderer = new KEN.ObjectRenderer(this._viewer);

    this._viewer["canvas"]["onResize"].add(this._canvasResizeHandler, this);

    this._viewer["tour"]["onSceneLoadStart"].add(this._onSceneLoadStart, this);
};

/**
 * Scene has started to load.
 * Init the view, the camera and the media
 * @todo create media / background renderer
 *
 * @method KEN.RenderManager#_onSceneLoadStart
 * @private
 */
KEN.RenderManager.prototype._onSceneLoadStart = function()
{
    // Listen to scene unload
    this._viewer["tour"]["scene"]["onUnloadStart"].addOnce(this._onSceneUnloadStart, this);

    var sceneConfig = /** @type {SceneConfig} */ (this._viewer["tour"]["scene"]["config"]);
    this._sceneConfig = sceneConfig;

    // Apply background to renderer
    if (typeof sceneConfig["background"] !== "undefined")
    {
        this._viewer["container"]["background"] = sceneConfig["background"];
    }

    this._initView(sceneConfig);

    this._initCamera(sceneConfig);

    this._initMedia(sceneConfig);
};

/**
 * Scene has started to unload
 * @todo clean media / background renderer
 *
 * @method KEN.RenderManager#_onSceneUnloadStart
 * @private
 */
KEN.RenderManager.prototype._onSceneUnloadStart = function()
{
    this._backgroundReady = false;
    this._hotspotsReady = false;

    // Clear fx composer and hotspot renderer
    if (this._objectRenderer !== null)
    {
        this._objectRenderer.clear();
    }

    if (this._renderPipeline !== null)
    {
        this._renderPipeline.clear();
    }

    this._sceneConfig = null;

    // Destroy media
    if (this._media !== null)
    {
        if (KEN.Utils.isTypeOf(this._media["displayObject"], ["VideoHTML5", "VideoDash"]) === true &&
            this._media["displayObject"]["onQualityChange"] !== undefined &&
            this._media["displayObject"]["onQualityChange"].has(this._mediaQualityChangeHandler, this))
        {
            this._media["displayObject"]["onQualityChange"].remove(this._mediaQualityChangeHandler, this);
        }

        if (this._onMediaRelease !== null)
        {
            this._onMediaRelease.dispatch();
        }

        this._media.destroy();
        this._media = null;
    }
};

/**
 * Init view with info contained in configuration
 * @method KEN.RenderManager#_initView
 * @param {SceneConfig} sceneConfig - scene configuration
 * @private
 */
KEN.RenderManager.prototype._initView = function(sceneConfig)
{
    var sceneViewConfig = /** @type {ViewConfig} */ (sceneConfig["view"]);
    var tourViewConfig = /** @type {ViewConfig} */ (this._viewer["tour"]["config"]["view"]);
    var extendedViewConfig = /** @type {ViewConfig} */ (KEN.Utils.extendMultipleObjects(tourViewConfig, sceneViewConfig));

    var type = (typeof extendedViewConfig["type"] === "string") ? extendedViewConfig["type"].toLowerCase() : KEN.ViewType.RECTILINEAR;

    switch (type)
    {
        case KEN.ViewType.GOPRO:
            this._setView(KEN.ViewType.GOPRO);
            break;

        case KEN.ViewType.RECTILINEAR:
        default:
            this._setView(KEN.ViewType.RECTILINEAR);
            break;
    }
};

/**
 * Init camera with info contained in configuration
 * @method KEN.RenderManager#_initCamera
 * @param {SceneConfig} sceneConfig - scene configuration
 * @private
 */
KEN.RenderManager.prototype._initCamera = function(sceneConfig)
{
    var sceneCameraConfig = /** @type {CameraConfig} */ (sceneConfig["camera"]);
    var tourCameraConfig = /** @type {CameraConfig} */ (this._viewer["tour"]["config"]["camera"]);
    var extendedCameraConfig = /** @type {CameraConfig} */ (KEN.Utils.extendMultipleObjects(tourCameraConfig, sceneCameraConfig));

    this._camera.load(extendedCameraConfig);
};

/**
 * Init the scene media with info contained in configuration
 * @method KEN.RenderManager#_initMedia
 * @param {SceneConfig} sceneConfig - scene configuration
 * @private
 */
KEN.RenderManager.prototype._initMedia = function(sceneConfig)
{
    // Create media
    if(typeof sceneConfig["media"] !== "undefined" && typeof sceneConfig["media"]["type"] !== "undefined")
    {
        if (sceneConfig["media"].format === "cubemap")
        {
            this._backgroundRendererType = KEN.BackgroundType.MESH;
        }
        else
        {
            this._backgroundRendererType = KEN.BackgroundType.SHADER;
        }

        this._media = new KEN.Media(this._viewer, sceneConfig["media"]);

        // Listen to media load complete event once
        this._media["onLoadComplete"].addOnce(this._mediaLoadCompleteHandler, this);

        // If media is a video, listen to the quality change event
        if (KEN.Utils.isTypeOf(this._media["displayObject"], ["VideoHTML5", "VideoDash"]))
        {
            this._media["displayObject"]["onQualityChange"].add(this._mediaQualityChangeHandler, this);
        }

        if (this._onMediaReady !== null)
        {
            this._onMediaReady.dispatch();
        }
    }
    else
    {
        // No media - Clear the previous background renderer
        this._clearBackgroundRenderer();
    }
};

/**
 * Handler of media load complete event
 * @method KEN.RenderManager#_mediaLoadCompleteHandler
 * @private
 */
KEN.RenderManager.prototype._mediaLoadCompleteHandler = function(event)
{
    this.log("Media load is complete");

    this._setBackgroundRenderer(this._backgroundRendererType);

    this._backgroundRenderer["displayObject"] = event["emitter"]["displayObject"];

    this._setupRenderPipeline();

    this._backgroundReady = true;

    if (this._onBackgroundReady !== null)
    {
        this._onBackgroundReady.dispatch();
    }
};

/**
 * Handler of media quality change event
 * @method KEN.RenderManager#_mediaQualityChangeHandler
 * @private
 */
KEN.RenderManager.prototype._mediaQualityChangeHandler = function(event)
{
    this.log("Media quality has changed");

    this._backgroundRenderer["displayObject"] = event["emitter"];
};


KEN.RenderManager.prototype._setupRenderPipeline = function()
{
    var fxSet = null;
    if (typeof this._sceneConfig["media"]["fx"] !== "undefined" && this._sceneConfig["media"]["fx"] !== null)
    {
        fxSet = this._viewer["postProcessing"].getFxSetByUID(this._sceneConfig["media"]["fx"]);
    }
    this._renderPipeline.addBackground(this._backgroundRenderer["renderTarget"]["texture"], fxSet);

    this._objectRenderer.createRenderScenes();
    this._renderPipeline.addRenderScenes(this._objectRenderer["renderScenes"]);

    if (typeof this._sceneConfig["fx"] !== "undefined")
    {
        var globalFxSet = this._viewer["postProcessing"].getFxSetByUID(this._sceneConfig["fx"]);
        this._renderPipeline.addGlobalFx(globalFxSet);
    }
};

/**
 * Render background.
 * @method KEN.RenderManager#_drawBackground
 * @private
 */
KEN.RenderManager.prototype._drawBackground = function()
{
    // this.log("_drawBackground");

    if (this._backgroundRenderer !== null)
    {
        this._backgroundRenderer.render();
    }
};

/**
 * Set renderer size and all objects aware of resolution
 * @method KEN.RenderManager#_setRendererSize
 * @param {KEN.Size} size - new renderer size
 * @private
 */
KEN.RenderManager.prototype._setRendererSize = function(size)
{
    var vr = this._renderDisplay["presentingVR"];

    var keepCanvasStyle = true;

    if (vr === true)
    {
        keepCanvasStyle = false;
    }

    // Resize
    if (vr === false)
    {
        this._renderDisplay.setSize(size);
    }

    this._webGLRenderer.setSize(size["width"], size["height"], keepCanvasStyle);
    this._canvasResolution = size;

    this._displayResolution = new KEN.Size(size["width"] * (vr ? 0.5 : 1), size["height"]);

    if (this._backgroundRenderer !== null)
    {
        this._backgroundRenderer.setSize(this._displayResolution);
    }

    if (this._view !== null)
    {
        this._view.setSize(this._displayResolution);
    }

    this._renderPipeline.setSize(this._displayResolution);

    this.log("Render size change in " + (vr ? "VR" : "screen") + " mode, resolution: " + this._displayResolution["width"] + "x" + this._displayResolution["height"]);
};

/**
 * Internal handler on canvas resize.
 * @method KEN.RenderManager#_canvasResizeHandler
 * @private
 */
KEN.RenderManager.prototype._canvasResizeHandler = function()
{
    this.log("_canvasResizeHandler");

    var canvas = this._viewer["canvas"]["dom"];
    this._setRendererSize(new KEN.Size(canvas["width"], canvas["height"]));
};

/**
 * VR Renderer display change event handler
 * @method KEN.RenderManager#_renderDisplayChangeHandler
 * @private
 */
KEN.RenderManager.prototype._renderDisplayChangeHandler = function()
{
    var vr = this._renderDisplay["presentingVR"];

    //Set render size BEFORE background renderer size
    this._setRendererSize(this._renderDisplay["rendererSize"]);
    this._backgroundRenderer.setSize(this._displayResolution);
    this._camera["viewfinder"]["visible"] = vr;
};



/**
 * Renderer set view type
 *
 * @method KEN.RenderManager#_setView
 * @param {string} type - type of view
 * @private
 */
KEN.RenderManager.prototype._setView = function(type)
{
    this.log("_setView");

    this._isReady = false;

    if (this._view !== null)
    {
        this.log("Destroy previous view");
        this._view.destroy();
        this._view = null;
    }

    if (type === KEN.ViewType.RECTILINEAR)
    {
        this._view = new KEN.ViewRectilinear(this._viewer, this._camera);
    }
    else if (type === KEN.ViewType.GOPRO)
    {
        this._view = new KEN.ViewGoPro(this._viewer, this._camera);
    }
    else
    {
        throw "View type not supported " + type;
    }

    // Set material resolution
    this._view.setSize(this._displayResolution);

    if (this._backgroundRenderer !== null)
    {
        this._backgroundRenderer.updateAfterViewChange();
    }

    this._isReady = true;
};

/**
 * Renderer set background renderer
 *
 * @method KEN.RenderManager#_setBackgroundRenderer
 * @param {string} type - type of background renderer
 * @private
 */
KEN.RenderManager.prototype._setBackgroundRenderer = function(type)
{
    this._clearBackgroundRenderer();

    if (type === KEN.BackgroundType.SHADER)
    {
        this._backgroundRenderer = new KEN.BackgroundShaderRenderer(this._viewer);

        var size = this._webGLRenderer.getSize();
        this._setRendererSize(new KEN.Size(size["width"], size["height"]));

        this._view["direction"] = KEN.ViewBase.SCREEN_TO_WORLD;
    }
    else if (type === KEN.BackgroundType.MESH)
    {
        var cubeConfig;

        if (typeof this._sceneConfig["media"] !== "undefined" && typeof this._sceneConfig["media"]["options"] !== "undefined")
        {
            cubeConfig = this._sceneConfig["media"]["options"];
        }
        else
        {
            cubeConfig =
            {
                order: "RLUDFB",
                faceHorizontal: 3,
                faceVertical: 2
            };
        }

        this._backgroundRenderer = new KEN.BackgroundMeshRenderer(this._viewer, cubeConfig);
    }
    else
    {
        //@todo not implemented
        // auto mode: try with fragment shader and fall back to mesh if fps is too low
    }

    this._isReady = true;
};

/**
 * Clear the background renderer.
 * @method KEN.RenderManager#_clearBackgroundRenderer
 * @private
 */
KEN.RenderManager.prototype._clearBackgroundRenderer = function()
{
    this._isReady = false;

    if (this._backgroundRenderer !== null)
    {
        this._backgroundRenderer.destroy();
        this._backgroundRenderer = null;

        if (this._backgroundRenderer !== null)
        {
            this._backgroundRenderer.destroy();
            this._backgroundRenderer = null;
        }
    }
};

/**
 * Render routine
 * @method KEN.RenderManager#render
 */
KEN.RenderManager.prototype.render = function()
{
    if (this._isReady === false || this._renderPipeline === null)
    {
        return;
    }

    this["camera"].update();

    if (this._backgroundReady === true)
    {
        // Draw background into background render target
        this._drawBackground();
    }

    // Render
    if (this._backgroundReady === true || this._hotspotsReady === true)
    {
        var renderParams = this._renderDisplay.getRenderParams();

        if (this._renderDisplay["presentingVR"] === true)
        {
            var quat = this._renderDisplay.getCameraQuaternion();
            if (quat !== null)
            {
                this._camera["quaternion"] = quat;
            }
        }

        for (var i = 0, ii = renderParams.length; i < ii; i++)
        {
            var params = renderParams[i];

            var rect = params["rectangle"];
            if (rect === null)
            {
                var size = this._webGLRenderer.getSize();
                rect = new KEN.Rectangle(0, 0, size["width"], size["height"]);
            }

            var camera = params["camera"] || this._camera["perspectiveCamera"];

            this._webGLRenderer.setViewport(rect["origin"].x, rect["origin"].y, rect["size"]["width"], rect["size"]["height"]);

            this._renderPipeline.render(camera);

            // Render perspective camera children (objects in camera local space)
            this._webGLRenderer.clearDepth();
            this._webGLRenderer.render(this._cameraScene, camera);
        }

        if (this._renderDisplay["presentingVR"] === true)
        {
            this._renderDisplay.submitFrame();
        }
    }

    // @todo implement event for render stats (fps, objects count...)
};

/**
 * Screen to world conversion based on current view
 *
 * @method KEN.RenderManager#screenToWorld
 * @param {THREE.Vector2} screenPt point in screen space
 * @return {THREE.Vector3} point in world space
 */
KEN.RenderManager.prototype.screenToWorld = function(screenPt)
{
    return this._view.screenToWorld(screenPt);
};

/**
 * World to screen conversion based on current view
 *
 * @method KEN.RenderManager#worldToScreen
 * @param {THREE.Vector3} worldPt point in world space
 * @param {number=} parallax parallax factor [0..1]
 * @return {THREE.Vector2} screenPt point in screen space
 */
KEN.RenderManager.prototype.worldToScreen = function(worldPt, parallax)
{
    return this._view.worldToScreen(worldPt, parallax || 0);
};

/**
 * Enable / disable VR display
 *
 * @method KEN.RenderManager#enableVR
 * @param {boolean} status new VR display status
 */
KEN.RenderManager.prototype.enableVR = function(status)
{
    if (this._renderDisplay["presentingVR"] === status)
    {
        return;
    }

    this._renderDisplay.enableVR(status);
};

/**
 * Renderer destroy sequence
 *
 * @method KEN.RenderManager#destroy
 */
KEN.RenderManager.prototype.destroy = function()
{
    this._viewer["canvas"]["onResize"].remove(this._canvasResizeHandler, this);
    this._viewer["tour"]["onSceneLoadStart"].remove(this._onSceneLoadStart, this);
    this._viewer["onReady"].remove(this._onViewerReady, this);

    this._cameraScene = null;

    if (this._onBackgroundReady !== null)
    {
        this._onBackgroundReady.destroy();
        this._onBackgroundReady = null;
    }

    if (this._onHotspotsReady !== null)
    {
        this._onHotspotsReady.destroy();
        this._onHotspotsReady = null;
    }

    if (this._onReady !== null)
    {
        this._onReady.destroy();
        this._onReady = null;
    }

    if (this._media !== null)
    {
        this._media.destroy();
        this._media = null;
    }

    if (this._textureLoader !== null)
    {
        this._textureLoader = null;
    }

    if (this._hotspotsRenderer !== null)
    {
        this._hotspotsRenderer.destroy();
        this._hotspotsRenderer = null;
    }

    if (this._view !== null)
    {
        this._view.destroy();
        this._view = null;
    }

    if (this._backgroundRenderer !== null)
    {
        this._backgroundRenderer.destroy();
        this._backgroundRenderer = null;
    }

    if (this._camera !== null)
    {
        this._camera.destroy();
        this._camera = null;
    }

    if (this._renderDisplay !== null)
    {
        this._renderDisplay["onDisplayChange"].remove(this._renderDisplayChangeHandler, this);
        this._renderDisplay.destroy();
        this._renderDisplay = null;
    }

    if (this._renderPipeline !== null)
    {
        this._renderPipeline.destroy();
        this._renderPipeline = null;
    }

    this._sceneConfig = null;
    this._webGLRenderer = null;
};

/**
 * Get viewer.
 * @name KEN.RenderManager#viewer
 * @type {KEN.Viewer}
 */
KEN.RenderManager.prototype.viewer;
Object.defineProperty(KEN.RenderManager.prototype, "viewer",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        return this._viewer;
    }
});

/**
 * Get media.
 * @name KEN.RenderManager#media
 * @type {KEN.Media}
 */
KEN.RenderManager.prototype.media;
Object.defineProperty(KEN.RenderManager.prototype, "media",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        return this._media;
    }
});

/**
 * Get WebGL renderer.
 * @name KEN.RenderManager#WebGLRenderer
 * @type {THREE.WebGLRenderer}
 */
KEN.RenderManager.prototype.webGLRenderer;
Object.defineProperty(KEN.RenderManager.prototype, "webGLRenderer",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        return this._webGLRenderer;
    }
});

/**
 * Get FX Composer.
 * @name KEN.RenderManager#renderPipeline
 * @type {KEN.RenderPipeline}
 */
KEN.RenderManager.prototype.renderPipeline;
Object.defineProperty(KEN.RenderManager.prototype, "renderPipeline",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        return this._renderPipeline;
    }
});

/**
 * Get background renderer.
 * @name KEN.RenderManager#backgroundRenderer
 * @type {KEN.BackgroundRenderer}
 */
KEN.RenderManager.prototype.backgroundRenderer;
Object.defineProperty(KEN.RenderManager.prototype, "backgroundRenderer",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        return this._backgroundRenderer;
    }
});

/**
 * Get and set the view.
 * @name KEN.RenderManager#view
 * @type {KEN.ViewBase}
 */
KEN.RenderManager.prototype.view;
Object.defineProperty(KEN.RenderManager.prototype, "view",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        return this._view;
    },
    /** @this {KEN.RenderManager} */
    set: function(value)
    {
        if (typeof value === "string" && value !== "")
        {
            switch (value)
            {
                case KEN.ViewType.GOPRO:
                    this._setView(KEN.ViewType.GOPRO);
                    break;

                case KEN.ViewType.RECTILINEAR:
                    this._setView(KEN.ViewType.RECTILINEAR);
                    break;

                default:
                    throw "View type not supported: " + value;
            }
        }
    }
});

/**
 * Get camera.
 * @name KEN.RenderManager#camera
 * @type {KEN.Camera}
 */
KEN.RenderManager.prototype.camera;
Object.defineProperty(KEN.RenderManager.prototype, "camera",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        return this._camera;
    }
});

/**
 * Get canvas resolution in pixels.
 * @name KEN.RenderManager#canvasResolution
 * @type {KEN.Size}
 */
KEN.RenderManager.prototype.canvasResolution;
Object.defineProperty(KEN.RenderManager.prototype, "canvasResolution",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        return this._canvasResolution;
    }
});

/**
 * Get display resolution in pixels.
 * @name KEN.RenderManager#displayResolution
 * @type {KEN.Size}
 */
KEN.RenderManager.prototype.displayResolution;
Object.defineProperty(KEN.RenderManager.prototype, "displayResolution",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        return this._displayResolution;
    }
});

/**
 * VR presenting status.
 * @name KEN.RenderManager#presentingVR
 * @type {boolean}
 */
KEN.RenderManager.prototype.presentingVR;
Object.defineProperty(KEN.RenderManager.prototype, "presentingVR",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        return this._renderDisplay["presentingVR"];
    }
});

/**
 * Get texture loader.
 * @name KEN.RenderManager#textureLoader
 * @type {THREE.TextureLoader}
 */
KEN.RenderManager.prototype.textureLoader;
Object.defineProperty(KEN.RenderManager.prototype, "textureLoader",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        return this._textureLoader;
    }
});

/**
 * Get the backgroundReady flag
 * @name KEN.RenderManager#backgroundReady
 * @readonly
 * @type boolean
 */
KEN.RenderManager.prototype.backgroundReady;
Object.defineProperty(KEN.RenderManager.prototype, "backgroundReady",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        return this._backgroundReady;
    }
});

/**
 * Get the onBackgroundReady {@link KEN.EventDispatcher}.
 * @name KEN.RenderManager#onBackgroundReady
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.RenderManager.prototype.onBackgroundReady;
Object.defineProperty(KEN.RenderManager.prototype, "onBackgroundReady",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        if (this._onBackgroundReady === null)
        {
            this._onBackgroundReady = new KEN.EventDispatcher(this, true);
        }

        return this._onBackgroundReady;
    }
});

/**
 * Get the objects
 * @name KEN.RenderManager#objects
 * @readonly
 * @type {KEN.ObjectRenderer}
 */
KEN.RenderManager.prototype.objects;
Object.defineProperty(KEN.RenderManager.prototype, "objects",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        return this._objectRenderer;
    }
});

/**
 * Get the hotspotsReady flag
 * @name KEN.RenderManager#hotspotsReady
 * @readonly
 * @type boolean
 */
KEN.RenderManager.prototype.hotspotsReady;
Object.defineProperty(KEN.RenderManager.prototype, "hotspotsReady",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        return this._hotspotsReady;
    }
});

/**
 * Get the onHotspotsReady {@link KEN.EventDispatcher}.
 * @name KEN.RenderManager#onHotspotsReady
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.RenderManager.prototype.onHotspotsReady;
Object.defineProperty(KEN.RenderManager.prototype, "onHotspotsReady",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        if (this._onHotspotsReady === null)
        {
            this._onHotspotsReady = new KEN.EventDispatcher(this, true);
        }

        return this._onHotspotsReady;
    }
});

/**
 * Get the onReady {@link KEN.EventDispatcher}.
 * @name KEN.RenderManager#onReady
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.RenderManager.prototype.onReady;
Object.defineProperty(KEN.RenderManager.prototype, "onReady",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        if (this._onReady === null)
        {
            this._onReady = new KEN.EventDispatcher(this);
        }

        return this._onReady;
    }
});

/**
 * Get the onMediaReady {@link KEN.EventDispatcher}.
 * @name  KEN.RenderManager#onMediaReady
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.RenderManager.prototype.onMediaReady;
Object.defineProperty(KEN.RenderManager.prototype, "onMediaReady",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        if (this._onMediaReady === null)
        {
            this._onMediaReady = new KEN.EventDispatcher(this);
        }

        return this._onMediaReady;
    }
});

/**
 * Get the onMediaRelease {@link KEN.EventDispatcher}.
 * @name  KEN.RenderManager#onMediaRelease
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.RenderManager.prototype.onMediaRelease;
Object.defineProperty(KEN.RenderManager.prototype, "onMediaRelease",
{
    /** @this {KEN.RenderManager} */
    get: function()
    {
        if (this._onMediaRelease === null)
        {
            this._onMediaRelease = new KEN.EventDispatcher(this);
        }

        return this._onMediaRelease;
    }
});

/**
 * A render scene is an object responsible of preparing the draw of a scene
 * with a camera, applying a set of image effect.
 *
 * It creates an effect composer that will be called by render loop.
 * It writes the resulting image into a texture used in main render pipeline.
 *
 * @constructor KEN.RenderScene
 * @param {KEN.Viewer} viewer reference on KEN viewer
 * @param {THREE.Scene} scene scene to render
 * @param {THREE.Camera} camera camera used to render the scene
 * @param {Object} fxConfig image fx configuration object
 * @extends {KEN.BaseObject}
 */
KEN.RenderScene = function(viewer, scene, camera, fxConfig)
{
    /**
     * The viewer reference.
     * @name KEN.RenderScene#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Scene to be rendered
     * @name KEN.RenderScene#_scene
     * @type {THREE.Scene}
     * @private
     */
    this._scene = scene;

    /**
     * Camera used to render the scene
     * @name KEN.RenderScene#_camera
     * @type {THREE.Camera}
     * @private
     */
    this._camera = camera;

    /**
     * Set of image effect configuration
     * @name KEN.RenderScene#_fxConfig
     * @type {Object}
     * @private
     */
    this._fxConfig = fxConfig;

    /**
     * Effect composer rendering the scene into a texture
     * @name KEN.RenderScene#_sceneComposer
     * @type {THREE.EffectComposer}
     * @private
     */
    this._sceneComposer = null;

    KEN.BaseObject.call(this, "RenderScene");

    this._boot();
};

KEN.RenderScene.prototype = Object.create(KEN.BaseObject.prototype);
KEN.RenderScene.prototype.constructor = KEN.RenderScene;

/**
 * Boot sequence
 * @method KEN.RenderScene#_boot
 * @private
 */
KEN.RenderScene.prototype._boot = function()
{
    this._sceneComposer = new THREE.EffectComposer(this._viewer["renderer"]["webGLRenderer"]);

    var renderPass = new THREE.RenderPass(this._scene, this._camera);
    renderPass.ken = {};
    renderPass.ken.pipelinePosition = "render";
    this._sceneComposer.addPass(renderPass);

    // var effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
    // effectFXAA.uniforms.resolution["value"] = new THREE.Vector2(1 / this._viewer["renderer"]["canvasResolution"]["width"], 1 / this._viewer["renderer"]["canvasResolution"]["height"]);
    // this._sceneComposer.addPass(effectFXAA);

    var shaderPasses = this._parseShaderPasses(this._fxConfig);
    for (var j = 0, jj = shaderPasses.length; j < jj; j++)
    {
        var shaderPass = shaderPasses[j];
        shaderPass.renderToScreen = false;
        shaderPass.ken.pipelinePosition = "render";
        this._sceneComposer.addPass(shaderPass);
    }
};

/**
 * Parse shader passes
 * @method KEN.RenderScene#_parseShaderPasses
 * @param {Object} config shader passes configuration
 * @private
 */
KEN.RenderScene.prototype._parseShaderPasses = function(config)
{
    return this._viewer["postProcessing"].parseShaderPasses(config);
};

/**
 * Set size of each pass of the render scene
 * @method KEN.RenderScene#setSize
 * @param {number} width composer width
 * @param {number} height composer height
 */
KEN.RenderScene.prototype.setSize = function(width, height)
{
    this._sceneComposer.setSize(width, height);
};

/**
 * Destroy sequence
 * @method KEN.RenderScene#destroy
 */
KEN.RenderScene.prototype.destroy = function()
{
    this._sceneComposer.readBuffer.dispose();
    this._sceneComposer.writeBuffer.dispose();

    while (this._sceneComposer.passes.length > 0)
    {
        var pass = this._sceneComposer.passes.pop();

        if (pass instanceof THREE.TexturePass && pass.hasOwnProperty("tDiffuse"))
        {
            pass.uniforms["tDiffuse"]["value"]["texture"].dispose();
            pass.uniforms["tDiffuse"]["value"] = null;
        }
    }

    this._sceneComposer = null;

    this._viewer = null;
    this._scene = null;
    this._camera = null;
    this._fxConfig = null;
};

/**
 * Get scene.
 * @name KEN.RenderScene#scene
 * @type {THREE.Scene}
 */
KEN.RenderScene.prototype.scene;
Object.defineProperty(KEN.RenderScene.prototype, "scene",
{
    /** @this {KEN.RenderScene} */
    get: function()
    {
        return this._scene;
    }
});

/**
 * Get scene composer.
 * @name KEN.RenderScene#sceneComposer
 * @type {THREE.EffectComposer}
 */
KEN.RenderScene.prototype.sceneComposer;
Object.defineProperty(KEN.RenderScene.prototype, "sceneComposer",
{
    /** @this {KEN.RenderScene} */
    get: function()
    {
        return this._sceneComposer;
    }
});

/**
 * FXComposer class.
 *
 * @constructor KEN.RenderPipeline
 * @param {KEN.Viewer} viewer reference on KEN viewer
 * @extends {KEN.BaseObject}
 *
 * @todo think about how to render multiple scene at the same time, with blending / overlap / viewport layouting...
 * maybe add a layer object encapsulating background / foreground renderings to ease the process
 */
KEN.RenderPipeline = function(viewer)
{
    /**
     * The viewer reference.
     * @name KEN.RenderPipeline#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Render composer
     * @name KEN.RenderPipeline#_renderComposer
     * @type {THREE.EffectComposer}
     * @private
     */
    this._renderComposer = null;

    /**
     * Sub composers array, created for each pass including texture/render + some shaders
     * @name KEN.RenderPipeline#_subComposers
     * @type {Array<THREE.EffectComposer>}
     * @private
     */
    this._subComposers = null;

    /**
     * Internal clock used to feed time to effect shaders
     * @name KEN.RenderPipeline#_clock
     * @type {THREE.Clock}
     * @private
     */
    this._clock = null;

    /**
     * Enabled status flag
     * @name KEN.RenderPipeline#_enabled
     * @type boolean
     * @private
     */
    this._enabled = true;

    KEN.BaseObject.call(this, "RenderPipeline");

    this._boot();
};

KEN.RenderPipeline.prototype = Object.create(KEN.BaseObject.prototype);
KEN.RenderPipeline.prototype.constructor = KEN.RenderPipeline;

/**
 * Boot sequence
 * @method KEN.RenderPipeline#_boot
 * @private
 */
KEN.RenderPipeline.prototype._boot = function()
{
    this._clock = new THREE.Clock();
    this._subComposers = [];

    this._renderComposer = new THREE.EffectComposer(this._viewer["renderer"]["webGLRenderer"]);
    this._renderComposer.ken = {};
    this._renderComposer.ken["name"] = "RenderComposer";
};

/**
 * Get pass type of a THREE.Pass
 * @method KEN.RenderPipeline#_getPassType
 * @param {THREE.Pass} pass - THREE pass object
 * @private
 * @return {string} - Returns the pass type.
 */
KEN.RenderPipeline.prototype._getPassType = function(pass)
{
    if (pass instanceof THREE.TexturePass)
    {
        if (pass.hasOwnProperty("map"))
        {
            var uid = pass.map.uuid.split("-")[0].slice(0, 4);
            return "Texture(" + uid + ")";
        }
        return "Texture";
    }

    if (pass instanceof THREE.RenderPass)
    {
        return "Render";
    }

    if (pass instanceof THREE.ClearMaskPass)
    {
        return "ClearMask";
    }

    if (pass instanceof THREE.MaskPass)
    {
        return "Mask";
    }

    if (pass instanceof THREE.ShaderPass)
    {
        if (pass.hasOwnProperty("ken"))
        {
            return "Shader(" + pass.ken["type"].replace("Shader", "") + ")";
        }
        return "Shader";
    }

    return "Pass";
};

/**
 * Dump some effect composer to console output
 * @method KEN.RenderPipeline#_dumpComposer
 * @param {THREE.EffectComposer} composer - The Effect composer you want to dump
 * @private
 */
KEN.RenderPipeline.prototype._dumpComposer = function(composer)
{
    this.log("COMPOSER: " + composer.ken["name"]);

    var types = [];
    var typesLength = 0;

    for (var i = 0, ii = composer.passes.length; i < ii; i++)
    {
        var typei = this._getPassType(composer.passes[i]);
        types.push(typei);
        typesLength += typei.length;
    }

    // Header/Footer
    var hdft = "";
    for (var j = 0, jj = types.length; j < jj; j++)
    {
        var type = types[j];

        hdft += "| ";
        for (var m=0; m<type.length; m++)
        {
            hdft += "-";
        }
        hdft += " |";

        if (j < jj - 1)
        {
            for (var l=0; l<5; l++)
            {
                hdft += " ";
            }
        }
    }

    // Header
    this.log(hdft);

    // Types
    var line = "";
    for (var k = 0, kk = types.length; k < kk; k++)
    {
        var typek = types[k];
        line += "| " + typek + " |";
        if (k < kk - 1)
        {
            line += " --- ";
        }
    }

    // Add composer output texture to the line if not render to screen
    if (composer.passes[composer.passes.length - 1].renderToScreen === false)
    {
        line += " --- tex";
    }

    this.log(line);

    // Footer
    this.log(hdft);
};

/**
 * Dump whole composing pipeline to console output
 * @method KEN.RenderPipeline#_dumpPipeline
 * @private
 */
KEN.RenderPipeline.prototype._dumpPipeline = function()
{
    for (var i = 0, ii = this._subComposers.length; i < ii; i++)
    {
        var composer = this._subComposers[i];
        this._dumpComposer(composer);
    }

    this._dumpComposer(this._renderComposer);
};

/**
 * Add a subcomposer to compositing pipeline
 * Add subcomposer to inner list and add a texture pass drawing subcomposer output
 * @method KEN.RenderPipeline#_addSubComposer
 * @param {THREE.EffectComposer} subComposer - new effect composer
 * @private
 */
KEN.RenderPipeline.prototype._addSubComposer = function(subComposer)
{
    // Add a ken object into subcomposer to set some private properties
    subComposer.ken = {};
    subComposer.ken["name"] = "SubComposer-" + this._subComposers.length;
    subComposer.ken["enabled"] = true;
    this._subComposers.push(subComposer);

    var additionPass = new THREE.ShaderPass(THREE.AdditionShader);
    additionPass.ken = {};
    additionPass.ken["type"] = "Addition";
    additionPass.ken.subComposerIndex = this._subComposers.length - 1;
    this._renderComposer.addPass(additionPass);

    this._updateRenderPipeline();
};

/**
 * Add shader passes to an effect composer
 * @method KEN.RenderPipeline#_addShaderPasses
 * @param {THREE.EffectComposer} composer - effect composer
 * @param {Array<THREE.Pass>|THREE.Pass} passes - pass or array of passes to be added to the composer
 * @param {number=} index - index where passes should be inserted
 * @private
 */
KEN.RenderPipeline.prototype._addShaderPasses = function(composer, passes, index)
{
    index = typeof index !== "undefined" ? index : composer.passes.length;

    if (Array.isArray(passes))
    {
        for (var i = passes.length - 1; i >= 0; i--)
        {
            var shaderPass = passes[i];
            composer.insertPass(shaderPass, index);
        }
    }
    else if (passes instanceof THREE.Pass)
    {
        var shaderThreePass = passes;
        composer.insertPass(shaderThreePass, index);
    }
};

/**
 * Change status of all shader passes in a composer
 * @method KEN.RenderPipeline#_setComposerShaderPassesStatus
 * @param {THREE.EffectComposer} composer - effect composer.
 * @param {boolean} status - The status you want to set.
 * @private
 */
KEN.RenderPipeline.prototype._setComposerShaderPassesStatus = function(composer, status)
{
    if (status === false)
    {
        this._enabled = false;
    }

    for (var i = composer.passes.length - 1; i >= 0; i--)
    {
        var pass = composer.passes[i];

        // Enable/disable shader passes except for Addition passes
        if (pass instanceof THREE.ShaderPass)
        {
            if (!(pass.hasOwnProperty("ken") === true && pass.ken["type"] === "Addition"))
            {
                pass["enabled"] = status;
            }
        }
    }

    if (composer.hasOwnProperty("ken") === true && composer.ken.hasOwnProperty("enabled"))
    {
        composer.ken["enabled"] = status;
    }

    this._updateRenderPipeline();
};

/**
 * Set all shader passes status
 * @method KEN.RenderPipeline#_setAllShaderPassesStatus
 * @param {boolean} status - new shader passes status.
 * @private
 */
KEN.RenderPipeline.prototype._setAllShaderPassesStatus = function(status)
{
    var composers = this._subComposers.concat(this._renderComposer);

    for (var i = 0, ii = composers.length; i < ii; i++)
    {
        var composer = composers[i];
        this._setComposerShaderPassesStatus(composer, status);
    }

    this._enabled = status;
};

/**
 * Update rendering pipeline
 * Called whenever pipeline has changed to optimize the render stream.
 * @method KEN.RenderPipeline#_updateRenderPipeline
 * @private
 */
KEN.RenderPipeline.prototype._updateRenderPipeline = function()
{
    // First check render composer order
    // background passes --> render passes --> global passes
    var passes = this._renderComposer.passes;

    // Collect background passes in reverse order and reinsert them at zero index
    var backgrounds = [];

    passes.filter(function(element, index) //array
    {
        if (element.ken.pipelinePosition === "background")
        {
            backgrounds.push(index);
        }
    });

    if (backgrounds.length > 0 && backgrounds[0] > 0)
    {
        var bgdPasses = [];

        for (var i = backgrounds.length - 1; i >= 0; i--)
        {
            var index = backgrounds[i];
            var passi = passes.splice(index, 1)[0];
            bgdPasses.push(passi);
        }

        for (var j = 0, jj = bgdPasses.length; j < jj; j++)
        {
            this._renderComposer.insertPass(bgdPasses[j], 0);
        }
    }

    // Collect global passes in nrmal order and reinsert them at the end
    var globals = [];
    passes.filter(function(element, index) //array
    {
        if (element.ken.pipelinePosition === "global")
        {
            globals.push(index);
        }
    });

    // Check if last global pass is at the end of passes array
    if (globals.length > 0 && globals[globals.length - 1] < passes.length - 1)
    {
        var globalPasses = [];

        for (var k = 0, kk = globals.length; k < kk; k++)
        {
            var indexk = globals[k];
            var passk = passes.splice(indexk, 1)[0];
            globalPasses.push(passk);
        }

        for (var l = 0, ll = globalPasses.length; l < ll; l++)
        {
            var passl = globalPasses[l];
            this._renderComposer.addPass(passl);
        }
    }

    // Only first pass of each composer should clear the target
    for (var m = 0, mm = this._subComposers.length; m < mm; m++)
    {
        var composer = this._subComposers[m];
        for (var n = 0, nn = composer.passes.length; n < nn; n++)
        {
            var passn = composer.passes[n];
            passn.clear = (n === 0);
        }
    }

    // Only last enabled pass of render composer should render to screen
    var rts = false;
    for (var p = passes.length - 1; p >= 0; p--)
    {
        var passp = passes[p];

        if (rts === true)
        {
            passp.renderToScreen = false;
        }
        else if (passp["enabled"] === true)
        {
            passp.renderToScreen = true;
            rts = true;
        }
    }

    this._dumpPipeline();
};

/**
 * Set all render passes camera.
 * @method KEN.RenderPipeline#_setAllRenderPassCamera.
 * @param {THREE.Camera} camera render pass camera.
 * @private
 */
KEN.RenderPipeline.prototype._setAllRenderPassCamera = function(camera)
{
    var composers = this._subComposers.concat(this._renderComposer);

    for (var i = 0, ii = composers.length; i < ii; i++)
    {
        var composer = composers[i];

        for (var j=0, jj=composer.passes.length; j<jj; j++)
        {
            var pass = composer.passes[j];

            if (pass instanceof THREE.RenderPass)
            {
                pass["camera"] = camera;
            }
        }
    }
};

/**
 * Add background to the rendering pipeline.
 * @method KEN.RenderPipeline#addBackground
 * @param {THREE.Texture} texture texture object used as background.
 * @param {Object} fxSet image fx set to apply to background only.
 */
KEN.RenderPipeline.prototype.addBackground = function(texture, fxSet)
{
    // Background addition will be an insertion of all passes at index 0
    // First we add all shaders passes in reverse order at index 0
    // Then we insert the texture pass so everything ends up in the right order

    if (typeof fxSet !== "undefined" && fxSet !== null && fxSet.length > 0)
    {
        var shaderPasses = this._viewer["postProcessing"].parseShaderPasses(fxSet);

        for (var i = 0, ii = shaderPasses.length; i < ii; i++)
        {
            var pass = shaderPasses[i];
            pass.ken.pipelinePosition = "background";
        }

        this._addShaderPasses(this._renderComposer, shaderPasses, 0);
    }

    var texturePass = new THREE.TexturePass(texture);
    texturePass.ken = {};
    texturePass.ken.pipelinePosition = "background";

    this._renderComposer.insertPass(texturePass, 0);

    this._updateRenderPipeline();
};

/**
 * Add render scenes to the rendering pipeline
 * @method KEN.RenderPipeline#addRenderScenes
 * @param {Array<KEN.RenderScene>} renderScenes array of render scenes
 */
KEN.RenderPipeline.prototype.addRenderScenes = function(renderScenes)
{
    for (var i = 0, ii = renderScenes.length; i < ii; i++)
    {
        this._addSubComposer(renderScenes[i]["sceneComposer"]);
    }

    this._updateRenderPipeline();
};

/**
 * Add fx at the end of the whole rendering pipeline
 * @method KEN.RenderPipeline#addGlobalFx
 * @param {string} fxSet set of effects
 */
KEN.RenderPipeline.prototype.addGlobalFx = function(fxSet)
{
    var shaderPasses = this._viewer["postProcessing"].parseShaderPasses(fxSet);

    for (var i = 0, ii = shaderPasses.length; i < ii; i++)
    {
        var pass = shaderPasses[i];
        pass.ken.pipelinePosition = "global";
    }

    this._addShaderPasses(this._renderComposer, shaderPasses);
    this._updateRenderPipeline();
};

/**
 * Get a shader pass with an UID
 * @method KEN.RenderPipeline#getShaderPassByUID
 * @param {string} uid - the uid of the ShaderPass
 * @return {THREE.Pass} shader pass
 */
KEN.RenderPipeline.prototype.getShaderPassByUID = function(uid)
{
    if (this._renderComposer !== null)
    {
        for (var i = 0, ii = this._renderComposer.passes.length; i < ii; i++)
        {
            var pass = this._renderComposer.passes[i];
            if (pass.hasOwnProperty("ken") && pass.ken["uid"] === uid)
            {
                return pass;
            }
        }
    }

    if (this._subComposers !== null)
    {
        for (var k = 0, kk = this._subComposers.length; k < kk; k++)
        {
            var composer = this._subComposers[k];

            for (var j = 0, jj = composer.passes.length; j < jj; j++)
            {
                var subPass = composer.passes[j];
                if (subPass.hasOwnProperty("ken") && subPass.ken["uid"] === uid)
                {
                    return subPass;
                }
            }
        }
    }

    return null;
};

/**
 * Set size of each composers
 * @method KEN.RenderPipeline#setSize
 * @param {KEN.Size} size new composer size
 */
KEN.RenderPipeline.prototype.setSize = function(size)
{
    for (var i = 0, ii = this._subComposers.length; i < ii; i++)
    {
        var composer = this._subComposers[i];
        composer.setSize(size["width"], size["height"]);

        for (var c = 0, cc = composer.passes.length; c < cc; c++)
        {
            var pass = composer.passes[c];

            if (pass instanceof THREE.ShaderPass)
            {
                if (typeof pass.uniforms.resolution !== "undefined")
                {
                    pass.uniforms.resolution["value"] = new THREE.Vector2(1 / size["width"], 1 / size["height"]);
                }
            }
        }
    }

    this._renderComposer.setSize(size["width"], size["height"]);
};

/**
 * Render routine
 * @method KEN.RenderPipeline#render
 * @param {THREE.PerspectiveCamera} camera - The camera to use for render.
 */
KEN.RenderPipeline.prototype.render = function(camera)
{
    if (this._renderComposer === null)
    {
        return;
    }

    for (var i = 0, ii = this._renderComposer.passes.length; i < ii; i++)
    {
        var pass = this._renderComposer.passes[i];

        if (pass.ken.hasOwnProperty("subComposerIndex"))
        {
            var src = this._subComposers[ /** @type {number} */ (pass.ken.subComposerIndex)];

            // Pick right buffer as texture provider for addition pass
            var lastPass = src.passes[src.passes.length - 1];
            var readBuffer = src.ken["enabled"] === false || lastPass instanceof THREE.RenderPass;
            var texture = readBuffer ? src.readBuffer["texture"] : src.writeBuffer["texture"];
            pass.uniforms["tAdd"]["value"] = texture;
        }
    }

    var delta = this._clock.getDelta();

    this._setAllRenderPassCamera(camera);

    for (var j = 0, jj = this._subComposers.length; j < jj; j++)
    {
        this._subComposers[j].render(delta);
    }

    this._renderComposer.render(delta);
};

/**
 * Clear composer components
 * @method KEN.RenderPipeline#clear
 */
KEN.RenderPipeline.prototype.clear = function()
{
    if (this._renderComposer !== null)
    {
        this._renderComposer.readBuffer.dispose();
        this._renderComposer.writeBuffer.dispose();

        for (var i = 0, ii = this._renderComposer.passes.length; i < ii; i++)
        {
            var pass = this._renderComposer.passes[i];
            if (pass instanceof THREE.ShaderPass && pass.uniforms.hasOwnProperty("tAdd"))
            {
                pass.uniforms["tAdd"]["value"] = null;
            }
        }

        this._renderComposer.passes = [];
    }

    this._subComposers = [];
};

/**
 * Destroy sequence
 * @method KEN.RenderPipeline#destroy
 */
KEN.RenderPipeline.prototype.destroy = function()
{
    this.clear();
    this._clock = null;
    this._subComposers = null;
    this._renderComposer = null;
    this._viewer = null;
};

/**
 * FX pipeline status.
 * @name KEN.RenderPipeline#enabled
 * @type {boolean}
 */
KEN.RenderPipeline.prototype.enabled;
Object.defineProperty(KEN.RenderPipeline.prototype, "enabled",
{
    /** @this {KEN.RenderPipeline} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {KEN.RenderPipeline} */
    set: function(status)
    {
        this._setAllShaderPassesStatus(status);
    }
});
/**
 * VRRenderer class.
 *
 * @constructor KEN.RenderDisplay
 * @param {KEN.Viewer} viewer reference on KEN viewer
 * @extends {KEN.BaseObject}
 */
KEN.RenderDisplay = function(viewer)
{
    /**
     * The viewer reference.
     * @name KEN.RenderDisplay#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * WebVR flag, true if runtime supports WebVR.
     * @name KEN.RenderDisplay#_webVR
     * @type {boolean}
     * @private
     */
    this._webVR = false;

    /**
     * Presenting VR status.
     * @name KEN.RenderDisplay#_presentingVR
     * @type {boolean}
     * @private
     */
    this._presentingVR = false;

    /**
     * WebVR VRDisplay interface.
     * @name KEN.RenderDisplay#_vrDisplay
     * @type {VRDisplay}
     * @private
     */
    this._vrDisplay = null;

    /**
     * VRDisplay boundaries for left eye.
     * @name KEN.RenderDisplay#_leftBounds
     * @type {Array<number>}
     * @private
     */
    this._leftBounds = null;

    /**
     * VRDisplay boundaries for right eye.
     * @name KEN.RenderDisplay#_rightBounds
     * @type {Array<number>}
     * @private
     */
    this._rightBounds = null;

    /**
     * Camera rendering left eye.
     * @name KEN.RenderDisplay#_cameraL
     * @type {THREE.PerspectiveCamera}
     * @private
     */
    this._cameraL = null;

    /**
     * Camera rendering right eye.
     * @name KEN.RenderDisplay#_cameraR
     * @type {THREE.PerspectiveCamera}
     * @private
     */
    this._cameraR = null;

    /**
     * Renderer size.
     * @name KEN.RenderDisplay#_rendererSize
     * @type {KEN.Size}
     * @private
     */
    this._rendererSize = null;

    /**
     * Renderer size for screen display.
     * @name KEN.RenderDisplay#_rendererSizeScreen
     * @type {KEN.Size}
     * @private
     */
    this._rendererSizeScreen = null;

    /**
     * Renderer pixel ratio.
     * @name KEN.RenderDisplay#_rendererPixelRatio
     * @type {number}
     * @private
     */
    this._rendererPixelRatio = 1;

    /**
     * WebVR frame data receiver
     * @name KEN.RenderDisplay#_frameData
     * @type {VRFrameData}
     * @private
     */
    this._frameData = null;

    /**
     * Fullscreen request.
     * @name KEN.RenderDisplay#_requestFullscreen
     * @type {string}
     * @private
     */
    this._requestFullscreen = "";

    /**
     * Fullscreen element.
     * @name KEN.RenderDisplay#_fullscreenElement
     * @type {string}
     * @private
     */
    this._fullscreenElement = "";

    /**
     * Exit fullscreen.
     * @name KEN.RenderDisplay#_exitFullscreen
     * @type {string}
     * @private
     */
    this._exitFullscreen = "";

    /**
     * Fullscreen change.
     * @name KEN.RenderDisplay#_fullscreenChange
     * @type {string}
     * @private
     */
    this._fullscreenChange = "";

    /**
     * On display change event dispatcher.
     * @name  KEN.Media#_onDisplayChange
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onDisplayChange = null;

    KEN.BaseObject.call(this, "RenderDisplay");

    this._boot();
};

KEN.RenderDisplay.prototype = Object.create(KEN.BaseObject.prototype);
KEN.RenderDisplay.prototype.constructor = KEN.RenderDisplay;

/**
 * Boot sequence
 * @method KEN.RenderDisplay#_boot
 * @private
 */
KEN.RenderDisplay.prototype._boot = function()
{
    this._rendererSizeScreen = this._viewer["renderer"]["webGLRenderer"].getSize();
    this._rendererSize = this._rendererSizeScreen;

    // Bounds will be set when user request fullscreen VR display
    this._leftBounds = [ 0.0, 0.0, 0.5, 1.0 ];
    this._rightBounds = [ 0.5, 0.0, 0.5, 1.0 ];

    // Left and right cameras are the same at start, they are update at each frame
    this._cameraL = new THREE.PerspectiveCamera();
    this._cameraL.layers.enable(1);

    this._cameraR = new THREE.PerspectiveCamera();
    this._cameraR.layers.enable(2);

    // Create frame data receiver
    if ("VRFrameData" in window)
    {
        this._frameData = new VRFrameData();
    }

    if(KEN.Device.webVR === true)
    {
        var self = this;

        navigator.getVRDisplays().then(
            function(displays)
            {
                self._gotVRDisplays(displays);
            }
        );

        this._addFullscreenListener();
    }
    else
    {
        this.warn("missing api navigator.getVRDisplays");
    }
};

/**
 * VR display interface found callback
 * Just keep the first interface available
 * @method KEN.RenderDisplay#_gotVRDisplays
 * @param {Array<VRDisplay>} displays - array of VRDisplay interfaces available
 * @param {Function=} onError - error callback
 * @private
 */
KEN.RenderDisplay.prototype._gotVRDisplays = function(displays, onError)
{
    this._webVR = displays.length > 0;

    for (var i=0, ii=displays.length; i<ii; i++)
    {
        if ("VRDisplay" in window && displays[i] instanceof VRDisplay)
        {
            this._vrDisplay = displays[i];
            break;
        }
    }

    if (typeof this._vrDisplay === "undefined")
    {
        if (typeof onError === "function")
        {
            onError("HMD not available");
        }
    }
};

/**
 * Add event listeners for fullscreen and VR display change
 * Cross browser implementation
 * @method KEN.RenderDisplay#_addFullscreenListener
 * @private
 */
KEN.RenderDisplay.prototype._addFullscreenListener = function()
{
    var canvas = this._viewer["canvas"]["dom"];

    if (typeof canvas.requestFullscreen !== "undefined")
    {
        this._requestFullscreen = "requestFullscreen";
        this._fullscreenElement = "fullscreenElement";
        this._exitFullscreen = "exitFullscreen";
        this._fullscreenChange = "fullscreenchange";
    }
    else if (typeof canvas.mozRequestFullScreen !== "undefined")
    {
        this._requestFullscreen = "mozRequestFullScreen";
        this._fullscreenElement = "mozFullScreenElement";
        this._exitFullscreen = "mozCancelFullScreen";
        this._fullscreenChange = "mozfullscreenchange";
    }
    else
    {
        this._requestFullscreen = "webkitRequestFullscreen";
        this._fullscreenElement = "webkitFullscreenElement";
        this._exitFullscreen = "webkitExitFullscreen";
        this._fullscreenChange = "webkitfullscreenchange";
    }

    document.addEventListener(this._fullscreenChange, this._displayChangeHandler.bind(this), false);
    window.addEventListener("vrdisplaypresentchange", this._displayChangeHandler.bind(this), false);
};

/**
 * Remove event listeners for fullscreen and VR display change
 * Cross browser implementation
 * @method KEN.RenderDisplay#_addFullscreenListener
 * @private
 */
KEN.RenderDisplay.prototype._removeFullscreenListener = function()
{
    document.removeEventListener(this._fullscreenChange, this._displayChangeHandler.bind(this));
    window.removeEventListener("vrdisplaypresentchange", this._displayChangeHandler.bind(this));
};

/**
 * Display change event handler
 * @method KEN.RenderDisplay#_displayChangeHandler
 * @private
 */
KEN.RenderDisplay.prototype._displayChangeHandler = function()
{
    var wasPresentingVR = this._presentingVR;
    var renderer = this._viewer["renderer"]["webGLRenderer"];

    this._presentingVR = typeof this._vrDisplay !== "undefined" &&
        (this._vrDisplay.isPresenting === true ||
            (this._webVR === false && document[this._fullscreenElement] instanceof window.HTMLElement));

    var displaySize;

    if (this._presentingVR === true)
    {
        var eyeParamsL = this._vrDisplay.getEyeParameters("left");

        if (this._webVR === true)
        {
            this._eyeWidth = eyeParamsL.renderWidth;
            this._eyeHeight = eyeParamsL.renderHeight;

            this._leftBounds = [ 0.0, 0.0, 0.5, 1.0 ];
            this._rightBounds = [ 0.5, 0.0, 0.5, 1.0 ];

            if (this._vrDisplay.getLayers)
            {
                var layers = this._vrDisplay.getLayers();

                if (layers.length > 0 && layers[0].leftBounds.length === 4)
                {
                    this._leftBounds = layers[0].leftBounds;
                    this._rightBounds = layers[0].rightBounds;
                }
            }
        }

        // console.log("eye width " + this._eyeWidth);

        if (wasPresentingVR === false)
        {
            this._rendererSizeScreen = renderer.getSize();
            this._rendererSize = new KEN.Size(this._eyeWidth * 2, this._eyeHeight);
        }
    }
    else if (wasPresentingVR === true)
    {
        this._rendererSize = this._rendererSizeScreen;
    }

    if (this._onDisplayChange !== null)
    {
        this._onDisplayChange.dispatch();
    }
};

/**
 * Set fullscreen
 * @method KEN.RenderDisplay#_setFullScreen
 * @param {boolean} status fullscreen status
 * @private
 */
KEN.RenderDisplay.prototype._setFullScreen = function (status)
{
    var canvas = this._viewer["renderer"]["webGLRenderer"].domElement;

    return new Promise(function (resolve, reject)
    {
        if (typeof this._vrDisplay === "undefined")
        {
            reject(new Error("No VR hardware found."));
            return;
        }

        if (this._presentingVR === status)
        {
            resolve();
            return;
        }

        if (this._webVR === true)
        {
            if (status)
            {
                resolve(this._vrDisplay.requestPresent([ { source: canvas } ] ));
            }
            else
            {
                resolve(this._vrDisplay.exitPresent());
            }
        }
        // else
        // {
        //     if (canvas[ this._requestFullscreen ])
        //     {
        //         canvas[ status ? this._requestFullscreen : this._exitFullscreen ]( { vrDisplay: this._vrDisplay } );
        //         resolve();
        //     }
        //     else
        //     {
        //         reject(new Error("No compatible requestFullscreen method found."));
        //     }
        // }

    }.bind(this));
};

/**
 * Get projection matrix from a VRFieldOfView
 * @method KEN.RenderDisplay#_fovToProjectionMatrix
 * @param {VRFieldOfViewObject} fov - VRFieldOfView for an eye
 * @param {THREE.PerspectiveCamera} camera - reference camera
 * @return {THREE.Matrix4} projection matrix
 * @private
 */
KEN.RenderDisplay.prototype._fovToProjectionMatrix = function(fov, camera)
{
    // Get projections of field of views on zn plane
    var fovUpTan = Math.tan(KEN.Math.degToRad(fov.upDegrees));
    var fovDownTan = Math.tan(KEN.Math.degToRad(fov.downDegrees));
    var fovLeftTan = Math.tan(KEN.Math.degToRad(fov.leftDegrees));
    var fovRightTan = Math.tan(KEN.Math.degToRad(fov.rightDegrees));

    // and with scale/offset info for normalized device coords
    var pxscale = 2.0 / (fovLeftTan + fovRightTan);
    var pxoffset = (fovLeftTan - fovRightTan) * pxscale * 0.5;
    var pyscale = 2.0 / (fovUpTan + fovDownTan);
    var pyoffset = (fovUpTan - fovDownTan) * pyscale * 0.5;

    // start with an identity matrix
    var matrix = new THREE.Matrix4();
    var m = matrix.elements;

    // X result, map clip edges to [-w,+w]
    m[ 0 * 4 + 0 ] = pxscale;
    m[ 0 * 4 + 1 ] = 0.0;
    m[ 0 * 4 + 2 ] = -pxoffset;
    m[ 0 * 4 + 3 ] = 0.0;

    // Y result, map clip edges to [-w,+w]
    // Y offset is negated because this proj matrix transforms from world coords with Y=up,
    // but the NDC scaling has Y=down (thanks D3D?)
    m[ 1 * 4 + 0 ] = 0.0;
    m[ 1 * 4 + 1 ] = pyscale;
    m[ 1 * 4 + 2 ] = pyoffset;
    m[ 1 * 4 + 3 ] = 0.0;

    // Z result (up to the app)
    m[ 2 * 4 + 0 ] = 0.0;
    m[ 2 * 4 + 1 ] = 0.0;
    m[ 2 * 4 + 2 ] = camera.far / ( camera.near - camera.far );
    m[ 2 * 4 + 3 ] = ( camera.far * camera.near ) / ( camera.near - camera.far );

    // W result (= Z in)
    m[ 3 * 4 + 0 ] = 0.0;
    m[ 3 * 4 + 1 ] = 0.0;
    m[ 3 * 4 + 2 ] = -1.0;
    m[ 3 * 4 + 3 ] = 0.0;

    matrix.transpose();
    return matrix;
};

/**
 * VR controls reset routine
 * @method KEN.RenderDisplay#_vrControlsReset
 * @private
 */
KEN.RenderDisplay.prototype._vrControlsReset = function()
{
    if (this._vrDisplay !== null)
    {
        if (typeof this._vrDisplay.resetPose !== "undefined")
        {
            this._vrDisplay.resetPose();
        }
        else if (typeof this._vrDisplay.resetSensor !== "undefined")
        {
            // Deprecated API.
            this._vrDisplay.resetSensor();
        }
        else if (typeof this._vrDisplay.zeroSensor !== "undefined")
        {
            // Really deprecated API.
            this._vrDisplay.zeroSensor();
        }
    }
};

/**
 * Request presentation through VR display interface
 * @method KEN.RenderDisplay#_requestPresent
 * @private
 */
KEN.RenderDisplay.prototype._requestPresent = function()
{
    this._viewer["raf"].stop();
    this._viewer["raf"].start(this._vrDisplay);
    return this._setFullScreen(true);
};

/**
 * Exit presentation from VR display interface
 * @method KEN.RenderDisplay#_exitPresent
 * @private
 */
KEN.RenderDisplay.prototype._exitPresent = function()
{
    this._viewer["raf"].stop();
    this._viewer["raf"].start(window);
    return this._setFullScreen(false);
};

/**
 * Start or stop VR display
 * @method KEN.RenderDisplay#enableVR
 * @param {boolean} status VR display status
 */
KEN.RenderDisplay.prototype.enableVR = function(status)
{
    if (status === true)
    {
        this._requestPresent();
    }
    else
    {
        this._exitPresent();
    }
};

/**
 * Get camera orientation quaternion when presenting VR
 * @method KEN.RenderDisplay#getCameraOrientation
 * @return {THREE.Quaternion} quaternion extracted from pose or null if vrDisplay is not available
 * @private
 */
KEN.RenderDisplay.prototype.getCameraQuaternion = function()
{
    if ( this._vrDisplay === null )
    {
        return null;
    }

    var quaternion = new THREE.Quaternion();

    if (typeof this._vrDisplay.getPose === "function")
    {
        var pose = this._vrDisplay.getPose();

        if (pose.orientation !== null)
        {
            var o = pose.orientation;
            quaternion = new THREE.Quaternion(-o[1], -o[0], -o[2], o[3]);
        }

        // if ( pose["position"] !== null ) {
        //     object["position"].fromArray( pose["position"] );
        // } else {
        //     object["position"].set( 0, 0, 0 );
        // }
    }

    // if ( this.standing ) {

    //     if ( vrDisplay.stageParameters ) {

    //         object.updateMatrix();

    //         standingMatrix.fromArray( vrDisplay.stageParameters.sittingToStandingTransform );
    //         object.applyMatrix( standingMatrix );

    //     } else {

    //         object["position"].setY( object["position"].y + this.userHeight );

    //     }

    // }

    // object["position"].multiplyScalar( scope.scale );

    return quaternion;
};

/**
 * Get render parameters
 * @method KEN.RenderDisplay#getRenderParams
 * @return {Array<KEN.RenderParams>} Returns an array of render parameters.
 */
KEN.RenderDisplay.prototype.getRenderParams = function()
{

    var renderer = this._viewer["renderer"]["webGLRenderer"];
    var canvas = renderer.domElement;
    var camera = this._viewer["renderer"]["camera"]["perspectiveCamera"];
    var renderParams = [];

    if (typeof this._vrDisplay !== "undefined" && this._vrDisplay !== null && this._presentingVR === true)
    {
        var eyeParamsL = this._vrDisplay.getEyeParameters("left");
        var eyeParamsR = this._vrDisplay.getEyeParameters("right");

        var eyeTranslationL = new THREE.Vector3();
        eyeTranslationL.fromArray(eyeParamsL.offset);

        var eyeTranslationR = new THREE.Vector3();
        eyeTranslationR.fromArray(eyeParamsR.offset);

        var rx = this._rendererSize["width"] * this._leftBounds[0],
        ry = this._rendererSize["height"] * this._leftBounds[1],
        rw = this._rendererSize["width"] * this._leftBounds[2],
        rh = this._rendererSize["height"] * this._leftBounds[3];

        var renderRectL = new KEN.Rectangle(rx, ry, rw, rh);

        rx = this._rendererSize["width"] * this._rightBounds[0];
        ry = this._rendererSize["height"] * this._rightBounds[1];
        rw = this._rendererSize["width"] * this._rightBounds[2];
        rh = this._rendererSize["height"] * this._rightBounds[3];

        var renderRectR = new KEN.Rectangle(rx, ry, rw, rh);

        if (camera["parent"] === null)
        {
            camera.updateMatrixWorld();
        }

        camera.matrixWorld.decompose(this._cameraL["position"], this._cameraL["quaternion"], this._cameraL.scale);
        camera.matrixWorld.decompose(this._cameraR["position"], this._cameraR["quaternion"], this._cameraR.scale);

        if (this._vrDisplay.getFrameData)
        {
            this._vrDisplay.depthNear = camera.near;
            this._vrDisplay.depthFar = camera.far;
            this._vrDisplay.getFrameData(this._frameData);

            this._cameraL.projectionMatrix.elements = this._frameData.leftProjectionMatrix;
            this._cameraR.projectionMatrix.elements = this._frameData.rightProjectionMatrix;
        }
        else
        {
            var eyeFOV =
            {
                upDegrees: Math.max(eyeParamsL.fieldOfView.upDegrees, eyeParamsR.fieldOfView.upDegrees),
                downDegrees: Math.max(eyeParamsL.fieldOfView.downDegrees, eyeParamsR.fieldOfView.downDegrees),
                leftDegrees: Math.max(eyeParamsL.fieldOfView.leftDegrees, eyeParamsR.fieldOfView.leftDegrees),
                rightDegrees: Math.max(eyeParamsL.fieldOfView.rightDegrees, eyeParamsR.fieldOfView.rightDegrees)
            };

            var projectionMatrix = this._fovToProjectionMatrix(eyeFOV, camera);
            this._cameraL.projectionMatrix = projectionMatrix;
            this._cameraR.projectionMatrix = projectionMatrix;
        }

        renderParams.push(new KEN.RenderParams(renderRectL, this._cameraL));
        renderParams.push(new KEN.RenderParams(renderRectR, this._cameraR));
    }
    else
    {
        var rectangle = new KEN.Rectangle(0, 0, this._rendererSizeScreen["width"], this._rendererSizeScreen["height"]);
        renderParams.push(new KEN.RenderParams(rectangle, camera));
    }

    return renderParams;
};

/**
 * Set size of rendering objects
 * @method KEN.RenderDisplay#setSize
 * @param {KEN.Size} size - new renderer size
 */
KEN.RenderDisplay.prototype.setSize = function(size)
{
    this._rendererSizeScreen = size;
};

/**
 * Submit current frame to VR display interface
 * @method KEN.RenderDisplay#submitFrame
 */
KEN.RenderDisplay.prototype.submitFrame = function()
{
    if (this._webVR === true && typeof this._vrDisplay !== "undefined" && this._presentingVR === true)
    {
        this._vrDisplay.submitFrame();
    }
};

/**
 * Destroy sequence
 * @method KEN.RenderDisplay#destroy
 */
KEN.RenderDisplay.prototype.destroy = function()
{
    this._removeFullscreenListener();

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.destroy();
        this._onLoadComplete = null;
    }

    this._vrDisplay = null;
    this._frameData = null;
    this._leftBounds = null;
    this._rightBounds = null;
    this._cameraL = null;
    this._cameraR = null;
    this._rendererSize = null;

    this._viewer = null;
};

/**
 * Presenting in VR or not.
 * @name KEN.RenderDisplay#presentingVR
 * @readonly
 * @type {boolean}
 */
KEN.RenderDisplay.prototype.presentingVR;
Object.defineProperty(KEN.RenderDisplay.prototype, "presentingVR",
{
    /** @this {KEN.RenderDisplay} */
    get: function()
    {
        return this._presentingVR;
    }
});

/**
 * Render size.
 * @name KEN.RenderDisplay#rendererSize
 * @readonly
 * @type {boolean}
 */
KEN.RenderDisplay.prototype.rendererSize;
Object.defineProperty(KEN.RenderDisplay.prototype, "rendererSize",
{
    /** @this {KEN.RenderDisplay} */
    get: function()
    {
        return this._rendererSize;
    }
});

/**
 * Get the onDisplayChange {@link KEN.EventDispatcher}.
 * @name KEN.RenderDisplay#onDisplayChange
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.RenderDisplay.prototype.onDisplayChange;
Object.defineProperty(KEN.RenderDisplay.prototype, "onDisplayChange",
{
    /** @this {KEN.RenderDisplay} */
    get: function()
    {
        if(this._onDisplayChange === null)
        {
            this._onDisplayChange = new KEN.EventDispatcher(this);
        }

        return this._onDisplayChange;
    }
});

/**
 * Render parameters
 * 
 * @constructor KEN.RenderParams
 * @param {KEN.Rectangle} rectangle render rectangle
 * @param {THREE.PerspectiveCamera} camera render camera
 */
KEN.RenderParams = function(rectangle, camera)
{
    /**
     * Render rectangle.
     * @name KEN.RenderParams#_rectangle
     * @type {KEN.Rectangle}
     * @private
     */
    this._rectangle = rectangle || null;

    /**
     * Render camera.
     * @name KEN.RenderParams#_camera
     * @type {THREE.PerspectiveCamera}
     * @private
     */
    this._camera = camera || null;
};

KEN.RenderParams.prototype.constructor = KEN.RenderParams;

/**
 * Get rectangle.
 * @name KEN.RenderParams#rectangle
 * @type {KEN.Rectangle}
 */
KEN.RenderParams.prototype.rectangle;
Object.defineProperty(KEN.RenderParams.prototype, "rectangle",
{
    /** @this {KEN.RenderParams} */
    get: function()
    {
        return this._rectangle;
    }
});

/**
 * Get camera.
 * @name KEN.RenderParams#camera
 * @type {THREE.PerspectiveCamera}
 */
KEN.RenderParams.prototype.camera;
Object.defineProperty(KEN.RenderParams.prototype, "camera",
{
    /** @this {KEN.RenderParams} */
    get: function()
    {
        return this._camera;
    }
});

/**
 * KEN.BackgroundRenderer
 * BackgroundRenderer class.
 *
 * @constructor KEN.BackgroundRenderer
 * @param {KEN.Viewer} viewer - KEN viewer.
 * @param {string=} type - The type of the object as long as many other object inherits from this one.
 * @extends {KEN.BaseObject}
 */
KEN.BackgroundRenderer = function(viewer, type)
{
    /**
     * @name KEN.BackgroundRenderer#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * @name KEN.BackgroundRenderer#_canvas
     * @type {KEN.Canvas}
     * @private
     */
    this._canvas = null;

    /**
     * @name KEN.BackgroundRenderer#_materialManager
     * @type {KEN.MaterialManager}
     * @private
     */
    this._materialManager = null;

    /**
     * @name KEN.BackgroundRenderer#_scene
     * @type {THREE.Scene}
     * @private
     */
    this._scene = null;

    /**
     * @name KEN.BackgroundRenderer#_camera
     * @type {THREE.Camera}
     * @private
     */
    this._camera = null;

    /**
     * @name KEN.BackgroundRenderer#_renderTarget
     * @type {THREE.WebGLRenderTarget}
     * @private
     */
    this._renderTarget = null;

    KEN.BaseObject.call(this, type || "BackgroundRenderer");

    this._boot();
};

KEN.BackgroundRenderer.prototype = Object.create(KEN.BaseObject.prototype);
KEN.BackgroundRenderer.prototype.constructor = KEN.BackgroundRenderer;

/**
 * Init routine.
 * @method KEN.BackgroundRenderer#_boot
 * @private
 */
KEN.BackgroundRenderer.prototype._boot = function()
{
    this._scene = new THREE.Scene();
    this._materialManager = new KEN.MaterialManager(this._viewer);

    var width = this._viewer["renderer"]["canvasResolution"]["width"];
    var height = this._viewer["renderer"]["canvasResolution"]["height"];

    var rtParams =
    {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        stencilBuffer: false
    };

    this._renderTarget = new THREE.WebGLRenderTarget(width, height, rtParams);
};

/**
 * Update internals
 * @method KEN.BackgroundRenderer#_updateInternals
 * @private
 */
KEN.BackgroundRenderer.prototype._updateInternals = function()
{

};

/**
 * Update after view change
 * @todo change name of this method to be more generic (used by init and )
 * Should be overriden by subclass
 * @method KEN.BackgroundRenderer#updateAfterViewChange
 */
KEN.BackgroundRenderer.prototype.updateAfterViewChange = function()
{
    throw new Error(this._className + "::updateAfterViewChange not implemented");
};

/**
 * Update size (resolution)
 * @method KEN.BackgroundRenderer#setSize
 * @param {KEN.Size} size - size [px]
 */
KEN.BackgroundRenderer.prototype.setSize = function(size)
{
    if (this["renderTarget"] !== null)
    {
        this["renderTarget"].setSize(size["width"], size["height"]);
    }
};

/**
 * Render routine.
 * @method KEN.BackgroundRenderer#render
 */
KEN.BackgroundRenderer.prototype.render = function()
{
    if (this._viewer["renderer"] === null || this._renderTarget === null)
    {
        return;
    }

    this._viewer["renderer"]["webGLRenderer"].render ( this._scene, this._camera, this._renderTarget, true );
};

/**
 * Destroy sequence.
 * @method KEN.BackgroundRenderer#destroy
 */
KEN.BackgroundRenderer.prototype.destroy = function()
{
    this._camera = null;

    this._materialManager.destroy();
    this._materialManager = null;

    if (this._renderTarget !== null)
    {
        this._renderTarget.dispose();
        this._renderTarget = null;
    }

    while (this._scene["children"].length > 0)
    {
        var mesh = this._scene["children"].pop();

        if (mesh.geometry !== null)
        {
            mesh.geometry.dispose();
            mesh.geometry = null;
        }

        this._scene.remove(mesh);
    }

    this._scene = null;
    this._viewer = null;
};

/**
 * Get background render target.
 * @name KEN.BackgroundRenderer#renderTarget
 * @type {THREE.Texture}
 */
KEN.BackgroundRenderer.prototype.renderTarget;
Object.defineProperty(KEN.BackgroundRenderer.prototype, "renderTarget",
{
    /** @this {KEN.BackgroundRenderer} */
    get: function()
    {
        return this._renderTarget;
    }
});



/**
 * @namespace {Object} KEN.BackgroundType
 */
KEN.BackgroundType = {};

/**
 * @name KEN.BackgroundType.UNDEFINED
 * @type {string}
 * @const
 */
KEN.BackgroundType.UNDEFINED = "undefined";

/**
 * @name KEN.BackgroundType.SHADER
 * @type {string}
 * @const
 */
KEN.BackgroundType.SHADER = "shader";

/**
 * @name KEN.BackgroundType.MESH
 * @type {string}
 * @const
 */
KEN.BackgroundType.MESH = "mesh";

/**
 * KEN.BackgroundMeshRenderer
 * BackgroundMeshRenderer class.
 *
 * @constructor KEN.BackgroundMeshRenderer
 * @extends {KEN.BackgroundRenderer}
 *
 * @param {KEN.Viewer} viewer - KEN viewer.
 * @param {SceneMediaOptionsConfig} options - the options for the cubemap
 */
KEN.BackgroundMeshRenderer = function(viewer, options)
{
    /**
     * Display object (image, canvas or video)
     * @type {KEN.DisplayObject}
     * @private
     */
    this._displayObject = null;

    /**
     * Texture used for video rendering
     * @type {THREE.Texture}
     * @private
     */
    this._texture = null;

    /**
     * Texture canvas used for video rendering
     * @type {Element|HTMLCanvasElement}
     * @private
     */
    this._textureCanvas = null;

    /**
     * Texture context associated with texture canvas
     * @type {CanvasRenderingContext2D}
     * @private
     */
    this._textureContext = null;

    /**
     * The mesh (cube) the video is on.
     * @type {THREE.Mesh}
     * @private
     */
    this._mesh = null;

    /**
     * The layout of the faces in the texture. There are six faces to specify:
     * Right (R), Left (L), Up (U), Down (D), Front (F), Back (B). The default
     * layout is the Facebook one, with RLUDFB.
     * @type {string}
     * @private
     */
    this._layout = options.order || "RLUDFB";

    /**
     * The number of horizontal faces and vertical ones in the media.
     * @type {THREE.Vector2}
     * @private
     */
    this._faces = new THREE.Vector2(options.faceHorizontal || 0, options.faceVertical || 0);

    /**
     * The size of the cube.
     * @type {number}
     * @private
     */
    this._size = 0;

    /**
     * The number of subdivision of a face, per direction. For example, if the
     * subdivision is 4, the cube would be composed of 4 * 4 quads per face (in
     * reality it is 4 * 4 * 2 triangles).
     * @type {number}
     * @private
     */
    this._subdivision = 1;

    /**
     * When source is a video, a reduction factor can be set to improve perf by lowering quality
     * @type {number}
     * @private
     */
    this._videoReductionFactor = 1;

    KEN.BackgroundRenderer.call(this, viewer, "BackgroundMeshRenderer");
};

KEN.BackgroundMeshRenderer.prototype = Object.create(KEN.BackgroundRenderer.prototype);
KEN.BackgroundMeshRenderer.prototype.constructor = KEN.BackgroundMeshRenderer;

/**
 * Init routine.
 * @method KEN.BackgroundMeshRenderer#_boot
 * @private
 */
KEN.BackgroundMeshRenderer.prototype._boot = function()
{
    KEN.BackgroundRenderer.prototype._boot.call(this);

    // Set perspective camera
    this._camera = this._viewer["renderer"]["camera"]["perspectiveCamera"];
    this._viewer["renderer"]["camera"]["fovMin"] = this._viewer["renderer"]["view"]["fovMin"];
    this._viewer["renderer"]["camera"]["fovMax"] = this._viewer["renderer"]["view"]["fovMax"];

    if (this._faces.x === 0 && this._faces.y === 0)
    {
        this._faces.x = 3;
        this._faces.y = 2;
    }
    else if (this._faces.x === 0)
    {
        this._faces.x = 6 / this._faces.y;
    }
    else if (this._faces.y === 0)
    {
        this._faces.y = 6 / this._faces.x;
    }

    this._size = 10000;

    this._subdivision = 1;

    // Finalize now
    this.updateAfterViewChange();
};

/**
 * Set display object.
 * @method KEN.BackgroundMeshRenderer#_setDisplayObject
 * @private
 */
KEN.BackgroundMeshRenderer.prototype._setDisplayObject = function(displayObject)
{
    this._displayObject = displayObject;

    if (KEN.Utils.isTypeOf(displayObject, "Image"))
    {
        this._texture = new THREE.Texture();
        this._texture.image = displayObject["element"];
    }
    else if (KEN.Utils.isTypeOf(displayObject, "Canvas"))
    {
        this._texture = new THREE.Texture();
        this._texture.image = displayObject["element"];
    }
    else if (KEN.Utils.isTypeOf(displayObject, ["VideoHTML5", "VideoDash"]))
    {
        // Evil hack from Hell
        // Reduce texture size for big videos on safari
        if (KEN.Device.browser.toLowerCase() === "safari" && displayObject["originalHeight"] > 1440)
        {
            this._videoReductionFactor = 2;
        }

        this._textureCanvas = document.createElement("canvas");
        this._textureCanvas["width"] = displayObject["originalWidth"] / this._videoReductionFactor;
        this._textureCanvas["height"] = displayObject["originalHeight"] / this._videoReductionFactor;
        this._textureContext = this._textureCanvas.getContext("2d");
        this._texture = new THREE.Texture(this._textureCanvas);
    }
    else
    {
        throw "Wrong type of display object " + displayObject.type;
    }

    this._texture.format = THREE.RGBAFormat;
    this._texture.mapping = THREE.Texture.DEFAULT_MAPPING;
    this._texture.magFilter = THREE.LinearFilter;
    this._texture.minFilter = THREE.LinearFilter;
    this._texture.wrapS = THREE.ClampToEdgeWrapping;
    this._texture.wrapT = THREE.ClampToEdgeWrapping;
    this._texture.generateMipmaps = false;

    this._texture.needsUpdate = true;

    this._mesh["material"].map = this._texture;
};

/**
 * Return an array containing each coord for the uv mapping
 * @method KEN.BackgroundMeshRenderer#_setUVMapping
 * @return {Float32Array} The array containing the UVs
 * @private
 */
KEN.BackgroundMeshRenderer.prototype._setUVMapping = function()
{
    // the final array of uv coord for mapping
    var uvMap = new Float32Array((this._subdivision + 1) * (this._subdivision + 1) * 6 * 2);

    // iterator accross the uv coord
    var it = uvMap.keys();

    // layout of the texture
    var layout = this._layout.split("");

    // the width/height of a division in uv coord
    // the 1.01 is the default value for expand_coef in the ffmpeg filter
    // see https://github.com/facebook/transform/blob/04ec220a5c066a75d87f9e463b219262f7527421/vf_transform.c#L961
    var u = (1 / 1.01) * ((1 / this._faces.x) / this._subdivision);
    var v = (1 / 1.01) * ((1 / this._faces.y) / this._subdivision);

    // tiny offsets are for compensating the expand_coef of the ffmpeg filter
    // u tiny offset
    var uto = 0.005 * (1 / this._faces.x);
    // v tiny offset
    var vto = 0.005 * (1 / this._faces.y);

    /**
     * Apply the correct UV to the uv map
     * @param  {number} idx
     * @param  {number} x
     * @param  {number} y
     * @param  {number} sub
     * @param  {boolean=} upOrDown
     */
    function applyUVMapForFace(idx, x, y, sub, upOrDown)
    {
        if (idx === -1)
        {
            throw "Unknown face for cube mapping.";
        }

        // iterator
        var i, j, ii, jj;

        // u offset, where is it in the layout, change for each face
        var uo = (idx % x) / x;
        // v offset, where is it in the layout, change for each face
        var vo = 1 - ((1 + parseInt(idx / x, 10)) / y);

        // not the same inversion if up or down
        if (upOrDown)
        {
            // vertical
            for (i = 0, ii = sub; i <= ii; i++)
            {
                // horizontal
                for (j = 0, jj = sub; j <= jj; j++)
                {
                    // u
                    uvMap[it.next().value] = uto + u * j + uo;
                    // v
                    uvMap[it.next().value] = vto + v * i + vo;
                }
            }
        }
        else
        {
            // vertical
            for (i = 0, ii = sub; i <= ii; ii--)
            {
                // horizontal
                for (j = 0, jj = sub; j <= jj; jj--)
                {
                    // u
                    uvMap[it.next().value] = uto + u * jj + uo;
                    // v
                    uvMap[it.next().value] = vto + v * ii + vo;
                }
            }
        }
    }

    applyUVMapForFace(layout.indexOf("R"), this._faces.x, this._faces.y, this._subdivision);
    applyUVMapForFace(layout.indexOf("L"), this._faces.x, this._faces.y, this._subdivision);
    applyUVMapForFace(layout.indexOf("U"), this._faces.x, this._faces.y, this._subdivision, true);
    applyUVMapForFace(layout.indexOf("D"), this._faces.x, this._faces.y, this._subdivision, true);
    applyUVMapForFace(layout.indexOf("B"), this._faces.x, this._faces.y, this._subdivision);
    applyUVMapForFace(layout.indexOf("F"), this._faces.x, this._faces.y, this._subdivision);

    return uvMap;
};

/**
 * Update texture if needed (video only).
 * @method KEN.BackgroundMeshRenderer#_updateTexture
 * @private
 */
KEN.BackgroundMeshRenderer.prototype._updateTexture = function()
{
    if (this._texture === null || this._textureCanvas === null ||
        this._textureContext === null || this._displayObject === null ||
        this._displayObject["element"] === null)
    {
        return;
    }

    var video = this._displayObject["element"];
    if (video && video.readyState === video.HAVE_ENOUGH_DATA)
    {
        if (this._textureContext)
        {
            this._textureContext.drawImage(video,
                0, 0, video.videoWidth, video.videoHeight,
                0, 0, this._textureCanvas["width"], this._textureCanvas["height"]);
            this._texture.needsUpdate = true;
            this.log("texture update done");
        }
    }
};

/**
 * Render routine.
 * Do preliminary job of specific background renderer, then summon superclass method
 * @method KEN.BackgroundMeshRenderer#render
 */
KEN.BackgroundMeshRenderer.prototype.render = function()
{
    if (this._viewer["renderer"] === null)
    {
        return;
    }

    this._updateTexture();

    KEN.BackgroundRenderer.prototype.render.call(this);
};

/**
 * Clear background.
 * @method KEN.BackgroundMeshRenderer#_clear
 * @private
 */
KEN.BackgroundMeshRenderer.prototype._clear = function()
{
    // Draw to clear screen, then clear display object / texture
    this._viewer["renderer"]["webGLRenderer"].clearColor();
};

/**
 * Update internals
 * @method KEN.BackgroundMeshRenderer#_updateInternals
 * @private
 */
KEN.BackgroundMeshRenderer.prototype._updateInternals = function()
{
    var material = new THREE.MeshBasicMaterial(
    {
        side: THREE.BackSide
    });

    if (this._texture !== null)
    {
        material.map = this._texture;
    }

    if (this._scene["children"].length === 0)
    {
        var geometry = new THREE.BoxBufferGeometry(this._size, this._size, this._size, this._subdivision, this._subdivision, this._subdivision);
        geometry.attributes.uv.set(this._setUVMapping());
        this._mesh = new THREE.Mesh(geometry, material);
        this._scene.add(this._mesh);
    }
    else
    {
        this._mesh = this._scene["children"][0];
        this._materialManager.remove(this._mesh["material"]);
        this._mesh["material"] = null;
    }

    this._materialManager.add(material);
    this._mesh["material"] = material;
    material.needsUpdate = true;
};

/**
 * Update after view change
 * @method KEN.BackgroundMeshRenderer#updateAfterViewChange
 */
KEN.BackgroundMeshRenderer.prototype.updateAfterViewChange = function()
{
    this._updateInternals();
};

/**
 * Destroy sequence.
 * @method KEN.BackgroundMeshRenderer#destroy
 */
KEN.BackgroundMeshRenderer.prototype.destroy = function()
{
    this._clear();

    this._displayObject = null;
    this._textureCanvas = null;
    this._textureContext = null;

    if (this._texture !== null)
    {
        this._texture.dispose();
        this._texture = null;
    }

    KEN.BackgroundRenderer.prototype.destroy.call(this);
};

/**
 * Get/Set background renderer displayObject.
 * @name KEN.BackgroundMeshRenderer#displayObject
 * @type {string}
 */
KEN.BackgroundMeshRenderer.prototype.displayObject;
Object.defineProperty(KEN.BackgroundMeshRenderer.prototype, "displayObject",
{
    /** @this {KEN.BackgroundMeshRenderer} */
    get: function()
    {
        return this._displayObject;
    },

    /** @this {KEN.BackgroundMeshRenderer} */
    set: function(value)
    {
        if (value === null)
        {
            this._clear();
        }
        else
        {
            this._setDisplayObject(value);
        }
    }
});

/**
 * Get background renderer texture.
 * @name KEN.BackgroundMeshRenderer#texture
 * @type {string}
 */
KEN.BackgroundMeshRenderer.prototype.texture;
Object.defineProperty(KEN.BackgroundMeshRenderer.prototype, "texture",
{
    /** @this {KEN.BackgroundMeshRenderer} */
    get: function()
    {
        return this._texture;
    }
});
/**
 * KEN.BackgroundShaderRenderer
 * BackgroundShaderRenderer class.
 *
 * @constructor KEN.BackgroundShaderRenderer
 * @param {KEN.Viewer} viewer - KEN viewer.
 * @extends {KEN.BackgroundRenderer}
 */
KEN.BackgroundShaderRenderer = function(viewer)
{
    /**
     * Display object (image, canvas or video)
     * @name KEN.BackgroundShaderRenderer#_displayObject
     * @type {KEN.DisplayObject}
     * @private
     */
    this._displayObject = null;

    /**
     * Texture used for video rendering
     * @name KEN.BackgroundShaderRenderer#_texture
     * @type {THREE.Texture}
     * @private
     */
    this._texture = null;

    /**
     * Texture canvas used for video rendering
     * @name KEN.BackgroundShaderRenderer#_textureCanvas
     * @type {Element|HTMLCanvasElement}
     * @private
     */
    this._textureCanvas = null;

    /**
     * Texture context associated with texture canvas
     * @name KEN.BackgroundShaderRenderer#_textureContext
     * @type {CanvasRenderingContext2D}
     * @private
     */
    this._textureContext = null;

    /**
     * When source is a video, a reduction factor can be set to improve perf by lowering quality
     * @name KEN.BackgroundShaderRenderer#_videoReductionFactor
     * @type {number}
     * @private
     */
    this._videoReductionFactor = 1;

    KEN.BackgroundRenderer.call(this, viewer, "BackgroundShaderRenderer");
};

KEN.BackgroundShaderRenderer.prototype = Object.create(KEN.BackgroundRenderer.prototype);
KEN.BackgroundShaderRenderer.prototype.constructor = KEN.BackgroundShaderRenderer;

/**
 * Init routine.
 * @method KEN.BackgroundShaderRenderer#_boot
 * @private
 */
KEN.BackgroundShaderRenderer.prototype._boot = function()
{
    KEN.BackgroundRenderer.prototype._boot.call(this);

    // Finalize now
    this.updateAfterViewChange();

    // Set orthographic camera
    this._camera = new THREE.OrthographicCamera( -1, 1, 1, -1, -1, 1 );

    // Debug: attach scene to window context to expose it into Three.js Inspector
    // window["scene"] = this._scene;
};

/**
 * Set display object.
 * @method KEN.BackgroundShaderRenderer#_setDisplayObject
 * @private
 */
KEN.BackgroundShaderRenderer.prototype._setDisplayObject = function(displayObject)
{
    this._displayObject = displayObject;

    if (KEN.Utils.isTypeOf(displayObject, "Image") || KEN.Utils.isTypeOf(displayObject, "Canvas"))
    {
        this._texture = new THREE.Texture();
        this._texture.image = displayObject["element"];
    }
    else if (KEN.Utils.isTypeOf(displayObject, ["VideoHTML5", "VideoDash"]))
    {
        // Evil hack from Hell
        // Reduce texture size for big videos on safari
        if (KEN.Device.browser.toLowerCase() === "safari" && displayObject["originalHeight"] > 1440) 
        {
            this._videoReductionFactor = 2;
        }

        this._displayObject["onQualityChange"].add(this._mediaQualityChangeHandler, this);

        this._textureCanvas = document.createElement("canvas");
        this._textureCanvas["width"] = displayObject["originalWidth"] / this._videoReductionFactor;
        this._textureCanvas["height"] = displayObject["originalHeight"] / this._videoReductionFactor;
        this._textureContext = this._textureCanvas.getContext("2d");
        this._texture = new THREE.Texture(this._textureCanvas);
    }
    else 
    {
        throw "Wrong type of display object " + displayObject.className;
    }
    
    this._texture.format = THREE.RGBFormat;
    this._texture.mapping = THREE.Texture.DEFAULT_MAPPING;
    this._texture.magFilter = THREE.LinearFilter;
    this._texture.minFilter = THREE.LinearFilter;
    this._texture.wrapS = THREE.ClampToEdgeWrapping;
    this._texture.wrapT = THREE.ClampToEdgeWrapping;
    this._texture.generateMipmaps = false;

    this._texture.needsUpdate = true;
    this._viewer["renderer"]["view"]["materialScreenToWorld"].uniforms.tEquirect["value"] = this._texture;
};

/**
 * Handler of media quality change event
 * @method KEN.BackgroundShaderRenderer#_mediaQualityChangeHandler
 * @private
 */
KEN.BackgroundShaderRenderer.prototype._mediaQualityChangeHandler = function(event)
{
    this.log("Media quality has changed");

    var displayObject = event["emitter"];
    this._textureCanvas["width"] = displayObject["originalWidth"] / this._videoReductionFactor;
    this._textureCanvas["height"] = displayObject["originalHeight"] / this._videoReductionFactor;
};

/**
 * Update texture if needed (video only).
 * @method KEN.BackgroundShaderRenderer#_updateTexture
 * @private
 */
KEN.BackgroundShaderRenderer.prototype._updateTexture = function()
{
    if (this._texture === null || this._textureCanvas === null ||
        this._textureContext === null || this._displayObject === null ||
        this._displayObject["element"] === null) 
    {
        return;
    }

    var video = this._displayObject["element"];
    if ( video && video.readyState === video.HAVE_ENOUGH_DATA )
    {
        if (this._textureContext)
        {
            this._textureContext.drawImage( video,
                0, 0, video.videoWidth, video.videoHeight,
                0, 0, this._textureCanvas["width"], this._textureCanvas["height"] );
            this._texture.needsUpdate = true;
            this.log("texture update done");
        }
    }
};

/**
 * Update internals
 * @method KEN.BackgroundShaderRenderer#_updateInternals
 * @private
 */
KEN.BackgroundShaderRenderer.prototype._updateInternals = function()
{
    KEN.BackgroundRenderer.prototype._updateInternals.call(this);

    var mesh = null;
    var material = this._viewer["renderer"]["view"]["materialScreenToWorld"].clone();

    if (this._texture !== null)
    {
        this._viewer["renderer"]["view"]["materialScreenToWorld"].uniforms.tEquirect["value"] = this._texture;
    }

    if (this._scene["children"].length === 0)
    {
        var geometry = new THREE.PlaneBufferGeometry( 2, 2 );
        mesh = new THREE.Mesh(geometry, material);
        this._scene.add(mesh);
    }
    else
    {
        mesh = this._scene["children"][0];
        this._materialManager.remove(mesh["material"]);
        mesh["material"] = null;
    }

    // var shader = this._viewer["renderer"].shaderFactory.buildShader(this._viewer["renderer"]["view"].shaderScreenToWorld);
    // shader.dump();

    this._materialManager.add(material);
    mesh["material"] = material;
    mesh["material"].needsUpdate = true;

    this._materialManager.syncUniformsWithMaterial(material);
};

/**
 * Clear background.
 * @method KEN.BackgroundShaderRenderer#clear
 * @private
 */
KEN.BackgroundShaderRenderer.prototype._clear = function() 
{
    // Draw to clear screen, then clear display object / texture
    this._viewer["renderer"]["webGLRenderer"].clearColor();
};

/**
 * Render routine.
 * Do preliminary job of specific background renderer, then summon superclass method
 * @method KEN.BackgroundShaderRenderer#render
 */
KEN.BackgroundShaderRenderer.prototype.render = function() 
{
    if (this._viewer["renderer"] === null) 
    {
        return;
    }

    this._updateTexture();

    // Update renderer materials with view's reference material
    this._materialManager.syncUniformsWithMaterial(this._viewer["renderer"]["view"]["materialScreenToWorld"]);

    KEN.BackgroundRenderer.prototype.render.call(this);
};

/**
 * Update after view change
 * @method KEN.BackgroundShaderRenderer#updateAfterViewChange
 */
KEN.BackgroundShaderRenderer.prototype.updateAfterViewChange = function()
{
    this._updateInternals();
};

/**
 * Destroy sequence.
 * @method KEN.BackgroundShaderRenderer#destroy
 */
KEN.BackgroundShaderRenderer.prototype.destroy = function()
{
    this._clear();

    if (typeof this._displayObject["onQualityChange"] !== "undefined" &&
        this._displayObject["onQualityChange"].has(this._mediaQualityChangeHandler, this)) 
    {
        this._displayObject["onQualityChange"].remove(this._mediaQualityChangeHandler, this);
    }

    this._displayObject = null;
    this._textureCanvas = null;
    this._textureContext = null;

    if (this._texture !== null) 
    {
        this._texture.dispose();
        this._texture = null;
    }

    KEN.BackgroundRenderer.prototype.destroy.call(this);
};

/**
 * Get/Set background renderer displayObject.
 * @name KEN.BackgroundShaderRenderer#displayObject
 * @type {string}
 */
KEN.BackgroundShaderRenderer.prototype.displayObject;
Object.defineProperty(KEN.BackgroundShaderRenderer.prototype, "displayObject",
{
    /** @this {KEN.BackgroundShaderRenderer} */
    get: function() 
    {
        return this._displayObject;
    },
    /** @this {KEN.BackgroundShaderRenderer} */
    set: function(value) 
    {
        if (value === null) 
        {
            this._clear();
        }
        else 
        {
            this._setDisplayObject(value);
        }
    }
});

/**
 * Get background renderer texture.
 * @name KEN.BackgroundShaderRenderer#texture
 * @type {string}
 */
KEN.BackgroundShaderRenderer.prototype.texture;
Object.defineProperty(KEN.BackgroundShaderRenderer.prototype, "texture",
{
    /** @this {KEN.BackgroundShaderRenderer} */
    get: function() 
    {
        return this._texture;
    }
});

/**
 * KEN.MaterialManager
 * Material Manager class.
 *
 * @constructor KEN.MaterialManager
 * @param {KEN.Viewer} viewer tour viewer
 * @extends {KEN.BaseObject}
 */
KEN.MaterialManager = function(viewer)
{
    /**
     * Reference on viewer.
     * @type {KEN.Viewer|undefined}
     * @private
     */
    this._viewer = viewer;

    /**
     * List of material references
     * @name KEN.MaterialManager#_materials
     * @type {Array<THREE.Material>}
     * @private
     */
    this._materials = null;

    KEN.BaseObject.call(this, "MaterialManager");
    this._init();
};

KEN.MaterialManager.prototype = Object.create(KEN.BaseObject.prototype);
KEN.MaterialManager.prototype.constructor = KEN.MaterialManager;

/**
 * Init routine
 * @method KEN.MaterialManager#_init
 * @private
 */
KEN.MaterialManager.prototype._init = function()
{
    this._materials = [];
};

/**
 * Get material index by id
 * @method KEN.MaterialManager#_getMaterialIndexById
 * @param {number} id material id
 * return {number} index of found material or -1 if not found
 * @private
 */
KEN.MaterialManager.prototype._getMaterialIndexById = function(id)
{
    for (var i = 0, ii = this._materials.length; i < ii; i++)
    {
        var material = this._materials[i];

        if (material["id"] === id)
        {
            return i;
        }
    }
    return -1;
};

/**
 * Add material to materials list
 * @method KEN.MaterialManager#add
 * @param {THREE.Material} material to store
 */
KEN.MaterialManager.prototype.add = function(material)
{
    this._materials.push(material);
    this.log("Material " + material["id"] + " added");
};

/**
 * Remove material from materials list
 * @method KEN.MaterialManager#remove
 * @param {THREE.Material} material to remove
 */
KEN.MaterialManager.prototype.remove = function(material)
{
    var mIdx = this._getMaterialIndexById(material["id"]);

    if (mIdx === -1)
    {
        return;
    }

    if (typeof material.map !== "undefined")
    {
        material.map.dispose();
    }

    this.log("Material " + this._materials[mIdx]["id"] + " removed");
    this._materials.splice(mIdx, 1);
    material.dispose();
};

/**
 * Synchronize all uniforms with a reference material
 * @method KEN.MaterialManager#syncUniformsWithMaterial
 * @param {THREE.ShaderMaterial} material reference material
 */
KEN.MaterialManager.prototype.syncUniformsWithMaterial = function(material)
{
    for (var name in material.uniforms)
    {
        for (var i = 0, ii = this._materials.length; i < ii; i++)
        {
            if (!this._materials[i].hasOwnProperty("uniforms"))
            {
                continue;
            }

            if (this._materials[i].uniforms.hasOwnProperty(name))
            {
                this._materials[i].uniforms[name]["value"] = material.uniforms[name]["value"];
                // this.log("commit uniform " + name + "(" + material.uniforms[name]["value"] + ")");
            }
        }
    }
};

/**
 * MaterialManager destroy sequence.
 *
 * @method KEN.MaterialManager#destroy
 */
KEN.MaterialManager.prototype.destroy = function()
{
    // Empty materials list and destroy each material
    while (this._materials.length > 0)
    {
        var material = this._materials.pop();

        for (var u in material.uniforms)
        {
            KEN.MaterialManager.releaseUniformValue(material.uniforms[u]);
        }
        material.dispose();
    }

    this._materials = null;
    this._viewer = null;
};

/**
 * Release uniform value
 * @method KEN.MaterialManager#releaseUniformValue
 * @param {Object} uniform shader uniform param
 */
KEN.MaterialManager.releaseUniformValue = function(uniform)
{
    if (uniform === null || uniform["value"] === null)
    {
        return;
    }

    // Check if uniform value should be disposed
    if (typeof uniform["value"].dispose !== "undefined")
    {
        uniform["value"].dispose();
    }

    uniform["value"] = null;
};

/**
 * Addition Shader for THREE
 * @type {Object}
 */
THREE.AdditionShader = {

    uniforms:
    {

        "tDiffuse": { value: null },
        "tAdd": { value: null }
    },

    vertexShader: [

        "varying vec2 vUv;",

        "void main() {",

            "vUv = uv;",
            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join( "\n" ),

    fragmentShader: [

        "uniform float tRatio;",

        "uniform sampler2D tDiffuse;",
        "uniform sampler2D tAdd;",

        "varying vec2 vUv;",

        "void main() {",

            "vec4 texel = texture2D( tDiffuse, vUv );",
            "vec4 texelAdd = texture2D( tAdd, vUv );",

            "gl_FragColor = vec4(vec3(texelAdd.a * texelAdd.rgb + (1.0 - texelAdd.a) * texel.rgb), 1.0);",

        "}"

    ].join( "\n" )

};
/**
 * KEN.PostProcessing
 * Post processing class.
 *
 * @constructor KEN.PostProcessing
 * @param {KEN.Viewer} viewer {@link KEN.Viewer} reference.
 * @extends {KEN.BaseObject}
 */
KEN.PostProcessing = function(viewer)
{
    /**
     * The viewer reference.
     * @name KEN.PostProcessing#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Input config.
     * @name KEN.PostProcessing#_config
     * @type {Object}
     * @private
     */
    this._config = null;

    /**
     * Shader pass sets.
     * @name KEN.PostProcessing#_sets
     * @type {Object}
     * @private
     */
    this._sets = null;

    KEN.BaseObject.call(this, "PostProcessing");

    this._boot();
};

KEN.PostProcessing.prototype = Object.create(KEN.BaseObject.prototype);
KEN.PostProcessing.prototype.constructor = KEN.PostProcessing;


/**
 * Init routine
 * @method KEN.PostProcessing#_boot
 * @private
 */
KEN.PostProcessing.prototype._boot = function()
{
    this._sets = {};
};

/**
 * Configuration parsing
 * @method KEN.PostProcessing#_parseConfig
 * @param {Object} config input media configuration
 * @private
 */
KEN.PostProcessing.prototype._parseConfig = function(config)
{
    this._uid = config["uid"];

    if (typeof config.fxSets !== "undefined" && config.fxSets.length > 0)
    {
        // Create sets of fx configuration
        for (var i = 0, ii = config.fxSets.length; i < ii; i++)
        {
            var fxConfig = config.fxSets[i];
            this._sets[fxConfig["uid"]] = fxConfig.set;
        }
    }
};

/**
 * Parse shader passes from FX configuration object
 * @method KEN.PostProcessing#parseShaderPasses
 * @return {Array<THREE.ShaderPass>} array of shader passes
 */
KEN.PostProcessing.prototype.parseShaderPasses = function(fxConfig)
{
    if (typeof fxConfig === "undefined" ||
        fxConfig === null ||
        fxConfig.length === 0)
    {
        return [];
    }

    var shaderPasses = [];
    for (var j = 0, jj = fxConfig.length; j < jj; j++)
    {
        var fx = /** type {FX} */ (fxConfig[j]);

        var pass = null;
        if (!THREE.hasOwnProperty(fx["type"]))
        {
            this.warn("Unknown image effect (" + fx["type"] + ")");
            continue;
        }

        var shader = THREE[fx["type"]];
        pass = new KEN.ShaderPass(shader, fx["uid"], fx["type"]);

        if (typeof pass.uniforms !== "undefined")
        {
            for (var param in fx.params)
            {
                var paramValue = fx.params[param];
                var value = paramValue;

                // Check if param is an object to build
                if (typeof paramValue === "object" && paramValue.hasOwnProperty("type") && paramValue.hasOwnProperty("args"))
                {
                    var args = paramValue.args;
                    switch (paramValue["type"])
                    {
                        case "THREE.Color":
                            if (args.length === 3)
                            {
                                value = new THREE.Color(args[0], args[1], args[2]);
                            }
                            else if (typeof args === "string" || typeof args === "number")
                            {
                                value = new THREE.Color(args);
                            }
                            else
                            {
                                throw new Error("Cannot create THREE.Color with " + (typeof args) + " (length " + args.length + ")");
                            }
                            break;

                        case "THREE.Vector2":
                            value = new THREE.Vector2(args[0], args[1]);
                            break;

                        case "THREE.Vector3":
                            value = new THREE.Vector3(args[0], args[1], args[2]);
                            break;
                    }
                }

                pass.uniforms[param]["value"] = value;
            }
        }

        shaderPasses.push(pass);
    }

    return shaderPasses;
};

/**
 * Add a post processing config.
 * @method KEN.PostProcessing#addConfig
 * @param {string} uid fx unique identifier
 * @return {string} fx set name
 */
KEN.PostProcessing.prototype.getFxSetByUID = function(uid)
{
    return this._sets[uid];
};

/**
 * Add a post processing config.
 * @method KEN.PostProcessing#addConfig
 * @param {Object} config - The config you want to add.
 */
KEN.PostProcessing.prototype.addConfig = function(config)
{
    this._config = config;
    this._parseConfig(this._config);
};

/**
 * Destroy sequence
 * @method KEN.PostProcessing#destroy
 */
KEN.PostProcessing.prototype.destroy = function()
{
    this._viewer = null;
    this._sets = null;
};

/**
 * ShaderPass class.
 *
 * Subclass of THREE Shader Pass
 * Used to feed time to shader when uniform is declared
 *
 * @constructor KEN.ShaderPass
 * @param {Object} shader shader object
 * @param {string} uid unique identifier
 * @param {string} type shader type
 * @extends {THREE.ShaderPass}
 */
KEN.ShaderPass = function(shader, uid, type)
{
    THREE.ShaderPass.call(this, shader, "tDiffuse");

    this.ken =
    {
        uid: uid,
        type: type
    };
};

KEN.ShaderPass.prototype = Object.create(THREE.ShaderPass.prototype);
KEN.ShaderPass.prototype.constructor = KEN.ShaderPass;

/**
 * @method  KEN.ShaderPass#render
 * @param  {THREE.WebGLRenderer} renderer
 * @param  {THREE.WebGLRenderTarget} writeBuffer
 * @param  {THREE.WebGLRenderTarget} readBuffer
 * @param  {number=} delta
 * @param  {boolean=} maskActive
 */
KEN.ShaderPass.prototype.render = function(renderer, writeBuffer, readBuffer, delta, maskActive)
{
    if (this.uniforms["time"])
    {
        this.uniforms["time"]["value"] = delta;
    }

    THREE.ShaderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, delta, maskActive);
};

/**
 * Destroy sequence
 * @method KEN.ShaderPass#destroy
 */
KEN.ShaderPass.prototype.destroy = function()
{
    this.ken = null;
};

/**
 * Shader object class.
 *
 * @constructor KEN.Shader
 * @extends {KEN.BaseObject}
 */
KEN.Shader = function(name, uniforms, vertex, fragment)
{
    /**
     * Shader program name (debug/inspection purpose).
     * @name KEN.Shader#_name
     * @type {string}
     * @private
     */
    this._name = name;

    /**
     * Map of uniforms properties.
     * All uniforms in the map follow this pattern.
     * @name KEN.Shader#_uniforms
     * @type {Object<string, TUniform>}
     * @private
     */
    this._uniforms = uniforms;

    /**
     * Vertex shader source code.
     * @name KEN.Shader#_vertex
     * @type {?string}
     * @private
     */
    this._vertex = vertex;

    /**
     * Fragment shader source code.
     * @name KEN.Shader#_fragment
     * @type {?string}
     * @private
     */
    this._fragment = fragment;

    KEN.BaseObject.call(this, "Shader");
};

KEN.Shader.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Shader.prototype.constructor = KEN.Shader;

/**
 * Dump content of shader to the console
 * @method KEN.Shader#dump
 */
KEN.Shader.prototype.dump = function()
{
    var _dump = function(source)
    {
        var text = "";
        var lines = source.split("\n");
        for (var i = 0, ii = lines.length; i < ii; i++)
        {
            var line = ("    " + (1 + i)).slice(-4);
            text += line + "  " + lines[i] + "\n";
        }
        return text;
    };

    this.log("Shader dump :: " + this._name);

    this.log("[Uniforms]");
    for (var u in this._uniforms)
    {
        this.log(u + " (t: " + this._uniforms[u]["type"] + ", v: " + this._uniforms[u]["value"]);
    }

    this.log("[Vertex source]");
    this.log(_dump(this._vertex));

    this.log("[Fragment source]");
    this.log(_dump(this._fragment));
};

/**
 * Destroy sequence
 * @method KEN.Shader#destroy
 */
KEN.Shader.prototype.destroy = function()
{
    this._name = "";
    this._uniforms = null;
    this._vertex = null;
    this._fragment = null;
};

/**
 * Shader name.
 * @name KEN.Shader#name
 * @type {string}
 * @readonly
 */
KEN.Shader.prototype.name;
Object.defineProperty(KEN.Shader.prototype, "name",
{
    /** @this {KEN.Shader} */
    get: function()
    {
        return this._name;
    }
});

/**
 * Shader uniforms.
 * @name KEN.Shader#uniforms
 * @type {KENUniform}
 * @readonly
 */
KEN.Shader.prototype.uniforms;
Object.defineProperty(KEN.Shader.prototype, "uniforms",
{
    /** @this {KEN.Shader} */
    get: function()
    {
        return this._uniforms;
    }
});

/**
 * Vertex part of the shader.
 * @name KEN.Shader#vertex
 * @type {string}
 * @readonly
 */
KEN.Shader.prototype.vertex;
Object.defineProperty(KEN.Shader.prototype, "vertex",
{
    /** @this {KEN.Shader} */
    get: function()
    {
        return this._vertex;
    }
});

/**
 * Fragment part of the shader.
 * @name KEN.Shader#fragment
 * @type {string}
 * @readonly
 */
KEN.Shader.prototype.fragment;
Object.defineProperty(KEN.Shader.prototype, "fragment",
{
    /** @this {KEN.Shader} */
    get: function()
    {
        return this._fragment;
    }
});

/**
 * KEN.ShaderFactory
 * Shader factory
 *
 * NB: this namespace contains "private static" methods: it means their names
 * are collapsed on minification.
 *
 * @namespace KEN.ShaderFactory
 * @type {Object}
 */
KEN.ShaderFactory = {};

/**
 * Join an array into a single string
 * @method KEN.ShaderFactory#format
 * @param  {Array} linesArray - The array you want to join into a string
 * @return {string}            [description]
 */
KEN.ShaderFactory.format = function(linesArray)
{
    return linesArray.join("\n");
};

/**
 * Common defines
 * @method  KEN.ShaderFactory#_defines
 * @private
 * @return {string} Returns the common defines
 */
KEN.ShaderFactory._defines = function()
{
    return KEN.ShaderFactory.format([
        "precision highp float;",
        "",
        "#define kpi_2      1.5707963267949",
        "#define kpi        3.14159265359",
        "#define k2pi       6.28318530718"
    ]);
};

/**
 * common shader functions
 * @method  KEN.ShaderFactory#_common
 * @private
 * @return {string}
 */
KEN.ShaderFactory._common = function()
{
    return KEN.ShaderFactory.format([
        /*
        Wrap a value between 2 edges without conditionnal call
        Input: ()
         */
        "float wrap(in float x, in float min, in float max) {",
        "  return x - ((max - min) * (1.0 - step(x, min) - step(x, max)));",
        "}",
        "",

        /*
        Converts 3D point from spherical into cartersian coordinates
        Input: (vec3) rtp spherical coordinates (.x = radius, .y = azimuth, .z = elevation)
        Output: (vec3) cartesian coordinates xyz
        Uniforms: N/A
         */
        "vec3 toCartesian(in vec3 rtp) {",
        "  float r = rtp.x;",
        "  float theta = rtp.y;",
        "  float phi = rtp.z;",
        "  float x = r * cos(phi) * sin(theta);",
        "  float y = r * sin(phi);",
        "  float z = r * cos(phi) * cos(theta);",
        "  return vec3(x,y,z);",
        "}",
        "",

        /*
        Converts 3D point from cartersian into spherical coordinates
        Input: (vec3) cartesian coordinates xyz
        Output: (vec3) rtp spherical coordinates (.x = radius, .y = azimuth, .z = elevation)
        Uniforms: N/A
         */
        "vec3 toSpherical(in vec3 pt) {",
        "  float r = length(pt);",
        "  float theta = -atan(pt.x, pt.z);",
        "  float phi = asin(pt.y / r);",
        "  return vec3(r,theta,phi);",
        "}",
        "",

        /*
        Get fragment in NDC space with ratio
        Input: N/A
        Output: (vec2) fragment in space [-w/h .. w/h, -1 .. 1]
        Uniforms: viewportResolution, screenOffset
         */
        "vec2 getFragment() {",
        "  return (2.0 * gl_FragCoord.xy / tViewportResolution - 1.0) * vec2(tViewportResolutionRatio, 1.0);",
        "}",
        "",

        /*
        Get equirectangular texture coordinates UV from projected point
        Theta equals 0 at center of the equirectangular texture, -pi at left and +pi at right
        Input: (vec2) spherical coordinate of projected point
        Output: (vec2) uv coordinate of texel
         */
        "vec2 toEquirectangularTexCoords(in vec2 thetaphi) {",
        "  thetaphi.x = wrap(thetaphi.x + kpi, -kpi, kpi);",
        "  vec2 texel = 0.5 + thetaphi / vec2(k2pi, kpi);",
        "  return texel;",
        "}"
    ]);
};

/**
 * Shader main routine for Screen to World
 * @method  KEN.ShaderFactory#_mainRoutineSTW
 * @private
 * @return {string}
 */
KEN.ShaderFactory._mainRoutineSTW = function()
{
    return KEN.ShaderFactory.format([
        "void main() {",
        "  vec2 thetaPhi = projection();",
        "  vec2 texCoords = toEquirectangularTexCoords(thetaPhi);",
        "  gl_FragColor = vec4(texture2D(tEquirect, texCoords).rgb, 1.0);",
        "}"
    ]);
};

/**
 * Shader main routine for World to Screen
 * @method KEN.ShaderFactory#_mainRoutineWTS
 * @private
 * @return {string}
 */
KEN.ShaderFactory._mainRoutineWTS = function()
{
    return KEN.ShaderFactory.format([
        "void main() {",
        "  vec2 texCoords = projection();",
        "  gl_FragColor = vec4(texture2D(tEquirect, texCoords).rgb, 1.0);",
        "}"
    ]);
};

/**
 * Default vertex shader
 * @method  KEN.ShaderFactory#_getDefaultVertexShaderCode
 * @private
 * @return {string} Default vertex shader code
 */
KEN.ShaderFactory._getDefaultVertexShaderCode = function()
{
    return KEN.ShaderFactory.format([
        "void main() {",
        "   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
        "}"
    ]);
};

/**
 * Default fragment shader
 * @method  KEN.ShaderFactory#_getDefaultFragmentShaderCode
 * @private
 * @return {string} Default fragment shader code
 */
KEN.ShaderFactory._getDefaultFragmentShaderCode = function()
{
    return KEN.ShaderFactory.format([
        "void main() {",
        "   gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);",
        "}"
    ]);
};

/**
 * Assemble parts of shader into a readable
 * @method  KEN.ShaderFactory#_assemble
 * @private
 * @param  {string|Array<string>} parts shader parts
 * @return {string} shader source
 */
KEN.ShaderFactory._assemble = function(parts)
{
    var source = "";

    if (typeof parts === "string")
    {
        source += "\n" + parts;
    }
    else if (Array.isArray(parts))
    {
        for (var i = 0, ii = parts.length; i < ii; i++)
        {
            var line = parts[i];
            source += (i ? "\n\n" : "") + line;
        }
    }

    return source;
};

KEN.ShaderFactory.buildVertexShader = function(uniforms, projectionShader, projectionDirection)
{
    if (typeof uniforms === "undefined")
    {
        uniforms = "";
    }

    if (typeof projectionShader === "undefined")
    {
        projectionShader = KEN.ShaderFactory._getDefaultVertexShaderCode();
    }

    var shaderContent = [KEN.ShaderFactory._defines(), uniforms];

    if (projectionDirection === KEN.ViewBase.SCREEN_TO_WORLD)
    {
        shaderContent.push(projectionShader);

    }
    else if (projectionDirection === KEN.ViewBase.WORLD_TO_SCREEN)
    {
        shaderContent.push(projectionShader);
    }

    return KEN.ShaderFactory._assemble(shaderContent);
};


KEN.ShaderFactory.buildFragmentShader = function(uniforms, projectionShader, projectionDirection)
{
    if (typeof uniforms === "undefined")
    {
        uniforms = "";
    }

    if (typeof projectionShader === "undefined")
    {
        projectionShader = KEN.ShaderFactory._getDefaultFragmentShaderCode();
    }

    var shaderContent = [KEN.ShaderFactory._defines(), uniforms];

    if (projectionDirection === KEN.ViewBase.SCREEN_TO_WORLD)
    {
        shaderContent.push(KEN.ShaderFactory._common());
        shaderContent.push(projectionShader);
        shaderContent.push(KEN.ShaderFactory._mainRoutineSTW());
    }
    else if (projectionDirection === KEN.ViewBase.WORLD_TO_SCREEN)
    {
        shaderContent.push(projectionShader);
        shaderContent.push(KEN.ShaderFactory._mainRoutineWTS());
    }

    return KEN.ShaderFactory._assemble(shaderContent);
};

KEN.ShaderFactory.mixUniforms = function(vertexUniforms, fragmentUniforms)
{
    return KEN.Utils.extendMultipleObjects(vertexUniforms, fragmentUniforms);
};

/**
 * @namespace {Object} KEN.ViewType
 */
KEN.ViewType = {};

/**
 * @name KEN.ViewType.UNDEFINED
 * @type {string}
 * @const
 */
KEN.ViewType.UNDEFINED = "undefined";

/**
 * @name KEN.ViewType.RECTILINEAR
 * @type {string}
 * @const
 */
KEN.ViewType.RECTILINEAR = "rectilinear";

/**
 * @name KEN.ViewType.GOPRO
 * @type {string}
 * @const
 */
KEN.ViewType.GOPRO = "gopro";

/**
 * Abstract base class for projeted views. Should be subclassed for every supported projection / view type.
 *
 * @constructor KEN.ViewBase
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @param {KEN.Camera} camera - {@link KEN.Camera} reference.
 * @param {string} className - object className.
 * @param {string=} direction - the direction of the projection, can be either KEN.ViewBase.SCREEN_TO_WORLD (default) or KEN.ViewBase.WORLD_TO_SCREEN.
 * @extends {KEN.BaseObject}
 */
KEN.ViewBase = function(viewer, camera, className, direction)
{
    /**
     * The KEN Viewer reference.
     * @name KEN.ViewBase#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The camera associated to the view.
     * @name KEN.ViewBase#_camera
     * @type {KEN.Camera}
     * @private
     */
    this._camera = camera;

    /**
     * The direction of the projection. Can be either KEN.ViewBase.SCREEN_TO_WORLD or KEN.ViewBase.WORLD_TO_SCREEN.
     * @name KEN.ViewBase#_projectionDirection
     * @type {string}
     * @private
     */
    this._projectionDirection = direction || KEN.ViewBase.SCREEN_TO_WORLD;

    /**
     * Screen to World material (texture containing the photo/video).
     * @name KEN.ViewBase#_screenToWorldMaterial
     * @type {THREE.ShaderMaterial}
     * @private
     */
    this._screenToWorldMaterial = null;

    /**
     * Uniforms for the Screen to World view
     * @name KEN.ViewBase#_screenToWorldUniforms
     * @type {Object}
     * @private
     */
    this._screenToWorldUniforms = null;

    /**
     * World to Screen material (texture containing the photo/video).
     * @name KEN.ViewBase#_worldToScreenMaterial
     * @type {THREE.ShaderMaterial}
     * @private
     */
    this._worldToScreenMaterial = null;

    /**
     * Uniforms for the World to Screen view
     * @name KEN.ViewBase#_worldToScreenUniforms
     * @type {Object}
     * @private
     */
    this._worldToScreenUniforms = null;

    KEN.BaseObject.call(this, className || "ViewBase");
};

KEN.ViewBase.prototype = Object.create(KEN.BaseObject.prototype);
KEN.ViewBase.prototype.constructor = KEN.ViewBase;

/**
 * The projection will be in screen to world direction.
 *
 * @type {string}
 * @const
 */
KEN.ViewBase.SCREEN_TO_WORLD = "screen_to_world";

/**
 * The projection will be in world to screen direction.
 *
 * @type {string}
 * @const
 */
KEN.ViewBase.WORLD_TO_SCREEN = "world_to_screen";

/**
 * Boot sequence.
 *
 * @method KEN.ViewBase#_boot
 * @private
 */
KEN.ViewBase.prototype._boot = function()
{

};

/**
 * Get shader object for screen to world projection.
 *
 * @method KEN.ViewBase#_getShaderScreenToWorld
 * @return {KEN.Shader} shader object
 * @private
 */
KEN.ViewBase.prototype._getShaderScreenToWorld = function()
{
    var vertex = KEN.ShaderFactory.buildVertexShader(this._screenToWorldVertexShaderUniforms(),
        this._screenToWorldVertexShaderProjection(), KEN.ViewBase.SCREEN_TO_WORLD);

    var fragment = KEN.ShaderFactory.buildFragmentShader(this._screenToWorldFragmentShaderUniforms(),
        this._screenToWorldFragmentShaderProjection(), KEN.ViewBase.SCREEN_TO_WORLD);

    return new KEN.Shader(this._className + " STW", this._screenToWorldUniforms, vertex, fragment);
};

/**
 * Get shader object for world to screen projection.
 *
 * @method KEN.ViewBase#_getShaderWorldToScreen
 * @return {KEN.Shader} shader object
 * @private
 */
KEN.ViewBase.prototype._getShaderWorldToScreen = function()
{
    var vertex = KEN.ShaderFactory.buildVertexShader(this._worldToScreenVertexShaderUniforms(),
        this._worldToScreenVertexShaderProjection(), KEN.ViewBase.WORLD_TO_SCREEN);

    var fragment = KEN.ShaderFactory.buildFragmentShader(this._worldToScreenFragmentShaderUniforms(),
        this._worldToScreenFragmentShaderProjection(), KEN.ViewBase.WORLD_TO_SCREEN);

    return new KEN.Shader(this._className + " WTS", this._worldToScreenUniforms, vertex, fragment);
};

/**
 * Get material for screen to world projection.
 * Create material if it does not exist.
 *
 * @method KEN.ViewBase#_getMaterialScreenToWorld
 * @return {THREE.ShaderMaterial} material
 * @private
 */
KEN.ViewBase.prototype._getMaterialScreenToWorld = function()
{
    if (this._screenToWorldMaterial !== null)
    {
        return this._screenToWorldMaterial;
    }

    // Get shader from subclass and create material
    var shader = this._getShaderScreenToWorld();

    this._screenToWorldMaterial = new THREE.ShaderMaterial(
    {
        uniforms: shader.uniforms,
        vertexShader: shader["vertex"],
        fragmentShader: shader["fragment"],
        side: THREE.FrontSide
    });

    return this._screenToWorldMaterial;
};

/**
 * Get material for world to screen projection.
 * Create material if it does not exist.
 *
 * @method KEN.ViewBase#_getMaterialWorldToScreen
 * @return {THREE.ShaderMaterial} material
 * @private
 */
KEN.ViewBase.prototype._getMaterialWorldToScreen = function()
{
    if (this._worldToScreenMaterial !== null)
    {
        return this._worldToScreenMaterial;
    }

    // Get shader from subclass and create material
    var shader = this._getShaderWorldToScreen();

    this._worldToScreenMaterial = new THREE.ShaderMaterial(
    {
        uniforms: shader.uniforms,
        vertexShader: shader["vertex"],
        fragmentShader: shader["fragment"],
        side: THREE.FrontSide
    });

    return this._worldToScreenMaterial;
};

/**
 * Compute fragment from a screen point.
 *
 * @method KEN.ViewBase#_screenToFragment
 * @param  {THREE.Vector2} screenPt - Point in screen space
 * @return {THREE.Vector2} Fragment in normalized space
 * @private
 */
KEN.ViewBase.prototype._screenToFragment = function(screenPt)
{
    var uniforms = this["materialScreenToWorld"].uniforms;

    var resolution = uniforms.tViewportResolution["value"];
    var ratio = uniforms.tViewportResolutionRatio["value"];

    var fx = 2.0 * (screenPt.x / resolution.x - 1.0) * ratio;
    var fy = 2.0 * (screenPt.y / resolution.y - 1.0) * ratio;
    return new THREE.Vector2(fx, fy);
};

/**
 * Compute screen point from a fragment.
 *
 * @method KEN.ViewBase#_fragmentToScreen
 * @param {THREE.Vector2} fragment - Fragment in normalized space
 * @return  {THREE.Vector2} Point in screen space
 * @private
 */
KEN.ViewBase.prototype._fragmentToScreen = function(fragment)
{
    var uniforms = this["materialScreenToWorld"].uniforms;

    var resolution = uniforms.tViewportResolution["value"];
    var ratio = uniforms.tViewportResolutionRatio["value"];

    fragment.x = ((fragment.x / ratio) + 1) * (resolution.x / 2);
    fragment.y = ((fragment.y / ratio) + 1) * (resolution.y / 2);
    return new THREE.Vector2(Math.round(fragment.x), resolution.y - Math.round(fragment.y));
};

/*
 * ==================== SCREEN TO WORLD SHADERS ====================
 */

/**
 * Get shader uniforms dictionary for screen to world projection.
 *
 * @method KEN.ViewBase#_screenToWorldVertexShaderUniformsDict
 * @return {Object} Uniforms dictionary to be used
 * @private
 */
KEN.ViewBase.prototype._screenToWorldVertexShaderUniformsDict = function()
{
    return this._screenToWorldUniforms;
};

/**
 * Get vertex shader uniforms declaration for screen to world projection.
 *
 * @method KEN.ViewBase#_screenToWorldVertexShaderUniforms
 * @return {string} Vertex shader uniforms declaration code
 * @private
 */
KEN.ViewBase.prototype._screenToWorldVertexShaderUniforms = function()
{
    return "";
};

/**
 * Get vertex shader code for screen to world projection.
 *
 * @method KEN.ViewBase#_screenToWorldVertexShaderProjection
 * @return {string} Vertex shader projection code
 * @private
 */
KEN.ViewBase.prototype._screenToWorldVertexShaderProjection = function()
{
    return KEN.ShaderFactory.format([
        "void main() {",
        "   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
        "}"
    ]);
};

/**
 * Get fragment shader uniforms dictionary.
 *
 * @method KEN.ViewBase#_screenToWorldFragmentShaderUniformsDict
 * @return {Object} Fragment shader uniforms
 * @private
 */
KEN.ViewBase.prototype._screenToWorldFragmentShaderUniformsDict = function()
{
    return this._screenToWorldUniforms;
};

/**
 * Get fragment shader uniforms declaration for screen to world projection.
 *
 * @method KEN.ViewBase#_screenToWorldFragmentShaderUniforms
 * @return {string} Fragment shader uniforms declaration code
 * @private
 */
KEN.ViewBase.prototype._screenToWorldFragmentShaderUniforms = function()
{
    return "";
};

/**
 * Get fragment shader code for screen to world projection.
 *
 * @method KEN.ViewBase#_screenToWorldFragmentShaderProjection
 * @return {string} Fragment shader projection code
 * @private
 */
KEN.ViewBase.prototype._screenToWorldFragmentShaderProjection = function()
{
    return "";
};

/*
 * ==================== WORLD TO SCREEN SHADERS ====================
 */

/**
 * Get shader uniforms dictionary for world to screen projection.
 *
 * @method KEN.ViewBase#_worldToScreenVertexShaderUniformsDict
 * @return {Object} Uniforms dictionary to be used
 * @private
 */
KEN.ViewBase.prototype._worldToScreenVertexShaderUniformsDict = function()
{
    return this._worldToScreenUniforms;
};

/**
 * Get vertex shader uniforms declaration for world to screen projection.
 *
 * @method KEN.ViewBase#_worldToScreenVertexShaderUniforms
 * @return {string} Vertex shader uniforms declaration code
 * @private
 */
KEN.ViewBase.prototype._worldToScreenVertexShaderUniforms = function()
{
    return "";
};

/**
 * Get vertex shader code for world to screen projection.
 *
 * @method KEN.ViewBase#_worldToScreenVertexShaderProjection
 * @return {string} Vertex shader projection code
 * @private
 */
KEN.ViewBase.prototype._worldToScreenVertexShaderProjection = function()
{
    return KEN.ShaderFactory.format([
        "void main() {",
        "   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
        "}"
    ]);
};

/**
 * Get fragment shader uniforms dictionary.
 *
 * @method KEN.ViewBase#_worldToScreenFragmentShaderUniformsDict
 * @return {Object} Fragment shader uniforms
 * @private
 */
KEN.ViewBase.prototype._worldToScreenFragmentShaderUniformsDict = function()
{
    return this._worldToScreenUniforms;
};

/**
 * Get fragment shader uniforms declaration for world to screen projection.
 *
 * @method KEN.ViewBase#_worldToScreenFragmentShaderUniforms
 * @return {string} Fragment shader uniforms declaration code
 * @private
 */
KEN.ViewBase.prototype._worldToScreenFragmentShaderUniforms = function()
{
    return KEN.ShaderFactory.format([
        "varying vec2 vUv;",
        "uniform sampler2D tTexture;"
    ]);
};

/**
 * Get fragment shader code for world to screen projection.
 *
 * @method KEN.ViewBase#_worldToScreenFragmentShaderProjection
 * @return {string} fragment shader projection code
 * @private
 */
KEN.ViewBase.prototype._worldToScreenFragmentShaderProjection = function()
{
    return "";
};

/*
 * ==============================================
 */

/**
 * Get updated shader params for world to screen projection.
 * Abstract method that should be implemented by subclass.
 *
 * @method KEN.ViewBase#_getUpdatedParamsWorldToScreen
 * @return {Object} Map of uniform params up to date
 * @private
 */
KEN.ViewBase.prototype._getUpdatedParamsWorldToScreen = function()
{
    throw this._className + "::_getUpdatedParamsWorldToScreen not implemented";
};

/**
 * Get updated shader params for screen to world projection.
 * Abstract method that should be implemented by subclass.
 *
 * @method KEN.ViewBase#_getUpdatedParamsScreenToWorld
 * @return {Object} Map of uniform params up to date
 * @private
 */
KEN.ViewBase.prototype._getUpdatedParamsScreenToWorld = function()
{
    throw this._className + "::_getUpdatedParamsScreenToWorld not implemented";
};

/**
 * Update screen to world material.
 *
 * @method KEN.ViewBase#_updateMaterialScreenToWorld
 * @private
 */
KEN.ViewBase.prototype._updateMaterialScreenToWorld = function()
{
    if (this._screenToWorldMaterial === null)
    {
        return;
    }

    // Get subclass view params
    var params = this._getUpdatedParamsScreenToWorld();

    for (var param in params)
    {
        this._screenToWorldMaterial.uniforms[param]["value"] = params[param];
    }
};

/**
 * Update world to screen material.
 *
 * @method KEN.ViewBase#_updateMaterialWorldToScreen
 * @private
 */
KEN.ViewBase.prototype._updateMaterialWorldToScreen = function()
{
    if (this._worldToScreenMaterial === null)
    {
        return;
    }

    // Get subclass view params
    var params = this._getUpdatedParamsWorldToScreen();

    for (var param in params)
    {
        this._worldToScreenMaterial.uniforms[param]["value"] = params[param];
    }
};

/**
 * Convert a point from world space to screen space.
 * Abstract method that should be implemented by subclass.
 *
 * @method KEN.ViewBase#worldToScreen
 * @param {THREE.Vector3} worldPt - Point in world space
 * @param {number} parallax - Parallax factor [0..1]
 * @return {THREE.Vector2} Point in screen coordinates
 * @todo Implement worldToScreen
 */
KEN.ViewBase.prototype.worldToScreen = function(worldPt, parallax)
{
    this.log(worldPt);
    this.log(parallax);
    throw "Please implement " + this._className + "::worldToScreen";
};

/**
 * Convert a point from screen space to world space.
 * Abstract method that should be implemented by subclass.
 * @method KEN.ViewBase#screenToWorld
 * @param {THREE.Vector2} screenPt point in screen space
 * @return {THREE.Vector3}
 * @todo Implement screenToWorld
 */
KEN.ViewBase.prototype.screenToWorld = function(screenPt)
{
    this.log(screenPt);
    throw "Please implement " + this._className + "::screenToWorld";
};

/**
 * Update size (resolution) of material properties
 * @method KEN.ViewBase#setSize
 * @param {KEN.Size} size - display size [px]
 */
KEN.ViewBase.prototype.setSize = function(size)
{
    var material;
    if (this._projectionDirection === KEN.ViewBase.SCREEN_TO_WORLD)
    {
        material = this._getMaterialScreenToWorld();
    }
    else if (this._projectionDirection === KEN.ViewBase.WORLD_TO_SCREEN)
    {
        material = this._getMaterialWorldToScreen();
    }

    material.uniforms.tViewportResolution["value"] = new THREE.Vector2(size["width"], size["height"]);
    material.uniforms.tViewportResolutionRatio["value"] = size["ratio"];
};

/**
 * Destroy method.
 *
 * @method KEN.ViewBase#destroy
 */
KEN.ViewBase.prototype.destroy = function()
{
    this._viewer = null;
    this._camera = null;

    if (this._screenToWorldMaterial !== null)
    {
        for (var u in this._screenToWorldMaterial.uniforms)
        {
            KEN.MaterialManager.releaseUniformValue(this._screenToWorldMaterial.uniforms[u]);
        }
        this._screenToWorldMaterial.dispose();
        this._screenToWorldMaterial = null;
    }

    if (this._worldToScreenMaterial !== null)
    {
        for (var un in this._worldToScreenMaterial.uniforms)
        {
            KEN.MaterialManager.releaseUniformValue(this._worldToScreenMaterial.uniforms[un]);
        }
        this._worldToScreenMaterial.dispose();
        this._worldToScreenMaterial = null;
    }

    this._worldToScreenUniforms = null;
    this._screenToWorldUniforms = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get material used by current view for world to screen projection.
 * @name KEN.ViewBase#materialWorldToScreen
 * @type {THREE.Material}
 * @readonly
 */
KEN.ViewBase.prototype.materialWorldToScreen;
Object.defineProperty(KEN.ViewBase.prototype, "materialWorldToScreen",
{
    /** @this {KEN.ViewBase} */
    get: function()
    {
        var material = this._getMaterialWorldToScreen();
        this._updateMaterialWorldToScreen();
        return material;
    }
});

/**
 * Get material used by current view for world to screen projection.
 * @name KEN.ViewBase#materialScreenToWorld
 * @type {THREE.Material}
 * @readonly
 */
KEN.ViewBase.prototype.materialScreenToWorld;
Object.defineProperty(KEN.ViewBase.prototype, "materialScreenToWorld",
{
    /** @this {KEN.ViewBase} */
    get: function()
    {
        var material = this._getMaterialScreenToWorld();
        this._updateMaterialScreenToWorld();
        return material;
    }
});

/**
 * Get minimum fov for current view [degrees]
 * @name KEN.ViewBase#fovMin
 * @type {number}
 * @readonly
 */
KEN.ViewBase.prototype.fovMin;
Object.defineProperty(KEN.ViewBase.prototype, "fovMin",
{
    /** @this {KEN.ViewBase} */
    get: function()
    {
        return this._camera["fovMin"];
    }
});

/**
 * Get maximum fov for current view [degrees]
 * @name KEN.ViewBase#fovMax
 * @type {number}
 * @readonly
 */
KEN.ViewBase.prototype.fovMax;
Object.defineProperty(KEN.ViewBase.prototype, "fovMax",
{
    /** @this {KEN.ViewBase} */
    get: function()
    {
        return this._camera["fovMax"];
    }
});

/**
 * The direction of the projection.
 * @name KEN.ViewBase#direction
 * @type {string}
 */
KEN.ViewBase.prototype.direction;
Object.defineProperty(KEN.ViewBase.prototype, "direction",
{
    /** @this {KEN.ViewBase} */
    get: function()
    {
        return this._projectionDirection;
    },

    /** @this {KEN.ViewBase} */
    set: function(dir)
    {
        if (dir === KEN.ViewBase.SCREEN_TO_WORLD || dir === KEN.ViewBase.WORLD_TO_SCREEN)
        {
            this._projectionDirection = dir;
        }
    }
});
/**
 * GoPro view class.
 *
 * @constructor KEN.ViewGoPro
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @param {KEN.Camera} camera - {@link KEN.Camera} reference.
 * @extends {KEN.ViewBase}
 */
KEN.ViewGoPro = function(viewer, camera)
{
    KEN.ViewBase.call(this, viewer, camera, "ViewGoPro");

    this._boot();
};

KEN.ViewGoPro.prototype = Object.create(KEN.ViewBase.prototype);
KEN.ViewGoPro.prototype.constructor = KEN.ViewGoPro;

/**
 * Boot sequence.
 *
 * @method KEN.ViewGoPro#_boot
 * @private
 */
KEN.ViewGoPro.prototype._boot = function()
{
    KEN.ViewBase.prototype._boot.call(this);

    this._camera["fovMin"] = 10;
    this._camera["fovMax"] = 290;

    this._worldToScreenUniforms =
    {
        tModelViewMatrix: { type: "m4", value: new THREE.Matrix4() },
        tViewportResolutionRatio: { type: "v2", value: new THREE.Vector2() },
        tProjectionScale: { type: "f", value: 1.0 },
        tEquirect: { type: "t", value: null },
        tTextureInfo: { type: "m4", value: new THREE.Matrix4() }
    };

    this._screenToWorldUniforms =
    {
        tEquirect: { type: "t", value: null },
        tViewportResolution: { type: "v2", value: new THREE.Vector2() },
        tViewportResolutionRatio: { type: "f", value: 1.0 },
        tModelViewMatrixInverse: { type: "m4", value: new THREE.Matrix4() },
        tProjectionScale: { type: "f", value: 1.0 },
        tProjectionDistance: { type: "f", value: 1.0 }
    };
};

/*
 * ==================== SCREEN TO WORLD SHADERS ====================
 */

/**
 * Get fragment shader uniforms for screen to world projection.
 *
 * @method KEN.ViewGoPro#_screenToWorldFragmentShaderUniforms
 * @return {string} Uniforms declaration
 * @private
 */
KEN.ViewGoPro.prototype._screenToWorldFragmentShaderUniforms = function()
{
    return KEN.ShaderFactory.format([
        "uniform sampler2D tEquirect;",
        "uniform vec2 tViewportResolution;",
        "uniform float tViewportResolutionRatio;",
        "uniform mat4 tModelViewMatrixInverse;",
        "uniform float tProjectionDistance;",
        "uniform float tProjectionScale;"
    ]);
};

/**
 * Get fragment shader code for screen to world projection.
 *
 * @method KEN.ViewGoPro#_screenToWorldFragmentShaderProjection
 * @return {string} Fragment shader code
 * @private
 */
KEN.ViewGoPro.prototype._screenToWorldFragmentShaderProjection = function()
{
    return KEN.ShaderFactory.format([
        "vec2 projection() {",
        "  vec2 frag = getFragment();",
        "  vec2 c = tProjectionScale * frag;",
        "  float zs = tProjectionDistance;",
        "  float xy2 = dot(c,c);",
        "  float zs12 = (zs+1.0)*(zs+1.0);",
        "  float delta = 4.0*(zs*zs*xy2*xy2 - (xy2+zs12)*(xy2*zs*zs-zs12));",
        "  if (delta < 0.0) {return vec2(-1.);}",
        "  float z = (2.0*zs*xy2 - sqrt(delta)) / (2.0 * (zs12 + xy2));",
        "  float x = c.x * ((zs-z) / (zs+1.0));",
        "  float y = c.y * ((zs-z) / (zs+1.0));",
        "  vec3 vx = vec3(tModelViewMatrixInverse * vec4(x, y, z, 1.0));",
        "  return toSpherical(vx).yz;",
        "}"
    ]);
};

/**
 * Get updated screen to world projection shader parameters.
 *
 * @method KEN.ViewGoPro#_getUpdatedParamsScreenToWorld
 * @return {Object} Uniforms
 * @private
 */
KEN.ViewGoPro.prototype._getUpdatedParamsScreenToWorld = function()
{
    var fovLow = 60;
    var fovHigh = 180;
    var distance;

    var fov = KEN.Math.clamp(this._camera["fov"], this._camera["fovMin"], this._camera["fovMax"]);

    if (fov < fovLow)
    {
        distance = 0;
    }
    else if (fov > fovHigh)
    {
        distance = 1;
    }
    else
    {
        var deltaFov = fovHigh - fovLow;
        var tn = (fov - fovLow) / deltaFov;

        // Apply sinus in out interpolation to smooth the transition
        distance = 0.5 * (1.0 + Math.sin(Math.PI / 2.0 * (2.0 * tn - 1.0)));
    }

    var f = Math.PI * fov / 360;
    var scale = (distance + 1) * Math.sin(f) / (distance - Math.cos(Math.PI - f));

    var result =
    {
        tModelViewMatrixInverse: this._camera["modelViewInverse"],
        tProjectionDistance: distance,
        tProjectionScale: scale
    };

    return result;
};

/*
 * ==================== WORLD TO SCREEN SHADERS ====================
 */

/**
 * Get fragment shader uniforms for world to screen projection.
 *
 * @method KEN.ViewGoPro#_worldToScreenFragmentShaderUniforms
 * @return {string} Uniforms declaration
 * @private
 */
KEN.ViewGoPro.prototype._worldToScreenFragmentShaderUniforms = function()
{
    return KEN.ShaderFactory.format([
        "varying vec2 vUv;",
        "varying vec3 vPosition;",
        "",
        "uniform sampler2D tEquirect;",
        "uniform mat4 tTextureInfo;"
    ]);
};

/**
 * Get fragment shader code for world to screen projection.
 *
 * @method KEN.ViewGoPro#_worldToScreenFragmentShaderProjection
 * @return {string} Fragment shader code
 * @private
 */
KEN.ViewGoPro.prototype._worldToScreenFragmentShaderProjection = function()
{
    return KEN.ShaderFactory.format([
        "vec2 projection() {",
        "  vec2 tc = vUv / vec2(tTextureInfo[0][0], tTextureInfo[0][1]);",
        "  tc += vPosition.x == tTextureInfo[0][2] ? vec2(tTextureInfo[1][0], tTextureInfo[1][1])", // LEFT
        "      : vPosition.x == tTextureInfo[0][3] ? vec2(tTextureInfo[1][2], tTextureInfo[1][3])", // RIGHT
        "      : vPosition.z == tTextureInfo[0][2] ? vec2(tTextureInfo[2][0], tTextureInfo[2][1])", // FRONT
        "      : vPosition.z == tTextureInfo[0][3] ? vec2(tTextureInfo[2][2], tTextureInfo[2][3])", // BACK
        "      : vPosition.y == tTextureInfo[0][2] ? vec2(tTextureInfo[3][0], tTextureInfo[3][1])", // UP
        "      : vec2(tTextureInfo[3][2], tTextureInfo[3][3]);", // DOWN
        "  return tc;",
        "}"
    ]);
};

/**
 * Get vertex shader uniforms for world to screen projection.
 *
 * @method KEN.ViewGoPro#_worldToScreenVertexShaderUniforms
 * @return {string} Uniforms declaration
 * @private
 */
KEN.ViewGoPro.prototype._worldToScreenVertexShaderUniforms = function()
{
    return KEN.ShaderFactory.format([
        "varying vec2 vUv;",
        "varying vec3 vPosition;",
        "",
        "uniform mat4 tModelViewMatrix;",
        "uniform vec2 tViewportResolutionRatio;",
        "uniform float tProjectionScale;"
    ]);
};

/**
 * Get vertex shader code for world to screen projection.
 *
 * @method KEN.ViewBase#_worldToScreenVertexShaderProjection
 * @return {string} vertex shader projection code
 * @private
 */
KEN.ViewGoPro.prototype._worldToScreenVertexShaderProjection = function()
{
    return KEN.ShaderFactory.format([
        "void main() {",
        "  vUv = uv;",
        "  vPosition = vec3(-position.x, position.yz);",
        "  vec4 camPt = normalize(tModelViewMatrix * vec4(vPosition, 1.0));",
        "  vec2 pt = tProjectionScale * camPt.xy * tViewportResolutionRatio.yx;",
        "  gl_Position =  vec4(vec3(2.0 * pt / (1.0 - camPt.z), length(camPt.xy)), 1.0);",
        "}"
    ]);
};

/**
 * Get updated world to screen projection shader parameters.
 *
 * @method KEN.ViewGoPro#_getUpdatedParamsWorldToScreen
 * @return {Object}
 * @private
 */
KEN.ViewGoPro.prototype._getUpdatedParamsWorldToScreen = function()
{
    var fovLow = 60;
    var fovHigh = 180;
    var distance;

    var fov = KEN.Math.clamp(this._camera["fov"], this._camera["fovMin"], this._camera["fovMax"]);

    if (fov < fovLow)
    {
        distance = 0;
    }
    else if (fov > fovHigh)
    {
        distance = 1;
    }
    else
    {
        var deltaFov = fovHigh - fovLow;
        var tn = (fov - fovLow) / deltaFov;

        // Apply sinus in out interpolation to smooth the transition
        distance = 0.5 * (1.0 + Math.sin(Math.PI / 2.0 * (2.0 * tn - 1.0)));
    }

    var f = Math.PI * fov / 360;
    var scale = (distance + 1) * Math.sin(f) / (distance - Math.cos(Math.PI - f));

    var result =
    {
        tModelViewMatrix: this._camera["modelView"],
        tProjectionScale: 1 / scale
    };

    return result;
};

/**
 * Destroy method.
 *
 * @method KEN.ViewGoPro#destroy
 */
KEN.ViewGoPro.prototype.destroy = function()
{
    KEN.ViewBase.prototype.destroy.call(this);
};
/**
 * Rectilinear view class.
 *
 * @constructor KEN.ViewRectilinear
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @param {KEN.Camera} camera - {@link KEN.Camera} reference.
 * @param {string=} direction - the direction of the projection, can be either KEN.ViewBase.SCREEN_TO_WORLD (default) or KEN.ViewBase.WORLD_TO_SCREEN.
 * @extends {KEN.ViewBase}
 */
KEN.ViewRectilinear = function(viewer, camera, direction)
{
    KEN.ViewBase.call(this, viewer, camera, "ViewRectilinear", direction);

    this._boot();
};

KEN.ViewRectilinear.prototype = Object.create(KEN.ViewBase.prototype);
KEN.ViewRectilinear.prototype.constructor = KEN.ViewRectilinear;

/**
 * Boot sequence.
 *
 * @method KEN.ViewRectilinear#_boot
 * @private
 */
KEN.ViewRectilinear.prototype._boot = function()
{
    KEN.ViewBase.prototype._boot.call(this);

    this._camera["fovMin"] = 10;
    this._camera["fovMax"] = 170;

    this._worldToScreenUniforms =
    {
        tModelViewMatrix: { type: "m4", value: new THREE.Matrix4() },
        tViewportResolutionRatio: { type: "v2", value: new THREE.Vector2() },
        tProjectionScale: { type: "f", value: 1.0 },
        tEquirect: { type: "t", value: null },
        tTextureInfo: { type: "m4", value: new THREE.Matrix4() }
    };

    this._screenToWorldUniforms =
    {
        tEquirect: { type: "t", value: null },
        tViewportResolution: { type: "v2", value: new THREE.Vector2() },
        tViewportResolutionRatio: { type: "f", value: 1.0 },
        tModelViewMatrixInverse: { type: "m4", value: new THREE.Matrix4() },
        tProjectionScale: { type: "f", value: 1.0 }
    };
};

/*
 * ==================== SCREEN TO WORLD SHADERS ====================
 */

/**
 * Get shader uniforms for screen to world projection.
 *
 * @method KEN.ViewRectilinear#_screenToWorldFragmentShaderUniforms
 * @return {string} Uniforms declaration
 * @private
 */
KEN.ViewRectilinear.prototype._screenToWorldFragmentShaderUniforms = function()
{
    return KEN.ShaderFactory.format([
        "uniform sampler2D tEquirect;",
        "uniform vec2 tViewportResolution;",
        "uniform float tViewportResolutionRatio;",
        "uniform mat4 tModelViewMatrixInverse;",
        "uniform float tProjectionScale;"
    ]);
};

/**
 * Get fragment shader code for screen to world projection.
 *
 * @method KEN.ViewRectilinear#_screenToWorldFragmentShaderProjection
 * @return {string} Fragment shader code
 * @private
 */
KEN.ViewRectilinear.prototype._screenToWorldFragmentShaderProjection = function()
{
    return KEN.ShaderFactory.format([
        "vec2 projection() {",
        // [-1 .. 1 , -1 .. 1]
        "  vec2 frag = tProjectionScale * getFragment();",

        // Camera point is in plane zn, express it in clip space
        "  vec4 cameraPT = vec4(frag, -1.0, 0.0);",

        // World space point
        "  vec4 worldPT = tModelViewMatrixInverse * cameraPT;",

        // Spherical point for texture lookup
        "  return toSpherical(worldPT.xyz).yz;",
        "}"
    ]);
};

/**
 * Update shader params and return object with updated values.
 *
 * @method KEN.ViewRectilinear#_getUpdatedParamsScreenToWorld
 * @return {Object} Object with updated values
 * @private
 */
KEN.ViewRectilinear.prototype._getUpdatedParamsScreenToWorld = function()
{
    // this.log("ViewRectilinear _getUpdatedParamsScreenToWorld");
    var fov = KEN.Math.clamp(this._camera["fov"], this._camera["fovMin"], this._camera["fovMax"]);

    var result =
    {
        tModelViewMatrixInverse: this._camera["modelViewInverse"],
        tProjectionScale: Math.tan(KEN.Math.degToRad(fov / 2))
    };

    return result;
};

/*
 * ==================== WORLD TO SCREEN SHADERS ====================
 */

/**
 * Get shader uniforms for world to screen projection.
 *
 * @method KEN.ViewRectilinear#_worldToScreenFragmentShaderUniforms
 * @return {string} Uniforms declaration
 * @private
 */
KEN.ViewRectilinear.prototype._worldToScreenFragmentShaderUniforms = function()
{
    return KEN.ShaderFactory.format([
        "varying vec2 vUv;",
        "varying vec3 vPosition;",
        "",
        "uniform sampler2D tEquirect;",
        "uniform mat4 tTextureInfo;"
    ]);
};

/**
 * Get fragment shader code for world to screen projection.
 *
 * @method KEN.ViewGoPro#_worldToScreenFragmentShaderProjection
 * @return {string} Fragment shader code
 * @private
 */
KEN.ViewRectilinear.prototype._worldToScreenFragmentShaderProjection = function()
{
    return KEN.ShaderFactory.format([
        "vec2 projection() {",
        "  vec2 tc = vUv / vec2(tTextureInfo[0][0], tTextureInfo[0][1]);",
        "  tc += vPosition.x == tTextureInfo[0][2] ? vec2(tTextureInfo[1][0], tTextureInfo[1][1])", // LEFT
        "      : vPosition.x == tTextureInfo[0][3] ? vec2(tTextureInfo[1][2], tTextureInfo[1][3])", // RIGHT
        "      : vPosition.z == tTextureInfo[0][2] ? vec2(tTextureInfo[2][0], tTextureInfo[2][1])", // FRONT
        "      : vPosition.z == tTextureInfo[0][3] ? vec2(tTextureInfo[2][2], tTextureInfo[2][3])", // BACK
        "      : vPosition.y == tTextureInfo[0][2] ? vec2(tTextureInfo[3][0], tTextureInfo[3][1])", // UP
        "      : vec2(tTextureInfo[3][2], tTextureInfo[3][3]);", // DOWN
        "  return tc;",
        "}"
    ]);
};

/**
 * Get vertex shader uniforms for world to screen projection.
 *
 * @method KEN.ViewRectilinear#_worldToScreenVertexShaderUniforms
 * @return {string} Uniforms declaration
 * @private
 */
KEN.ViewRectilinear.prototype._worldToScreenVertexShaderUniforms = function()
{
    return KEN.ShaderFactory.format([
        "varying vec2 vUv;",
        "varying vec3 vPosition;",
        "",
        "uniform mat4 tModelViewMatrix;",
        "uniform vec2 tViewportResolutionRatio;",
        "uniform float tProjectionScale;"
    ]);
};

/**
 * Get vertex shader code for world to screen projection.
 *
 * @method KEN.ViewBase#_worldToScreenVertexShaderProjection
 * @return {string} vertex shader projection code
 * @private
 */
KEN.ViewRectilinear.prototype._worldToScreenVertexShaderProjection = function()
{
    return KEN.ShaderFactory.format([
        "void main() {",
        "  vUv = uv;",
        "  vPosition = vec3(- position.x, position.yz);",
        "  mat4 scaledProj = projectionMatrix;",
        "  scaledProj[0][0] = tProjectionScale * tViewportResolutionRatio.y;",
        "  scaledProj[1][1] = tProjectionScale * tViewportResolutionRatio.x;",
        "  gl_Position = scaledProj * tModelViewMatrix * vec4( vPosition, 1.0 );",
        "}"
    ]);
};

/**
 * Update shader params and return object with updated values.
 *
 * @method KEN.ViewBase#_getUpdatedParamsWorldToScreen
 * @return {Object} Object with updated values
 * @private
 */
KEN.ViewRectilinear.prototype._getUpdatedParamsWorldToScreen = function()
{
    var fov = KEN.Math.clamp(this._camera["fov"], this._camera["fovMin"], this._camera["fovMax"]);

    var result =
    {
        tModelViewMatrix: this._camera["modelView"],
        tProjectionScale: 1 / Math.tan(KEN.Math.degToRad(fov / 2))
    };

    return result;
};

/*
 * =================================================================
 */

/**
 * Convert a point from world space to screen space.
 *
 * @method KEN.ViewRectilinear#worldToScreen
 * @param {THREE.Vector3} worldPt - 3D point in world space
 * @param {number} parallaxFactor - parallax factor [0..1]
 * @return {THREE.Vector2} point in screen coordinates
 */
KEN.ViewRectilinear.prototype.worldToScreen = function(worldPt, parallaxFactor)
{
    parallaxFactor = parallaxFactor || 0;

    // Get point projected on unit sphere and apply camera rotation
    var worldPt4 = new THREE.Vector4(worldPt.x, worldPt.y, worldPt.z, 1.0);

    // Apply reversed rotation
    var camEuler = KEN.Math.rotationMatrixToEuler(this._camera["modelView"]);
    var rotation = KEN.Math.eulerToRotationMatrix(camEuler["yaw"], camEuler["pitch"], camEuler["roll"], true);
    rotation = rotation.transpose();
    worldPt4.applyMatrix4(rotation);

    if (worldPt4.z < 0)
    {
        return new THREE.Vector2(Infinity, Infinity);
    }

    // Project on zn plane by dividing x,y components by -z
    var projScale = Math.max(Number.EPSILON, worldPt4.z);
    var znPt = new THREE.Vector2(worldPt4.x, worldPt4.y).divideScalar(projScale);

    // Apply fov scaling
    var scale = this["materialScreenToWorld"].uniforms.tProjectionScale["value"];
    znPt.x /= (1 + parallaxFactor) * scale;
    znPt.y /= scale;

    // Return fragment
    return this._fragmentToScreen(znPt);
};

/**
 * Convert a point from screen space to world space.
 *
 * @method KEN.ViewRectilinear#screenToWorld
 * @param {THREE.Vector2} screenPt - 2D point in screen space [0..w, 0..h]
 * @return {THREE.Vector3} world point
 */
KEN.ViewRectilinear.prototype.screenToWorld = function(screenPt)
{
    var uniforms = this["materialScreenToWorld"].uniforms;
    var scale = uniforms.tProjectionScale["value"];

    var fragment = this._screenToFragment(screenPt);
    fragment.multiplyScalar(scale);

    var cameraPt = new THREE.Vector4(fragment.x, fragment.y, -1, 0);

    var worldPt = cameraPt.applyMatrix4(this._camera["modelViewInverse"]).normalize();

    return new THREE.Vector3(worldPt.x, worldPt.y, worldPt.z);
};

/**
 * Destroy method.
 *
 * @method KEN.ViewRectilinear#destroy
 */
KEN.ViewRectilinear.prototype.destroy = function()
{
    KEN.ViewBase.prototype.destroy.call(this);
};



/**
 * The KEN.HotspotManager is an object that manages hotspots styles and actions for the tour.
 *
 * @constructor KEN.HotspotManager
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @extends {KEN.BaseObject}
 */
KEN.HotspotManager = function(viewer)
{
    /**
     * The viewer reference.
     * @name KEN.HotspotManager#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The general config backup.
     * @name KEN.HotspotManager#_config
     * @type {Object}
     * @private
     */
    this._config = null;

    /**
     * Hotspots array
     * @name  KEN.HotspotManager#_hotspots
     * @type {Array<KEN.Hotspot3D>}
     * @private
     */
    this._hotspots = [];

    KEN.BaseObject.call(this, "HotspotManager");

};

KEN.HotspotManager.prototype = Object.create(KEN.BaseObject.prototype);
KEN.HotspotManager.prototype.constructor = KEN.HotspotManager;

/**
 * Parse a hotspots config object.
 * @method KEN.HotspotManager#_parseConfig
 * @private
 * @param {Array<HotspotConfig>} config - The array of hotspot config you want to parse.
 */
KEN.HotspotManager.prototype._parseConfig = function(config)
{
    for(var i = 0, ii = config.length; i < ii; i++)
    {
        this._createHotspot(config[i]);
    }
};

/**
 * Create a hotspot from a hotpsot config object.
 * @method KEN.HotspotManager#_createHotspot
 * @private
 * @param {HotspotConfig} config - The config of the hotspot you want to create.
 */
KEN.HotspotManager.prototype._createHotspot = function(config)
{
    var hotspot = null;

    switch(config["type"])
    {
        case KEN.HotspotType.THREE_DIMENSIONAL:
            hotspot = new KEN.Hotspot3D(this._viewer, config);
            break;
    }

    if(hotspot !== null)
    {
        this._hotspots.push(hotspot);
    }
};

/**
 * Check if all hotspots are ready
 * @method KEN.HotspotManager#_checkHotspotsReady
 * @return boolean true if all hotspots are ready, false otherwise
 * @private
 */
KEN.HotspotManager.prototype._checkHotspotsReady = function()
{
    for (var i = 0, ii = this._hotspots.length; i < ii; i++)
    {
        var hotspot = this._hotspots[i];

        if (hotspot["ready"] === false)
        {
            return false;
        }
    }

    return true;
};

/**
 * Event handler for scene load start.
 * @method  KEN.HotspotManager#_sceneLoadStartHandler
 * @private
 */
KEN.HotspotManager.prototype._sceneLoadStartHandler = function()
{
    var scene = this._viewer["tour"]["scene"];
    scene["onUnloadStart"].addOnce(this._sceneUnloadStartHandler, this);

    if(typeof scene["config"]["hotspots"] !== "undefined")
    {
        var hotspots = scene["config"]["hotspots"];
        this.addConfig(hotspots);
    }
};

/**
 * Event handler for scene unload start.
 * @method  KEN.HotspotManager#_sceneUnloadStartHandler
 * @private
 */
KEN.HotspotManager.prototype._sceneUnloadStartHandler = function()
{
    this.clear();
};

/**
 * Boot sequence.
 * @method KEN.HotspotManager#boot
 */
KEN.HotspotManager.prototype.boot = function()
{
    this._config = [];

    this._viewer["tour"]["onSceneLoadStart"].add(this._sceneLoadStartHandler, this);
};

/**
 * Get hotspots by type
 * @method  KEN.HotspotManager#getByType
 * @param  {string} type - The type of hotspots you want to get.
 * @return {Array<KEN.Hotspot3D>}
 */
KEN.HotspotManager.prototype.getByType = function(type)
{
    var result = this._hotspots.filter(function(hotspot)
    {
        return hotspot["type"] === type;
    });

    return result;
};

/**
 * Add a hotspots config to the manager.
 * @method KEN.HotspotManager#addConfig
 * @param {Array<HotspotConfig>} config - The config you want to add.
 */
KEN.HotspotManager.prototype.addConfig = function(config)
{
    this._parseConfig(config);
};

/**
 * Update loop
 * @method KEN.HotspotManager#update
 */
KEN.HotspotManager.prototype.update = function()
{
    for(var i = 0, ii = this._hotspots.length; i < ii; i++)
    {
        this._hotspots[i].update();
    }
};

/**
 * Clear all hotspots from the manager
 * @method KEN.HotspotManager#clear
 */
KEN.HotspotManager.prototype.clear = function()
{
    var count = this._hotspots.length;
    while(count--)
    {
        var hs = this._hotspots.pop();
        hs.destroy();
    }
};

/**
 * Destroy sequence
 * @method KEN.HotspotManager#destroy
 */
KEN.HotspotManager.prototype.destroy = function()
{
    this.clear();

    this._viewer = null;
    this._hotspots = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get all the hotspots.
 * @name KEN.HotspotManager#all
 * @readonly
 * @type {Array<KEN.Hotspot3D>}
 */
KEN.HotspotManager.prototype.all;
Object.defineProperty(KEN.HotspotManager.prototype, "all",
{
    /** @this {KEN.HotspotManager} */
    get: function()
    {
        return this._hotspots;
    }
});

/**
 * Get the hotspots count.
 * @name KEN.HotspotManager#count
 * @readonly
 * @type {number}
 */
KEN.HotspotManager.prototype.count;
Object.defineProperty(KEN.HotspotManager.prototype, "count",
{
    /** @this {KEN.HotspotManager} */
    get: function()
    {
        return this._hotspots;
    }
});

/**
 * KEN.Hotspot3D
 * Abstract base class for projeted views. Should be subclassed for every supported projection / view type.
 *
 * @constructor KEN.Hotspot3D
 * @param {KEN.Viewer} viewer - viewer reference
 * @param {HotspotConfig} config - hostspot configuration
 * @extends {KEN.Object3D}
 *
 * @todo Review/refactor all the raycasting and click part
 */
KEN.Hotspot3D = function(viewer, config)
{
    /**
     * Hotspot configuration
     * @name  KEN.Hotspot3D#_config
     * @type {HotspotConfig}
     * @private
     */
    this._config = config;

    /**
     * Name
     * @name  KEN.Hotspot3D#_name
     * @type {string}
     * @private
     */
    this._name = "";

    /**
     * HotspotTransform object for the 3D object.
     * @name  KEN.Hotspot3D#_transform
     * @type {KEN.HotspotTransform}
     * @private
     */
    this._transform = null;

    /**
     * Material object for the 3D object.
     * @name  KEN.Hotspot3D#_material
     * @type {KEN.HotspotMaterial}
     * @private
     */
    this._material = null;

    /**
     * Sound object for the 3D object.
     * @name  KEN.Hotspot3D#_sound
     * @type {KEN.HotspotSound}
     * @private
     */
    this._sound = null;


    KEN.Object3D.call(this, viewer, "Hotspot3D");
};

KEN.Hotspot3D.prototype = Object.create(KEN.Object3D.prototype);
KEN.Hotspot3D.prototype.constructor = KEN.Hotspot3D;

/**
 * Boot sequence.<br>
 * Call superclass boot when objects are created as it will trigger parse config
 * @private
 */
KEN.Hotspot3D.prototype._boot = function()
{
    KEN.Object3D.prototype._boot.call(this);

    this._transform = new KEN.HotspotTransform();
    this._material = new KEN.HotspotMaterial(this._viewer);

    if (typeof this._config !== "undefined" && this._config !== null)
    {
        this._parseConfig(this._config);
    }
};

/**
 * Parse the config object.
 * @method KEN.Hotspot3D#_parseConfig
 * @param {HotspotConfig} config - The hotspot config to parse.
 * @private
 */
KEN.Hotspot3D.prototype._parseConfig = function(config)
{
    this._uid = config["uid"];
    this._tags = config["tags"];
    this._register();

    this._type = config["type"];
    this._name = config["name"];
    this._visible = config["visible"];

    if (typeof config.transform !== "undefined")
    {
        this._transform.load(config.transform);
    }

    this._material["onReady"].addOnce(this._materialReadyHandler, this);

    var materialConfig;

    if (typeof config["material"] !== "undefined")
    {
        materialConfig = /** @type {HotspotMaterialConfig} */ config["material"];
    }
    else
    {
        materialConfig = /** @type {HotspotMaterialConfig} */ KEN.HotspotMaterial.presets.TRANSPARENT;
    }

    if (this._debug === true)
    {
        materialConfig = /** @type {HotspotMaterialConfig} */ KEN.Utils.extendMultipleObjects(materialConfig, KEN.HotspotMaterial.presets.DEBUG);
    }

    this._material.load(materialConfig);

    if (typeof config["sound"] !== "undefined")
    {
        this._sound = new KEN.HotspotSound(this._viewer);
        this._sound.load(config["sound"], config.transform);
    }

    if(typeof config["fx"] === "string")
    {
        this._fx = config["fx"];
    }

    if(typeof config["events"] === "object")
    {
        this._createEvents(config["events"]);
    }
};

/**
 * Event handler for material ready. Triggers the creation of the hotspot3D.
 * @method KEN.Hotspot3D#_materialReadyHandler
 * @private
 */
KEN.Hotspot3D.prototype._materialReadyHandler = function()
{
    this._transform.computeSizeFromAnglesAndMaterial(this._material);

    this._createHotspot3D();
};

/**
 * Final init step once setup is done.
 * @method KEN.Hotspot3D#_setupDoneCallback
 * @private
 */
KEN.Hotspot3D.prototype._createHotspot3D = function()
{
    this._mesh.geometry = new THREE.PlaneGeometry(this._transform["size"]["width"], this._transform["size"]["height"], 2);
    this._mesh["material"] = this._material["material"];
    this._mesh.userData = this._config;

    this._updatePosition();

    this._ready = true;

    if (this._onReady !== null)
    {
        this._onReady.dispatch();
    }
};

/**
 * Setup hotspot spatial position.
 * @method KEN.Hotspot3D#_setupPosition
 * @private
 */
KEN.Hotspot3D.prototype._updatePosition = function()
{
    // inverse theta angle
    var theta = KEN.Math.wrap(Math.PI - KEN.Math.degToRad(this._transform["position"].theta), -Math.PI, Math.PI);
    var phi = KEN.Math.degToRad(this._transform["position"].phi);

    var radius = this._transform["position"].radius;

    // Adjust radius if there is some parallax set in the camera
    radius += this._viewer["renderer"]["camera"]["parallax"] * KEN.Camera.RADIUS;

    var position = KEN.Utils.toTHREESpherical(radius, theta, phi);
    this._mesh["position"].copy(new THREE.Vector3().setFromSpherical(position));

    // Apply rotation
    var rx = -KEN.Math.degToRad(this._transform["rotation"].x); // pitch
    var ry = KEN.Math.degToRad(this._transform["rotation"].y); // yaw
    var rz = KEN.Math.degToRad(this._transform["rotation"].z);
    this._mesh.rotateY(ry).rotateX(rx).rotateZ(rz);
};



/**
 * Update hotspot content
 * @method KEN.Hotspot3D#update
 */
KEN.Hotspot3D.prototype.update = function()
{
    if (this._material !== null)
    {
        this._material.update();
    }

    if (this._sound !== null)
    {
        this._sound.update();
    }
};

/**
 * Destroy routine
 * @method KEN.Hotspot3D#destroy
 */
KEN.Hotspot3D.prototype.destroy = function()
{
    if(this._transform !== null)
    {
        this._transform.destroy();
        this._transform = null;
    }

    if (this._material !== null)
    {
        this._material.destroy();
        this._material = null;
    }

    if (this._sound !== null)
    {
        this._sound.destroy();
        this._sound = null;
    }

    KEN.Object3D.prototype.destroy.call(this);
};

/**
 * Hotspot type accessor
 * @name KEN.Hotspot3D#visible
 * @readonly
 * @type {string}
 */
KEN.Hotspot3D.prototype.type;
Object.defineProperty(KEN.Hotspot3D.prototype, "type",
{
    /** @this {KEN.Hotspot3D} */
    get: function()
    {
        return this._type;
    }
});

/**
 * Hotspot name accessor
 * @name KEN.Hotspot3D#name
 * @readonly
 * @type {string}
  */
KEN.Hotspot3D.prototype.name;
Object.defineProperty(KEN.Hotspot3D.prototype, "name",
{
    /** @this {KEN.Hotspot3D} */
    get: function()
    {
        return this._name;
    }
});


/**
 * Hotspot sound handles the parse of the sound config and the loading of the needed sound ressource.
 *
 * @constructor KEN.HotspotSound
 * @param {KEN.Viewer} viewer - The viewer reference.
 * @extends {KEN.BaseObject}
 */
KEN.HotspotSound = function(viewer)
{
    /**
     * Viewer reference.
     * @name  KEN.HotspotSound#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Sound input type.<br>
     * Can be one of the values listed in KEN.HotspotSound.types
     * @name  KEN.HotspotSound#_type
     * @type {string}
     * @private
     */
    this._type = "";

    /**
     * The onReady event dispatcher.
     * @name  KEN.HotspotSound#_onReady
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onReady = null;

    /**
     * World position
     * @name KEN.HotspotSound#_positionWorld
     * @type {THREE.Vector3}
     * @private
     */
    this._positionWorld = null;

    /**
     * The KEN.Sound object
     * @name KEN.HotspotSound#_sound
     * @type {KEN.Sound}
     * @private
     */
    this._sound = null;

    /**
     * Is the sound out of bounds?
     * @name KEN.HotspotSound#_outOfBounds
     * @type {boolean}
     * @private
     */
    this._outOfBounds = false;

    /**
     * The sound hotspot base volume.
     * @name  KEN.HotspotSound#_baseVolume
     * @type {number}
     * @private
     */
    this._baseVolume = 1;

    /**
     * Is sound looped?
     * @name KEN.HotspotSound#_loop
     * @type {boolean}
     * @private
     */
    this._loop = false;

    /**
     * Start time for the sound.
     * @name  KEN.HotspotSound#_startTime
     * @type {number}
     * @private
     */
    this._startTime = 0;

    /**
     * Is sound auto started?
     * @name  KEN.HotspotSound#_autoPlay
     * @type {boolean}
     * @private
     */
    this._autoPlay = false;

    /**
     * The theta/phi position of the sound.
     * @name  KEN.HotspotSound#_position
     * @type {?HotspotTransformPositionConfig}
     * @private
     *
     * @todo Use the HotspotTransformPosition object of the HotspotTransform class?
     */
    this._position = { radius: 200, theta: 0, phi: 0 };

    /**
     * Is the sound must be muted when out of the camera Fov?<br>
     * Related to spatilized sound.
     * @name  KEN.HotspotSound#_muteOutOfFov
     * @type {boolean}
     * @private
     */
    this._muteOutOfFov = false;

    /**
     * Is the sound must be fade out when out of the camera Fov?<br>
     * Related to spatilized sound.
     * @name  KEN.HotspotSound#_fadeOutOfFov
     * @type {boolean}
     * @private
     */
    this._fadeOutOfFov = false;

    /**
     * Fade in/out time?<br>
     * Related to spatilized sound.
     * @name  KEN.HotspotSound#_fadeTimeOutOfFov
     * @type {number}
     * @private
     */
    this._fadeTimeOutOfFov = 0;

    /**
     * Fade out minimum volume.<br>
     * Related to spatilized sound.
     * @name  KEN.HotspotSound#_fadeVolumeOutOfFov
     * @type {number}
     * @private
     */
    this._fadeVolumeOutOfFov = 0;


    /**
     * The range in degrees where sound can be played from it's position.<br>
     * Related to spatilized sound.
     * @name  KEN.HotspotSound#_coneRange
     * @type {number}
     * @default
     * @private
     */
    this._coneRange = 360;

    KEN.BaseObject.call(this, "HotspotSound");
};

KEN.HotspotSound.prototype = Object.create(KEN.BaseObject.prototype);
KEN.HotspotSound.prototype.constructor = KEN.HotspotSound;

/**
 * Sound input type list.
 * @name KEN.HotspotSound.types
 * @type {Object}
 * @const
 */
KEN.HotspotSound.types = {};

/**
 * @name KEN.HotspotSound.types.STEREO
 * @type {string}
 * @const
 */
KEN.HotspotSound.types.STEREO = "2d";

/**
 * @name KEN.HotspotSound.types.SPATIAL
 * @type {string}
 * @const
 */
KEN.HotspotSound.types.SPATIAL = "3d";

/**
 * @name KEN.HotspotSound.DEFAULT_RAMP_TIME
 * @type {number}
 * @const
 */
KEN.HotspotSound.DEFAULT_RAMP_TIME = 0.5;

/**
 * Parse the configuration object.
 * @method KEN.HotspotSound#_parseConfig
 * @param {HotspotSoundConfig} configSound - The configuration object of the sound.
 * @param {HotspotTransformConfig} configTransform - The transform configuration object.
 * @private
 */
KEN.HotspotSound.prototype._parseConfig = function(configSound, configTransform)
{
    if(typeof configSound["url"] === "undefined" || configSound["url"] === "")
    {
        return;
    }

    // Warning : UID is not registered and applied to the KEN.Sound for registration
    this._uid = configSound["uid"];

    this._url = configSound["url"];
    this._baseVolume = (typeof configSound["volume"] === "number") ? KEN.Math.clamp(configSound["volume"], 0, 1) : 1; //@todo better management if volume is modified into the Sound class
    this._loop = (typeof configSound["loop"] === "boolean") ? configSound["loop"] : false;
    this._startTime = (typeof configSound.startTime === "number") ? configSound.startTime : 0; //in ms
    this._autoPlay = (typeof configSound["autoPlay"] === "boolean") ? configSound["autoPlay"] : false;

    if(typeof configSound["type"] !== "undefined" && configSound["type"] === KEN.HotspotSound.types.SPATIAL)
    {
        this._type = KEN.HotspotSound.types.SPATIAL;
        if(typeof configSound.outOfFov !== "undefined")
        {
            this._type = KEN.HotspotSound.types.SPATIAL;
            if(typeof configSound.outOfFov !== "undefined")
            {
                this._muteOutOfFov = (typeof configSound.outOfFov.mute === "boolean") ? configSound.outOfFov.mute : false;
                this._fadeOutOfFov = (typeof configSound.outOfFov.fade === "boolean") ? configSound.outOfFov.fade : false;
                this._fadeTimeOutOfFov = (typeof configSound.outOfFov.fadeTime === "number") ? configSound.outOfFov.fadeTime : KEN.HotspotSound.DEFAULT_RAMP_TIME;
                this._fadeVolumeOutOfFov = (typeof configSound.outOfFov.minVolume === "number") ? configSound.outOfFov.minVolume : 0;
            }
            this._coneRange = (typeof configSound.range === "number") ? KEN.Math.clamp(configSound.range, 1, 360) : 360;

        }
        this._coneRange = (typeof configSound.range === "number") ? KEN.Math.clamp(configSound.range, 1, 360) : 360;
    }

    // set default type to 2d sound
    if(this._type === "")
    {
        this._type = KEN.HotspotSound.types.STEREO;
    }

    if(typeof configTransform !== "undefined" && typeof configTransform["position"] !== "undefined")
    {
        this._position.theta = (typeof configTransform["position"].theta === "number") ? KEN.Math.clamp(configTransform["position"].theta, -180, 180) : 0;
        this._position.phi = (typeof configTransform["position"].phi === "number") ? KEN.Math.clamp(configTransform["position"].phi, -90, 90) : 0;
        //@todo manage radius
    }

    this._setupSound();
};

/**
 * Setup the sound and apply options.
 * @method KEN.HotspotSound#_setupSound
 * @private
 */
KEN.HotspotSound.prototype._setupSound = function()
{
    this._sound = new KEN.Sound(this._viewer, this._uid, this._url || "");
    this._sound["onCanPlayThrough"].addOnce(this._onCanPlayThroughHandler, this);

    // spatial sound options
    if(this._isSpatialized() === true)
    {
        // Create world position from inversed theta angle and phi angle
        var sphericalPt = KEN.Utils.toTHREESpherical(1, KEN.Math.degToRad(-this._position.theta), KEN.Math.degToRad(this._position.phi)); //@todo manage radius here
        this._positionWorld = new THREE.Vector3().setFromSpherical(sphericalPt);

        this._sound["spatialized"] = this._isSpatialized();
        this._sound.x = this._positionWorld.x;
        this._sound.y = this._positionWorld.y;
        this._sound.z = this._positionWorld.z;

        if(this._sound["volume"] <= this._fadeVolumeOutOfFov)
        {
            this._fadeOutOfFov = false;
            this.warn("Fade minVolume can't be higher that the current sound volume.");
        }
    }

    // sound options
    this._sound["volume"] = this._baseVolume;
    this._sound["loop"] = this._loop;
    this._sound.startTime = this._startTime;

    if(this._autoPlay === true)
    {
        this._sound.play(this._startTime, this._loop, true);
    }
};

/**
 * Is the sound spatialized?
 * @method  KEN.HotspotSound#_isSpatialized
 * @return {boolean} Is spatialized?
 * @private
 */
KEN.HotspotSound.prototype._isSpatialized = function()
{
    return (this._type === KEN.HotspotSound.types.SPATIAL);
};

/**
 * Get screen point (x and y positions).
 * @method KEN.HotspotSound#_getScreenPoint
 * @private
 */
KEN.HotspotSound.prototype._getScreenPoint = function()
{
    return this._viewer["renderer"].worldToScreen(this._positionWorld);
};

/**
 * On can play through handler.
 * @method  KEN.HotspotSound#_onCanPlayThroughHandler
 * @private
 */
KEN.HotspotSound.prototype._onCanPlayThroughHandler = function()
{
    this.log("Sound load complete");
    this._setupComplete();
};

/**
 * Setup completed handler.
 * @method KEN.HotspotSound#_setupComplete
 * @private
 */
KEN.HotspotSound.prototype._setupComplete = function()
{
    if(this._onReady !== null)
    {
        this._onReady.dispatch();
    }
};

/**
 * Set an observer cone for the sound volume.
 * @method KEN.HotspotSound#_setObserverCone
 * @private
 *
 * @todo  doesn't work if the camera is reversed on the y axis !
 */
KEN.HotspotSound.prototype._setObserverCone = function()
{
    if(this._isSpatialized() === true && typeof this._coneRange === "number")
    {
        var camera = this._viewer["renderer"]["camera"];
        var qCamera = KEN.Quaternion.fromEuler(KEN.Math.degToRad(camera["yaw"]), KEN.Math.degToRad(camera["pitch"]), 0);
        var qSound = KEN.Quaternion.fromEuler(KEN.Math.degToRad(this._position.theta), KEN.Math.degToRad(this._position.phi), 0);
        var distance = KEN.Quaternion.angularDistance(qSound, qCamera);
        var radius = KEN.Math.degToRad(this._coneRange / 2); //from range to radius in radians

        // reduce the volume or "mute" volume when out of the range
        if ( distance < radius )
        {
            this._sound["volume"] = this._baseVolume * ( 1 - distance / radius );
        }
        else
        {
            this._sound["volume"] = 0;
        }
    }
};

/**
 * Apply Fov limits to the sound if concerned.
 * @method  KEN.HotspotSound#_setFovLimits
 * @private
 */
KEN.HotspotSound.prototype._setFovLimits = function()
{
    var center = this._getScreenPoint();
    if (center.x === Infinity || center.y === Infinity)
    {
        if(this._outOfBounds === false)
        {
            //this._sound["visible"] = false;

            //mute sound if outof the screen
            if (this._muteOutOfFov === true)
            {
                this._sound.mute();
            }
            else if (this._fadeOutOfFov === true && this._viewer["audio"]["useWebAudio"] === true)
            {
                // Fading out
                this._sound._gainNode.gain.linearRampToValueAtTime(Math.min(this._sound["volume"], this._fadeVolumeOutOfFov), this._sound._context["currentTime"] + this._fadeTimeOutOfFov);
            }

            this._outOfBounds = true;
        }
    }
    else
    {
        if(this._outOfBounds === true)
        {
            //this._sound["visible"] = true;

            this._outOfBounds = false;

            if (this._sound["muted"] === true && this._muteOutOfFov === true)
            {
                this._sound.unmute();
            }
            else if (this._fadeOutOfFov === true && this._viewer["audio"]["useWebAudio"] === true)
            {
                // Fading in
                this._sound._gainNode.gain.linearRampToValueAtTime(this._sound["volume"], this._sound._context["currentTime"] + this._fadeTimeOutOfFov);
            }
        }
    }
};

/**
 * Load a sound configuration
 * @method KEN.HotspotSound#load
 * @param  {HotspotSoundConfig} configSound - The hotspot sound configuration object.
 * @param  {HotspotTransformConfig} configTransform - The hotspot transform configuration object.
 */
KEN.HotspotSound.prototype.load = function(configSound, configTransform)
{
    this._parseConfig(configSound, configTransform);
};

/**
 * Render sound.
 * @method KEN.HotspotSound#update
 */
KEN.HotspotSound.prototype.update = function()
{
    //@todo what happens if sound spot is hidden ? this._sound["enabled"] = this._visible;
    if (this._viewer["audio"]["enabled"] === false || this._sound["enabled"] === false)
    {
        //stop sound
        this._sound.stop();
        return;
    }

    if(this._isSpatialized() === true)
    {
        // add the observer cone based on the spot range
        this._setObserverCone();

        // apply Fov limits
        this._setFovLimits();
    }
};

/**
 * Destroy routine.
 * @method KEN.HotspotSound#destroy
 */
KEN.HotspotSound.prototype.destroy = function()
{
    this._sound.destroy();
    this._sound = null;

    this._positionWorld = null;

    this._position = null;

    if(this._onReady !== null)
    {
        this._onReady.destroy();
    }

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the type of the sound.
 * @name KEN.HotspotSound#type
 * @readonly
 * @type {string}
 */
KEN.HotspotSound.prototype.type;
Object.defineProperty(KEN.HotspotSound.prototype, "type",
{
    /** @this {KEN.HotspotSound} */
    get: function()
    {
        return this._type;
    }
});

/**
 * Get the {@link KEN.Sound} object.
 * @name KEN.HotspotSound#sound
 * @readonly
 * @type {KEN.Sound}
 */
KEN.HotspotSound.prototype.sound;
Object.defineProperty(KEN.HotspotSound.prototype, "sound",
{
    /** @this {KEN.HotspotSound} */
    get: function()
    {
        return this._sound;
    }
});

/**
 * Get the "onReady" {@link KEN.EventDispatcher} of this hotspot sound.
 * @name KEN.HotspotSound#onReady
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.HotspotSound.prototype.onReady;
Object.defineProperty(KEN.HotspotSound.prototype, "onReady",
{
    /** @this {KEN.HotspotSound} */
    get: function()
    {
        if(this._onReady === null)
        {
            this._onReady = new KEN.EventDispatcher(this);
        }

        return this._onReady;
    }
});

/**
 * Hotspot material handles the parse of the material config and the loading of the needed ressource.<br>
 * In the end it provides a THREE.MeshBasicMaterial when the ressources are loaded.
 *
 * @constructor KEN.HotspotMaterial
 * @param {KEN.Viewer} viewer - The viewer reference.
 * @extends {KEN.BaseObject}
 */
KEN.HotspotMaterial = function(viewer)
{
    /**
     * Viewer reference.
     * @name  KEN.HotspotMaterial#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Hotspot material config
     * @name KEN.HotspotMaterial#_config
     * @type {?HotspotMaterialConfig}
     * @private
     */
    this._config = null;

    /**
     * Material input type.<br>
     * Can be one of the values listed in KEN.HotspotMaterial.types
     * @name  KEN.HotspotMaterial#_type
     * @type {string}
     * @private
     */
    this._type = "";

    /**
     * THREE texture.
     * @name  KEN.HotspotMaterial#_texture
     * @type {THREE.Texture}
     * @private
     */
    this._texture = null;

    /**
     * THREE material.
     * @name  KEN.HotspotMaterial#_material
     * @type {THREE.MeshBasicMaterial}
     * @private
     */
    this._material = null;

    /**
     * The opacity of the material (between 0 and 1)
     * @name  KEN.HotspotMaterial#_opacity
     * @type {number}
     * @default
     * @private
     */
    this._opacity = 1;

    /**
     * The transparent flag of the material.<br>
     * if you use a PNG file as texture with some transparency, you have to set this to true.
     * @name  KEN.HotspotMaterial#_transparent
     * @type {boolean}
     * @default
     * @private
     */
    this._transparent = false;

    /**
     * The base color of the material.<br>
     * Can be a number 0xff0000 or a string: rgb(255, 0, 0), rgb(100%, 0%, 0%), hsl(0, 100%, 50%), #ff0000.
     * @name  KEN.HotspotMaterial#_opacity
     * @type {(number|string)}
     * @default
     * @private
     */
    this._color = 0xffffff;

    /**
     * The display object used for the texture
     * @name  KEN.HotspotMaterial#_displayObject
     * @type {(KEN.ImageScalable|KEN.DisplayObject)}
     * @private
     */
    this._displayObject = null;

    /**
     * Does this material needs update
     * @name KEN.HotspotMaterial#_update
     * @type {boolean}
     * @private
     */
    this._update = false;

    /**
     * The onReady event dispatcher.
     * @name  KEN.HotspotMaterial#_onReady
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onReady = null;

    KEN.BaseObject.call(this, "HotspotMaterial");
};

KEN.HotspotMaterial.prototype = Object.create(KEN.BaseObject.prototype);
KEN.HotspotMaterial.prototype.constructor = KEN.HotspotMaterial;

/**
 * Material input type list.
 * @name KEN.HotspotMaterial.types
 * @type {Object}
 * @const
 */
KEN.HotspotMaterial.types = {};

/**
 * @name KEN.HotspotMaterial.types.IMAGE
 * @type {string}
 * @const
 */
KEN.HotspotMaterial.types.IMAGE = "image";

/**
 * @name KEN.HotspotMaterial.types.PLUGIN
 * @type {string}
 * @const
 */
KEN.HotspotMaterial.types.PLUGIN = "plugin";

/**
 * @name KEN.HotspotMaterial.types.GRAPHICS
 * @type {string}
 * @const
 */
KEN.HotspotMaterial.types.GRAPHICS = "graphics";


/**
 * Materials presets.
 * @name KEN.HotspotMaterial.presets
 * @type {Object}
 * @const
 */
KEN.HotspotMaterial.presets = {};

/**
 * @name KEN.HotspotMaterial.presets.TRANSPARENT
 * @type {HotspotMaterialConfig}
 * @const
 */
KEN.HotspotMaterial.presets.TRANSPARENT =
{
    color: "#ffffff",
    opacity: 0,
    transparent: false
};

/**
 * @name KEN.HotspotMaterial.presets.DEBUG
 * @type {HotspotMaterialConfig}
 * @const
 */
KEN.HotspotMaterial.presets.DEBUG =
{
    color: "#00ff00",
    opacity: 0.8,
    transparent: false
};

/**
 * Parse the configuration object.
 * @method KEN.HotspotMaterial#_parseConfig
 * @param  {HotspotMaterialConfig} config - Configuration object of the material.
 * @private
 */
KEN.HotspotMaterial.prototype._parseConfig = function(config)
{
    this._opacity = (typeof config["opacity"] === "number") ? KEN.Math.clamp(config["opacity"], 0, 1) : 1;
    this._transparent = (typeof config["transparent"] === "boolean") ? config["transparent"] : false;
    this._color = (typeof config["color"] === "string") ? config["color"] : 0xffffff;
    this._update = (typeof config.update === "boolean") ? config.update : false;

    // Hotspot with image as background
    if (typeof config.image !== "undefined" && config.image !== null)
    {
        this._setupWithImage(config.image);
    }

    // Hotspot with plugin that provide a texture as background
    else if (typeof config.plugin !== "undefined" && config.plugin !== null)
    {
        this._setupWithPlugin(config.plugin);
    }

    // Hotspot with graphical options as background
    else
    {
        this._setupWithGraphics();
    }

    // Nothing is defined, don't know what to do
    // else
    // {
    //     throw new Error("Unknown hotspot material texture input");
    // }
};

/**
 * Setup hotspot material with an image as texture.
 * @method KEN.HotspotMaterial#_setupWithImage
 * @param {(string|ImageConfig)} config - The image configuration you want to load and use as a texture.
 * @private
 */
KEN.HotspotMaterial.prototype._setupWithImage = function(config)
{
    this._type = KEN.HotspotMaterial.types.IMAGE;

    this._displayObject = new KEN.ImageScalable(this._viewer, config);
    this._displayObject["onLoadComplete"].addOnce(this._imageLoadCompleteHandler, this);
};

/**
 * Image loaded event handler for the image setup.
 * @method KEN.HotspotMaterial#_imageLoadCompleteHandler
 * @param {KEN.Event} event - load event
 * @private
 */
KEN.HotspotMaterial.prototype._imageLoadCompleteHandler = function(event)
{
    var image = event["emitter"];

    this.log("Texture load complete (Image) : " + image["element"].src);
    this._createTextureFromImage(image);
};

/**
 * Create a THREE.Texture from the loaded KEN.Image
 * @method  KEN.HotspotMaterial#_createTextureFromImage
 * @param  {KEN.Image} image - The KEN.Image used to create the texture.
 * @private
 */
KEN.HotspotMaterial.prototype._createTextureFromImage = function(image)
{
    this._displayObject = image;

    this._texture = new THREE.Texture(image["element"]);
    this._texture.image.crossOrigin = "anonymous";
    this._texture.wrapS = THREE.ClampToEdgeWrapping;
    this._texture.wrapT = THREE.ClampToEdgeWrapping;
    this._texture.minFilter = THREE.LinearFilter;
    this._texture.magFilter = THREE.LinearFilter;

    this._texture.needsUpdate = true;

    this.log("Map new texture from image");

    this._setupComplete();
};

/**
 * Create a hotspot with a plugin that will provide a texture as input.
 * @method KEN.HotspotMaterial#_setupWithPlugin
 * @param {string} config - The plugin instance UID you want to use as a texture provider.<br>
 * The plugin have to have a "texture" public property.
 * @private
 */
KEN.HotspotMaterial.prototype._setupWithPlugin = function(config)
{
    this._type = KEN.HotspotMaterial.types.PLUGIN;

    var plugin = this._viewer["plugins"].get(config);

    if (typeof plugin === "undefined" || plugin === null)
    {
        this._viewer["plugins"]["onInstanceCreate"].add(this._pluginInstanceCreateHandler, this);
    }
    else
    {
        this._setPlugin(plugin);
    }
};

/**
 * Plugin instance create event handler.
 * @method KEN.HotspotMaterial#_pluginInstanceCreateHandler
 * @param {KEN.Event} event - instance create event
 * @private
 */
KEN.HotspotMaterial.prototype._pluginInstanceCreateHandler = function(event)
{
    var plugin = event["data"];

    if (plugin["uid"] === this._config.plugin)
    {
        this._viewer["plugins"]["onInstanceCreate"].remove(this._pluginInstanceCreateHandler, this);
        this._setPlugin(plugin);
    }
};

/**
 * Once the plugin is created by the manager we can set the plugin that we will provide the texture.
 * This method will check if the instance is ready, if not will setup a listener.
 * @method KEN.HotspotMaterial#_setPlugin
 * @param {KEN.Plugin} plugin - The plugin that will provides the texture.
 * @private
 */
KEN.HotspotMaterial.prototype._setPlugin = function(plugin)
{
    if (plugin["instanceReady"] === true)
    {
        this._createTextureFromPlugin(plugin);
    }
    else
    {
        plugin["onInstanceReady"].addOnce(this._pluginInstanceReadyHandler, this);
    }
};

/**
 * Plugin instance ready event handler.
 * @method KEN.HotspotMaterial#_pluginInstanceReadyHandler
 * @param {KEN.Event} event - instance ready event
 * @private
 */
KEN.HotspotMaterial.prototype._pluginInstanceReadyHandler = function(event)
{
    var plugin = event["emitter"];

    if (plugin["instance"] === null || plugin["instanceReady"] === false)
    {
        throw new Error("Plugin instance not available");
    }

    this._createTextureFromPlugin(plugin);
};

/**
 * Create a texture from a plugin that provides a display object on a "texture" property.
 * @method KEN.HotspotMaterial#_createTextureFromPlugin
 * @param {KEN.Plugin} plugin - plugin that provides the texture.
 * @private
 */
KEN.HotspotMaterial.prototype._createTextureFromPlugin = function(plugin)
{
    this._displayObject = plugin["instance"]["texture"];

    this._texture = new THREE.Texture(this._displayObject["dom"]);
    this._texture.format = THREE.RGBAFormat;
    this._texture.wrapS = THREE.ClampToEdgeWrapping;
    this._texture.wrapT = THREE.ClampToEdgeWrapping;
    this._texture.magFilter = THREE.LinearFilter;
    this._texture.minFilter = THREE.LinearFilter;
    this._texture.generateMipmaps = false;
    this._texture.needsUpdate = true;

    this.log("Map new texture from plugin");

    this._setupComplete();
};

/**
 * Create a hotspot material with graphical attributes.
 * @method KEN.HotspotMaterial#_setupWithGraphics
 * @private
 * @todo Make a config to use only graphical properties
 */
KEN.HotspotMaterial.prototype._setupWithGraphics = function()
{
    this._type = KEN.HotspotMaterial.types.GRAPHICS;

    this._setupComplete();
};

/**
 * This is the final setup step when any of the loading or wainting instance ready process is complete.
 * @method KEN.HotspotMaterial#_setupComplete
 * @private
 */
KEN.HotspotMaterial.prototype._setupComplete = function()
{
    this._createMaterial();
};

/**
 * Create the THREE.MeshBasicMaterial that will be used on a THREE.Mesh.<br>
 * Dispatch the onReady event when it's complete.
 * @method KEN.HotspotMaterial#_createMaterial
 * @private
 */
KEN.HotspotMaterial.prototype._createMaterial = function()
{
    /** @type {MeshBasicMaterialOptions} */
    var materialOptions = {
        side: THREE.FrontSide
    };
    this._material = new THREE.MeshBasicMaterial(materialOptions);

    this._material["opacity"] = this._opacity;
    this._material["color"] = new THREE.Color(this._color);

    if (this._texture !== null)
    {
        //Apply transparent parameter only if we have a texture.
        this._material["transparent"] = this._transparent;

        this._material.map = this._texture;
        this._material.needsUpdate = true;
    }

    if (this._onReady !== null)
    {
        this._onReady.dispatch();
    }
};

/**
 * Load a material configuration
 * @method KEN.HotspotMaterial#load
 * @param  {HotspotMaterialConfig} config - The hotspot material configuration object.
 */
KEN.HotspotMaterial.prototype.load = function(config)
{
    this._config = config;
    this._parseConfig(this._config);
};

/**
 * Update method taht will be called by the Hotspot.
 * @method KEN.HotspotMaterial#update
 */
KEN.HotspotMaterial.prototype.update = function()
{
    if(this._texture !== null && this._update === true)
    {
        this._texture.needsUpdate = true;
    }
};

/**
 * Destroy sequence.
 * @method KEN.HotspotTransform#destroy
 */
KEN.HotspotMaterial.prototype.destroy = function()
{
    if (this._texture !== null)
    {
        this._texture.dispose();
        this._texture = null;
    }

    this._material.dispose();
    this._material = null;

    if(this._type === KEN.HotspotMaterial.types.IMAGE && this._displayObject !== null)
    {
        this._displayObject.destroy();
    }
    this._displayObject = null;

    if(this._viewer["plugins"]["onInstanceCreate"].has(this._pluginInstanceCreateHandler, this) === true)
    {
        this._viewer["plugins"]["onInstanceCreate"].remove(this._pluginInstanceCreateHandler, this);
    }

    if(this._onReady !== null)
    {
        this._onReady.destroy();
        this._onReady = null;
    }

    this._viewer = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the type of texture provider of this hotspot material.
 * @name KEN.HotspotMaterial#type
 * @readonly
 * @type {string}
 */
KEN.HotspotMaterial.prototype.type;
Object.defineProperty(KEN.HotspotMaterial.prototype, "type",
{
    /** @this {KEN.HotspotMaterial} */
    get: function()
    {
        return this._type;
    }
});

/**
 * Get the THREE.Texture used for this hotspot material.
 * @name KEN.HotspotMaterial#texture
 * @readonly
 * @type {THREE.Texture}
 */
KEN.HotspotMaterial.prototype.texture;
Object.defineProperty(KEN.HotspotMaterial.prototype, "texture",
{
    /** @this {KEN.HotspotMaterial} */
    get: function()
    {
        return this._texture;
    }
});

/**
 * Get the THREE.MeshBasicMaterial used for this hotspot material.
 * @name KEN.HotspotMaterial#material
 * @readonly
 * @type {THREE.MeshBasicMaterial}
 */
KEN.HotspotMaterial.prototype.material;
Object.defineProperty(KEN.HotspotMaterial.prototype, "material",
{
    /** @this {KEN.HotspotMaterial} */
    get: function()
    {
        return this._material;
    }
});

/**
 * Get the opacity of this hotspot material.
 * @name KEN.HotspotMaterial#opacity
 * @readonly
 * @type {number}
 */
KEN.HotspotMaterial.prototype.opacity;
Object.defineProperty(KEN.HotspotMaterial.prototype, "opacity",
{
    /** @this {KEN.HotspotMaterial} */
    get: function()
    {
        return this._opacity;
    }
});

/**
 * Get the transparent flag of this hotspot material.
 * @name KEN.HotspotMaterial#transparent
 * @readonly
 * @type {boolean}
 */
KEN.HotspotMaterial.prototype.transparent;
Object.defineProperty(KEN.HotspotMaterial.prototype, "transparent",
{
    /** @this {KEN.HotspotMaterial} */
    get: function()
    {
        return this._transparent;
    }
});

/**
 * Get the color of this hotspot material.
 * @name KEN.HotspotMaterial#color
 * @readonly
 * @type {(string|number)}
 */
KEN.HotspotMaterial.prototype.color;
Object.defineProperty(KEN.HotspotMaterial.prototype, "color",
{
    /** @this {KEN.HotspotMaterial} */
    get: function()
    {
        return this._color;
    }
});

/**
 * Get the displayObject of this hotspot material.
 * @name KEN.HotspotMaterial#displayObject
 * @readonly
 * @type {(KEN.ImageScalable|KEN.DisplayObject)}
 */
KEN.HotspotMaterial.prototype.displayObject;
Object.defineProperty(KEN.HotspotMaterial.prototype, "displayObject",
{
    /** @this {KEN.HotspotMaterial} */
    get: function()
    {
        return this._displayObject;
    }
});

/**
 * Get the "onReady" {@link KEN.EventDispatcher} of this hotspot material.<br/>
 * Dispatched when the material texture is loaded and ready to be used by a THREE.Texture.
 * @name KEN.HotspotMaterial#onReady
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.HotspotMaterial.prototype.onReady;
Object.defineProperty(KEN.HotspotMaterial.prototype, "onReady",
{
    /** @this {KEN.HotspotMaterial} */
    get: function()
    {
        if (this._onReady === null)
        {
            this._onReady = new KEN.EventDispatcher(this);
        }

        return this._onReady;
    }
});

/**
 * HotspotTransform handle the parsing of the position rotation and size of a 3d Hotspot.
 *
 * @constructor KEN.HotspotTransform
 * @param {HotspotTransformPositionConfig=} position - The spherical coordinates of a 3D object (radius, theta, phi)
 * @param {HotspotTransformRotationConfig=} rotation - The rotaion of a 3D object (x, y, z).
 * @extends {KEN.BaseObject}
 *
 * @todo Find a way to express size with something else than angles.
 * @todo Add an option to keep the ratio of a texture or not.
 */
KEN.HotspotTransform = function(position, rotation)
{
    /**
     * The spherical coordinates of a 3D object (radius, theta, phi).
     * @name KEN.HotspotTransform#_position
     * @type {HotspotTransformPositionConfig}
     * @private
     */
    this._position = position || { radius: 200, theta: 0, phi: 0 };

    /**
     * The rotaion of a 3D object (x, y, z).
     * @name KEN.HotspotTransform#_rotation
     * @type {HotspotTransformRotationConfig}
     * @private
     */
    this._rotation = rotation || { x: 0, y: 0, z: 0 };

    /**
     * The size of a 3D object.<br>
     * Can be express in angles (theta, phi) for 3d hotspots, or world units (width, height).
     * @type {HotspotTransformSizeConfig}
     * @private
     */
    this._size = { theta: 10, phi: 10, width: 0, height: 0 };

    KEN.BaseObject.call(this, "HotspotTransform");
};

KEN.HotspotTransform.prototype = Object.create(KEN.BaseObject.prototype);
KEN.HotspotTransform.prototype.constructor = KEN.HotspotTransform;

/**
 * Parse the config object, set default values where values are undefined.
 * @method KEN.HotspotTransform#_parseConfig
 * @param {HotspotTransformConfig} config - The transform config to parse.
 * @private
 */
KEN.HotspotTransform.prototype._parseConfig = function(config)
{
    if(typeof config["position"] !== "undefined")
    {
        this._position.radius = (typeof config["position"].radius === "number") ? config["position"].radius : 0;
        this._position.theta = (typeof config["position"].theta === "number") ? config["position"].theta : 0;
        this._position.phi = (typeof config["position"].phi === "number") ? config["position"].phi : 0;
    }

    if(typeof config["rotation"] !== "undefined" && config["rotation"] !== "auto")
    {
        this._rotation.x = (typeof config["rotation"].x === "number") ? config["rotation"].x : 0;
        this._rotation.y = (typeof config["rotation"].y === "number") ? config["rotation"].y : 0;
        this._rotation.z = (typeof config["rotation"].z === "number") ? config["rotation"].z : 0;
    }
    else if(typeof config["rotation"] === "undefined" || config["rotation"] === "auto")
    {
        this._rotation = this._getAutoRotationFromPosition(this._position);
    }

    if(typeof config["size"] !== "undefined")
    {
        this._size.theta = (typeof config["size"].theta === "number") ? config["size"].theta : "auto";
        this._size.phi = (typeof config["size"].phi === "number") ? config["size"].phi : "auto";
    }
};

/**
 * Computes actual position to an automatic rotation in a way that the object will faces the camera.
 * @method KEN.HotspotTransform#_getAutoRotationFromPosition
 * @param {HotspotTransformPositionConfig} position - The position used to determine the rotation.
 * @private
 */
KEN.HotspotTransform.prototype._getAutoRotationFromPosition = function(position)
{
    var rotation = { x: 0, y: 0, z: 0 };

    if(typeof position !== "undefined")
    {
        // Apply inverse rotation angles to make the spot facing the camera

        // y-axis rotation: yaw
        rotation.y = (typeof position.theta === "number") ? -position.theta : 0;

        // x-axis rotation: pitch
        rotation.x = (typeof position.phi === "number") ? -position.phi : 0;
    }

    return rotation;
};

/**
 * Compute a size for a plan geometry from angular size and material texture size.
 * @method KEN.HotspotTransform#computeSizeFromAnglesAndMaterial
 * @param {KEN.HotspotMaterial} material - Material used by the hotspot, used to compute a ratio
 *
 * @todo Add an option to keep the ratio of a texture or not.
 */
KEN.HotspotTransform.prototype.computeSizeFromAnglesAndMaterial = function(material)
{
    var texture = material["texture"];

    //Compute a ratio from the texture size
    var iWidth = 1, iHeight = 1, iRatio = 1;
    if (texture !== null && typeof texture.image !== "undefined")
    {
        iWidth = texture.image["width"];
        iHeight = texture.image["height"];
    }
    iRatio = iWidth / iHeight;


    var w = iWidth, h = iHeight;
    var dPhi, dTheta;

    if (typeof this._size.phi === "number")
    {
        dPhi = KEN.Math.degToRad(this._size.phi);
        h = 2 * this._position.radius * Math.tan(dPhi/2);

        if (this._size.theta === "auto")
        {
            w = h * iRatio;
        }
    }

    if (typeof this._size.theta === "number")
    {
        dTheta = KEN.Math.degToRad(this._size.theta);
        w = 2 * this._position.radius * Math.tan(dTheta/2);

        if (this._size.phi === "auto")
        {
            h = w / iRatio;
        }
    }

    this._size["width"] = w;
    this._size["height"] = h;
};

/**
 * Load a transform configuration.
 * @method KEN.HotspotTransform#load
 * @param {HotspotTransformConfig} config - The transform config to load.
 */
KEN.HotspotTransform.prototype.load = function(config)
{
    this._parseConfig(config);
};

/**
 * Destroy sequence.
 * @method KEN.HotspotTransform#destroy
 */
KEN.HotspotTransform.prototype.destroy = function()
{
    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the spherical position of the transform object
 * @name KEN.HotspotTransform#position
 * @type {HotspotTransformPositionConfig}
  */
KEN.HotspotTransform.prototype.position;
Object.defineProperty(KEN.HotspotTransform.prototype, "position",
{
    /** @this {KEN.HotspotTransform} */
    get: function()
    {
        return this._position;
    }
});

/**
 * Get the rotation of the transform object
 * @name KEN.HotspotTransform#rotation
 * @type {HotspotTransformRotationConfig}
  */
KEN.HotspotTransform.prototype.rotation;
Object.defineProperty(KEN.HotspotTransform.prototype, "rotation",
{
    /** @this {KEN.HotspotTransform} */
    get: function()
    {
        return this._rotation;
    }
});

/**
 * Get the size of the transform object
 * @name KEN.HotspotTransform#size
 * @type {HotspotTransformRotationConfig}
  */
KEN.HotspotTransform.prototype.size;
Object.defineProperty(KEN.HotspotTransform.prototype, "size",
{
    /** @this {KEN.HotspotTransform} */
    get: function()
    {
        return this._size;
    }
});


/**
 * @namespace {Object} KEN.HotspotType
 */
KEN.HotspotType = {};

/**
 * @name KEN.HotspotType.THREE_DIMENSIONAL
 * @type {string}
 * @const
 */
KEN.HotspotType.THREE_DIMENSIONAL = "3d";


/**
 * A KEN.Camera tells the renderer wich part of the scene to render.
 *
 * @constructor KEN.Camera
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @extends {KEN.BaseObject}
 */
KEN.Camera = function(viewer)
{
    /**
     * The viewer reference.
     * @name KEN.Camera#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Camera configuration that has been loaded.
     * @name  KEN.Camera#_config
     * @type {?CameraConfig}
     * @private
     */
    this._config = null;

    /**
     * The yaw value in radians.
     * @name KEN.Camera#_yaw
     * @type {number}
     * @private
     */
    this._yaw = 0;

    /**
     * The yaw minimum value in radians.
     * @name KEN.Camera#_yawMin
     * @type {?number}
     * @private
     */
    this._yawMin = 0;

    /**
     * The yaw maximum value in radians.
     * @name KEN.Camera#_yawMax
     * @type {number}
     * @private
     */
    this._yawMax = 0;

    /**
     * The pitch value in radians.
     * @name KEN.Camera#_pitch
     * @type {number}
     * @private
     */
    this._pitch = 0;

    /**
     * The pitch minimum value in radians.
     * @name KEN.Camera#_pitchMin
     * @type {number}
     * @private
     */
    this._pitchMin = 0;

    /**
     * The pitch maximum value  in radians.
     * @name KEN.Camera#_pitchMax
     * @type {number}
     * @private
     */
    this._pitchMax = 0;

    /**
     * The roll value in radians.
     * @name KEN.Camera#_roll
     * @type {number}
     * @private
     */
    this._roll = 0;

    /**
     * The roll minimum value  in radians.
     * @name KEN.Camera#_rollMin
     * @type {number}
     * @private
     */
    this._rollMin = 0;

    /**
     * The roll maximum value in radians.
     * @name KEN.Camera#_rollMax
     * @type {number}
     * @private
     */
    this._rollMax = 0;

    /**
     * The fov value in radians.
     * @name KEN.Camera#_fov
     * @type {number}
     * @private
     */
    this._fov = Math.PI / 2;

    /**
     * The fov minimum value in radians.
     * @name KEN.Camera#_fovMin
     * @type {number}
     * @private
     */
    this._fovMin = 0;

    /**
     * The fov maximum value in radians.
     * @name KEN.Camera#_fovMax
     * @type {number}
     * @private
     */
    this._fovMax = 0;

    /**
     * Parallax setting
     * Value range is between 0 and 1
     * @name KEN.Camera#_parallax
     * @type {number}
     * @private
     */
    this._parallax = 0;

    /**
     * The modelview rotation matrix.
     * @name KEN.Camera#_modelView
     * @type {THREE.Matrix4}
     * @private
     */
    this._modelView = null;

    /**
     * The inverse of the modelview rotation matrix.
     * @name KEN.Camera#_modelViewInverse
     * @type {THREE.Matrix4}
     * @private
     */
    this._modelViewInverse = null;

    /**
     * Rotation quaternion of the camera
     * @name KEN.Camera#_quaternion
     * @type {THREE.Quaternion}
     * @private
     */
    this._quaternion = null;

    /**
     * Camera viewfinder
     * @name KEN.Camera#_viewfinder
     * @type {KEN.CameraViewfinder}
     * @private
     */
    this._viewfinder = null;

    /**
     * Camera animation object
     * @name KEN.Camera#_cameraAnimation
     * @type {KEN.CameraAnimation}
     * @private
     */
    this._cameraAnimation = null;

    /**
     * Three Perspective Camera object
     * @name KEN.Camera#_perspectiveCamera
     * @type {THREE.PerspectiveCamera}
     * @private
     */
    this._perspectiveCamera = null;

    /**
     * On camera change event dispatcher.
     * @name KEN.Camera#_onCameraChange
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onCameraChange = null;

    KEN.BaseObject.call(this, "Camera");

    this._boot();
};

KEN.Camera.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Camera.prototype.constructor = KEN.Camera;

/**
 * Camera default radius for parallax.
 * @name KEN.Camera.RADIUS
 * @type {number}
 * @const
 */
KEN.Camera.RADIUS = 50;

/**
 * Camera default configuration in degrees like in the tour json.
 * @name KEN.Camera.DEFAULT_CONFIG
 * @type {CameraConfig}
 * @const
 */
KEN.Camera.DEFAULT_CONFIG = {
    parallax: 0,
    yaw: /** @type {CameraValueConfig} */ ({ default: 0 }),
    pitch: /** @type {CameraValueConfig} */ ({ default: 0, min: -90, max: 90 }),
    roll: /** @type {CameraValueConfig} */ ({ default: 0 }),
    fov: /** @type {CameraValueConfig} */ ({ default: 90 })
};

/**
 * Init sequence.
 * @method KEN.Camera#_boot
 * @private
 */
KEN.Camera.prototype._boot = function()
{
    this._modelView = new THREE.Matrix4();
    this._modelViewInverse = new THREE.Matrix4();
    this._quaternion = new THREE.Quaternion();

    this._createPerspectiveCamera();
};

/**
 * Parse a camera configuration.
 * @method KEN.Camera#_parseConfig
 * @param {CameraConfig} config - The camera configuration to parse.
 * @private
 */
KEN.Camera.prototype._parseConfig = function(config)
{
    this._parallax = config["parallax"];

    this._yawMin = KEN.Math.degToRad(config["yaw"].min);
    this._yawMax = KEN.Math.degToRad(config["yaw"].max);
    this._setYaw(config["yaw"]["default"], KEN.Math.DEGREES);

    this._pitchMin = KEN.Math.degToRad(config["pitch"].min);
    this._pitchMax = KEN.Math.degToRad(config["pitch"].max);
    this._setPitch(config["pitch"]["default"], KEN.Math.DEGREES);

    this._rollMin = KEN.Math.degToRad(config["roll"].min);
    this._rollMax = KEN.Math.degToRad(config["roll"].max);
    this._setRoll(config["roll"]["default"], KEN.Math.DEGREES);

    if (typeof config["fov"].min !== "undefined")
    {
        this._fovMin = KEN.Math.degToRad(config["fov"].min);
    }

    if (typeof config["fov"].max !== "undefined")
    {
        this._fovMax = KEN.Math.degToRad(config["fov"].max);
    }

    this._setFov(config["fov"]["default"], KEN.Math.DEGREES);

    this._updateFromEuler();
    this._updateComplete();
};

/**
 * Init the THREE PerspectiveCamera.
 * @method KEN.Camera#_createPerspectiveCamera
 * @return {THREE.PerspectiveCamera} Returns the created perspective camera.
 * @private
 */
KEN.Camera.prototype._createPerspectiveCamera = function()
{
    if (typeof this._viewer["renderer"] !== "undefined")
    {
        var aspect = this._viewer["renderer"]["displayResolution"]["ratio"];
        this._perspectiveCamera = new THREE.PerspectiveCamera(this._fov, aspect, 1, 10000);
        this._perspectiveCamera["name"] = "Main perspective camera";
        this._perspectiveCamera.matrixAutoUpdate = true;

        // @todo add tour.json parameter to choose a viewfinder type or a texture
        this._viewfinder = new KEN.CameraViewfinder(this._viewer, KEN.CameraViewfinderType.CROSSHAIR);
        this._perspectiveCamera.add(this._viewfinder["object"]);
    }

    return this._perspectiveCamera;
};

/**
 * Apply Camera change internally.
 * @method KEN.Camera#_updateFromEuler
 * @private
 */
KEN.Camera.prototype._updateFromEuler = function()
{
    this._modelView = KEN.Math.eulerToRotationMatrix(this._yaw, this._pitch, this._roll, false);

    this._modelViewInverse = this._modelView.clone().transpose();

    this._quaternion = KEN.Quaternion.fromEuler(this._yaw, this._pitch, this._roll);
};

/**
 * Camera update internals after quaternion has been set
 * @method KEN.Camera#_updateFromQuaternion
 * @private
 */
KEN.Camera.prototype._updateFromQuaternion = function()
{
    this._modelView = KEN.Quaternion.toRotationMatrix(this._quaternion);

    this._modelViewInverse = this._modelView.clone().transpose();

    var euler = KEN.Quaternion.toEuler(this._quaternion);

    this._setAll(euler["yaw"], euler["pitch"], euler["roll"], null, KEN.Math.RADIANS);
};

/**
 * Camera update internals after modelview matrix has been set.
 * @method KEN.Camera#_updateFromMatrix
 * @private
 */
KEN.Camera.prototype._updateFromMatrix = function()
{
    this._modelViewInverse = this._modelView.clone().transpose();

    var euler = KEN.Math.rotationMatrixToEuler(this._modelView);

    this._setAll(euler["yaw"], euler["pitch"], euler["roll"], null, KEN.Math.RADIANS);

    this._quaternion = KEN.Quaternion.fromRotationMatrix(this._modelView);
};

/**
 * THREE Perspective camera update internals after modelview matrix has been set.
 * @method KEN.Camera#_updatePerspectiveCamera
 * @private
 */
KEN.Camera.prototype._updatePerspectiveCamera = function()
{
    if (this._perspectiveCamera === null)
    {
        return;
    }

    var mat = new THREE.Matrix4().fromArray(this._modelViewInverse.elements);

    if (this._parallax !== 0)
    {
        var z = -this._parallax * KEN.Camera.RADIUS;
        mat.multiply(new THREE.Matrix4().makeTranslation(0, 0, z));
    }

    this._perspectiveCamera.matrixWorld = mat;
    this._perspectiveCamera.matrixWorldInverse.getInverse(mat);
    this._perspectiveCamera["quaternion"].setFromRotationMatrix(mat);

    this._perspectiveCamera["fov"] = KEN.Math.radToDeg(this._fov);
    this._perspectiveCamera.aspect = this._viewer["renderer"]["displayResolution"]["ratio"];
    this._perspectiveCamera.updateProjectionMatrix();
};

/**
 * Final method call to complete camera update.
 * @method KEN.Camera#_updateComplete
 * @param  {boolean} [dispatch=true] - Does the fianl update have to dispatch a camera change event?
 * @private
 */
KEN.Camera.prototype._updateComplete = function(dispatch)
{
    if (dispatch !== false && this._onCameraChange !== null)
    {
        this._onCameraChange.dispatch(null, true);
    }
};

/**
 * Internal setter for yaw, take a value and a unit. Default unit is radians.
 * @method KEN.Camera#_setYaw
 * @param {?number=} value - The value you want to set for yaw.
 * @param {string=} [unit="radians"] - The unit you use to set the yaw value.
 * @private
 */
KEN.Camera.prototype._setYaw = function(value, unit)
{
    if (typeof value !== "number" || isNaN(value) === true)
    {
        return;
    }

    // If unit is not well defined, default will be radians
    unit = (unit === KEN.Math.DEGREES || unit === KEN.Math.RADIANS) ? unit : KEN.Math.RADIANS;

    // Convert value in radians for clamp if unit is in degrees.
    value = (unit === KEN.Math.DEGREES) ? KEN.Math.degToRad(value) : value;

    // Wrap the value between -PI and +PI
    value = KEN.Math.wrap(value, -Math.PI, Math.PI);

    // Clamp the value between min and max
    this._yaw = KEN.Math.clamp(value, this._yawMin, this._yawMax);
};

/**
 * Internal setter for pitch, take a value and a unit. Default unit is radians.
 * @method KEN.Camera#_setPitch
 * @param {?number=} value - The value you want to set for pitch.
 * @param {string=} [unit="radians"] - The unit you use to set the pitch value.
 * @private
 */
KEN.Camera.prototype._setPitch = function(value, unit)
{
    if (typeof value !== "number" || isNaN(value) === true)
    {
        return;
    }

    // If unit is not well defined, default will be radians
    unit = (unit === KEN.Math.DEGREES || unit === KEN.Math.RADIANS) ? unit : KEN.Math.RADIANS;

    // Convert value in radians for clamp if unit is in degrees.
    value = (unit === KEN.Math.DEGREES) ? KEN.Math.degToRad(value) : value;

    // Wrap the value between -PI and +PI
    value = KEN.Math.wrap(value, -Math.PI, Math.PI);

    // Clamp the value between min and max
    this._pitch = KEN.Math.clamp(value, this._pitchMin, this._pitchMax);
};

/**
 * Internal setter for roll, take a value and a unit. Default unit is radians.
 * @method KEN.Camera#_setRoll
 * @param {?number=} value - The value you want to set for roll.
 * @param {string=} [unit="radians"] - The unit you use to set the roll value.
 * @private
 */
KEN.Camera.prototype._setRoll = function(value, unit)
{
    if (typeof value !== "number" || isNaN(value) === true)
    {
        return;
    }

    // If unit is not well defined, default will be radians
    unit = (unit === KEN.Math.DEGREES || unit === KEN.Math.RADIANS) ? unit : KEN.Math.RADIANS;

    // Convert value in radians for clamp if unit is in degrees.
    value = (unit === KEN.Math.DEGREES) ? KEN.Math.degToRad(value) : value;

    // Wrap the value between -PI and +PI
    value = KEN.Math.wrap(value, -Math.PI, Math.PI);

    // Clamp the value between min and max
    this._roll = KEN.Math.clamp(value, this._rollMin, this._rollMax);
};

/**
 * Internal setter for fov (field of view), take a value and a unit. Default unit is radians.
 * @method KEN.Camera#_setFov
 * @param {?number=} value - The value you want to set for fov.
 * @param {string=} [unit="radians"] - The unit you use to set the fov value.
 * @private
 */
KEN.Camera.prototype._setFov = function(value, unit)
{
    if (typeof value !== "number" || isNaN(value) === true)
    {
        return;
    }

    // If unit is not well defined, default will be radians
    unit = (unit === KEN.Math.DEGREES || unit === KEN.Math.RADIANS) ? unit : KEN.Math.RADIANS;

    // Convert value in radians for clamp if unit is in degrees.
    value = (unit === KEN.Math.DEGREES) ? KEN.Math.degToRad(value) : value;

    this._fov = KEN.Math.clamp(value, this._fovMin, this._fovMax);
};

/**
 * Set all camera angles in one call (yaw, pitch, roll, fov)
 * @method KEN.Camera#_setAll
 * @param {?number=} yaw - The yaw value you want to set.
 * @param {?number=} pitch - The pitch value you want to set.
 * @param {?number=} roll - The roll value you want to set.
 * @param {?number=} fov - The fov value you want to set.
 * @param {string=} unit - The unit you use for all the previous arguments (KEN.Math.DEGREES or KEN.Math.RADIANS)
 * @private
 */
KEN.Camera.prototype._setAll = function(yaw, pitch, roll, fov, unit)
{
    this._setYaw(yaw, unit);
    this._setPitch(pitch, unit);
    this._setRoll(roll, unit);
    this._setFov(fov, unit);
};

/**
 * Load a camera configuration.
 * @method KEN.Camera#load
 * @param {CameraConfig} config - The camera configuration to load.
 */
KEN.Camera.prototype.load = function(config)
{
    this._config = /** @type {CameraConfig} */ (KEN.Utils.extendMultipleObjects(KEN.Camera.DEFAULT_CONFIG, config));

    this._parseConfig(this._config);
};

/**
 * Set the Camera to look at a specified point into the yaw/pitch/roll space.
 * @method KEN.Camera#lookAt
 * @param {?number=} yaw Euler yaw angle (deg)
 * @param {?number=} pitch Euler pitch angle (deg)
 * @param {?number=} roll Euler roll angle (deg)
 * @param {?number=} fov Field of view (deg)
 * @param {number=} durationMS - Rotation animation duration ms (undefined or zero means immediat effect)
 * @param {boolean=} [cancelRoll=false] - If set to true, roll will be cancelled (always at 0).<br> If false an auto roll movement will be done by the camera for a more natural movement effect.
 * @param {function(number)=} easing - Easing method (default to {@link KEN.Easing.LINEAR}.
 */
KEN.Camera.prototype.lookAt = function(yaw, pitch, roll, fov, durationMS, cancelRoll, easing)
{
    if (typeof durationMS !== "number" || durationMS === 0)
    {
        this._setAll(yaw, pitch, roll, fov, KEN.Math.DEGREES);
        this._updateFromEuler();
        this._updateComplete();
    }
    else
    {
        var waypoints = [new KEN.CameraWaypoint(durationMS, yaw, pitch, roll, fov)];

        this["animation"]["waypoints"] = waypoints;
        this["animation"].play(false, cancelRoll, easing);
    }
};

/**
 * Update routine called by render manager before rendering a frame.
 * @method KEN.Camera#update
 */
KEN.Camera.prototype.update = function()
{
    // All internals should be up to date, just maintain perspective camera here
    this._updatePerspectiveCamera();
};

/**
 * Destroy sequence.
 * @method KEN.Camera#destroy
 */
KEN.Camera.prototype.destroy = function()
{
    this._modelView = null;
    this._modelViewInverse = null;
    this._quaternion = null;
    this._perspectiveCamera = null;
    this._viewfinder = null;

    if (this._onCameraChange !== null)
    {
        this._onCameraChange.destroy();
        this._onCameraChange = null;
    }

    if (this._cameraAnimation !== null)
    {
        this._cameraAnimation.destroy();
        this._cameraAnimation = null;
    }

    this._viewer = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get and set the ycamera configuration (default min & max for all angles yaw, pitch, roll and fov).
 * @name KEN.Camera#config
 * @type {CameraConfig}
 */
KEN.Camera.prototype.config;
Object.defineProperty(KEN.Camera.prototype, "config",
{
    /** @this {KEN.Camera} */
    get: function()
    {
        return this._config;
    },

    /** @this {KEN.Camera} */
    set: function(config)
    {
        this.load(config);
    }
});

/**
 * Get and set the yaw value in degree.
 * @name KEN.Camera#yaw
 * @type {number}
 */
KEN.Camera.prototype.yaw;
Object.defineProperty(KEN.Camera.prototype, "yaw",
{
    /** @this {KEN.Camera} */
    get: function()
    {
        return KEN.Math.radToDeg(this._yaw);
    },

    /** @this {KEN.Camera} */
    set: function(value)
    {
        this._setYaw(value, KEN.Math.DEGREES);
        this._updateFromEuler();
        this._updateComplete();
    }
});

/**
 * Get and set the pitch value in degree.
 * @name KEN.Camera#pitch
 * @type {number}
 */
KEN.Camera.prototype.pitch;
Object.defineProperty(KEN.Camera.prototype, "pitch",
{
    /** @this {KEN.Camera} */
    get: function()
    {
        return KEN.Math.radToDeg(this._pitch);
    },

    /** @this {KEN.Camera} */
    set: function(value)
    {
        this._setPitch(value, KEN.Math.DEGREES);
        this._updateFromEuler();
        this._updateComplete();
    }
});

/**
 * Get and set the roll value in degree.
 * @name KEN.Camera#roll
 * @type {number}
 */
KEN.Camera.prototype.roll;
Object.defineProperty(KEN.Camera.prototype, "roll",
{
    /** @this {KEN.Camera} */
    get: function()
    {
        return KEN.Math.radToDeg(this._roll);
    },

    /** @this {KEN.Camera} */
    set: function(value)
    {
        this._setRoll(value, KEN.Math.DEGREES);
        this._updateFromEuler();
        this._updateComplete();
    }
});

/**
 * Get and set the fov value in degree.
 * @name KEN.Camera#fov
 * @type {number}
 */
KEN.Camera.prototype.fov;
Object.defineProperty(KEN.Camera.prototype, "fov",
{
    /** @this {KEN.Camera} */
    get: function()
    {
        return KEN.Math.radToDeg(this._fov);
    },

    /** @this {KEN.Camera} */
    set: function(value)
    {
        this._setFov(value, KEN.Math.DEGREES);
        this._updateComplete();
    }
});

/**
 * Get and set the minimum fov value in degree.
 * @name KEN.Camera#fovMin
 * @type {number}
 */
KEN.Camera.prototype.fovMin;
Object.defineProperty(KEN.Camera.prototype, "fovMin",
{
    /** @this {KEN.Camera} */
    get: function()
    {
        return KEN.Math.radToDeg(this._fovMin);
    },

    /** @this {KEN.Camera} */
    set: function(value)
    {
        this._fovMin = KEN.Math.degToRad(value);
    }
});

/**
 * Get and set the maximum fov value in degree.
 * @name KEN.Camera#fovMax
 * @type {number}
 */
KEN.Camera.prototype.fovMax;
Object.defineProperty(KEN.Camera.prototype, "fovMax",
{
    /** @this {KEN.Camera} */
    get: function()
    {
        return KEN.Math.radToDeg(this._fovMax);
    },

    /** @this {KEN.Camera} */
    set: function(value)
    {
        this._fovMax = KEN.Math.degToRad(value);
    }
});

/**
 * Get/set quaternion rotation object of the camera.
 * Setter will update internal quaternion object
 * @name KEN.Camera#quaternion
 * @readonly
 * @type {THREE.Quaternion}
 */
KEN.Camera.prototype.quaternion;
Object.defineProperty(KEN.Camera.prototype, "quaternion",
{
    /** @this {KEN.Camera} */
    get: function()
    {
        return this._quaternion;
    },
    /** @this {KEN.Camera} */
    set: function(value)
    {
        this._quaternion = value;
        this._updateFromQuaternion();
        this._updateComplete();
    }
});

/**
 * Get camera animation manager.
 * @name KEN.Camera#animation
 * @readonly
 * @type {KEN.CameraAnimation}
 */
KEN.Camera.prototype.animation;
Object.defineProperty(KEN.Camera.prototype, "animation",
{
    /** @this {KEN.Camera} */
    get: function()
    {
        if (this._cameraAnimation === null)
        {
            this._cameraAnimation = new KEN.CameraAnimation(this._viewer, this);
        }

        return this._cameraAnimation;
    }
});

/**
 * Get/Set parallax setting.
 * @name KEN.Camera#parallax
 * @type number
 */
KEN.Camera.prototype.parallax;
Object.defineProperty(KEN.Camera.prototype, "parallax",
{
    /** @this {KEN.Camera} */
    get: function()
    {
        return this._parallax;
    },
    /** @this {KEN.Camera} */
    set: function(value)
    {
        this._parallax = KEN.Math.clamp(value, 0, 1);
        this._updateComplete();
    }
});

/**
 * Get the modelView of the camera.
 * @name KEN.Camera#modelView
 * @readonly
 * @type {THREE.Matrix4}
 */
KEN.Camera.prototype.modelView;
Object.defineProperty(KEN.Camera.prototype, "modelView",
{
    /** @this {KEN.Camera} */
    get: function()
    {
        return this._modelView;
    }
});

/**
 * Get the modelViewInverse of the camera.
 * @name KEN.Camera#modelViewInverse
 * @readonly
 * @type {THREE.Matrix4}
 */
KEN.Camera.prototype.modelViewInverse;
Object.defineProperty(KEN.Camera.prototype, "modelViewInverse",
{
    /** @this {KEN.Camera} */
    get: function()
    {
        return this._modelViewInverse;
    }
});

/**
 * Get the Three perspectiveCamera of the camera.
 * @name KEN.Camera#perspectiveCamera
 * @readonly
 * @type {THREE.PerspectiveCamera}
 */
KEN.Camera.prototype.perspectiveCamera;
Object.defineProperty(KEN.Camera.prototype, "perspectiveCamera",
{
    /** @this {KEN.Camera} */
    get: function()
    {
        if (this._perspectiveCamera === null)
        {
            this._createPerspectiveCamera();
        }

        return this._perspectiveCamera;
    }
});

/**
 * Get the camera viewfinder.
 * @name KEN.Camera#viewfinder
 * @readonly
 * @type {KEN.CameraViewfinder}
 */
KEN.Camera.prototype.viewfinder;
Object.defineProperty(KEN.Camera.prototype, "viewfinder",
{
    /** @this {KEN.Camera} */
    get: function()
    {
        return this._viewfinder;
    }
});

/**
 * Get the "onCameraChange" {@link KEN.EventDispatcher} of the camera.
 * @name KEN.Camera#onCameraChange
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Camera.prototype.onCameraChange;
Object.defineProperty(KEN.Camera.prototype, "onCameraChange",
{
    /** @this {KEN.Camera} */
    get: function()
    {
        if (this._onCameraChange === null)
        {
            this._onCameraChange = new KEN.EventDispatcher(this);
        }

        return this._onCameraChange;
    }
});
/**
 * A KEN.CameraAnimation is used by the camera to animate along waypoints.
 *
 * @constructor KEN.CameraAnimation
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @param {KEN.Camera} camera - {@link KEN.Camera} reference.
 * @extends {KEN.BaseObject}
 *
 */
KEN.CameraAnimation = function(viewer, camera)
{
    /**
     * Viewer reference.
     * @name KEN.CameraAnimation#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Camera reference.
     * @name  KEN.CameraAnimation#_camera
     * @type {KEN.Camera}
     * @private
     */
    this._camera = camera;

    /**
     * Camera waypoints array.
     * @name KEN.CameraAnimation#_waypoints
     * @type {Array<KEN.CameraWaypoint>}
     * @private
     */
    this._waypoints = null;

    /**
     * Current animation time.
     * @name KEN.CameraAnimation#_time
     * @type {number}
     * @private
     */
    this._time = 0;

    /**
     * Animation duration.
     * @name KEN.CameraAnimation#_duration
     * @type {number}
     * @private
     */
    this._duration = 0;

    /**
     * Previous keyframe.
     * @name KEN.CameraAnimation#_kf0
     * @type {KEN.Keyframe}
     * @private
     */
    this._kf0 = null;

    /**
     * Next keyframe.
     * @name KEN.CameraAnimation#_kf1
     * @type {KEN.Keyframe}
     * @private
     */
    this._kf1 = null;


    /**
     * Left spline for squad algo.
     * @name KEN.CameraAnimation#_a0
     * @type {THREE.Quaternion}
     * @private
     */
    this._a0 = null;

    /**
     * Right spline for squad algo.
     * @name KEN.CameraAnimation#_a1
     * @type {THREE.Quaternion}
     * @private
     */
    this._a1 = null;

    /**
     * Fov source value.
     * @name KEN.CameraAnimation#_fov0
     * @type {number}
     * @private
     */
    this._fov0 = NaN;

    /**
     * Fov destination value.
     * @name KEN.CameraAnimation#_fov1
     * @type {number}
     * @private
     */
    this._fov1 = NaN;

    /**
     * Smooth interpolation flag.
     * @name KEN.CameraAnimation#_smooth
     * @type {boolean}
     * @private
     */
    this._smooth = false;

    /**
     * Timeline reference.
     * @name KEN.CameraAnimation#_timeline
     * @type {KEN.Timeline}
     * @private
     */
    this._timeline = null;

    /**
     * Easing curve to use on start of animation.
     * @name KEN.CameraAnimation#_easingStart
     * @type {Function}
     * @private
     */
    this._easingStart = KEN.Easing.LINEAR;

    /**
     * Easing curve to use on end of animation.
     * @name KEN.CameraAnimation#_easingStart
     * @type {Function}
     * @private
     */
    this._easingEnd = KEN.Easing.LINEAR;

    /**
     * Cancel roll flag. If set to true, the roll will always be 0.
     * @name KEN.CameraAnimation#_cancelRoll
     * @type {boolean}
     * @private
     */
    this._cancelRoll = false;

    /**
     * Tween object.
     * @name KEN.CameraAnimation#_tween
     * @type {KEN.Tween}
     * @private
     */
    this._tween = null;

    /**
     * Tween flag.
     * @name KEN.CameraAnimation#_tweening
     * @type {boolean}
     * @private
     */
    this._tweening = false;

    /**
     * Tween time (normalized in [0 .. 1])
     * @name KEN.CameraAnimation#_tweenTime
     * @type {number}
     * @private
     */
    this._tweenTime = 0;

    /**
     * On camera animation play event dispatcher.
     * @name KEN.CameraAnimation#_onPlay
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onPlay = null;

    /**
     * On camera animation progress event dispatcher.
     * @name KEN.CameraAnimation#_onProgress
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onProgress = null;

    /**
     * On camera animation complete event dispatcher.
     * @name KEN.CameraAnimation#_onComplete
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onComplete = null;

    //KEN.CameraAnimation.call(this, viewer, camera, "CameraAnimation");
    KEN.BaseObject.call(this, "CameraAnimation");

    this._boot();
};

KEN.CameraAnimation.prototype = Object.create(KEN.BaseObject.prototype);
KEN.CameraAnimation.prototype.constructor = KEN.CameraAnimation;

/**
 * Init sequence
 * @method KEN.CameraAnimation#_boot
 * @private
 */
KEN.CameraAnimation.prototype._boot = function()
{
    //Create the tween object and set up some listeners
    this._tween = new KEN.Tween(this._viewer, this);
    this._tween["onStart"].add(this._onTweenStartHandler, this);
    this._tween["onStop"].add(this._onTweenStopHandler, this);
    this._tween["onProgress"].add(this._onTweenProgressHandler, this);
    this._tween["onComplete"].add(this._onTweenCompleteHandler, this);
    this._viewer["tween"].add(this._tween);

    this._timeline = new KEN.Timeline(this._viewer);
};

/**
 * Get quadrangles indexes
 * @method KEN.CameraAnimation#_getQuadranglesIndexes
 * @param {?number} previousInput left input index
 * @param {?number} nextInput right input index
 * @return {TimelineKeyframesPrevNextIndexes} indexes object with left and right properties
 * @private
 */
KEN.CameraAnimation.prototype._getQuadranglesIndexes = function(previousInput, nextInput)
{
    var previousOutput, nextOutput;

    if (previousInput === 0 || this._timeline["keyframes"].length <= 2)
    {
        previousOutput = previousInput;
        nextOutput = nextInput;
    }

    var an, bn;

    for (var i = 0, ii = this._timeline["keyframes"].length; i < ii; i++)
    {
        if (i===previousInput)
        {
            an = i;
            break;
        }
    }

    for (var j = this._timeline["keyframes"].length - 1; j >= 0; j--)
    {
        if (j===nextInput)
        {
            bn = j;
            break;
        }
    }

    previousOutput = Math.max(an - 1, 0);
    nextOutput = Math.min(bn + 1, this._timeline["keyframes"].length - 1);
    this.log("Splines: " + previousOutput + ", " + nextOutput);

    return { previous: previousOutput, next: nextOutput };
};

/**
 * Prepare tween for the next keyframe.<br>
 * 1/ Define the easing method that will be use.<br>
 * 2/ Define the quadrangles if it is a smoothed animation.
 *
 * @method KEN.CameraAnimation#_prepareTween
 * @return {boolean} true if there is a tween to come, false if there's no tween left.
 * @private
 */
KEN.CameraAnimation.prototype._prepareTween = function()
{
    var kfs = this._timeline.getKeyframesFromTime(this._time);
    var indexes = this._timeline.getKeyframesIndexesFromTime(this._time);

    this._kf0 = kfs.previous;
    this._kf1 = kfs.next;

    if (this._kf1 === null)
    {
        return false;
    }

    this._fov0 = this._kf0["data"]["fov"];
    this._fov1 = this._kf1["data"]["fov"];

    if (indexes.previous < 1)
    {
        this._tween["easing"] = this._easingStart || KEN.Easing.LINEAR;
    }
    else if (indexes.next === this._waypoints.length - 1)
    {
        this._tween["easing"] = this._easingEnd || KEN.Easing.LINEAR;
    }
    else
    {
        this._tween["easing"] = KEN.Easing.LINEAR;
    }

    if (this._smooth === true)
    {
        var qIndexes = this._getQuadranglesIndexes(indexes.previous, indexes.next);
        var previous = /** @type {number} */ (qIndexes.previous);
        var next = /** @type {number} */ (qIndexes.next);

        var q0 = this._kf0["data"]["quaternion"];
        var q1 = this._kf1["data"]["quaternion"];

        var q00 = this._timeline._keyframes[previous]["data"];
        var q10 = this._timeline._keyframes[next]["data"];

        this._a0 = KEN.Quaternion.makeQuadrangle(q00, q0, q1);
        this._a1 = KEN.Quaternion.makeQuadrangle(q0, q1, q10);

        this.log("Quaternion q0: [" + q0.w.toFixed(2) + ", " + q0.x.toFixed(2) + ", " + q0.y.toFixed(2) + ", " + q0.z.toFixed(2) + "]");
        this.log("Quadrangle a0: [" + this._a0.w.toFixed(2) + ", " + this._a0.x.toFixed(2) + ", " + this._a0.y.toFixed(2) + ", " + this._a0.z.toFixed(2) + "]");
        this.log("Quadrangle a1: [" + this._a1.w.toFixed(2) + ", " + this._a1.x.toFixed(2) + ", " + this._a1.y.toFixed(2) + ", " + this._a1.z.toFixed(2) + "]");
        this.log("Quaternion q1: [" + q1.w.toFixed(2) + ", " + q1.x.toFixed(2) + ", " + q1.y.toFixed(2) + ", " + q1.z.toFixed(2) + "]");
    }

    return true;
};

/**
 * Interpolation evalutation function.
 * @method KEN.CameraAnimation#_at
 * @param {number} t current time [0 .. tween duration]
 * @private
 */
KEN.CameraAnimation.prototype._at = function(t)
{
    var interval = this._kf1["timestamp"] - this._kf0["timestamp"];
    this._time = (t * interval) + this._kf0["timestamp"];

    var currentIndex = this._timeline.getKeyframesIndexesFromTime(this._time).previous;
    //var kfs = this._timeline.getKeyframesFromTime(this._time);

    if (this._kf1 === null)
    {
        return;
    }

    var alpha = this._tween.easing(t);
    this._camera["fov"] = (1 - alpha) * this._fov0 + alpha * this._fov1;

    var q0 = this._kf0["data"]["quaternion"];
    var q1 = this._kf1["data"]["quaternion"];

    var cameraQuat = this._camera["quaternion"];

    if (this._smooth === false || currentIndex === 0 || currentIndex === this._waypoints.length - 2)
    {
        cameraQuat = KEN.Quaternion.slerpNoInvert(q0, q1, this._tweenTime);
    }
    else
    {
        cameraQuat = KEN.Quaternion.squadNoInvert(q0, this._a0, this._a1, q1, this._tweenTime);
    }

    if (this._cancelRoll === true)
    {
        cameraQuat = KEN.Quaternion.cancelRoll(cameraQuat);
    }

    this._camera["quaternion"] = cameraQuat;
};

/**
 * On tween start event handler.
 * @method KEN.CameraAnimation#_onTweenStartHandler
 * @private
 */
KEN.CameraAnimation.prototype._onTweenStartHandler = function()
{
    this.log("Camera animation start");
    this._tweening = true;

    var currentIndex = this._timeline.getKeyframesIndexesFromTime(this._time).previous;

    if (currentIndex === 0 && this._onPlay !== null)
    {
        this._onPlay.dispatch();
    }
};

/**
 * On tween stop event handler.
 * @method KEN.CameraAnimation#_onTweenStopHandler
 * @private
 */
KEN.CameraAnimation.prototype._onTweenStopHandler = function()
{
    this.log("Camera animation stops");
    this._tweening = false;
};

/**
 * On tween progress event handler.
 * @method KEN.CameraAnimation#_onTweenProgressHandler
 * @private
 */
KEN.CameraAnimation.prototype._onTweenProgressHandler = function()
{
    // this.log("Camera animation tween progress: " + this._tweenTime);
    this._at(this._tweenTime);

    if (this._onProgress !== null)
    {
        this._onProgress.dispatch({progress: this._time / this._duration});
    }
};

/**
 * On tween complete event handler.
 * @method KEN.CameraAnimation#_onTweenCompleteHandler
 * @private
 */
KEN.CameraAnimation.prototype._onTweenCompleteHandler = function()
{
    // Check if a tween is complete or if we have reach the end of the animation.
    this.log("Camera animation tween complete");

    //If there's no tween left, then dispatch the complete event.
    if (this._prepareTween() === false)
    {
        if (this._onComplete !== null)
        {
            this._onComplete.dispatch();
        }
    }
    else
    {
        this._tweenTime = 0;

        // WARNING: let the tweenTime key below in string, if not closure will break the code
        this._tween.to({ "tweenTime": 1 }, (this._kf1["timestamp"] - this._kf0["timestamp"]));
        this._tween.start();
    }
};

/**
 * Get the angular speed betweeen two waypoints.
 * @param  {KEN.CameraWaypoint} wp0 - First waypoint
 * @param  {KEN.CameraWaypoint} wp1 - Second waypoint
 * @return {number} Returns the angular speed.
 * @private
 */
KEN.CameraAnimation.prototype._getAngularSpeed = function(wp0, wp1)
{
    var yaw0 = KEN.Math.degToRad(wp0["yaw"]);
    var pitch0 = KEN.Math.degToRad(wp0["pitch"]);
    var roll0 = KEN.Math.degToRad(wp0["roll"]);
    var quat0 = KEN.Quaternion.fromEuler(yaw0, pitch0, roll0);

    var yaw1 = KEN.Math.degToRad(wp1["yaw"]);
    var pitch1 = KEN.Math.degToRad(wp1["pitch"]);
    var roll1 = KEN.Math.degToRad(wp1["roll"]);
    var quat1 = KEN.Quaternion.fromEuler(yaw1, pitch1, roll1);

    // Compute angular speed between 2 first animation waypoints and
    // set time offset based on this value
    var dt = Math.abs(wp1["ts"] - wp0["ts"]);
    var angularSpeed = Math.abs(KEN.Quaternion.angularDistance(quat0, quat1)) / dt;

    return angularSpeed;
};

/**
 * Load a camera animation waypoints configuration.<br>
 * Convert waypoint into timeline keyframes.
 *
 * @method KEN.CameraAnimation#load
 * @param  {boolean} tweenToStart - animation configuration
 */
KEN.CameraAnimation.prototype._convertWaypoints = function(tweenToStart)
{
    tweenToStart = (typeof tweenToStart !== "undefined") ? Boolean(tweenToStart) : true;

    //Reset timeline keyframes
    this._timeline["keyframes"] = [];

    // Set quaternions array -> N elements
    var timeOffset = 0;

    for (var i = 0, ii = this._waypoints.length; i < ii; i++)
    {
        var wp = this._waypoints[i];

        var yaw = KEN.Math.degToRad(wp["yaw"]);
        var pitch = KEN.Math.degToRad(wp["pitch"]);
        var roll = KEN.Math.degToRad(wp["roll"]);
        var quat = KEN.Quaternion.fromEuler(yaw, pitch, roll);

        // Add a first waypoint to reach the first waypoint
        if (i === 0 && tweenToStart === true)
        {
            var kf0;
            if(this._waypoints.length > 1)
            {
                var angle = KEN.Quaternion.angularDistance(this._camera["quaternion"], quat);
                if (KEN.Math.radToDeg(angle) > 0.01)
                {
                    var angularSpeed = this._getAngularSpeed(wp, this._waypoints[1]);
                    timeOffset = angle / angularSpeed;
                    //this.log("timeOffset >>> " + timeOffset);
                }
            }

            kf0 = new KEN.Keyframe(0, {quaternion: this._camera["quaternion"], fov: this._camera["fov"]});
            this._timeline["keyframes"].push(kf0);
        }

        var e = KEN.Quaternion.toEuler(quat);
        this.log(KEN.Math.radToDeg(e["yaw"]).toFixed() + ", " + KEN.Math.radToDeg(e["pitch"]).toFixed() + ", " + KEN.Math.radToDeg(e["roll"]).toFixed());

        var kf = new KEN.Keyframe(wp["ts"] + timeOffset, {quaternion: quat, fov: wp["fov"]});
        this._timeline["keyframes"].push(kf);
    }

    this._duration = this._timeline["keyframes"][this._timeline["keyframes"].length-1]["timestamp"];

    // Debug
    // for (var i=0,ii = this._waypoints.length-1; i<ii; i++)
    // {
    //     var key0 = this._waypoints[i];
    //     var yaw = KEN.Math.degToRad(key0["yaw"]);
    //     var pitch = KEN.Math.degToRad(key0["pitch"]);
    //     var roll = KEN.Math.degToRad(key0["roll"]);
    //     var q0 = KEN.Quaternion.fromEuler(yaw, pitch, roll);

    //     var key1 = this._waypoints[i+1];
    //     yaw = KEN.Math.degToRad(key1["yaw"]);
    //     pitch = KEN.Math.degToRad(key1["pitch"]);
    //     roll = KEN.Math.degToRad(key1["roll"]);
    //     var q1 = KEN.Quaternion.fromEuler(yaw, pitch, roll);

    //     var angle = KEN.Math.radToDeg(KEN.Quaternion.angularDistance(q0, q1));
    //     this.log("Angle (" + i + ", " + (i+1) + "): " + angle.toFixed() + "");
    // }
};

/**
 * Start to move along the waypoints.
 *
 * @method KEN.CameraAnimation#play
 * @param {boolean} smooth use smooth interpolation (default: false)
 * @param {boolean} cancelRoll rotation will disallow roll if true (default: false)
 * @param {Function} easingStart start easing curve
 * @param {Function} easingEnd end easing curve
 */
KEN.CameraAnimation.prototype.play = function(smooth, cancelRoll, easingStart, easingEnd, tweenToStart)
{
    this._smooth = (typeof smooth !== "undefined") ? smooth : false;
    this._cancelRoll = (typeof cancelRoll !== "undefined") ? cancelRoll : false;
    this._easingStart = (typeof easingStart !== "undefined") ? easingStart : KEN.Easing.SINE_IN;
    this._easingEnd = (typeof easingEnd !== "undefined") ? easingEnd : KEN.Easing.SINE_OUT;

    tweenToStart = (typeof tweenToStart !== "undefined") ? Boolean(tweenToStart) : true;

    // Stop tween if in progress
    if (this._tweening === true)
    {
        this._tween.stop();
    }

    this._convertWaypoints(tweenToStart);

    this._time = 0;
    this._prepareTween();

    this._tweenTime = 0;
    var kfs = this._timeline.getKeyframesFromTime(0);

    // WARNING: let the tweenTime key below in string, if not closure will break the code
    this._tween.to({ "tweenTime": 1 }, (kfs.next["timestamp"] - kfs.previous["timestamp"]));
    this._tween.start();

    this._started = true;
};

/**
 * Stop the current animation
 * @method  KEN.CameraAnimation#stop
 */
KEN.CameraAnimation.prototype.stop = function()
{
    // Stop tween if in progress
    if (this._tweening === true)
    {
        this._tween.stop();
    }
};

/**
 * Destroy sequence.
 * @method KEN.CameraAnimation#destroy
 */
KEN.CameraAnimation.prototype.destroy = function()
{
    this._timeline = null;
    this._waypoints = null;

    this._a0 = null;
    this._a1 = null;

    this._kf0 = null;
    this._kf1 = null;

    if(this._onPlay !== null)
    {
        this._onPlay.destroy();
        this._onPlay = null;
    }

    if(this._onProgress !== null)
    {
        this._onProgress.destroy();
        this._onProgress = null;
    }

    if(this._onComplete !== null)
    {
        this._onComplete.destroy();
        this._onComplete = null;
    }

    if(this._tween !== null)
    {
        this._tween.destroy();
        this._tween = null;
    }

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * AGet and set the waypoints array
 * @name KEN.CameraAnimation#waypoints
 * @type {Array<KEN.CameraWaypoint>}
 */
KEN.CameraAnimation.prototype.waypoints;
Object.defineProperty(KEN.CameraAnimation.prototype, "waypoints",
{
    /** @this {KEN.CameraAnimation} */
    get: function()
    {
        return this._waypoints;
    },
    /** @this {KEN.CameraAnimation} */
    set: function(value)
    {
        this._waypoints = [];

        if(KEN.Utils.isArrayOf(value, "CameraWaypoint") === true)
        {
            this._waypoints = value;
        }
        else
        {
            this.warn("Waypoints array is wrong!");
        }
    }
});

/**
 * Accessors to normalized tween time [0..1]
 * @name KEN.CameraAnimation#tweenTime
 * @type {number}
 */
KEN.CameraAnimation.prototype.tweenTime;
Object.defineProperty(KEN.CameraAnimation.prototype, "tweenTime",
{
    /** @this {KEN.CameraAnimation} */
    get: function()
    {
        return this._tweenTime;
    },
    /** @this {KEN.CameraAnimation} */
    set: function(value)
    {
        this._tweenTime = value;
    }
});

/**
 * No roll property. Freezes roll to zero everytime if true.
 * @name KEN.CameraAnimation#cancelRoll
 * @type {boolean}
 */
KEN.CameraAnimation.prototype.cancelRoll;
Object.defineProperty(KEN.CameraAnimation.prototype, "cancelRoll",
{
    /** @this {KEN.CameraAnimation} */
    get: function()
    {
        return this._cancelRoll;
    },
    /** @this {KEN.CameraAnimation} */
    set: function(value)
    {
        this._cancelRoll = value;
    }
});

/**
 * Get the "onPlay" {@link KEN.EventDispatcher} of the camera.
 * @name KEN.CameraAnimation#onPlay
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.CameraAnimation.prototype.onPlay;
Object.defineProperty(KEN.CameraAnimation.prototype, "onPlay",
{
    /** @this {KEN.CameraAnimation} */
    get: function()
    {
        if(this._onPlay === null)
        {
            this._onPlay = new KEN.EventDispatcher(this);
        }

        return this._onPlay;
    }
});

/**
 * Get the "onProgress" {@link KEN.EventDispatcher} of the camera.
 * @name KEN.CameraAnimation#onProgress
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.CameraAnimation.prototype.onProgress;
Object.defineProperty(KEN.CameraAnimation.prototype, "onProgress",
{
    /** @this {KEN.CameraAnimation} */
    get: function()
    {
        if(this._onProgress === null)
        {
            this._onProgress = new KEN.EventDispatcher(this);
        }

        return this._onProgress;
    }
});

/**
 * Get the "onComplete" {@link KEN.EventDispatcher} of the camera.
 * @name KEN.CameraAnimation#onComplete
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.CameraAnimation.prototype.onComplete;
Object.defineProperty(KEN.CameraAnimation.prototype, "onComplete",
{
    /** @this {KEN.CameraAnimation} */
    get: function()
    {
        if(this._onComplete === null)
        {
            this._onComplete = new KEN.EventDispatcher(this);
        }

        return this._onComplete;
    }
});
/**
 * A KEN.CameraWaypoint defines a point on a camera path
 * It embeds following information:
 *  - timestamp
 *  - orientation
 *  - field of view
 *
 * @constructor KEN.CameraWaypoint
 * @param {number=} ts timestamp [milliseconds]
 * @param {?number=} yaw euler yaw angle around y axis [degrees]
 * @param {?number=} pitch euler pitch angle around x axis [degrees]
 * @param {?number=} roll euler roll angle around z axis [degrees]
 * @param {?number=} fov vertical field of view [degrees]
 * @extends {KEN.BaseObject}
 */
KEN.CameraWaypoint = function(ts, yaw, pitch, roll, fov)
{
    /**
     * Timestamp [miliseconds]
     * @type {number}
     * @name KEN.CameraWaypoint#_ts
     * @private
     */
    this._ts = ts || 0;

    /**
     * Yaw angle
     * @type {number}
     * @name KEN.CameraWaypoint#_yaw
     * @private
     */
    this._yaw = yaw || 0;

    /**
     * Pitch angle
     * @type {number}
     * @name KEN.CameraWaypoint#_pitch
     * @private
     */
    this._pitch = pitch || 0;

    /**
     * Roll angle
     * @type {number}
     * @name KEN.CameraWaypoint#_roll
     * @private
     */
    this._roll = roll || 0;

    /**
     * Field of view
     * @type {number}
     * @name KEN.CameraWaypoint#_fov
     * @private
     */
    this._fov = fov || 0;

    KEN.BaseObject.call(this, "CameraWaypoint");
};

KEN.CameraWaypoint.prototype = Object.create(KEN.BaseObject.prototype);
KEN.CameraWaypoint.prototype.constructor = KEN.CameraWaypoint;

/**
 * Get camera path point timestamp
 * @name KEN.CameraWaypoint#ts
 * @readonly
 * @type {number}
 */
KEN.CameraWaypoint.prototype.ts;
Object.defineProperty(KEN.CameraWaypoint.prototype, "ts",
{
    /** @this {KEN.CameraWaypoint} */
    get: function()
    {
        return this._ts;
    },
    /** @this {KEN.CameraWaypoint} */
    set: function(value)
    {
        if (typeof value === "number")
        {
            this._ts = value;
        }
    }
});

/**
 * Get camera path point field of view
 * @name KEN.CameraWaypoint#fov
 * @readonly
 * @type {number}
 */
KEN.CameraWaypoint.prototype.fov;
Object.defineProperty(KEN.CameraWaypoint.prototype, "fov",
{
    /** @this {KEN.CameraWaypoint} */
    get: function()
    {
        return this._fov;
    }
});

/**
 * Get camera path point euler yaw angle [degrees]
 * @name KEN.CameraWaypoint#yaw
 * @readonly
 * @type {number}
 */
KEN.CameraWaypoint.prototype.yaw;
Object.defineProperty(KEN.CameraWaypoint.prototype, "yaw",
{
    /** @this {KEN.CameraWaypoint} */
    get: function()
    {
        return this._yaw;
    }
});

/**
 * Get camera path point euler pitch angle [degrees]
 * @name KEN.CameraWaypoint#pitch
 * @readonly
 * @type {number}
 */
KEN.CameraWaypoint.prototype.pitch;
Object.defineProperty(KEN.CameraWaypoint.prototype, "pitch",
{
    /** @this {KEN.CameraWaypoint} */
    get: function()
    {
        return this._pitch;
    }
});

/**
 * Get camera path point euler roll angle [degrees]
 * @name KEN.CameraWaypoint#roll
 * @readonly
 * @type {number}
 */
KEN.CameraWaypoint.prototype.roll;
Object.defineProperty(KEN.CameraWaypoint.prototype, "roll",
{
    /** @this {KEN.CameraWaypoint} */
    get: function()
    {
        return this._roll;
    }
});

/**
 * @namespace {Object} KEN.CameraViewfinderType
 */
KEN.CameraViewfinderType = {};

/**
 * @name KEN.CameraViewfinderType.RING
 * @type {string}
 * @const
 */
KEN.CameraViewfinderType.RING = "ring";

/**
 * @name KEN.CameraViewfinderType.CROSSHAIR
 * @type {string}
 * @const
 */
KEN.CameraViewfinderType.CROSSHAIR = "crosshair";

/**
 * Camera viewfinder
 *
 * @constructor KEN.CameraViewfinder
 * @param {KEN.Viewer} viewer - reference on KEN viewer
 * @param {string} type - viewfinder type
 * @extends {KEN.BaseObject}
 */
KEN.CameraViewfinder = function(viewer, type)
{
    /**
     * The viewer reference.
     * @name KEN.CameraViewfinder#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Viewfinder type
     * @name KEN.CameraViewfinder#_type
     * @type {string}
     * @private
     */
    this._type = type || KEN.CameraViewfinderType.RING;

    /**
     * THREE object
     * @name KEN.CameraViewfinder#_object
     * @type {THREE.Object3D}
     * @private
     */
    this._object = null;

    KEN.BaseObject.call(this, "CameraViewfinder");

    this._boot();
};

KEN.CameraViewfinder.prototype = Object.create(KEN.BaseObject.prototype);
KEN.CameraViewfinder.prototype.constructor = KEN.CameraViewfinder;


/**
 * Boot sequence.
 * @method KEN.CameraViewfinder#_boot
 * @private
 */
KEN.CameraViewfinder.prototype._boot = function()
{
    this._object = this._createMesh();
    this._object["name"] = "CameraViewfinder";
    this._object["position"].z = - 2;
};

/**
 * Create ring object.
 * @method KEN.CameraViewfinder#_createObjectRing
 * @return {THREE.Mesh} mesh ring
 * @private
 */
KEN.CameraViewfinder.prototype._createObjectRing = function()
{
    var material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        opacity: 0.5,
        transparent: true
    });

    var geometry = new THREE.RingBufferGeometry(0.02, 0.04, 32);

    return new THREE.Mesh(geometry, material);
};

/**
 * Create crosshair object.
 * @method KEN.CameraViewfinder#_createObjectCrosshair
 * @return {THREE.Line} crosshair line
 * @private
 */
KEN.CameraViewfinder.prototype._createObjectCrosshair = function()
{
    var material = new THREE.LineBasicMaterial({
        color: 0xffffff,
        linewidth: 4,
        opacity: 0.5,
        transparent: true
    });

    //jscs:disable
    var geometry = new THREE.Geometry();
    geometry.vertices.push(new THREE.Vector3(    0,     0, 0));
    geometry.vertices.push(new THREE.Vector3(-0.05,     0, 0));
    geometry.vertices.push(new THREE.Vector3(    0,     0, 0));
    geometry.vertices.push(new THREE.Vector3( 0.05,     0, 0));
    geometry.vertices.push(new THREE.Vector3(    0,     0, 0));
    geometry.vertices.push(new THREE.Vector3(    0,  0.05, 0));
    geometry.vertices.push(new THREE.Vector3(    0,     0, 0));
    geometry.vertices.push(new THREE.Vector3(    0, -0.05, 0));
    //jscs:enable

    return new THREE.Line(geometry, material);
};

/**
 * Create object.
 * @method KEN.CameraViewfinder#_createMesh
 * @private
 */
KEN.CameraViewfinder.prototype._createMesh = function()
{
    switch (this._type)
    {
        case KEN.CameraViewfinderType.CROSSHAIR:
            return this._createObjectCrosshair();

        // case KEN.CameraViewfinderType.RING:
        default:
            return this._createObjectRing();
    }
};

/**
 * Destroy sequence.
 * @method KEN.CameraViewfinder#destroy
 */
KEN.CameraViewfinder.prototype.destroy = function()
{
    if (this._object !== null)
    {
        this._object.geometry.dispose();
        this._object["material"].dispose();
        this._object = null;
    }

    this._scene = null;
};

/**
 * Viewfinder visibility.
 * @name KEN.CameraViewfinder#visible
 * @type {boolean}
 */
KEN.CameraViewfinder.prototype.visible;
Object.defineProperty(KEN.CameraViewfinder.prototype, "visible",
{
    /** @this {KEN.CameraViewfinder} */
    get: function()
    {
        return this._object["visible"];
    },

    /** @this {KEN.CameraViewfinder} */
    set: function(value)
    {
        this._object["visible"] = value;
    }
});

/**
 * Viewfinder object
 * @name KEN.CameraViewfinder#object
 * @readonly
 * @type {THREE.Mesh}
  */
KEN.CameraViewfinder.prototype.object;
Object.defineProperty(KEN.CameraViewfinder.prototype, "object",
{
    /** @this {KEN.CameraViewfinder} */
    get: function()
    {
        return this._object;
    }
});




/**
 * @constructor KEN.ControllerManager
 * @param {KEN.Viewer} viewer - viewer reference.
 * @extends {KEN.BaseObject}
 */
KEN.ControllerManager = function(viewer)
{
    /**
     * Viewer reference.
     * @name KEN.Controllermanager#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Array of controllers.
     * @name KEN.Controllermanager#_controllers
     * @type {Array<KEN.ControllerBase>}
     * @private
     */
    this._controllers = null;

    /**
     * Event dispatcher for control start.
     * @name KEN.Controllermanager#_onControlStart
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onControlStart = null;

    /**
     * Event dispatcher for control end.
     * @name KEN.Controllermanager#_onControlEnd
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onControlEnd = null;

    KEN.BaseObject.call(this, "ControllerManager");
};

KEN.ControllerManager.prototype = Object.create(KEN.BaseObject.prototype);
KEN.ControllerManager.prototype.constructor = KEN.ControllerManager;

/**
 * Viewer ready handler
 * @method KEN.ControllerManager#_onViewerReady
 * @private
 */
KEN.ControllerManager.prototype._onViewerReady = function()
{
    var camera = this._viewer["renderer"]["camera"];

    this._controllers.push(new KEN.ControllerZoom(this._viewer));
    this._controllers.push(new KEN.ControllerPanScreen(this._viewer));
    // this._controllers.push(new KEN.ControllerPanWorld(this._viewer, camera));
};

/**
 * Parse configuration object
 * @method KEN.ControllerManager#_parseConfig
 * @param {ControlsConfig} config - The config you want to add.
 * @private
 */
KEN.ControllerManager.prototype._parseConfig = function(config)
{
    for (var i = 0, ii = config.length; i < ii; i++)
    {
        var item = config[i];

        for (var j = 0, jj = this._controllers.length; j < jj; j++)
        {
            var controller = this._controllers[j];

            if (controller["className"] === item["type"] && item["options"] !== null)
            {
                if (typeof controller.addConfig === "function")
                {
                    controller.addConfig(item["options"]);
                }
            }
        }
    }
};

/**
 * Controllers will call this method to notify the manager that a control start.
 * @method KEN.ControllerManager#notifyControlStart
 * @param  {KEN.ControllerBase} controller - The controller that notifies the manager.
 */
KEN.ControllerManager.prototype.notifyControlStart = function(controller)
{
    if(this._onControlStart !== null)
    {
        this._onControlStart.dispatch({"controller": controller});
    }
};

/**
 * Controllers will call this method to notify the manager that a controller ends.
 * @method KEN.ControllerManager#notifyControlEnd
 * @param  {KEN.ControllerBase} controller - The controller that notifies the manager.
 */
KEN.ControllerManager.prototype.notifyControlEnd = function(controller)
{
    if(this._onControlEnd !== null)
    {
        this._onControlEnd.dispatch({"controller": controller});
    }
};

/**
 * Controllers update routine
 * @method KEN.ControllerManager#update
 */
KEN.ControllerManager.prototype.update = function()
{
    if (this._controllers === null)
    {
        return;
    }

    for(var i = 0, ii = this._controllers.length; i < ii; i++)
    {
        if (typeof this._controllers[i].update === "function")
        {
            this._controllers[i].update();
        }
    }
};

/**
 * Add a config to the manager.
 * @method KEN.ControllerManager#addConfig
 * @param {ControlsConfig} config - The config you want to add.
 */
KEN.ControllerManager.prototype.addConfig = function(config)
{
    this._parseConfig(config);
};

/**
 * Boot sequence.
 * @method KEN.ControllerManager#boot
 */
KEN.ControllerManager.prototype.boot = function()
{
    this._controllers = [];

    this._viewer["onReady"].add(this._onViewerReady, this);
};

/**
 * Destroy method.
 */
KEN.ControllerManager.prototype.destroy = function()
{
    this._viewer["onReady"].remove(this._onViewerReady, this);

    var count = this._controllers.length - 1;
    while(count--)
    {
        this._controllers[count].destroy();
        this._controllers[count] = null;
    }
    this._controllers = null;

    if(this._onControlStart !== null)
    {
        this._onControlStart.destroy();
        this._onControlStart = null;
    }

    if(this._onControlEnd !== null)
    {
        this._onControlEnd.destroy();
        this._onControlEnd = null;
    }

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get all controllers.
 * @name KEN.ControllerManager#all
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.ControllerManager.prototype.all;
Object.defineProperty(KEN.ControllerManager.prototype, "all",
{
    /** @this {KEN.ControllerManager} */
    get: function()
    {
        return this._controllers;
    }
});

/**
 * know if any of the controllers is currently in use
 * @name KEN.ControllerManager#active
 * @readonly
 * @type {boolean}
 */
KEN.ControllerManager.prototype.active;
Object.defineProperty(KEN.ControllerManager.prototype, "active",
{
    /** @this {KEN.ControllerManager} */
    get: function()
    {
        for(var i = 0, ii = this._controllers.length; i < ii; i++)
        {
            if(this._controllers[i]["active"] === true)
            {
                return true;
            }
        }

        return false;
    }
});

/**
 * Get the "onControlStart" {@link KEN.EventDispatcher} of the camera controller.
 * @name KEN.ControllerManager#onControlStart
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.ControllerManager.prototype.onControlStart;
Object.defineProperty(KEN.ControllerManager.prototype, "onControlStart",
{
    /** @this {KEN.ControllerManager} */
    get: function()
    {
        if(this._onControlStart === null)
        {
            this._onControlStart = new KEN.EventDispatcher(this);
        }

        return this._onControlStart;
    }
});

/**
 * Get the "onControlEnd" {@link KEN.EventDispatcher} of the camera controller.
 * @name KEN.ControllerManager#onControlEnd
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.ControllerManager.prototype.onControlEnd;
Object.defineProperty(KEN.ControllerManager.prototype, "onControlEnd",
{
    /** @this {KEN.ControllerManager} */
    get: function()
    {
        if(this._onControlEnd === null)
        {
            this._onControlEnd = new KEN.EventDispatcher(this);
        }

        return this._onControlEnd;
    }
});
/**
 * KEN.ControllerBase
 * CameraBaseController class.
 *
 * Base controller class
 *
 * @constructor KEN.ControllerBase
 * @param {KEN.Viewer} viewer KEN viewer
 * @param {string=} className - subclass className
 * @extends {KEN.BaseObject}
 */
KEN.ControllerBase = function(viewer, className)
{
    /**
     * Viewer reference
     * @type {KEN.Viewer}
     * @name KEN.ControllerBase#_viewer
     * @private
     */
    this._viewer = viewer;

    /**
     * Main camera reference.
     * @type {KEN.Camera}
     * @name KEN.ControllerBase#_camera
     * @private
     */
    this._camera = null;

    /**
     * Enabled state flag.
     * @type {boolean}
     * @name KEN.ControllerBase#_enabled
     * @private
     */
    this._enabled = true;

    /**
     * Active state flag.
     * @type {boolean}
     * @name KEN.ControllerBase#_active
     * @private
     */
    this._active = false;

    /**
     * Control start event handler.
     * @type {KEN.EventDispatcher}
     * @name KEN.ControllerBase#_onControlStart
     * @private
     */
    this._onControlStart = null;

    /**
     * Control end event handler.
     * @type {KEN.EventDispatcher}
     * @name KEN.ControllerBase#_onControlEnd
     * @private
     */
    this._onControlEnd = null;

    KEN.BaseObject.call(this, className || "ControllerBase");

    this._boot();
};

KEN.ControllerBase.prototype = Object.create(KEN.BaseObject.prototype);
KEN.ControllerBase.prototype.constructor = KEN.ControllerBase;

/**
 * Boot sequence.
 * @method KEN.ControllerBase#_boot
 * @private
 */
KEN.ControllerBase.prototype._boot = function()
{
    this._viewer["canvas"]["pointer"]["enabled"] = true;

    this._camera = this._viewer["renderer"]["camera"];
};

/**
 * Destroy sequence.
 * @method KEN.ControllerBase#destroy
 * @private
 */
KEN.ControllerBase.prototype.destroy = function()
{
    this._camera = null;
    this._viewer = null;

    if(this._onControlStart !== null)
    {
        this._onControlStart.destroy();
        this._onControlStart = null;
    }

    if(this._onControlEnd !== null)
    {
        this._onControlEnd.destroy();
        this._onControlEnd = null;
    }
};

/**
 * Get the "onCameraChange" {@link KEN.EventDispatcher} of the camera controller.
 * @name KEN.ControllerBase#active
 * @type {boolean}
 * @readonly
 */
KEN.ControllerBase.prototype.active;
Object.defineProperty(KEN.ControllerBase.prototype, "active",
{
    /** @this {KEN.ControllerBase} */
    get: function()
    {
        return this._active;
    }
});

/**
 * Get the "onCameraChange" {@link KEN.EventDispatcher} of the camera controller.
 * @name KEN.ControllerBase#onControlStart
 * @type {KEN.EventDispatcher}
 * @readonly
 */
KEN.ControllerBase.prototype.onControlStart;
Object.defineProperty(KEN.ControllerBase.prototype, "onControlStart",
{
    /** @this {KEN.ControllerBase} */
    get: function()
    {
        if(this._onControlStart === null)
        {
            this._onControlStart = new KEN.EventDispatcher(this);
        }

        return this._onControlStart;
    }
});

/**
 * Get the "onCameraChange" {@link KEN.EventDispatcher} of the camera controller.
 * @name KEN.ControllerBase#onControlEnd
 * @type {KEN.EventDispatcher}
 * @readonly
 */
KEN.ControllerBase.prototype.onControlEnd;
Object.defineProperty(KEN.ControllerBase.prototype, "onControlEnd",
{
    /** @this {KEN.ControllerBase} */
    get: function()
    {
        if(this._onControlEnd === null)
        {
            this._onControlEnd = new KEN.EventDispatcher(this);
        }

        return this._onControlEnd;
    }
});
/**
 * CameraPanControllerScreen class.
 *
 * This controller takes pan events on screen to animate camera moves
 * Camera angles are changed proportionnally with velocities on X and Y axis
 *
 * @constructor KEN.ControllerPanScreen
 * @param {KEN.Viewer} viewer KEN viewer
 * @extends {KEN.ControllerBase}
 */
KEN.ControllerPanScreen = function(viewer)
{
    /**
     * Hardness factor impatcing controller response to some instant force.
     * @name KEN.ControllerPanScreen#_hardness
     * @type {number}
     * @private
     */
    this._hardness = 0;

    /**
     * Damping factor controlling inertia.
     * @name KEN.ControllerPanScreen#_damping
     * @type {number}
     * @private
     */
    this._damping = 0;

    /**
     * Maximum velocity.
     * @name KEN.ControllerPanScreen#_velocityMax
     * @type {number}
     * @private
     */
    this._velocityMax = 0;

    /**
     * Drag in push mode if false and in pull mode if true.
     * @name KEN.ControllerPanScreen#_inversion
     * @type {boolean}
     * @private
     */
    this._inversion = false;

    /**
     * Previous position vector.
     * @name KEN.ControllerPanScreen#_positionStart
     * @type {THREE.Vector2}
     * @private
     */
    this._positionStart = null;

    /**
     * Previous position vector.
     * @name KEN.ControllerPanScreen#_positionCurrent
     * @type {THREE.Vector2}
     * @private
     */
    this._positionCurrent = null;

    /**
     * Current velocity vector.
     * @name KEN.ControllerPanScreen#_velocity
     * @type {THREE.Vector2}
     * @private
     */
    this._velocity = null;

    /**
     * Previous velocity vector.
     * @name KEN.ControllerPanScreen#_inertia
     * @type {THREE.Vector2}
     * @private
     */
    this._inertia = null;

    KEN.ControllerBase.call(this, viewer, "ControllerPanScreen");
};

KEN.ControllerPanScreen.prototype = Object.create(KEN.ControllerBase.prototype);
KEN.ControllerPanScreen.prototype.constructor = KEN.ControllerPanScreen;

/**
 * Boot sequence.
 * @method KEN.ControllerPanScreen#_boot
 * @private
 */
KEN.ControllerPanScreen.prototype._boot = function()
{
    KEN.ControllerBase.prototype._boot.call(this);

    this._inertia = new THREE.Vector2();
    this._velocity = new THREE.Vector2();
    this._positionStart = new THREE.Vector2();
    this._positionCurrent = new THREE.Vector2();

    this._hardness = 0.6;
    this._damping = 0.15;
    this._velocityMax = 300;
    this._inversion = false;

    this.enable();
};

/**
 * Pan start event handler.
 * @method KEN.ControllerPanScreen#_panStartHandler
 * @param {KEN.Event} event - Event object
 * @private
 */
KEN.ControllerPanScreen.prototype._panStartHandler = function(event)
{
    this._viewer["canvas"]["pointer"]["onPanMove"].add(this._panMoveHandler, this);
    this.log("_panStartHandler (" + event["data"].velocityX.toFixed(2) + ", " + event["data"].velocityY.toFixed(2) + ")");

    this._active = true;

    this._positionStart = new THREE.Vector2(event["data"]["center"].x, event["data"]["center"].y);
    this._positionCurrent.copy(this._positionStart);

    this._velocity.set(0, 0);

    if (this._onControlStart !== null)
    {
        this._onControlStart.dispatch();
    }

    this._viewer["controllers"].notifyControlStart(this);
};

/**
 * Pan move event handler.
 * @method KEN.ControllerPanScreen#_panMoveHandler
 * @param {KEN.Event} event - Event object
 * @private
 */
KEN.ControllerPanScreen.prototype._panMoveHandler = function(event)
{
    this._positionCurrent.set(event["data"]["center"].x, event["data"]["center"].y);
    // this.log("Current position: " + this._positionCurrent.x + ", " + this._positionCurrent.y);
};

/**
 * Pan end event handler.
 * @method KEN.ControllerPanScreen#_panEndHandler
 * @private
 */
KEN.ControllerPanScreen.prototype._panEndHandler = function()
{
    this._viewer["canvas"]["pointer"]["onPanMove"].remove(this._panMoveHandler, this);
    this.log("_panEndHandler");

    this._active = false;

    this._velocity.set(0, 0);
    this._positionStart.set(0, 0);
    this._positionCurrent.copy(this._positionStart);

    if (this._onControlEnd !== null)
    {
        this._onControlEnd.dispatch();
    }

    this._viewer["controllers"].notifyControlEnd(this);
};

/**
 * Enable controller
 * @method KEN.ControllerPanScreen#enable
 */
KEN.ControllerPanScreen.prototype.enable = function()
{
    this._viewer["canvas"]["pointer"]["onPanStart"].add(this._panStartHandler, this);
    this._viewer["canvas"]["pointer"]["onPanEnd"].add(this._panEndHandler, this);
};

/**
 * Disable controller
 * @method KEN.ControllerPanScreen#disable
 */
KEN.ControllerPanScreen.prototype.disable = function()
{
    this._viewer["canvas"]["pointer"]["onPanStart"].remove(this._panStartHandler, this);
    this._viewer["canvas"]["pointer"]["onPanMove"].remove(this._panMoveHandler, this);
    this._viewer["canvas"]["pointer"]["onPanEnd"].remove(this._panEndHandler, this);
};

/**
 * Update routine.
 * @method KEN.ControllerPanScreen#update
 */
KEN.ControllerPanScreen.prototype.update = function()
{
    var size = this._viewer["renderer"]["displayResolution"];
    var hardness = 1 / (this._hardness * Math.min(size["width"], size["height"]));

    this._velocity.subVectors(this._positionCurrent, this._positionStart);

    if (this._velocity.length() > this._velocityMax)
    {
        this._velocity.setLength(this._velocityMax);
    }

    this._velocity.multiplyScalar(hardness);

    // this.log("Current velocity: " + this._velocity.x + ", " + this._velocity.y);

    var inversion = this._inversion ? -1 : 1;
    this._camera["yaw"] += inversion * (this._velocity.x + this._inertia.x);
    this._camera["pitch"] -= inversion * (this._velocity.y + this._inertia.y);

    // Damping 1 -> stops instantly, 0 infinite rebounds
    this._inertia.add(this._velocity).multiplyScalar(KEN.Math.clamp(1 - this._damping, 0, 1));
};

/**
 * Abstract addConfig routine.
 * @method KEN.ControllerPanScreen#addConfig
 * @param {PanScreenConfig} config - configuration object
 */
KEN.ControllerPanScreen.prototype.addConfig = function(config)
{
    if (config.hardness !== null)
    {
        this._hardness = config.hardness;
    }

    if (config.damping !== null)
    {
        this._damping = config.damping;
    }

    if (config.velocityMax !== null)
    {
        this._velocityMax = config.velocityMax;
    }

    if (config.inversion !== null)
    {
        this._inversion = config.inversion;
    }
};

/**
 * Destroy routine
 * @method KEN.ControllerPanScreen#destroy
 */
KEN.ControllerPanScreen.prototype.destroy = function()
{
    KEN.ControllerBase.prototype.destroy.call(this);
};

/**
 * Get or set the enabled flag.
 * @name KEN.ControllerPanScreen#enabled
 * @type {boolean}
 */
KEN.ControllerPanScreen.prototype.enabled;
Object.defineProperty(KEN.ControllerPanScreen.prototype, "enabled",
{
    /** @this {KEN.ControllerPanScreen} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {KEN.ControllerPanScreen} */
    set: function(value)
    {
        if (Boolean(value) === true)
        {
            this.enable();
        }
        else
        {
            this.disable();
        }
    }
});

/**
 * CameraPanControllerWorld class.
 *
 * This controller takes pan events on screen to animate camera moves
 * Camera angles are changed using current view projection of current screen coordinates
 *
 * @constructor KEN.ControllerPanWorld
 * @param {KEN.Viewer} viewer KEN viewer
 * @extends {KEN.ControllerBase}
 */
KEN.ControllerPanWorld = function(viewer)
{
    KEN.ControllerBase.call(this, viewer, "ControllerPanWorld");

    this._boot();
};

KEN.ControllerPanWorld.prototype = Object.create(KEN.ControllerBase.prototype);
KEN.ControllerPanWorld.prototype.constructor = KEN.ControllerPanWorld;

/**
 * Boot sequence.
 * @method KEN.ControllerPanWorld#_boot
 * @private
 */
KEN.ControllerPanWorld.prototype._boot = function()
{
    KEN.ControllerBase.prototype._boot.call(this);

    this._viewer["canvas"]["pointer"]["onPanStart"].add(this._panStartHandler, this);
    this._viewer["canvas"]["pointer"]["onPanEnd"].add(this._panEndHandler, this);
};

/**
 * Pan start event handler.
 * @method KEN.ControllerPanWorld#_panStartHandler
 * @param {KEN.Event} event - Event object
 * @private
 */
KEN.ControllerPanWorld.prototype._panStartHandler = function(event)
{
    this._viewer["canvas"]["pointer"]["onPanMove"].add(this._panMoveHandler, this);
    this.log("_panStartHandler "+event);
};

/**
 * Pan move event handler.
 * @method KEN.ControllerPanWorld#_panMoveHandler
 * @param {KEN.Event} event - Event object
 * @private
 */
KEN.ControllerPanWorld.prototype._panMoveHandler = function(event)
{
    this.log("_panMoveHandler "+event);
};

/**
 * Pan end event handler.
 * @method KEN.ControllerPanWorld#_panEndHandler
 * @param {KEN.Event} event - Event object
 * @private
 */
KEN.ControllerPanWorld.prototype._panEndHandler = function(event)
{
    this._viewer["canvas"]["pointer"]["onPanMove"].remove(this._panMoveHandler, this);
    this.log("_panEndHandler "+event);
};

/**
 * Enable controller
 * @method KEN.ControllerPanWorld#enable
 */
KEN.ControllerPanWorld.prototype.enable = function()
{
    this._viewer["canvas"]["pointer"]["onPanStart"].add(this._panStartHandler, this);
    this._viewer["canvas"]["pointer"]["onPanEnd"].add(this._panEndHandler, this);
};

/**
 * Disable controller.
 * @method KEN.ControllerPanWorld#disable
 */
KEN.ControllerPanWorld.prototype.disable = function()
{
    this._viewer["canvas"]["pointer"]["onPanStart"].remove(this._panStartHandler, this);
    this._viewer["canvas"]["pointer"]["onPanMove"].remove(this._panMoveHandler, this);
    this._viewer["canvas"]["pointer"]["onPanEnd"].remove(this._panEndHandler, this);
};

/**
 * Destroy sequence
 * @method KEN.ControllerPanWorld#destroy
 */
KEN.ControllerPanWorld.prototype.destroy = function()
{
    KEN.ControllerBase.prototype.destroy.call(this);
};

/**
 * Get or set the enabled flag.
 * @name KEN.ControllerPanWorld#enabled
 * @type {boolean}
 */
KEN.ControllerPanWorld.prototype.enabled;
Object.defineProperty(KEN.ControllerPanWorld.prototype, "enabled",
{
    /** @this {KEN.ControllerPanWorld} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {KEN.ControllerPanWorld} */
    set: function(value)
    {
        if(Boolean(value) === true)
        {
            this.enable();
        }
        else
        {
            this.disable();
        }
    }
});

/**
 * CameraControllerZoom class.
 *
 * This controller enables zooming in/out with pinch and mouse wheel events
 *
 * @constructor KEN.ControllerZoom
 * @param {KEN.Viewer} viewer KEN viewer
 * @extends {KEN.ControllerBase}
 */
KEN.ControllerZoom = function(viewer)
{
    /**
     * Hardness factor impacting controller response to some instant force
     * @name KEN.ControllerZoom#_hardness
     * @type {number}
     * @private
     */
    this._hardness = 0;

    /**
     * Drag in push mode if false and in pull mode if true
     * @name KEN.ControllerZoom#_inversion
     * @type {boolean}
     * @private
     */
    this._inversion = false;

    KEN.ControllerBase.call(this, viewer, "ControllerZoom");
};

KEN.ControllerZoom.prototype = Object.create(KEN.ControllerBase.prototype);
KEN.ControllerZoom.prototype.constructor = KEN.ControllerZoom;

/**
 * Boot sequence.
 * @method KEN.ControllerZoom#_boot
 * @private
 */
KEN.ControllerZoom.prototype._boot = function()
{
    KEN.ControllerBase.prototype._boot.call(this);

    this._hardness = 5;
    this._inversion = false;

    this.enable();
};

/**
 * Pinch start event handler.
 * @method KEN.ControllerZoom#_pinchStartHandler
 * @param {KEN.Event} event - Event object
 * @private
 */
KEN.ControllerZoom.prototype._pinchStartHandler = function(event)
{
    this._viewer["canvas"]["pointer"]["onPinchMove"].add(this._pinchMoveHandler, this);
    this.log("_pinchStartHandler "+event);
};

/**
 * Pinch move event handler.
 * @method KEN.ControllerZoom#_pinchMoveHandler
 * @param {KEN.Event} event - Event object
 * @private
 */
KEN.ControllerZoom.prototype._pinchMoveHandler = function(event)
{
    this.log("_pinchMoveHandler " + event["data"]["pinch"]);
};

/**
 * Pinch end event handler.
 * @method KEN.ControllerZoom#_pinchEndHandler
 * @param {KEN.Event} event - Event object
 * @private
 */
KEN.ControllerZoom.prototype._pinchEndHandler = function(event)
{
    this._viewer["canvas"]["pointer"]["onPinchMove"].remove(this._pinchMoveHandler, this);
    this.log("_pinchEndHandler "+event);
};

/**
 * Wheel event handler.
 * @method KEN.ControllerZoom#_wheelHandler
 * @param {KEN.Event} event - Event object
 * @private
 */
KEN.ControllerZoom.prototype._wheelHandler = function(event)
{
    var inversion = this._inversion ? 1 : -1;
    var delta = inversion / this._hardness;

    if (event["data"].deltaY)
    {
        delta *= event["data"].deltaY / 5;
    }

    this._camera["fov"] = KEN.Math.clamp(this._camera["fov"] - delta, this._camera["fovMin"], this._camera["fovMax"]);
    this.log("_wheelHandler (fov:" + this._camera["fov"] + ")");
};

/**
 * Enable controller
 * @method KEN.ControllerZoom#enable
 */
KEN.ControllerZoom.prototype.enable = function()
{
    this._viewer["canvas"]["pointer"]["onPinchStart"].add(this._pinchStartHandler, this);
    this._viewer["canvas"]["pointer"]["onPinchEnd"].add(this._pinchEndHandler, this);
    this._viewer["canvas"]["pointer"]["onWheel"].add(this._wheelHandler, this);
};

/**
 * Disable controller
 * @method KEN.ControllerZoom#disable
 */
KEN.ControllerZoom.prototype.disable = function()
{
    this._viewer["canvas"]["pointer"]["onPinchStart"].remove(this._pinchStartHandler, this);
    this._viewer["canvas"]["pointer"]["onPinchMove"].remove(this._pinchEndHandler, this);
    this._viewer["canvas"]["pointer"]["onPinchEnd"].remove(this._pinchEndHandler, this);
    this._viewer["canvas"]["pointer"]["onWheel"].remove(this._wheelHandler, this);
};

/**
 * Abstract addConfig routine.
 * @method KEN.ControllerZoom#addConfig
 * @param {ZoomConfig} config - configuration object
 */
KEN.ControllerZoom.prototype.addConfig = function(config)
{
    if (config.hardness !== null)
    {
        this._hardness = config.hardness;
    }

    if (config.inversion !== null)
    {
        this._inversion = config.inversion;
    }
};

/**
 * Destroy routine
 * @method KEN.ControllerZoom#destroy
 */
KEN.ControllerZoom.prototype.destroy = function()
{
    KEN.ControllerBase.prototype.destroy.call(this);
};

/**
 * Get or set the enabled flag.
 * @name KEN.ControllerZoom#enabled
 * @type {boolean}
 */
KEN.ControllerZoom.prototype.enabled;
Object.defineProperty(KEN.ControllerZoom.prototype, "enabled",
{
    /** @this {KEN.ControllerZoom} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {KEN.ControllerZoom} */
    set: function(value)
    {
        if(Boolean(value) === true)
        {
            this.enable();
        }
        else
        {
            this.disable();
        }
    }
});


/**
 * A KEN.SoundManager is an object to manage all sounds.
 *
 * @constructor KEN.SoundManager
 * @param {KEN.Viewer} viewer - The {@link KEN.Viewer} reference.
 * @extends {KEN.BaseObject}
 *
 * @todo Start/Stop sound to avoid autoplay
 */
KEN.SoundManager = function(viewer)
{
    /**
     * The viewer reference.
     * @name KEN.SoundManager#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The global sound config backup.
     * @name KEN.SoundManager#_config
     * @type {?AudioConfig}
     * @private
     */
    this._config = null;

    /**
     * The global volume for sounds.
     * @name KEN.SoundManager#_volume
     * @type {number}
     * @private
     */
    this._volume = 1;

    /**
     * The volume has been changed?
     * @name KEN.SoundManager#_volumeChanged
     * @type {boolean}
     * @private
     */
    this._volumeChanged = false;

    /**
     * The default volume for sounds.
     * Can't be greater than the maximum volume.
     * @name KEN.SoundManager#_defaultVolume
     * @type {number}
     * @private
     */
    this._defaultVolume = 1;

    /**
     * The maximum volume for sounds.
     * @name  KEN.SoundManager#_maxVolume
     * @type {number}
     * @private
     */
    this._maxVolume = 1;

    /**
     * The save of the global volume for sounds before a mute.
     * @name KEN.SoundManager#_mutedVolume
     * @type {number}
     * @private
     */
    this._mutedVolume = 1;

    /**
     * Are all sounds muted?
     * @name KEN.SoundManager#_muted
     * @type {boolean}
     * @private
     */
    this._muted = false;

    /**
     * Is the sound manager enabled?
     * @name  KEN.SoundManager#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * Array of {@link KEN.Sound}.
     * @name KEN.SoundManager#_sounds
     * @type {?Array<KEN.Sound>}
     * @private
     */
    this._sounds = null;

    /**
     * Is audio deactivated?
     * @name KEN.SoundManager#_noAudio
     * @type {boolean}
     * @private
     */
    this._noAudio = false;

    /**
     * Is Audio tag activated?
     * @name KEN.SoundManager#_useAudioTag
     * @type {boolean}
     * @private
     */
    this._useAudioTag = false;

    /**
     * Is WebAudio API activated?
     * @name KEN.SoundManager#_useWebAudio
     * @type {boolean}
     * @private
     */
    this._useWebAudio = true;

    /**
     * Number of sound channels.
     * @name KEN.SoundManager#_channels
     * @type {number}
     * @private
     */
    this._channels = 32;

    /**
     * The AudioContext interface.
     * @name KEN.SoundManager#_context
     * @type {?(AudioContext|webkitAudioContext)}
     * @private
     */
    this._context = null;

    /**
     * AnalyserNode to expose audio time and frequency data and create data visualisations.
     * @name KEN.SoundManager#_analyser
     * @type {AnalyserNode}
     * @private
     */
    this._analyser = null;

    /**
     * Master GainNode used to control the overall volume of the audio graph.
     * @name KEN.SoundManager#_masterGain
     * @type {GainNode}
     * @private
     */
    this._masterGain = null;

    /**
     * On sounds muted event dispatcher.
     * @name KEN.SoundManager#_onMute
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onMute = null;

     /**
     * On sounds unmuted event dispatcher.
     * @name KEN.SoundManager#_onUnmute
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onUnmute = null;

    /**
     * On sounds volume change event dispatcher.
     * @name KEN.SoundManager#_onVolumeChange
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onVolumeChange = null;

    /**
     * On sounds disabled event dispatcher.
     * @name KEN.SoundManager#_onDisable
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onDisable = null;

    /**
     * On sounds enabled event dispatcher.
     * @name KEN.SoundManager#_onEnable
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onEnable = null;

    KEN.BaseObject.call(this, "SoundManager");
};

KEN.SoundManager.prototype = Object.create(KEN.BaseObject.prototype);
KEN.SoundManager.prototype.constructor = KEN.SoundManager;

/**
 * Boot sequence.
 * @method KEN.SoundManager#_boot
 * @private
 * @suppress {deprecated}
 */
KEN.SoundManager.prototype.boot = function()
{
    this._sounds = [];

    if (KEN.Device.iOS && KEN.Device.webAudio === false)
    {
        this._channels = 1; //only 1 channel in iOS !
    }

    if (KEN.Device.webAudio === true)
    {
        try
        {
            if (typeof window.AudioContext === "function")
            {
                this._context = new window.AudioContext();
            }
            else
            {
                this._context = new window.webkitAudioContext();
            }
        }
        catch (error)
        {
            this._context = null;
            this._useWebAudio = false;
            this._noAudio = true;
        }
    }

    if (KEN.Device.audioTag === true && this._context === null)
    {
        this._useWebAudio = false;
        this._useAudioTag = true;
        this._noAudio = false;
    }

    if (this._context !== null)
    {
        if (typeof this._context.createGain === "undefined")
        {
            this._masterGain = this._context.createGainNode();
        }
        else
        {
            this._masterGain = this._context.createGain();
        }

        this._analyser = this._context.createAnalyser();
        this._analyser.connect(this._masterGain);

        this._masterGain.gain["value"] = this._volume;
        this._masterGain.connect(this._context.destination);

        // The common coordinate system used with WebGL.
        // The listener is always facing down the negative Z axis, the
        // positive Y axis points up, the positive X axis points right.
        this._context["listener"].setOrientation(0, 0, -1, 0, 1, 0);

        // Set listener poistion to the center of the sphere.
        //this._context["listener"].setPosition(1, 0, 0); // deprecated
    }

    this._viewer["tour"]["onSceneLoadStart"].add(this._sceneLoadStartHandler, this);
};

/**
 * Event handler for scene start.
 * @method KEN.SoundManager#_sceneLoadStartHandler
 * @private
 */
KEN.SoundManager.prototype._sceneLoadStartHandler = function()
{
    if(typeof this._viewer["tour"]["scene"]["config"]["audio"] !== "undefined")
    {
        this._parseSceneConfig(this._viewer["tour"]["scene"]["config"]["audio"]);
    }
    else
    {
        //restore global sounds config
        this._applyConfig(this._config);

        //Is the sound manager enabled?
        if(this._enabled === false)
        {
            if(this._onDisable !== null)
            {
                this._onDisable.dispatch();
            }
        }
        else
        {
            if(this._onEnable !== null)
            {
                this._onEnable.dispatch();
            }
        }
    }
};

/**
 * Parse the scene configuration part related to sounds.
 * @method  KEN.SoundManager#_parseSceneConfig
 * @private
 * @param  {AudioConfig} config - The scene configuration part related to sounds.
 */
KEN.SoundManager.prototype._parseSceneConfig = function(config)
{
    var extendedConfig = /** @type {AudioConfig} */ KEN.Utils.extendMultipleObjects(this._config, config);
    this._applyConfig(extendedConfig);

    //Is the sound manager enabled?
    if(this._enabled === false)
    {
        if(this._onDisable !== null)
        {
            this._onDisable.dispatch();
        }
    }
    else
    {
        if(this._onEnable !== null)
        {
            this._onEnable.dispatch();
        }
    }
};

/**
 * Set values from configuration file.
 * @method  KEN.SoundManager#_applyConfig
 * @param {?AudioConfig} config - The config file.
 * @private
 */
KEN.SoundManager.prototype._applyConfig = function(config)
{
    if(config !== null)
    {
        this._enabled = typeof config["enabled"] !== "undefined" ? Boolean(config["enabled"]) : true;
        this._maxVolume = (typeof config["volume"] !== "undefined" && config["volume"].max === "number") ? KEN.Math.clamp(config["volume"].max, 0, 1) : 1;

        if(this._volumeChanged === false)
        {
            this._defaultVolume = (typeof config["volume"] !== "undefined" && typeof config["volume"]["default"] === "number") ? KEN.Math.clamp(config["volume"]["default"], 0, this._maxVolume) : 1;
        }
        else
        {
            this._defaultVolume = KEN.Math.clamp(this._volume, 0, this._maxVolume);
        }
    }
};

/**
 * Add a sound config to the manager.
 * @method KEN.SoundManager#addConfig
 * @param {AudioConfig} config - The config you want to add.
 */
KEN.SoundManager.prototype.addConfig = function(config)
{
    this._parseConfig(config);

    this._initSounds();
};

/**
 * Parse a playlist config object.
 * @method KEN.SoundManager#_parseConfig
 * @private
 * @param {AudioConfig} config - The config you want to parse.
 */
KEN.SoundManager.prototype._parseConfig = function(config)
{
    this._config = config;

    this._applyConfig(config);
};

/**
 * Initialize the sounds manager.
 * @method KEN.PlaylistManager#_initSounds
 * @private
 */
KEN.SoundManager.prototype._initSounds = function()
{
    if(typeof this._defaultVolume === "number" && this._volumeChanged === false)
    {
        this._volume = KEN.Math.clamp(this._defaultVolume, 0, 1);
    }

    this._updateVolume();
};

/**
 * Update method called by the viewer main loop.
 * @method KEN.SoundManager#update
 */
KEN.SoundManager.prototype.update = function ()
{
    for (var i = 0, ii = this._sounds.length; i < ii; i++)
    {
        this._sounds[i].update();
    }

    // update listener position
    this._setContextListenerOrientation();
};

/**
 * Add a {@link KEN.Sound} into the _sounds Array.
 * @method KEN.SoundManager#add
 * @param {KEN.Sound} sound - The {@link KEN.Sound} to add.
 */
KEN.SoundManager.prototype.add = function (sound)
{
    var index = this._indexOfSound(sound);

    if(index === -1)
    {
        this._sounds.push(sound);
    }
};

/**
 * Remove a {@link KEN.Sound} into the _sounds Array.
 * @method KEN.SoundManager#remove
 * @param {KEN.Sound} sound - The {@link KEN.Sound} to remove.
 */
KEN.SoundManager.prototype.remove = function (sound)
{
    var index = this._indexOfSound(sound);

    if(index > -1)
    {
        this._sounds.splice(index, 1);
    }
};

/**
 * Internal method to find a {@link KEN.Sound} index in the _sounds Array.
 * @method KEN.SoundManager#_indexOfSound
 * @private
 * @param {KEN.Sound} sound - The {@link KEN.Sound} itself.
 * @return {number} Returns the index of the searched {@link KEN.Sound} if found, -1 if not.
 *
 * @todo Either the {@link KEN.Sound} itself or its index or its uid. (KEN.Sound|Number|String)
 */
KEN.SoundManager.prototype._indexOfSound = function (sound)
{
    if(this._sounds === null)
    {
        return -1;
    }

    var _sound;

    for (var i = 0, ii = this._sounds.length; i < ii; i++)
    {
        _sound = this._sounds[i];

        if(_sound === sound)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Suspend audio context if no sound are playing.
 * @method KEN.SoundManager#autoSuspend
 */
KEN.SoundManager.prototype.autoSuspend = function()
{
    if(this._context !== null && typeof this._context.suspend !== "undefined" && this._useWebAudio === true)
    {
        if(this._context.state === "running")
        {
            var allStopped = true;
            for (var i = 0, ii = this._sounds.length; i < ii; i++)
            {
                if(this._sounds[i]["playing"] === true || this._sounds[i]["paused"] === true)
                {
                    allStopped = false;
                    break;
                }
            }

            if(allStopped === true)
            {
                this._context.suspend();
            }
        }
    }
};

/**
 * Resume the audio context if at least one sound is playing.
 * @method KEN.SoundManager#autoResume
 */
KEN.SoundManager.prototype.autoResume = function()
{
    if(this._context !== null && typeof this._context.resume !== "undefined" && this._useWebAudio === true)
    {
        if(this._context.state === "suspended")
        {
            for (var i = 0, ii = this._sounds.length; i < ii; i++)
            {
                if(this._sounds[i]["playing"] === true || this._sounds[i]["paused"] === true)
                {
                    this._context.resume();
                    break;
                }
            }
        }
    }
};

/**
 * Mute method of the sounds.
 * @method KEN.SoundManager#mute
 */
KEN.SoundManager.prototype.mute = function()
{
    if(this._muted === true)
    {
        return;
    }

    this._muted = true;
    this._mutedVolume = this._volume;
    this._volume = 0;

    if (this._useWebAudio === true)
    {
        this._mutedVolume = this._masterGain.gain["value"];
    }

    this._updateVolume();

    if(this._onMute !== null)
    {
        this._onMute.dispatch();
    }
};

/**
 * Unmute method of the sounds.
 * @method KEN.SoundManager#unmute
 */
KEN.SoundManager.prototype.unmute = function()
{
    if(this._muted === false)
    {
        return;
    }

    this._muted = false;
    this._volume = this._mutedVolume;

    this._updateVolume();

    if(this._onUnmute !== null)
    {
        this._onUnmute.dispatch();
    }
};

/**
 * Update volume method for the sounds.
 * @method KEN.SoundManager#unmute
 * @private
 */
KEN.SoundManager.prototype._updateVolume = function()
{
    if (this._useWebAudio === true)
    {
        this._masterGain.gain["value"] = this._volume;
    }
    else if (this._useAudioTag === true)
    {
        // Loop through the sound cache and change the volume of all html audio tags
        for (var i = 0; i < this._sounds.length; i++)
        {
            this._sounds[i]._sound["data"]["volume"] = KEN.Math.clamp(this._sounds[i]._volume, 0, 1) * this._volume;
        }
    }
    this._volumeChanged = true;
};

/**
 * Change the sound manager orientation to follow the THREE perspective camera.
 * @method KEN.SoundManager#_setContextListenerOrientation
 * @private
 */
KEN.SoundManager.prototype._setContextListenerOrientation = function()
{
    if (this._useWebAudio === true && this._viewer["renderer"]["camera"]["perspectiveCamera"] !== null)
    {
        var cameraDirection = new THREE.Vector3();
        var qCamera = this._viewer["renderer"]["camera"]["perspectiveCamera"]["quaternion"];

        cameraDirection.set(0, 0, 1); //@todo verify the perspective matrix, real value should be (0, 0, -1) ?!
        cameraDirection.applyQuaternion(qCamera);
        var camera = cameraDirection.clone();

        cameraDirection.set(0, 1, 0);
        cameraDirection.applyQuaternion(qCamera);
        var cameraUp = cameraDirection;

        // apply orientation values
        this._context["listener"].setOrientation(camera.x, camera.y, camera.z, cameraUp.x, cameraUp.y, cameraUp.z);
    }
};

/**
 * Destroy sequence
 * @method KEN.SoundManager#destroy
 */
KEN.SoundManager.prototype.destroy = function()
{
    this._viewer["tour"]["onSceneLoadStart"].remove(this._sceneLoadStartHandler, this);

    this._viewer = null;
    this._config = null;

    var i = this._sounds.length;
    while(i--)
    {
        this._sounds[i].destroy();
    }

    this._sounds = null;

    this._context = null;
    this._analyser = null;
    this._masterGain = null;

    if(this._onMute !== null)
    {
        this._onMute.destroy();
        this._onMute = null;
    }

    if(this._onUnmute !== null)
    {
        this._onUnmute.destroy();
        this._onUnmute = null;
    }

    if(this._onVolumeChange !== null)
    {
        this._onVolumeChange.destroy();
        this._onVolumeChange = null;
    }

    if(this._onDisable !== null)
    {
        this._onDisable.destroy();
        this._onDisable = null;
    }

    if(this._onEnable !== null)
    {
        this._onEnable.destroy();
        this._onEnable = null;
    }

    KEN.BaseObject.prototype.destroy.call(this);
};


/**
 * Get the audio context.
 * @name KEN.SoundManager#context
 * @type {?AudioContext}
 * @readonly
 */
KEN.SoundManager.prototype.context;
Object.defineProperty(KEN.SoundManager.prototype, "context",
{
    /** @this {KEN.SoundManager} */
    get: function()
    {
        return this._context;
    }
});

/**
 * Get the analyser.
 * @name KEN.SoundManager#analyser
 * @type {?AnalyserNode}
 * @readonly
 */
KEN.SoundManager.prototype.analyser;
Object.defineProperty(KEN.SoundManager.prototype, "analyser",
{
    /** @this {KEN.SoundManager} */
    get: function()
    {
        return this._analyser;
    }
});

/**
 * Get the analyser
 * @name  KEN.SoundManager#inputNode
 * @type {?AudioDestinationNode}
 * @readonly
 */
KEN.SoundManager.prototype.inputNode;
Object.defineProperty(KEN.SoundManager.prototype, "inputNode",
{
    /** @this {KEN.SoundManager} */
    get: function()
    {
        return this._analyser;
    }
});

/**
 * Get the masterGain.
 * @name KEN.SoundManager#masterGain
 * @type {?GainNode}
 * @readonly
 */
KEN.SoundManager.prototype.masterGain;
Object.defineProperty(KEN.SoundManager.prototype, "masterGain",
{
    /** @this {KEN.SoundManager} */
    get: function()
    {
        return this._masterGain;
    }
});

/**
 * The WebAudio API tag must be used?
 * @name KEN.SoundManager#useWebAudio
 * @type {boolean}
 * @readonly
 */
KEN.SoundManager.prototype.useWebAudio;
Object.defineProperty(KEN.SoundManager.prototype, "useWebAudio",
{
    /** @this {KEN.SoundManager} */
    get: function()
    {
        return this._useWebAudio;
    },

    /** @this {KEN.SoundManager} */
    set: function(value)
    {
        if(typeof value === "boolean")
        {
            this._useWebAudio = value;
            this._useAudioTag = !value;
        }
    }
});

/**
 * The Audio tag must be used?
 * @name KEN.SoundManager#useAudioTag
 * @type {boolean}
 * @readonly
 */
KEN.SoundManager.prototype.useAudioTag;
Object.defineProperty(KEN.SoundManager.prototype, "useAudioTag",
{
    /** @this {KEN.SoundManager} */
    get: function()
    {
        return this._useAudioTag;
    },

    /** @this {KEN.SoundManager} */
    set: function(value)
    {
        if(typeof value === "boolean")
        {
            this._useAudioTag = value;
            this._useWebAudio = !value;
        }
    }
});

/**
 * Get the enabled state for sounds.
 * @name KEN.SoundManager#enabled
 * @type {boolean}
 */
KEN.SoundManager.prototype.enabled;
Object.defineProperty(KEN.SoundManager.prototype, "enabled", {

    /** @this {KEN.SoundManager} */
    get: function()
    {
        return this._enabled;
    }

});

/**
 * Get or set the muted state for sounds.
 * @name KEN.SoundManager#muted
 * @type {boolean}
 */
KEN.SoundManager.prototype.muted;
Object.defineProperty(KEN.SoundManager.prototype, "muted", {

    /** @this {KEN.SoundManager} */
    get: function()
    {
        return this._muted;
    },

    /** @this {KEN.SoundManager} */
    set: function(value)
    {
        if(typeof value === "boolean")
        {
            if (value === true)
            {
                this.mute();
            }
            else
            {
                this.unmute();
            }
        }
    }
});

/**
 * Get or set the global volume for sounds.
 * @name KEN.SoundManager#volume
 * @type {number}
 */
KEN.SoundManager.prototype.volume;
Object.defineProperty(KEN.SoundManager.prototype, "volume", {

    /** @this {KEN.SoundManager} */
    get: function()
    {
        if (this._useWebAudio === true)
        {
            return this._masterGain.gain["value"];
        }
        else
        {
            return this._volume;
        }
    },

    /** @this {KEN.SoundManager} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        value = KEN.Math.clamp(value, 0, 1);
        if(this._maxVolume < value)
        {
            this._volume = this._maxVolume;
        }
        else
        {
            this._volume = value;
        }

        if (this._volume > 0)
        {
            this._muted = false;
        }

        this._updateVolume();

        if(this._onVolumeChange !== null)
        {
            this._onVolumeChange.dispatch();
        }
    }
});

/**
 * Get the sounds "onMute" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.SoundManager#onMute
 * @type {KEN.EventDispatcher}
 */
KEN.SoundManager.prototype.onMute;
Object.defineProperty(KEN.SoundManager.prototype, "onMute",
{
    /** @this {KEN.SoundManager} */
    get: function()
    {
        if(this._onMute === null)
        {
            this._onMute = new KEN.EventDispatcher(this);
        }

        return this._onMute;
    }
});

/**
 * Get the sounds "onUnmute" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.SoundManager#onUnmute
 * @type {KEN.EventDispatcher}
 */
KEN.SoundManager.prototype.onUnmute;
Object.defineProperty(KEN.SoundManager.prototype, "onUnmute",
{
    /** @this {KEN.SoundManager} */
    get: function()
    {
        if(this._onUnmute === null)
        {
            this._onUnmute = new KEN.EventDispatcher(this);
        }

        return this._onUnmute;
    }
});

/**
 * Get the sounds "onVolumeChange" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.SoundManager#onVolumeChange
 * @type {KEN.EventDispatcher}
 */
KEN.SoundManager.prototype.onVolumeChange;
Object.defineProperty(KEN.SoundManager.prototype, "onVolumeChange",
{
    /** @this {KEN.SoundManager} */
    get: function()
    {
        if(this._onVolumeChange === null)
        {
            this._onVolumeChange = new KEN.EventDispatcher(this);
        }

        return this._onVolumeChange;
    }
});

/**
 * Get the sounds "onDisable" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.SoundManager#onDisable
 * @type {KEN.EventDispatcher}
 */
KEN.SoundManager.prototype.onDisable;
Object.defineProperty(KEN.SoundManager.prototype, "onDisable",
{
    /** @this {KEN.SoundManager} */
    get: function()
    {
        if(this._onDisable === null)
        {
            this._onDisable = new KEN.EventDispatcher(this);
        }

        return this._onDisable;
    }
});

/**
 * Get the sounds "onEnable" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.SoundManager#onDisable
 * @type {KEN.EventDispatcher}
 */
KEN.SoundManager.prototype.onEnable;
Object.defineProperty(KEN.SoundManager.prototype, "onEnable",
{
    /** @this {KEN.SoundManager} */
    get: function()
    {
        if(this._onEnable === null)
        {
            this._onEnable = new KEN.EventDispatcher(this);
        }

        return this._onEnable;
    }
});


/**
 * A KEN.Sound is an object that manages a sound.
 *
 * @constructor KEN.Sound
 * @param {KEN.Viewer} viewer - The {@link KEN.Viewer} reference.
 * @param {string} key - The sound file id reference.
 * @param {string} url - The sound file url.
 * @extends {KEN.BaseObject}
 *
 * @todo  Ability to force audio type into config
 * @todo  Make a test plugin that creates sound, add sound to the PluginObjectFactory
 * @todo  Loop during x steps (parameter) only if loop is true
 */
KEN.Sound = function(viewer, key, url)
{
    /**
     * The viewer reference.
     * @name KEN.Sound#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The sound identifier.
     * @name KEN.Sound#_key
     * @type {string}
     * @private
     */
    this._key = key;

    /**
     * The sound file url.
     * @name KEN.Sound#_url
     * @type {string}
     * @private
     */
    this._url = url;

    /**
     * The current volume of the sound.
     * @name KEN.Sound#_volume
     * @type {number}
     * @private
     */
    this._volume = 1;

    /**
     * The volume level before a mute of the sound.
     * @name KEN.Sound#_mutedVolume
     * @type {number}
     * @private
     */
    this._mutedVolume = 1;

    /**
     * The muted state of the sound.
     * @name KEN.Sound#_muted
     * @type {boolean}
     * @private
     */
    this._muted = false;

    /**
     * Is the sound enabled?
     * @name  KEN.Sound#enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * Is the sound spatialized?
     * @name  KEN.Sound#_spatialized
     * @type {boolean}
     * @private
     */
    this._spatialized = false;

    /**
     * The duration in seconds of the sound.
     * @name KEN.Sound#_duration
     * @type {number}
     * @private
     */
    this._duration = 0;

    /**
     * The duration in milliseconds of the sound.
     * @name KEN.Sound#_durationMS
     * @type {number}
     * @private
     */
    this._durationMS = 0;

    /**
     * The start time in milliseconds of the sound linked to the global clock.
     * @name KEN.Sound#_startTime
     * @type {number}
     * @private
     */
    this._startTime = 0;

    /**
     * The pause time in milliseconds of the sound linked to the global clock.
     * @name KEN.Sound#_pauseTime
     * @type {number}
     * @private
     */
    this._pauseTime = 0;

    /**
     * The current time in milliseconds of the sound.<br>
     * The current time value is based on duration minus time on the current clock because the AudioContext currentTime value is global to the audio context.
     * @name KEN.Sound#_currentTime
     * @type {number}
     * @private
     */
    this._currentTime = 0;

    /**
     * The loop state of the sound.
     * @name KEN.Sound#_loop
     * @type {boolean}
     * @private
     */
    this._loop = false;

    /**
     * The playing state of the sound.
     * @name KEN.Sound#_playing
     * @type {boolean}
     * @private
     */
    this._playing = false;

    /**
     * The number of play of the sound.
     * @name KEN.Sound#_playCount
     * @type {number}
     * @private
     */
    this._playCount = 0;

    /**
     * The paused state of the sound.
     * @name KEN.Sound#_paused
     * @type {boolean}
     * @private
     */
    this._paused = false;

    /**
     * The sound file with augmented properties.
     * @property {AudioBuffer} data The sound file data contained into an AudioBuffer.
     * @name KEN.Sound#_soundFile
     * @type {?KEN.File}
     * @private
     */
    this._soundFile = null;

    /**
     * The AudioBufferSourceNode instance used to play audio data contained within an AudioBuffer object.
     * @name KEN.Sound#_sound
     * @type {?AudioBufferSourceNode}
     * @private
     */
    this._sound = null;

    /**
     * The sound file data contained into an AudioBuffer.
     * @name KEN.Sound#_buffer
     * @type {?AudioBuffer}
     * @private
     */
    this._buffer = null;

    /**
     * The sound file position data contained into a PannerNode.
     * @name KEN.Sound#_panner
     * @type {?PannerNode}
     * @private
     */
    this._panner = null;

    /**
     * The AudioContext interface.
     * @name KEN.Sound#_context
     * @type {?AudioContext}
     * @private
     */
    this._context = null;

    /**
     * The AudioDestinationNode representing the final destination of all audio in the context.
     * @name KEN.Sound#_inputNode
     * @type {?AudioDestinationNode}
     * @private
     */
    this._inputNode = null; //Either analyser node or gain node ?

    /**
     * The GainNode which can be used to control the overall volume of the audio graph.
     * @type {?GainNode}
     * @private
     */
    this._gainNode = null;

    /**
     * THREE Vector3 x coordinate.
     * @name  KEN.Sound#_x
     * @type {number}
     * @private
     */
    this._x = 0;

    /**
     * THREE Vector3 y coordinate.
     * @name  KEN.Sound#_y
     * @type {number}
     * @private
     */
    this._y = 0;

    /**
     * THREE Vector3 z coordinate.
     * @name  KEN.Sound#_z
     * @type {number}
     * @private
     */
    this._z = 0;

    /**
     * To save the pending state to be applied after the sound object will be ready.
     * @name KEN.Sound#_pendingPlay
     * @type {boolean}
     * @private
     */
    this._pendingPlay = false;

    /**
     * Is this sound object is ready?
     * @name KEN.Sound#_ready
     * @type {boolean}
     * @private
     */
    this._ready = false;

    /**
     * This is a reference to decodeComplete function but with a different this bind reference.
     * @name  KEN.Sound#_decodeCompleteBind
     * @type {?Function}
     * @private
     */
    this._decodeCompleteBind = null;

    /**
     * This is a reference to decodeError function but with a different this bind reference.
     * @name  KEN.Sound#_decodeErrorBind
     * @type {?Function}
     * @private
     */
    this._decodeErrorBind = null;

    /**
     * Is the sound decoded?
     * @name  KEN.Sound#_decoded
     * @type {boolean}
     * @private
     */
    this._decoded = false;

    /**
     * On sound decoded event dispatcher.
     * @name KEN.Sound#_onSoundDecode
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onSoundDecode = null;

    /**
     * On load start event dispatcher.
     * @name KEN.Sound#_onLoadStart
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onLoadStart = null;

    /**
     * On loaded data event dispatcher.
     * @name KEN.Sound#_onLoadedData
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onLoadedData = null;

    /**
     * On can play event dispatcher.
     * @name KEN.Sound#_onCanPlay
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onCanPlay = null;

    /**
     * On can play through event dispatcher.
     * @name KEN.Sound#_onCanPlayThrough
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onCanPlayThrough = null;

    /**
     * On sound muted event dispatcher.
     * @name KEN.Sound#_onMute
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onMute = null;

     /**
     * On sound unmuted event dispatcher.
     * @name KEN.Sound#_onUnmute
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onUnmute = null;

    /**
     * On sound volume change event dispatcher.
     * @name KEN.Sound#_onVolumeChange
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onVolumeChange = null;

    /**
     * On sound play event dispatcher.
     * @name KEN.Sound#_onPlay
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPlay = null;

    /**
     * On sound stop event dispatcher.
     * @name KEN.Sound#_onStop
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onStop = null;

    /**
     * On sound pause event dispatcher.
     * @name KEN.Sound#_onPause
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * On sound resume event dispatcher.
     * @name KEN.Sound#_onResume
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onResume = null;

    /**
     * On sound decoded event dispatcher.
     * @name KEN.Sound#_onEnded
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onEnded = null;

    KEN.BaseObject.call(this, "Sound");

    this._boot();
};

KEN.Sound.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Sound.prototype.constructor = KEN.Sound;

/**
 * Boot sequence.
 * @method KEN.Sound#_boot
 * @private
 * @suppress {deprecated}
 */
KEN.Sound.prototype._boot = function()
{
    //register the uid
    this._uid = this._key;
    this._register();

    if (this._viewer["audio"]["useWebAudio"] === true)
    {
        this._context = this._viewer["audio"]["context"];

        this._inputNode = this._viewer["audio"]["inputNode"];

        if (typeof this._context.createGain === "undefined")
        {
            this._gainNode = this._context.createGainNode();
        }
        else
        {
            this._gainNode = this._context.createGain();
        }

        this._gainNode.gain["value"] = this._volume * this._viewer["audio"]["volume"];
        this._gainNode.connect(this._inputNode);
    }
    else if (this._viewer["audio"]["useAudioTag"] === true)
    {
        if (this._viewer["cache"].has( KEN.Cache.types.SOUND, this._key) === true)
        {
            this._loadComplete(this._viewer["cache"].get(KEN.Cache.types.SOUND, this._key));
        }

        //Listen to the main volume change to adapt the sound volume accordingly.
        this._viewer["audio"]["onVolumeChange"].add(this._mainVolumeChangeHandler, this);
    }

    this._viewer["audio"]["onDisable"].add(this._disableSoundHandler, this);

    if(this._url !== "")
    {
        this._viewer["load"].sound(this._key, this._url, this._loadComplete, this);

        if(this._onLoadStart !== null)
        {
            this._onLoadStart.dispatch();
        }
    }

    this._viewer["audio"].add(this);
};

/**
 * Event handler for load complete event, it launch the decoding of the sound file.
 * @method KEN.Sound#_loadComplete
 * @private
 * @param {KEN.File} file - The sound file.
 */
KEN.Sound.prototype._loadComplete = function(file)
{
    this._soundFile = file;

    this._ready = true;

    // loaded events
    if(this._onLoadedData !== null)
    {
        this._onLoadedData.dispatch();
    }

    if (this._viewer["audio"]["useWebAudio"] === true)
    {
        this._decode(this._soundFile);
    }
    else
    {
        if(this._onSoundDecode !== null)
        {
            this._onSoundDecode.dispatch();
        }

        if(this._onCanPlay !== null)
        {
            this._onCanPlay.dispatch();
        }

        if(this._onCanPlayThrough !== null)
        {
            this._onCanPlayThrough.dispatch();
        }

        this._decoded = true;
    }

    if (this._decoded === true)
    {
        if (this._viewer["audio"]["useAudioTag"] === true)
        {
            this._sound = this._viewer["cache"].get(KEN.Cache.types.SOUND, this._key);

            this._updateVolume();

            this._duration = 0;
            if (this._sound["data"]["duration"])
            {
                this._duration = this._sound["data"]["duration"];
                this._durationMS = Math.ceil(this._duration * 1000);
            }
        }

        if(this._pendingPlay === true)
        {
            this.play(this._currentTime, this._loop, true);
        }
    }
};

/**
 * Decoding of the sound file.
 * @method KEN.Sound#_decode
 * @private
 * @param {Object} file - The sound file
 */
KEN.Sound.prototype._decode = function(file)
{
    if (file)
    {
        if (this._decoded === false)
        {
            this._decodeCompleteBind = this._decodeComplete.bind(this);
            this._decodeErrorBind = this._decodeError.bind(this);
            this._context.decodeAudioData(file["data"], this._decodeCompleteBind, this._decodeErrorBind);
        }
    }
};

/**
 * Event handler for decode error event, it stores decoding data into the sound file object.
 * @method KEN.Sound#_decodeError
 * @private
 */
KEN.Sound.prototype._decodeError = function()
{
    if(this._soundFile !== null)
    {
        this._soundFile["data"] = null;
        this._decoded = false;
    }
};

/**
 * Event handler for decode complete event, it stores decoding data into the sound file object.
 * @method KEN.Sound#_decodeComplete
 * @private
 * @param  {AudioBuffer} buffer - The raw binary data buffer.
 */
KEN.Sound.prototype._decodeComplete = function(buffer)
{
    if(this._soundFile === null)
    {
        //throw "KEN.Sound._decodeComplete error, sound file is null";
        return;
    }

    if (buffer)
    {
        //this._viewer["cache"].updateDecodedSound(key, buffer);
        this._soundFile["data"] = buffer;
        this._decoded = true;

        if(this._onSoundDecode !== null)
        {
            this._onSoundDecode.dispatch();
        }

        if(this._onCanPlay !== null)
        {
            this._onCanPlay.dispatch();
        }

        if(this._onCanPlayThrough !== null)
        {
            this._onCanPlayThrough.dispatch();
        }

        if(this._pendingPlay === true)
        {
            this.play(this._currentTime, this._loop, true);
        }
    }
};

/**
 * Handles the main volume change, update the volume factor to the sound volume.
 * @method KEN.Sound#_mainVolumeChangeHandler
 * @private
 */
KEN.Sound.prototype._mainVolumeChangeHandler = function()
{
    this._updateVolume();
};

/**
 * Apply the main volume factor to the sound volume.
 * @method KEN.Sound#_updateVolume
 * @private
 */
KEN.Sound.prototype._updateVolume = function()
{
    if (this._viewer["audio"]["useAudioTag"] === true && this._sound !== null)
    {
        this._sound["data"]["volume"] = KEN.Math.clamp(this._volume, 0, 1) * this._viewer["audio"]["volume"];
    }
};

/**
 * Disable the sound.
 * @method KEN.Sound#_disableSoundHandler
 * @private
 */
KEN.Sound.prototype._disableSoundHandler = function()
{
    if(this._playing === true)
    {
        this.pause();
    }
    else if(this["paused"] === false)
    {
        this.stop();
    }
};

/**
 * Reset of the sound values.
 * @method KEN.Sound#_reset
 * @private
 */
KEN.Sound.prototype._reset = function()
{
    this._currentTime = 0;
    this._pendingPlay = false;
    this._playing = false;
    this._paused = false;
};

/**
 * Setup for sound panner.
 * @method KEN.Sound#_setupPanner
 * @private
 */
KEN.Sound.prototype._setupPanner = function()
{
    this._panner = this._context.createPanner();
    this._panner.panningModel = "HRTF";
    this._panner.distanceModel = "inverse";
    this._panner.refDistance = 1;
    this._panner.maxDistance = 10000;
    this._panner.rolloffFactor = 1;
    this._panner.coneInnerAngle = 360;
    this._panner.coneOuterAngle = 0;
    this._panner.coneOuterGain = 0;
    this._panner.setOrientation(0, 0, 0); //look to listener position (0, 0, 0)
    // init the 3D position of the panner (x, y, z)
    this._panner.setPosition(0, 0, 0);
};

/**
 * Apply sound panner orientation.
 * @method  KEN.Sound#_applyPanner
 * @param {boolean=} connect - Panner must be connected to sound and gainNode?
 * @private
 */
KEN.Sound.prototype._applyPanner = function(connect)
{
    if(this._panner === null)
    {
        this._setupPanner();
    }

    // this._panner.setOrientation(0, 0, 0);

    this._panner.setPosition(this._x, this._y, this._z);

    if(connect === true)
    {
        this._sound.connect(this._panner);
        // Connect the "panner" object to the "destination" object.
        this._panner.connect(this._gainNode);
    }
};

/**
 * Update method called by the viewer main loop.
 * @method KEN.Sound#update
 */
KEN.Sound.prototype.update = function()
{
    if(this._playing === true && this._paused === false)
    {
        var time = this._viewer["clock"]["time"] - this._startTime;
        if(time >= this._durationMS)
        {
            this._currentTime = this._durationMS;

            if (this._viewer["audio"]["useWebAudio"] === true || this._viewer["audio"]["useAudioTag"] === true)
            {
                this.stop(true);

                if(this._onEnded !== null)
                {
                    this._onEnded.dispatch();
                }

                if(this._loop === true)
                {
                    this._currentTime = 0;
                    this.resume();
                }
            }
        }
        else
        {
            //also for this case when using streaming for data or bad headers : this._duration === Infinity
            this._currentTime = time;
        }
    }
};

/**
 * Play method of the sound.
 * @method KEN.Sound#play
 * @param {number=} position - The start position to play the sound in milliseconds.
 * @param {?boolean=} loop - The loop state of the sound.
 * @param {?boolean=} forceRestart - If the sound is already playing you can set forceRestart to restart it from the beginning.
 * @suppress {deprecated}
 */
KEN.Sound.prototype.play = function(position, loop, forceRestart)
{
    //save the currentTime used
    if(typeof position === "number")
    {
        this._currentTime = position;
    }

    if(this._viewer["audio"]["enabled"] === false || this._enabled === false)
    {
        this._playing = false;
        this._paused = false;
        return;
    }

    this._loop = loop || false;

    if(this._playing === true)
    {
        if(forceRestart === true)
        {
            this.stop();
        }
        else
        {
            return;
        }
    }

    if(this._ready === false)
    {
        this._pendingPlay = true;
        return;
    }

    if (this._viewer["audio"]["useWebAudio"] === true)
    {
        //if(typeof volume !== "undefined" && !isNaN(volume))
            //this["volume"] = volume;

        //  Does the sound need decoding?
        if (this._decoded === true)
        {
            //  Do we need to do this every time we play? How about just if the buffer is empty?
            if (this._buffer === null)
            {
                this._buffer = this._soundFile["data"];
            }

            this._sound = this._context.createBufferSource();
            this._sound["buffer"] = this._buffer;

            if (this._spatialized === true)
            {
                this._applyPanner(true);
            }
            else
            {
                this._sound.connect(this._gainNode);
            }

            this._duration = this._sound["buffer"]["duration"];
            this._durationMS = Math.ceil(this._duration * 1000);

            // this.log('dur', this._sound["buffer"]["duration"], Math.ceil(this._sound["buffer"]["duration"] * 1000));

            /*
            if (this["duration"] === 0)
            {
                // this.log('duration reset');
                this["duration"] = this.totalDuration;
                this["durationMS"] = Math.ceil(this.totalDuration * 1000);
            }
            */

            if(!isNaN(position) && position < this._durationMS)
            {
                this._currentTime = /** @type {number} */ (position);
                this._startTime = this._viewer["clock"]["time"] - position;
            }
            else
            {
                this._startTime = this._viewer["clock"]["time"];
            }

            var time = KEN.Math.round10(this._currentTime / 1000);
            //  Useful to cache this somewhere perhaps?
            if (typeof this._sound.start === "undefined")
            {
                this._sound.noteGrainOn(0, time % this._duration, this._duration);
                //this._sound.noteOn(0); // the zero is vitally important, crashes iOS6 without it
            }
            else
            {
                // Start playback, but make sure we stay in bound of the buffer.
                this._sound.start(0, time % this._duration, this._duration);
            }

            this._playing = true;

            this._playCount++;
            //this.stopTime = this.startTime + this["durationMS"];

            if(this._onPlay !== null)
            {
                this._onPlay.dispatch();
            }

            this._viewer["audio"].autoResume();
        }
        else
        {
            this.log("Sound is not decoded yet");
            this._pendingPlay = true;
            return;
        }
    }
    else if (this._viewer["audio"]["useAudioTag"] === true)
    {
        if (this._duration === 0)
        {
            this._duration = this._sound["data"]["duration"];
            this._durationMS = Math.ceil(this._duration * 1000);
        }
        else if(this._duration === Infinity)
        {
            this._sound["data"]["loop"] = true;
        }

        if(!isNaN(position))
        {
            if(this._durationMS !== 0 && position < this._durationMS)
            {
                this._sound["data"]["currentTime"] = KEN.Math.round10(position / 1000);
                this._startTime = this._viewer["clock"]["time"] - position;
            }
            else
            {
                this._sound["data"]["currentTime"] = 0;
                this._startTime = this._viewer["clock"]["time"];
            }
        }
        else
        {
            position = 0;
            this._sound["data"]["currentTime"] = 0;
            this._startTime = this._viewer["clock"]["time"];
        }

        this._sound["data"].play();

        //if(typeof volume !== "undefined" && !isNaN(volume))
            //this["volume"] = volume;

        this._playing = true;
        this._currentTime = /** @type {number} */ (position);
        this._playCount++;

        if(this._onPlay !== null)
        {
            this._onPlay.dispatch();
        }
    }
};

/**
 * Stop method of the sound.
 * @method KEN.Sound#stop
 * @param  {boolean=} internal - Internal use: true prevents event firing.
 */
KEN.Sound.prototype.stop = function(internal)
{
    /*
    if(this._viewer["audio"]["enabled"] === false)
    {
        return;
    }
    */

    if(this._sound !== null)
    {
        this._stop(true);

        this._pendingPlay = false;
        this._playing = false;
        this._paused = false;

        if(this._onStop !== null && internal === true)
        {
            this._onStop.dispatch();
        }

        this._viewer["audio"].autoSuspend();
    }
    else if(this._ready === false || this._decoded !== true)
    {
        this._reset();
    }
};

/**
 * Stop actions to apply to the sound.
 * @method KEN.Sound#_stop
 * @private
 * @param {boolean} resetCurrentTime - To force a reset of the current time
 * @suppress {deprecated}
 */
KEN.Sound.prototype._stop = function(resetCurrentTime)
{
    if (this._viewer["audio"]["useWebAudio"] === true)
    {
        if (typeof this._sound.stop === "undefined")
        {
            this._sound.noteOff(0);
        }
        else
        {
            try
            {
                this._sound.stop(0);
            }
            catch (e)
            {

            }
        }

        // Clean up the buffer source
        this._sound.disconnect(0);
        this._sound = null;

        if(resetCurrentTime === true)
        {
            this._currentTime = 0;
        }
    }
    else if (this._viewer["audio"]["useAudioTag"] === true)
    {
        this._sound["data"].pause();
        if(resetCurrentTime === true)
        {
            this._sound["data"]["currentTime"] = 0; //The current time the sound is at.
        }
    }
    this._pauseTime = this._viewer["clock"]["time"];
    this._startTime = this._viewer["clock"]["time"];
};

/**
 * Pause method of the sound.
 * @method KEN.Sound#pause
 */
KEN.Sound.prototype.pause = function()
{
    /*
    if(this._viewer["audio"]["enabled"] === false)
    {
        return;
    }
    */

    if(this._playing === true && this._sound !== null)
    {
        this._stop(false);

        this._paused = true;
        this._pauseTime = this._viewer["clock"]["time"];
        this._pendingPlay = false;
        this._playing = false;

        if(this._onPause !== null)
        {
            this._onPause.dispatch();
        }
    }
    else if(this._ready === false || this._decoded !== true)
    {
        this._reset();
    }
};

/**
 * Resume method of the sound.
 * @method KEN.Sound#resume
 * @suppress {deprecated}
 */
KEN.Sound.prototype.resume = function()
{
    if(this._viewer["audio"]["enabled"] === false || this._enabled === false)
    {
        return;
    }

    if(this._paused === true || this._playing === false)
    {
        if(this._sound === null)
        {
            this.play(this._currentTime, this._loop, true);
            return;
        }
        else
        {
            if(this._viewer["audio"]["useWebAudio"] === true)
            {
                this._sound = this._context.createBufferSource();
                this._sound["buffer"] = this._buffer;

                if (this._spatialized === true)
                {
                    this._applyPanner(true);
                }
                else
                {
                    this._sound.connect(this._gainNode);
                }

                this._startTime += (this._viewer["clock"]["time"] - this._pauseTime);
                var time = KEN.Math.round10(this._currentTime / 1000);
                var duration = Math.ceil((this._durationMS - this._currentTime) / 1000);

                if (typeof this._sound.start === "undefined")
                {
                    this._sound.noteGrainOn(0, time % this._duration, duration);
                }
                else
                {
                    this._sound.start(0, time % this._duration, duration);
                }
            }
            else if(this._viewer["audio"]["useAudioTag"] === true)
            {
                this._sound["data"]["currentTime"] = KEN.Math.round10(this._currentTime / 1000);
                this._sound["data"].play();
            }
        }

        this._playing = true;
        this._paused = false;

        if(this._onResume !== null)
        {
            this._onResume.dispatch();
        }
    }
    else if(this._ready === false || this._decoded === false)
    {
        this._reset();
        this._pendingPlay = true;
    }
};

/**
 * Mute method of the sound.
 * @method KEN.Sound#mute
 */
KEN.Sound.prototype.mute = function()
{
    if(this._muted === true || this._viewer["audio"]["enabled"] === false || this._enabled === false)
    {
        return;
    }

    this._muted = true;
    this._mutedVolume = this._volume;
    this._volume = 0;

    if (this._viewer["audio"]["useWebAudio"] === true)
    {
        this._gainNode.gain["value"] = this._volume;
    }
    else if (this._viewer["audio"]["useAudioTag"] === true && this._sound !== null)
    {
        this._sound["data"]["volume"] = this._volume;
    }

    if(this._onMute !== null)
    {
        this._onMute.dispatch();
    }
};

/**
 * Unmute method of the sound.
 * @method KEN.Sound#unmute
 */
KEN.Sound.prototype.unmute = function()
{
    if(this._muted === false || this._viewer["audio"]["enabled"] === false || this._enabled === false)
    {
        return;
    }

    this._muted = false;
    this._volume = this._mutedVolume;

    if (this._viewer["audio"]["useWebAudio"] === true)
    {
        this._gainNode.gain["value"] = this._mutedVolume;
    }
    else if (this._viewer["audio"]["useAudioTag"] === true && this._sound !== null)
    {
        this._sound["data"]["volume"] = this._mutedVolume;
    }

    if(this._onUnmute !== null)
    {
        this._onUnmute.dispatch();
    }
};

/**
 * Augmented destroy method.
 * @method KEN.Sound#destroy
 */
KEN.Sound.prototype.destroy = function()
{
    this.stop();

    if(this._viewer["audio"]["useAudioTag"] === true)
    {
        this._viewer["audio"]["onVolumeChange"].remove(this._mainVolumeChangeHandler, this);
    }

    this._viewer["audio"]["onDisable"].remove(this._disableSoundHandler, this);

    this._viewer["audio"].remove(this);

    this._viewer = null;

    this._soundFile = null;
    this._sound = null;
    this._buffer = null;
    this._context = null;
    this._inputNode = null;
    this._gainNode = null;
    this._panner = null;

    this._decodeCompleteBind = null;
    this._decodeErrorBind = null;

    if(this._onSoundDecode !== null)
    {
        this._onSoundDecode.destroy();
        this._onSoundDecode = null;
    }

    if(this._onLoadStart !== null)
    {
        this._onLoadStart.destroy();
        this._onLoadStart = null;
    }

    if(this._onLoadedData !== null)
    {
        this._onLoadedData.destroy();
        this._onLoadedData = null;
    }

    if(this._onCanPlay !== null)
    {
        this._onCanPlay.destroy();
        this._onCanPlay = null;
    }

    if(this._onCanPlayThrough !== null)
    {
        this._onCanPlayThrough.destroy();
        this._onCanPlayThrough = null;
    }

    if(this._onMute !== null)
    {
        this._onMute.destroy();
        this._onMute = null;
    }

    if(this._onUnmute !== null)
    {
        this._onUnmute.destroy();
        this._onUnmute = null;
    }

    if(this._onVolumeChange !== null)
    {
        this._onVolumeChange.destroy();
        this._onVolumeChange = null;
    }

    if(this._onPlay !== null)
    {
        this._onPlay.destroy();
        this._onPlay = null;
    }

    if(this._onStop !== null)
    {
        this._onStop.destroy();
        this._onStop = null;
    }

    if(this._onPause !== null)
    {
        this._onPause.destroy();
        this._onPause = null;
    }

    if(this._onResume !== null)
    {
        this._onResume.destroy();
        this._onResume = null;
    }

    if(this._onEnded !== null)
    {
        this._onEnded.destroy();
        this._onEnded = null;
    }

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get and set the sound enabled status.
 * @name KEN.Sound#enabled
 * @type {boolean}
 */
KEN.Sound.prototype.enabled;
Object.defineProperty(KEN.Sound.prototype, "enabled",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {KEN.Sound} */
    set: function(value)
    {
        if(typeof value === "boolean")
        {
            this._enabled = value;

            if (this._enabled === false && (this._playing === true || this._paused === true))
            {
                this.stop();
            }
        }
    }
});


/**
 * Get or set the current time in milliseconds of the sound.
 * @name KEN.Sound#currentTime
 * @type {number}
 */
KEN.Sound.prototype.currentTime;
Object.defineProperty(KEN.Sound.prototype, "currentTime",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        return this._currentTime;
    },

    /** @this {KEN.Sound} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        this.pause();
        this._currentTime = value;
        if(this._playing === true)
        {
            this.resume();
        }
    }
});

/**
 * Get or set the spatialized state of the sound.
 * @name KEN.Sound#spatialized
 * @type {boolean}
 */
KEN.Sound.prototype.spatialized;
Object.defineProperty(KEN.Sound.prototype, "spatialized",
{
    /** @this {KEN.Sound} */
    get: function ()
    {
        return this._spatialized;
    },

    /** @this {KEN.Sound} */
    set: function (value)
    {
        if(typeof value === "boolean")
        {
            this._spatialized = value;
        }
    }
});

/**
 * Get the duration in seconds of the sound.
 * @name KEN.Sound#duration
 * @readonly
 * @type {number}
 */
KEN.Sound.prototype.duration;
Object.defineProperty(KEN.Sound.prototype, "duration",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        return this._duration;
    }
});

/**
 * Get or set the muted state of the sound.
 * @name KEN.Sound#muted
 * @type {boolean}
 */
KEN.Sound.prototype.muted;
Object.defineProperty(KEN.Sound.prototype, "muted",
{
    /** @this {KEN.Sound} */
    get: function ()
    {
        return (this._muted || this._viewer["audio"].mute);
    },

    /** @this {KEN.Sound} */
    set: function (value)
    {
        if(typeof value === "boolean")
        {
            if (value === true)
            {
                this.mute();
            }
            else
            {
                this.unmute();
            }
        }
    }
});

/**
 * Get or set the volume of the sound.
 * @name KEN.Sound#volume
 * @type {number}
 */
KEN.Sound.prototype.volume;
Object.defineProperty(KEN.Sound.prototype, "volume",
{
    /** @this {KEN.Sound} */
    get: function ()
    {
        return this._volume;
    },

    /** @this {KEN.Sound} */
    set: function (value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        value = KEN.Math.clamp(value, 0, 1);

        if (value === this._volume || this._viewer["audio"]["enabled"] === false || this._enabled === false)
        {
            /*
            //force volume refresh on AudioTag
            if(this._viewer["audio"]["useAudioTag"] === true)
            {
                if(this._onVolumeChange !== null)
                {
                    this._onVolumeChange.dispatch();
                }
            }
            */
            return;
        }

        this._volume = value;

        if (this._volume > 0)
        {
            this._muted = false;
        }

        if (this._viewer["audio"]["useWebAudio"] === true)
        {
            this._gainNode.gain["value"] = value;
        }
        else
        {
            this._updateVolume();
        }

        if(this._onVolumeChange !== null)
        {
            this._onVolumeChange.dispatch();
        }
    }
});

/**
 * Get the decoded status of the sound.
 * @name KEN.Sound#decoded
 * @readonly
 * @type {boolean}
 */
KEN.Sound.prototype.decoded;
Object.defineProperty(KEN.Sound.prototype, "decoded",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        if (this._soundFile === null)
        {
            return false;
        }

        return this._decoded;
    }
});

/**
 * Get the number of play of the sound.
 * @name KEN.Sound#playCount
 * @readonly
 * @type {boolean}
 */
KEN.Sound.prototype.playCount;
Object.defineProperty(KEN.Sound.prototype, "playCount",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        return this._playCount;
    }
});

/**
 * Get the playing status of the sound.
 * @name KEN.Sound#playing
 * @readonly
 * @type {boolean}
 */
KEN.Sound.prototype.playing;
Object.defineProperty(KEN.Sound.prototype, "playing",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        return this._playing;
    }
});

/**
 * Get the ready status of the sound.
 * @name KEN.Sound#ready
 * @readonly
 * @type {boolean}
 */
KEN.Sound.prototype.ready;
Object.defineProperty(KEN.Sound.prototype, "ready",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        return this._ready;
    }
});

/**
 * Get the paused status of the sound.
 * @name KEN.Sound#paused
 * @readonly
 * @type {boolean}
 */
KEN.Sound.prototype.paused;
Object.defineProperty(KEN.Sound.prototype, "paused",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        return this._paused;
    }
});

/**
 * Get and set the loop status of the sound.
 * @name KEN.Sound#loop
 * @type {boolean}
 */
KEN.Sound.prototype.loop;
Object.defineProperty(KEN.Sound.prototype, "loop",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        return this._loop;
    },

    /** @this {KEN.Sound} */
    set: function(value)
    {
        if(typeof value === "boolean")
        {
            this._loop = value;

            if(this._viewer["audio"]["useAudioTag"] === true && this._sound !== null && this._duration === Infinity)
            {
                this._sound["data"]["loop"] = this._loop;
            }
        }
    }
});

/**
 * Get and set the x axis position of the sound.
 * @name KEN.Sound#x
 * @type {number}
 */
KEN.Sound.prototype.x;
Object.defineProperty(KEN.Sound.prototype, "x",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        return this._x;
    },

    /** @this {KEN.Sound} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._x = value;

            if (this._viewer["audio"]["useWebAudio"] === true && this._sound !== null && this._panner !== null && this._spatialized === true)
            {
                this._applyPanner();
            }
        }
    }
});

/**
 * Get and set the y axis position of the sound.
 * @name KEN.Sound#y
 * @type {number}
 */
KEN.Sound.prototype.y;
Object.defineProperty(KEN.Sound.prototype, "y",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        return this._y;
    },

    /** @this {KEN.Sound} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._y = value;

            if (this._viewer["audio"]["useWebAudio"] === true && this._sound !== null && this._panner !== null && this._spatialized === true)
            {
                this._applyPanner();
            }
        }
    }
});

/**
 * Get and set the z axis position of the sound.
 * @name KEN.Sound#z
 * @type {number}
 */
KEN.Sound.prototype.z;
Object.defineProperty(KEN.Sound.prototype, "z",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        return this._y;
    },

    /** @this {KEN.Sound} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._z = value;

            if (this._viewer["audio"]["useWebAudio"] === true && this._sound !== null && this._panner !== null && this._spatialized === true)
            {
                this._applyPanner();
            }
        }
    }
});

/**
 * Get the sound "onSoundDecode" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.Sound#onSoundDecode
 * @type {KEN.EventDispatcher}
 */
KEN.Sound.prototype.onSoundDecode;
Object.defineProperty(KEN.Sound.prototype, "onSoundDecode",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        if(this._onSoundDecode === null)
        {
            this._onSoundDecode = new KEN.EventDispatcher(this);//, true); //@todo why true ?
        }

        return this._onSoundDecode;
    }
});

/**
 * Get the sound "onLoadStart" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.Sound#onLoadStart
 * @type {KEN.EventDispatcher}
 */
KEN.Sound.prototype.onLoadStart;
Object.defineProperty(KEN.Sound.prototype, "onLoadStart",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        if(this._onLoadStart === null)
        {
            this._onLoadStart = new KEN.EventDispatcher(this);
        }

        return this._onLoadStart;
    }
});

/**
 * Get the sound "onLoadedData" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.Sound#onLoadedData
 * @type {KEN.EventDispatcher}
 */
KEN.Sound.prototype.onLoadedData;
Object.defineProperty(KEN.Sound.prototype, "onLoadedData",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        if(this._onLoadedData === null)
        {
            this._onLoadedData = new KEN.EventDispatcher(this);
        }

        return this._onLoadedData;
    }
});

/**
 * Get the sound "onCanPlay" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.Sound#onCanPlay
 * @type {KEN.EventDispatcher}
 */
KEN.Sound.prototype.onCanPlay;
Object.defineProperty(KEN.Sound.prototype, "onCanPlay",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        if(this._onCanPlay === null)
        {
            this._onCanPlay = new KEN.EventDispatcher(this);
        }

        return this._onCanPlay;
    }
});

/**
 * Get the sound "onCanPlayThrough" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.Sound#onCanPlayThrough
 * @type {KEN.EventDispatcher}
 */
KEN.Sound.prototype.onCanPlayThrough;
Object.defineProperty(KEN.Sound.prototype, "onCanPlayThrough",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        if(this._onCanPlayThrough === null)
        {
            this._onCanPlayThrough = new KEN.EventDispatcher(this);
        }

        return this._onCanPlayThrough;
    }
});

/**
 * Get the sound "onMute" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.Sound#onMute
 * @type {KEN.EventDispatcher}
 */
KEN.Sound.prototype.onMute;
Object.defineProperty(KEN.Sound.prototype, "onMute",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        if(this._onMute === null)
        {
            this._onMute = new KEN.EventDispatcher(this);
        }

        return this._onMute;
    }
});

/**
 * Get the sound "onUnmute" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.Sound#onUnmute
 * @type {KEN.EventDispatcher}
 */
KEN.Sound.prototype.onUnmute;
Object.defineProperty(KEN.Sound.prototype, "onUnmute",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        if(this._onUnmute === null)
        {
            this._onUnmute = new KEN.EventDispatcher(this);
        }

        return this._onUnmute;
    }
});

/**
 * Get the sound "onVolumeChange" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.Sound#onVolumeChange
 * @type {KEN.EventDispatcher}
 */
KEN.Sound.prototype.onVolumeChange;
Object.defineProperty(KEN.Sound.prototype, "onVolumeChange",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        if(this._onVolumeChange === null)
        {
            this._onVolumeChange = new KEN.EventDispatcher(this);
        }

        return this._onVolumeChange;
    }
});

/**
 * Get the sound "onPlay" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.Sound#onPlay
 * @type {KEN.EventDispatcher}
 */
KEN.Sound.prototype.onPlay;
Object.defineProperty(KEN.Sound.prototype, "onPlay",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        if(this._onPlay === null)
        {
            this._onPlay = new KEN.EventDispatcher(this);
        }

        return this._onPlay;
    }
});

/**
 * Get the sound "onStop" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.Sound#onStop
 * @type {KEN.EventDispatcher}
 */
KEN.Sound.prototype.onStop;
Object.defineProperty(KEN.Sound.prototype, "onStop",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        if(this._onStop === null)
        {
            this._onStop = new KEN.EventDispatcher(this);
        }

        return this._onStop;
    }
});

/**
 * Get the sound "onPause" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.Sound#onPause
 * @type {KEN.EventDispatcher}
 */
KEN.Sound.prototype.onPause;
Object.defineProperty(KEN.Sound.prototype, "onPause",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        if(this._onPause === null)
        {
            this._onPause = new KEN.EventDispatcher(this);
        }

        return this._onPause;
    }
});

/**
 * Get the sound "onResume" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.Sound#onResume
 * @type {KEN.EventDispatcher}
 */
KEN.Sound.prototype.onResume;
Object.defineProperty(KEN.Sound.prototype, "onResume",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        if(this._onResume === null)
        {
            this._onResume = new KEN.EventDispatcher(this);
        }

        return this._onResume;
    }
});

/**
 * Get the sound "onEnded" event {@link KEN.EventDispatcher}.
 * The {@link KEN.EventDispatcher} is created only if you ask for it.
 * @name KEN.Sound#onEnded
 * @type {KEN.EventDispatcher}
 */
KEN.Sound.prototype.onEnded;
Object.defineProperty(KEN.Sound.prototype, "onEnded",
{
    /** @this {KEN.Sound} */
    get: function()
    {
        if(this._onEnded === null)
        {
            this._onEnded = new KEN.EventDispatcher(this);
        }

        return this._onEnded;
    }
});


/**
 * A KEN.Playlist is an object that represents a list of media.
 *
 * @constructor KEN.Playlist
 * @param {KEN.Viewer} viewer - The {@link KEN.Viewer} reference.
 * @param {AudioPlaylistConfig} config - The playlist config object.
 * @extends {KEN.BaseObject}
 */
KEN.Playlist = function(viewer, config)
{
    /**
     * The viewer reference. 
     * @name KEN.Playlist#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The config object. 
     * @name KEN.Playlist#_config
     * @type {?AudioPlaylistConfig}
     * @private
     */
    this._config = config;

    /**
     * Array of PlaylistTrack uid.
     * @name KEN.Playlist#_tracks
     * @type {?Array<string>}
     * @private
     */
    this._tracks = null;

    /**
     * The name of the playlist.
     * @name KEN.Playlist#_name
     * @type {?KEN.LocaleString}
     * @private
     */
    this._name = null;

    /**
     * The default track uid or index of the playlist.
     * @name KEN.Playlist#_defaultTrack
     * @type {string}
     * @private
     */
    this._defaultTrack = "";

    /**
     * UID of the current {@link KEN.PlaylistTrack}.
     * @name KEN.Playlist#_trackUID
     * @type {string}
     * @private
     */
    this._trackUID = "";

    /**
     * Playlist with tracks ready event dispatcher.
     * @name KEN.Playlist#_onReady
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onReady = null;

    /**
     * On playlist play event dispatcher.
     * @name KEN.Playlist#_onPlay
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPlay = null;

    /**
     * On playlist stop event dispatcher.
     * @name KEN.Playlist#_onStop
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onStop = null;

    /**
     * On playlist pause event dispatcher.
     * @name KEN.Playlist#_onPause
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * On playlist resume event dispatcher.
     * @name KEN.Playlist#_onResume
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onResume = null;

    /**
     * On playlist ended event dispatcher.
     * @name KEN.Playlist#_onEnded
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onEnded = null;

    KEN.BaseObject.call(this, "Playlist");

    this._boot();
};

KEN.Playlist.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Playlist.prototype.constructor = KEN.Playlist;

/**
 * Boot sequence.
 * @method KEN.Playlist#_boot
 * @private
 */
KEN.Playlist.prototype._boot = function()
{
    this._uid = this._config["uid"];
    this._register();
    this._name = new KEN.LocaleString(this._viewer, this._config["name"]);

    this._tracks = [];

    this._parseTracks(this._config);
};

/**
 * Parse playlist tracks.
 * @method KEN.Playlist#_parseTracks
 * @private
 * @param {AudioPlaylistConfig} config - The object that describes the playlist config.
 */
KEN.Playlist.prototype._parseTracks = function(config)
{
    if(typeof config["tracks"] !== "undefined" && KEN.Utils.isArrayOf(config["tracks"], "string") === true)
    {
        this._tracks = config["tracks"];
    }
    else
    {
        this.warn("A playlist has no track in its configuration, or configuration is not valid!");
    }

    //Parse the default track of the playlist
    if(typeof config.defaultTrack === "string" && config.defaultTrack !== "")
    {
        this._defaultTrack = config.defaultTrack;
    }
    else if(typeof config.defaultTrack === "number" && config.defaultTrack >= 0 && config.defaultTrack < this._tracks.length)
    {
        this._defaultTrack = this._tracks[config.defaultTrack]["uid"];
    }
    else
    {
        this.warn("A playlist has a default track that is not in its tracks array!");
    }

    this._trackUID = this._defaultTrack;

    if(this._onReady !== null)
    {
        this._onReady.dispatch();
    }
};

/**
 * Internal method to find a {@link KEN.PlaylistTrack} index in the _tracks Array.
 * @method KEN.Playlist#_indexOfTrack
 * @private
 * @param {KEN.PlaylistTrack} value - The {@link KEN.PlaylistTrack} you search for. 
 * @return {number} Returns the index of the searched {@link KEN.PlaylistTrack} if found, -1 if not.
 *
KEN.Playlist.prototype._indexOfTrack = function (track) 
{
    if(this._tracks === null)
        return -1;

    var _track;

    for (var i = 0, ii = this._tracks.length; i < ii; i++)
    {
        _track = this._tracks[i];

        if(_track === track)
            return i;
    }

    return -1;
};
*/

/**
 * Event handler that triggers when the current track ends, set the next track to play.
 * @method KEN.Playlist#_trackEndHandler
 * @private
 */
KEN.Playlist.prototype._trackEndHandler = function()
{
    if(this._tracks.length > 0)
    {
        var index = this._tracks.indexOf(this._trackUID) + 1;
        if(index === this._tracks.length && this._viewer["playlists"]["loop"] === false)
        {
            return;
        }
    }
    
    this.nextTrack();
};

/**
 * Dispatch play event to the track
 * @method  KEN.PlaylistManager#_notifyPlay
 * @private
 */
KEN.Playlist.prototype._notifyPlay = function()
{
    if(this._onPlay !== null)
    {
        this._onPlay.dispatch();
    }
};

/**
 * Dispatch stop event to the track
 * @method  KEN.PlaylistManager#_notifyStop
 * @private
 */
KEN.Playlist.prototype._notifyStop = function()
{
    if(this._onStop !== null)
    {
        this._onStop.dispatch();
    }
};

/**
 * Dispatch pause event to the track
 * @method  KEN.PlaylistManager#_notifyPause
 * @private
 */
KEN.Playlist.prototype._notifyPause = function()
{
    if(this._onPause !== null)
    {
        this._onPause.dispatch();
    }
};

/**
 * Dispatch resume event to the track
 * @method  KEN.PlaylistManager#_notifyResume
 * @private
 */
KEN.Playlist.prototype._notifyResume = function()
{
    if(this._onResume !== null)
    {
        this._onResume.dispatch();
    }
};

/**
 * Dispatch ended event to the track
 * @method  KEN.PlaylistManager#_notifyEnded
 * @private
 */
KEN.Playlist.prototype._notifyEnded = function()
{
    if(this._onEnded !== null)
    {
        this._onEnded.dispatch();
    }
};

/**
 * Know if the playlist have any {@link KEN.PlaylistTrack}.
 * @method KEN.Playlist#hasTracks
 * @return {boolean} Returns true if the playlist has at least a {@link KEN.PlaylistTrack}, false if not.
 */
KEN.Playlist.prototype.hasTracks = function()
{
    return this._tracks.length !== 0;
};

/**
 * Play the current track or set a track to be the current one then play it.
 * @method KEN.Playlist#play
 * @param {?KEN.PlaylistTrack|string|number=} track - The track you want to play or its uid or its index, if undefined, play the current track.
 * @return {KEN.PlaylistTrack} Returns the playing track.
 */
KEN.Playlist.prototype.play = function(track)
{
    var uid;

    if(typeof track === "string" && KEN.UID.isTypeOf(track, "PlaylistTrack"))
    {
        uid = track;
    }
    else if(KEN.Utils.isTypeOf(track, "PlaylistTrack"))
    {
        uid = track["uid"];
    }
    else if (typeof track === "number" && track >= 0 && track < this._tracks.length)
    {
        uid = this._tracks[track];
    }
    else if(this._trackUID !== "")
    {
        uid = this._trackUID;
    }
    else if(typeof track === "undefined" || track === "")
    {
        uid = this._tracks[0];
    }

    if(typeof uid !== "undefined")
    {
        this.stop();

        this._trackUID = uid;

        this["track"].play();

        if(this["track"]["onEnded"].has(this._trackEndHandler, this) === false)
        {
            this["track"]["onEnded"].add(this._trackEndHandler, this);
        }
        
        this.log("KEN.Playlist.play(); [uid: "+this._trackUID+"]");

        return this["track"];
    }

    return null;
};

/**
 * Stop the current track.
 * @method KEN.Playlist#stop
 */
KEN.Playlist.prototype.stop = function()
{
    if(this["track"] !== null)
    {
        this["track"].stop();
    }
};

/**
 * Pause the current track.
 * @method KEN.Playlist#pause
 */
KEN.Playlist.prototype.pause = function()
{
    if(this["track"] !== null)// && this["track"]["playing"] === true)
    {
        this["track"].pause();
    }
};

/**
 * Resume the current track if it's paused.
 * @method KEN.Playlist#resume
 */
KEN.Playlist.prototype.resume = function()
{
    if(this["track"] !== null)// && this["track"]["paused"] === true
    {
        this["track"].resume();
    }
};

/**
 * Set the next {@link KEN.PlaylistTrack} to be the current track.
 * If the playlist is paused, keep the pause status of the playlist.
 * @method KEN.Playlist#nextTrack
 */
KEN.Playlist.prototype.nextTrack = function()
{
    var index = -1;

    if(this._tracks.length > 0)
    {
        index = this._tracks.indexOf(this._trackUID) + 1;

        if(index === this._tracks.length)
        {
            index = 0;
        }
    }

    var paused = this["paused"];

    this.play(index);

    if(paused === true)
    {
        this.pause();
    }
};

/**
 * Set the previous {@link KEN.PlaylistTrack} to be the current track.
 * If the playlist is paused, keep the pause status of the playlist.
 * @method KEN.Playlist#previousTrack
 */
KEN.Playlist.prototype.previousTrack = function()
{
    var index = -1;

    if(this._tracks.length > 0)
    {
        index = this._tracks.indexOf(this._trackUID) - 1;

        if(index === -1)
        {
            index = this._tracks.length - 1;
        }
    }

    var paused = this["paused"];

    this.play(index);

    if(paused === true)
    {
        this.pause();
    }
};

/**
 * Destroy sequence
 * @method KEN.Playlist#destroy
 */
KEN.Playlist.prototype.destroy = function()
{
    this.stop();

    this._viewer = null;

    this._name.destroy();
    this._name = null;

    if(this._tracks.length > 0)
    {
        this._tracks.length = 0;
        this._tracks = null;
    }

    this._config = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the list of tracks of this playlist.
 * @name KEN.Playlist#tracks
 * @readonly
 * @type {Array<string>}
 */
KEN.Playlist.prototype.tracks;
Object.defineProperty(KEN.Playlist.prototype, "tracks",
{
    /** @this {KEN.Playlist} */
    get: function ()
    {
        return this._tracks;
    }
});

/**
 * Get the name of this playlist.
 * @name KEN.Playlist#name
 * @readonly
 * @type {string}
 */
KEN.Playlist.prototype.name;
Object.defineProperty(KEN.Playlist.prototype, "name", 
{
    /** @this {KEN.Playlist} */
    get: function () 
    {
        return this._name["value"];
    }
});

/**
 * Get the ready status of this playlist current track.
 * @name KEN.Playlist#ready
 * @readonly
 * @type {boolean}
 */
KEN.Playlist.prototype.ready;
Object.defineProperty(KEN.Playlist.prototype, "ready", 
{
    /** @this {KEN.Playlist} */
    get: function()
    {
        if(this["track"] !== null)
        {
            return this["track"]["ready"];
        }

        return false;
    }
});

/**
 * Get the decoded status of this playlist current track.
 * @name KEN.Playlist#decoded
 * @readonly
 * @type {boolean}
 */
KEN.Playlist.prototype.decoded;
Object.defineProperty(KEN.Playlist.prototype, "decoded", 
{
    /** @this {KEN.Playlist} */
    get: function()
    {
        if(this["track"] !== null)
        {
            return this["track"]["decoded"];
        }

        return false;
    }
});

/**
 * Get the playing status of this playlist current track.
 * @name KEN.Playlist#playing
 * @readonly
 * @type {boolean}
 */
KEN.Playlist.prototype.playing;
Object.defineProperty(KEN.Playlist.prototype, "playing", 
{
    /** @this {KEN.Playlist} */
    get: function()
    {
        if(this["track"] !== null)
        {
            return this["track"]["playing"];
        }

        return false;
    }
});

/**
 * Get the paused status of this playlist current track.
 * @name KEN.Playlist#paused
 * @readonly
 * @type {boolean}
 */
KEN.Playlist.prototype.paused;
Object.defineProperty(KEN.Playlist.prototype, "paused", 
{
    /** @this {KEN.Playlist} */
    get: function()
    {
        if(this["track"] !== null)
        {
            return this["track"]["paused"];
        }

        return false;
    }
});

/**
 * Get the current {@link KEN.PlaylistTrack} of this playlist.
 * @name KEN.Playlist#track
 * @readonly
 * @type {KEN.PlaylistTrack}
 */
KEN.Playlist.prototype.track;
Object.defineProperty(KEN.Playlist.prototype, "track", 
{
    /** @this {KEN.Playlist} */
    get: function()
    {
        if(KEN.UID.isTypeOf(this._trackUID, "PlaylistTrack") === true)
        {
            return KEN.UID.get(this._trackUID, "PlaylistTrack");
        }

        return null;
    }
});

/**
 * Get the "onPlay" event {@link KEN.EventDispatcher} of the playlist.
 * @name KEN.Playlist#onPlay
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Playlist.prototype.onPlay;
Object.defineProperty(KEN.Playlist.prototype, "onPlay", 
{
    /** @this {KEN.Playlist} */
    get: function()
    {
        if(this._onPlay === null)
        {
            this._onPlay = new KEN.EventDispatcher(this);
        }

        return this._onPlay;
    }
});

/**
 * Get the "onStop" event {@link KEN.EventDispatcher} of the playlist.
 * @name KEN.Playlist#onStop
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Playlist.prototype.onStop;
Object.defineProperty(KEN.Playlist.prototype, "onStop", 
{
    /** @this {KEN.Playlist} */
    get: function()
    {
        if(this._onStop === null)
        {
            this._onStop = new KEN.EventDispatcher(this);
        }

        return this._onStop;
    }
});

/**
 * Get the "onPause" event {@link KEN.EventDispatcher} of the playlist.
 * @name KEN.Playlist#onPause
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Playlist.prototype.onPause;
Object.defineProperty(KEN.Playlist.prototype, "onPause", 
{
    /** @this {KEN.Playlist} */
    get: function()
    {
        if(this._onPause === null)
        {
            this._onPause = new KEN.EventDispatcher(this);
        }

        return this._onPause;
    }
});

/**
 * Get the "onResume" event {@link KEN.EventDispatcher} of the playlist.
 * @name KEN.Playlist#onResume
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Playlist.prototype.onResume;
Object.defineProperty(KEN.Playlist.prototype, "onResume", 
{
    /** @this {KEN.Playlist} */
    get: function()
    {
        if(this._onResume === null)
        {
            this._onResume = new KEN.EventDispatcher(this);
        }

        return this._onResume;
    }
});

/**
 * Get the "onEnded" event {@link KEN.EventDispatcher} of the playlist.
 * @name KEN.Playlist#onEnded
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Playlist.prototype.onEnded;
Object.defineProperty(KEN.Playlist.prototype, "onEnded", 
{
    /** @this {KEN.Playlist} */
    get: function()
    {
        if(this._onEnded === null)
        {
            this._onEnded = new KEN.EventDispatcher(this);
        }

        return this._onEnded;
    }
});

/**
 * Get the "onReady" {@link KEN.EventDispatcher} of the playlist.
 * @name KEN.Playlist#onReady
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Playlist.prototype.onReady;
Object.defineProperty(KEN.Playlist.prototype, "onReady", 
{
    /** @this {KEN.Playlist} */
    get: function()
    {
        if(this._onReady === null)
        {
            this._onReady = new KEN.EventDispatcher(this);
        }

        return this._onReady;
    }
});


/**
 * The KEN.PlaylistManager is an object that manages playlists of the tour.
 *
 * @constructor KEN.PlaylistManager
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @extends {KEN.BaseObject}
 *
 * @todo  autoPlay management (true by default)
 * @todo  previous/next playlist
 * @todo  real keepAudio to resume a "lost sound"
 * @todo  preload of all sounds
 */
KEN.PlaylistManager = function(viewer)
{
    /**
     * The viewer reference. 
     * @name KEN.PlaylistManager#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The general config backup.
     * @name KEN.PalylistManager#_config
     * @type {?AudioPlaylistsConfig}
     * @private
     */
    this._config = null;

    /**
     * Array of {@link KEN.Playlist}.
     * @name KEN.PlaylistManager#_playlists
     * @type {?Array<KEN.Playlist>}
     * @private
     */
    this._playlists = null;

    /**
     * The tracks list object.
     * @name  KEN.PlaylistManager#_tracks
     * @type {?Array<KEN.PlaylistTrack>}
     * @private
     */
    this._tracks = null;

    /**
     * Uid of the current {@link KEN.Playlist}.
     * @name  KEN.PlaylistManager#_playlistUID
     * @type {string}
     * @private
     */
    this._playlistUID = "";

    /**
     * The default playlist uid.
     * @name KEN.PlaylistManager#_defaultList
     * @type {string}
     * @private
     */
    this._defaultList = "";

    /**
     * The default playlist track uid or index.
     * @name KEN.PlaylistManager#_defaultTrack
     * @type {string}
     * @private
     */
    this._defaultTrack = "";

    /**
     * Is the current playlist will auto play?
     * @name KEN.PlaylistManager#_autoPlay
     * @type {boolean}
     * @private
     */
    this._autoPlay = true;

    /**
     * Is the current playlist will loop?
     * @name KEN.PlaylistManager#_loop
     * @type {boolean}
     * @private
     */
    this._loop = true;

    /**
     * The default volume for playlist.
     * Can't be greater than the maximum volume.
     * @name KEN.PlaylistManager#_defaultVolume
     * @type {number}
     * @private
     */
    this._defaultVolume = 1;

    /**
     * The maximum volume for playlist.
     * @name  KEN.PlaylistManager#_maxVolume
     * @type {number}
     * @private
     */
    this._maxVolume = 1;

    /**
     * Is the playlist manager enabled?
     * @name  KEN.PlaylistManager#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * The current volume of the playlist manager.
     * @name KEN.PlaylistManager#_volume
     * @type {number}
     * @private
     */
    this._volume = 1;

    /**
     * Is the current playlist track position kept?
     * @name  KEN.PlaylistManager#_keepAudio
     * @type {boolean}
     * @private
     */
    this._keepAudio = true;

    /**
     * Tracks must be preloaded?
     * @name  KEN.PlaylistManager#_preload
     * @type {boolean}
     * @private
     */
    this._preload = false;

    /**
     * On playlist manager ready event dispatcher.
     * @name KEN.Sound#_onReady
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onReady = null;

    /**
     * On playlist manager play event dispatcher.
     * @name KEN.PlaylistManager#_onPlay
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPlay = null;

    /**
     * On playlist manager stop event dispatcher.
     * @name KEN.PlaylistManager#_onStop
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onStop = null;

    /**
     * On playlist manager pause event dispatcher.
     * @name KEN.PlaylistManager#_onPause
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * On playlist manager resume event dispatcher.
     * @name KEN.PlaylistManager#_onResume
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onResume = null;

    /**
     * On playlist manager ended event dispatcher.
     * @name KEN.PlaylistManager#_onEnded
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onEnded = null;

    KEN.BaseObject.call(this, "PlaylistManager");

};

KEN.PlaylistManager.prototype = Object.create(KEN.BaseObject.prototype);
KEN.PlaylistManager.prototype.constructor = KEN.PlaylistManager;

/**
 * Boot sequence.
 * @method KEN.PlaylistManager#boot
 */
KEN.PlaylistManager.prototype.boot = function()
{
    this._playlists = [];
    this._tracks = [];

    this._viewer["audio"]["onEnable"].add(this._enableSoundHandler, this);
    this._viewer["tour"]["onSceneLoadStart"].add(this._sceneLoadStartHandler, this);
};

/**
 * Enable handler the sound manager.
 * @method KEN.PlaylistManager#_enableSoundHandler
 * @private
 */
KEN.PlaylistManager.prototype._enableSoundHandler = function()
{
    if(this._enabled === true && this._playlists.length > 0)
    {
        if(this["paused"] === true)
        {
            this.resume();
        }
        else if(this["playing"] === false)
        {
            this.play();
        }
    }
};

/**
 * Event handler for scene start.
 * @method KEN.PlaylistManager#_sceneLoadStartHandler
 * @private
 */
KEN.PlaylistManager.prototype._sceneLoadStartHandler = function()
{
    if(typeof this._viewer["tour"]["scene"]["config"]["playlists"] !== "undefined")
    {
        this._parseSceneConfig(this._viewer["tour"]["scene"]["config"]["playlists"]);
    }
    else 
    {
        if(this._enabled === false || this["ready"] === false || this["decoded"] === false || this["playing"] === true)
        {
            this._stopScenePlaylist();
        }

        //restore global playlists config
        this._applyConfig(this._config);

        //load the default playlist of the global audio if exists
        this._startScenePlaylist(this._defaultList, this._defaultTrack);
    }
};

/**
 * Parse the scene configuration part related to playlist.
 * @method  KEN.PlaylistManager#_parseSceneConfig
 * @private
 * @param  {AudioPlaylistsConfig} config - The scene configuration part related to playlist.
 */
KEN.PlaylistManager.prototype._parseSceneConfig = function(config)
{
    var extendedConfig = /** @type {AudioPlaylistsConfig} */ KEN.Utils.extendMultipleObjects(this._config, config);
    this._applyConfig(extendedConfig);

    if(this._enabled === false)
    {
        this._stopScenePlaylist();
    }
    else
    {
        if(!this._startScenePlaylist(this._defaultList, this._defaultTrack))
        {
            if(this["playing"] === true)
            {
                this._stopScenePlaylist();
            }
        }
    }
};

/**
 * Set values from configuration file.
 * @method  KEN.PlaylistManager#_applyConfig
 * @param {?AudioPlaylistsConfig} config - The config file.
 * @private
 */
KEN.PlaylistManager.prototype._applyConfig = function(config)
{
    if(config !== null)
    {
        this._enabled = typeof config["enabled"] !== "undefined" ? Boolean(config["enabled"]) : true;
        
        if (typeof config.defaultList !== "undefined")
        {
            if (typeof config.defaultList === "string" && config.defaultList !== "")
            {
                this._defaultList = config.defaultList;
            }
            else if (typeof config.defaultList === "number" && config.defaultList >= 0 && config.defaultList < this._playlists.length)
            {
                this._defaultList = this._playlists[config.defaultList]["uid"];
            }
        }

        if (typeof config.defaultTrack !== "undefined")
        {
            if (typeof config.defaultTrack === "string" && config.defaultTrack !== "")
            {
                this._defaultTrack = config.defaultTrack;
            }
            else if (typeof config.defaultTrack === "number" && config.defaultTrack >= 0 && config.defaultTrack < this._tracks.length)
            {
                this._defaultTrack = this._tracks[config.defaultTrack]["uid"];
            }
        }

        this._maxVolume = (typeof config["volume"] !== "undefined" && typeof config["volume"].max === "number") ? KEN.Math.clamp(config["volume"].max, 0, 1) : 1;
        this._defaultVolume = (typeof config["volume"] !== "undefined" && typeof config["volume"]["default"] === "number") ? KEN.Math.clamp(config["volume"]["default"], 0, this._maxVolume) : 1;
        this._autoPlay = typeof config["autoPlay"] !== "undefined" ? Boolean(config["autoPlay"]) : true;
        this._loop = typeof config["loop"] !== "undefined" ? Boolean(config["loop"]) : true;
    }
};

/**
 * Add a playlist config to the manager.
 * @method KEN.PlaylistManager#addConfig
 * @param {AudioPlaylistsConfig} config - The config you want to add.
 */
KEN.PlaylistManager.prototype.addConfig = function(config)
{
    this._parseConfig(config);

    this._initPlaylist();
};

/**
 * Parse a playlist config object.
 * @method KEN.PlaylistManager#_parseConfig
 * @private
 * @param {AudioPlaylistsConfig} config - The config you want to parse.
 */
KEN.PlaylistManager.prototype._parseConfig = function(config)
{
    var playlist, track;

    this._config = config;

    if(typeof config.lists !== "undefined")
    {
        for(var i = 0, ii = config.lists.length; i<ii; i++)
        {
            playlist = new KEN.Playlist(this._viewer, config.lists[i]);
            this.add(playlist);
        }
    }

    if(typeof config["tracks"] !== "undefined")
    {
        for(var j = 0, jj = config["tracks"].length; j<jj; j++)
        {
            track = new KEN.PlaylistTrack(this._viewer, config["tracks"][j]);
            this.addTrack(track);

            if(this._preload === true)
            {
                //@todo manage preload queue
                this.warn("Preload if not supported yet.");
            }
        }
    }

    this._applyConfig(config);

    if(typeof config.lists !== "undefined" && config.lists.length > 0)
    {
        //Parse the default playlist of the playlist manager
        if(typeof config.defaultList === "string" && config.defaultList !== "")
        {
            this._defaultList = config.defaultList;
        }
        else if(typeof config.defaultList === "number" && config.defaultList >= 0 && config.defaultList < this._playlists.length)
        {
            this._defaultList = this._playlists[config.defaultList]["uid"];
        }
        else
        {
            this.warn("The playlist manager has a default playlist that is not in its playlists array!");
        }

        this._playlistUID = this._defaultList;
    }
};

/**
 * Initialize the default playlist.
 * @method KEN.PlaylistManager#_initPlaylist
 * @private
 */
KEN.PlaylistManager.prototype._initPlaylist = function()
{
    if(this._playlists.length <= 0)
    {
        return;
    }

    if(typeof this._defaultVolume === "number")
    {
        this._volume = KEN.Math.clamp(this._defaultVolume, 0, 1);
    }

    var uid;
    if(typeof this._defaultList === "string" && this._defaultList !== "")
    {
        uid = this._defaultList;
    }
    else
    {
        uid = this._playlists[0]["uid"];
    }

    if(KEN.UID.get(uid) === undefined)
    {
        this.warn("PlaylistManager : uid \""+uid+"\" is not into playlists");
    }

    if(KEN.UID.isTypeOf(uid, "Playlist") === true)
    {
        this.play(uid);
    }
    else
    {
        this.warn("Impossible to play the playlist with uid "+uid+", it doesn't seem to be a playlist!");
    }
};

/**
 * Start or resume a playlist for a specific scene.
 * @method  KEN.PlaylistManager#_startScenePlaylist
 * @param {string} playlistUID - The default playlist uid.
 * @param {string|number} trackUID - The default track uid.
 * @return {boolean} Returns true if the playlist is found.
 * @private
 */
KEN.PlaylistManager.prototype._startScenePlaylist = function(playlistUID, trackUID)
{
    if(playlistUID !== null && KEN.UID.isTypeOf(playlistUID, "Playlist") === true)
    {
        //Maybe the new scene shares the same playlist so we do not reset the playback
        if(this["playlist"] !== null && this["playlist"]["uid"] === playlistUID)
        {
            if(this["playlist"]["track"] !== null && (trackUID === "" || this["playlist"]["track"]["uid"] === trackUID || this["playlist"]["track"]["uid"] === "" || typeof this["playlist"]["track"]["uid"] === "undefined"))
            {
                if(this._keepAudio === true && this["paused"] === true)
                {
                    this.resume();
                }
                else if(this._keepAudio === true && this["playing"] === false)
                {
                    this.play();
                }
            }
            else
            {
                this.stop();
                this.play(playlistUID, trackUID);
            }
        }
        else
        {
            this.stop();
            this.play(playlistUID, trackUID);
        }

        return true;
    }

    return false;
};

/**
 * Stop or pause a playlist.
 * @method  KEN.PlaylistManager#_stopScenePlaylist
 * @private
 */
KEN.PlaylistManager.prototype._stopScenePlaylist = function()
{
    if(this._keepAudio === true && this["playing"] === true)
    {
        this.pause();
    }
    else   
    {
        this.stop();
    }
};

/**
 * Dispatch play event and notify it to the playlist
 * @method  KEN.PlaylistManager#_notifyPlay
 * @private
 */
KEN.PlaylistManager.prototype._notifyPlay = function()
{
    if(this._onPlay !== null)
    {
        this._onPlay.dispatch();
    }

    if(this["playlist"] !== null)
    {
        this["playlist"]._notifyPlay();
    }
};

/**
 * Dispatch stop event and notify it to the playlist
 * @method  KEN.PlaylistManager#_notifyStop
 * @private
 */
KEN.PlaylistManager.prototype._notifyStop = function()
{
    if(this._onStop !== null)
    {
        this._onStop.dispatch();
    }

    if(this["playlist"] !== null)
    {
        this["playlist"]._notifyStop();
    }
};

/**
 * Dispatch pause event and notify it to the playlist
 * @method  KEN.PlaylistManager#_notifyPause
 * @private
 */
KEN.PlaylistManager.prototype._notifyPause = function()
{
    if(this._onPause !== null)
    {
        this._onPause.dispatch();
    }

    if(this["playlist"] !== null)
    {
        this["playlist"]._notifyPause();
    }
};

/**
 * Dispatch resume event and notify it to the playlist
 * @method  KEN.PlaylistManager#_notifyResume
 * @private
 */
KEN.PlaylistManager.prototype._notifyResume = function()
{
    if(this._onResume !== null)
    {
        this._onResume.dispatch();
    }

    if(this["playlist"] !== null)
    {
        this["playlist"]._notifyResume();
    }
};

/**
 * Dispatch ended event and notify it to the playlist
 * @method  KEN.PlaylistManager#_notifyEnded
 * @private
 */
KEN.PlaylistManager.prototype._notifyEnded = function()
{
    if(this._onEnded !== null)
    {
        this._onEnded.dispatch();
    }

    if(this["playlist"] !== null)
    {
        this["playlist"]._notifyEnded();
    }
};

/**
 * Add a {@link KEN.Playlist} to the playlist manager.
 * @method  KEN.PlaylistManager#add
 * @param {KEN.Playlist} playlist - The {@link KEN.Playlist} you want to add.
 */
KEN.PlaylistManager.prototype.add = function(playlist)
{
    this._playlists.push(playlist);
};

/**
 * Add a {@link KEN.PlaylistTrack} to the playlist manager.
 * @method  KEN.PlaylistManager#addTrack
 * @param {KEN.PlaylistTrack} track - The {@link KEN.PlaylistTrack} you want to add.
 */
KEN.PlaylistManager.prototype.addTrack = function(track)
{
    this._tracks.push(track);
};

/**
 * Know if the tour have any {@link KEN.Playlist}.
 * @method KEN.PlaylistManager#hasPlaylists
 * @return {boolean} Returns true if the tour has at least a {@link KEN.Playlist}, false if not.
 */
KEN.PlaylistManager.prototype.hasPlaylists = function()
{
    return this._playlists.length !== 0;
};

/**
 * Know if the tour have any {@link KEN.PlaylistTrack}.
 * @method KEN.PlaylistManager#hasTracks
 * @return {boolean} Returns true if the tour has at least a {@link KEN.PlaylistTrack}, false if not.
 */
KEN.PlaylistManager.prototype.hasTracks = function()
{
    return this._tracks.length !== 0;
};

/**
 * Play the current playlist or a specific one at a specific track.
 * @method  KEN.PlaylistManager#play
 * @param  {KEN.Playlist|string|number=} playlist - The {@link KEN.Playlist} you want to play or its uid or its index.
 * @param  {string|number=} track - The {@link KEN.PlaylistTrack} you want to play or its uid or its index, if undefined, play the current track.
 */
KEN.PlaylistManager.prototype.play = function(playlist, track)
{
    var uid;

    if(typeof playlist === "string" && KEN.UID.isTypeOf(playlist, "Playlist"))
    {
        uid = playlist;
    }
    else if(KEN.Utils.isTypeOf(playlist, "Playlist"))
    {
        uid = playlist["uid"];
    }
    else if (typeof playlist === "number" && playlist >= 0 && playlist < this._playlists.length)
    {
        uid = this._playlists[playlist]["uid"];
    }
    else if(this._playlistUID !== "")
    {
        uid = this._playlistUID;
    }
    else if(typeof playlist === "undefined" || playlist === "")
    {
        uid = this._playlists[0]["uid"];
    }
    
    if(typeof uid !== "undefined")
    {
        if(this["playing"] === true)
        {   
            this.stop();
        }

        this._playlistUID = uid;

        if(this._enabled === true)
        {
            //verify if the track is into the playlist
            if(typeof track === "string" && KEN.UID.isTypeOf(track, "PlaylistTrack") && this["playlist"]["tracks"].length > 0 && this["playlist"]["tracks"].indexOf(track) !== -1)
            {
                this["playlist"].play(track);
            }
            else
            {
                this["playlist"].play();
            }

            this.log("KEN.PlaylistManager.play(); [uid: "+this._playlistUID+"]");
        }
    }
};

/**
 * Stop the current {@link KEN.Playlist}.
 * @method  KEN.PlaylistManager#play
 */
KEN.PlaylistManager.prototype.stop = function()
{
    if(this["playlist"] !== null)
    {
        this["playlist"].stop();
    }
};

/**
 * Pause the current {@link KEN.Playlist}.
 * @method  KEN.PlaylistManager#pause
 */
KEN.PlaylistManager.prototype.pause = function()
{
    if(this["playlist"] !== null && this["playlist"]["playing"] === true)
    {
        this["playlist"].pause();
    }
};

/**
 * Resume the current {@link KEN.Playlist}.
 * @method  KEN.PlaylistManager#resume
 */
KEN.PlaylistManager.prototype.resume = function()
{
    if(this["playlist"] !== null && this._enabled === true && this["playlist"]["paused"] === true)
    {
        this["playlist"].resume();
    }
};

/**
 * Set the next {@link KEN.PlaylistTrack} of the current {@link KEN.Playlist} to be the current track.<br>
 * If the playlist is paused, keep the pause status of the playlist.
 * @method KEN.PlaylistManager#nextTrack
 */
KEN.PlaylistManager.prototype.nextTrack = function()
{
    if(this["playlist"] !== null && this._enabled === true)
    {
        this["playlist"].nextTrack();
    }
};

/**
 * Set the previous {@link KEN.PlaylistTrack} of the current {@link KEN.Playlist} to be the current track.<br>
 * If the playlist is paused, keep the pause status of the playlist.
 * @method KEN.PlaylistManager#previousTrack
 */
KEN.PlaylistManager.prototype.previousTrack = function()
{
    if(this["playlist"] !== null && this._enabled === true)
    {
        this["playlist"].previousTrack();
    }
};

/**
 * Destroy sequence
 * @method KEN.PlaylistManager#destroy
 */
KEN.PlaylistManager.prototype.destroy = function()
{
    this.stop();

    this._viewer["audio"]["onEnable"].remove(this._enableSoundHandler, this);
    this._viewer["tour"]["onSceneLoadStart"].remove(this._sceneLoadStartHandler, this);

    this._viewer = null;
    this._config = null;

    var i = this._playlists.length;
    while(i--)
    {
        this._playlists[i].destroy();
    }
    this._playlists = null;

    var j = this._tracks.length;
    while(j--)
    {
        this._tracks[j].destroy();
    }
    this._tracks = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the playlists Array.
 * @name KEN.PlaylistManager#playlists
 * @readonly
 * @type {Array<KEN.Playlist>}
 */
KEN.PlaylistManager.prototype.playlists;
Object.defineProperty(KEN.PlaylistManager.prototype, "playlists", 
{
    /** @this {KEN.PlaylistManager} */
    get: function()
    {
        return this._playlists;
    }
});

/**
 * Get the tracks Array.
 * @name KEN.PlaylistManager#tracks
 * @readonly
 * @type {Array<KEN.Playlist>}
 */
KEN.PlaylistManager.prototype.tracks;
Object.defineProperty(KEN.PlaylistManager.prototype, "tracks", 
{
    /** @this {KEN.PlaylistManager} */
    get: function()
    {
        return this._tracks;
    }
});

/**
 * Get the current playlist.
 * @name KEN.PlaylistManager#playlist
 * @readonly
 * @type {?KEN.Playlist}
 */
KEN.PlaylistManager.prototype.playlist;
Object.defineProperty(KEN.PlaylistManager.prototype, "playlist", 
{
    /** @this {KEN.PlaylistManager} */
    get: function()
    {
        if(KEN.UID.isTypeOf(this._playlistUID, "Playlist") === true)
        {
            return KEN.UID.get(this._playlistUID, "Playlist");
        }
    
        return null;
    }
});

/**
 * Used to try to keep the current audio position rather than to use play and stop actions.
 * @name KEN.PlaylistManager#keepAudio
 * @type {boolean}
 */
KEN.PlaylistManager.prototype.keepAudio;
Object.defineProperty(KEN.PlaylistManager.prototype, "keepAudio", 
{
    /** @this {KEN.PlaylistManager} */
    get: function() 
    {
        return this._keepAudio;
    },

    /** @this {KEN.PlaylistManager} */
    set: function(value)
    {
        this._keepAudio = Boolean(value);
    }
});

/**
 * Current playlist must be looped.
 * @name KEN.PlaylistManager#loop
 * @type {boolean}
 */
KEN.PlaylistManager.prototype.loop;
Object.defineProperty(KEN.PlaylistManager.prototype, "loop", 
{
    /** @this {KEN.PlaylistManager} */
    get: function() 
    {
        return this._loop;
    },

    /** @this {KEN.PlaylistManager} */
    set: function(value)
    {
        this._loop = Boolean(value);
    }
});

/**
 * Auto play status of the playlist.
 * @name KEN.PlaylistManager#autoPlay
 * @type {boolean}
 */
KEN.PlaylistManager.prototype.autoPlay;
Object.defineProperty(KEN.PlaylistManager.prototype, "autoPlay", 
{
    /** @this {KEN.PlaylistManager} */
    get: function() 
    {
        return this._autoPlay;
    },

    /** @this {KEN.PlaylistManager} */
    set: function(value)
    {
        this._autoPlay = Boolean(value);
    }
});

/**
 * Preload status of audio files.
 * @name KEN.PlaylistManager#preload
 * @type {boolean}
 */
KEN.PlaylistManager.prototype.preload;
Object.defineProperty(KEN.PlaylistManager.prototype, "preload", 
{
    /** @this {KEN.PlaylistManager} */
    get: function() 
    {
        return this._preload;
    },

    /** @this {KEN.PlaylistManager} */
    set: function(value)
    {
        this._preload = Boolean(value);
    }
});

/**
 * Get the enabled status of the playlists manager.
 * @name KEN.PlaylistManager#enabled
 * @readonly
 * @type {boolean}
 */
KEN.PlaylistManager.prototype.enabled;
Object.defineProperty(KEN.PlaylistManager.prototype, "enabled", 
{
    /** @this {KEN.PlaylistManager} */
    get: function()
    {
        return this._enabled;
    }
});

/**
 * Get the ready status of current {@link KEN.Playlist}.
 * @name KEN.PlaylistManager#ready
 * @readonly
 * @type {boolean}
 */
KEN.PlaylistManager.prototype.ready;
Object.defineProperty(KEN.PlaylistManager.prototype, "ready", 
{
    /** @this {KEN.PlaylistManager} */
    get: function()
    {
        if(this["playlist"] !== null)
        {
            return this["playlist"]["ready"];
        }

        return false;
    }
});

/**
 * Get the decoded status of current {@link KEN.Playlist}.
 * @name KEN.PlaylistManager#decoded
 * @readonly
 * @type {boolean}
 */
KEN.PlaylistManager.prototype.decoded;
Object.defineProperty(KEN.PlaylistManager.prototype, "decoded", 
{
    /** @this {KEN.PlaylistManager} */
    get: function()
    {
        if(this["playlist"] !== null)
        {
            return this["playlist"]["decoded"];
        }

        return false;
    }
});

/**
 * Get the playing status of current {@link KEN.Playlist}.
 * @name KEN.PlaylistManager#playing
 * @readonly
 * @type {boolean}
 */
KEN.PlaylistManager.prototype.playing;
Object.defineProperty(KEN.PlaylistManager.prototype, "playing", 
{
    /** @this {KEN.PlaylistManager} */
    get: function()
    {
        if(this["playlist"] !== null)
        {
            return this["playlist"]["playing"];
        }

        return false;
    }
});

/**
 * Get the pause status of current {@link KEN.Playlist}.
 * @name KEN.PlaylistManager#paused
 * @readonly
 * @type {boolean}
 */
KEN.PlaylistManager.prototype.paused;
Object.defineProperty(KEN.PlaylistManager.prototype, "paused", 
{
    /** @this {KEN.PlaylistManager} */
    get: function()
    {
        if(this["playlist"] !== null)
        {
            return this["playlist"]["paused"];
        }

        return false;
    }
});

/**
 * Get the playlist lanager main volume.
 * @name KEN.PlaylistManager#volume
 * @type {number}
 */
KEN.PlaylistManager.prototype.volume;
Object.defineProperty(KEN.PlaylistManager.prototype, "volume", 
{
    /** @this {KEN.PlaylistManager} */
    get: function()
    {
        return this._volume;
    },

    /** @this {KEN.PlaylistManager} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        value = KEN.Math.clamp(value, 0, 1);
        if(this._maxVolume < value)
        {
            this._volume = this._maxVolume;
        }
        else
        {
            this._volume = value;
        }

        if(KEN.UID.isTypeOf(this._playlistUID, "Playlist") === true)
        {
            var track = KEN.UID.get(this._playlistUID, "Playlist").track;

            if(track !== null)
            {
                track["volume"] = this._volume;
            }
        }
    }
});

/**
 * Get the "onReady" event {@link KEN.EventDispatcher} of the playlist.
 * @name KEN.PlaylistManager#onReady
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.PlaylistManager.prototype.onReady;
Object.defineProperty(KEN.PlaylistManager.prototype, "onReady", 
{
    /** @this {KEN.PlaylistManager} */
    get: function()
    {
        if(this._onReady === null)
        {
            this._onReady = new KEN.EventDispatcher(this);
        }
        
        return this._onReady;
    }
});

/**
 * Get the "onPlay" event {@link KEN.EventDispatcher} of the track.
 * @name KEN.PlaylistManager#onPlay
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.PlaylistManager.prototype.onPlay;
Object.defineProperty(KEN.PlaylistManager.prototype, "onPlay", 
{
    /** @this {KEN.PlaylistManager} */
    get: function()
    {
        if(this._onPlay === null)
        {
            this._onPlay = new KEN.EventDispatcher(this);
        }
        
        return this._onPlay;
    }
});

/**
 * Get the "onStop" event {@link KEN.EventDispatcher} of the track.
 * @name KEN.PlaylistManager#onStop
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.PlaylistManager.prototype.onStop;
Object.defineProperty(KEN.PlaylistManager.prototype, "onStop", 
{
    /** @this {KEN.PlaylistManager} */
    get: function()
    {
        if(this._onStop === null)
        {
            this._onStop = new KEN.EventDispatcher(this);
        }
        
        return this._onStop;
    }
});

/**
 * Get the "onPause" event {@link KEN.EventDispatcher} of the track.
 * @name KEN.PlaylistManager#onPause
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.PlaylistManager.prototype.onPause;
Object.defineProperty(KEN.PlaylistManager.prototype, "onPause", 
{
    /** @this {KEN.PlaylistManager} */
    get: function()
    {
        if(this._onPause === null)
        {
            this._onPause = new KEN.EventDispatcher(this);
        }
        
        return this._onPause;
    }
});

/**
 * Get the "onResume" event {@link KEN.EventDispatcher} of the track.
 * @name KEN.PlaylistManager#onResume
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.PlaylistManager.prototype.onResume;
Object.defineProperty(KEN.PlaylistManager.prototype, "onResume", 
{
    /** @this {KEN.PlaylistManager} */
    get: function()
    {
        if(this._onResume === null)
        {
            this._onResume = new KEN.EventDispatcher(this);
        }
        
        return this._onResume;
    }
});

/**
 * Get the "onEnded" event {@link KEN.EventDispatcher} of the track.
 * @name KEN.PlaylistManager#onEndedd
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.PlaylistManager.prototype.onEnded;
Object.defineProperty(KEN.PlaylistManager.prototype, "onEnded", 
{
    /** @this {KEN.PlaylistManager} */
    get: function()
    {
        if(this._onEnded === null)
        {
            this._onEnded = new KEN.EventDispatcher(this);
        }
        
        return this._onEnded;
    }
});


/**
 * A KEN.PlaylistTrack is an object that manages the sound atached to a playlist track.
 *
 * @constructor KEN.PlaylistTrack
 * @param {KEN.Viewer} viewer - The {@link KEN.Viewer} reference.
 * @param {AudioTrackConfig} config - The track config object.
 * @extends {KEN.BaseObject}
 */
KEN.PlaylistTrack = function(viewer, config)
{
    /**
     * The viewer reference. 
     * @name KEN.PlaylistTrack#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The config object. 
     * @name KEN.PlaylistTrack#_config
     * @type {?AudioTrackConfig}
     * @private
     */
    this._config = config;

    /**
     * The name of the track.
     * @name  KEN.PlaylistTrack#_name
     * @type {?KEN.LocaleString}
     * @private
     */
    this._name = null;

    /**
     * The author of the track.
     * @name  KEN.PlaylistTrack#_author
     * @type {?KEN.LocaleString}
     * @private
     */
    this._author = null;

    /**
     * The url of the track.
     * @name  KEN.PlaylistTrack#_url
     * @type {string}
     * @private
     */
    this._url = "";

    /**
     * The {@link KEN.Sound} attached to this track.
     * @name  KEN.PlaylistTrack#_sound
     * @type {?KEN.Sound}
     * @private
     */
    this._sound = null;

    KEN.BaseObject.call(this, "PlaylistTrack");

    this._boot();
};

KEN.PlaylistTrack.prototype = Object.create(KEN.BaseObject.prototype);
KEN.PlaylistTrack.prototype.constructor = KEN.PlaylistTrack;

/**
 * Boot sequence.
 * @method KEN.PlaylistTrack#_boot
 * @private
 */
KEN.PlaylistTrack.prototype._boot = function()
{
    this._uid = this._config["uid"];
    this._register();

    this._parseConfig(this._config);
};

/**
 * Parse the track config.
 * @method KEN.PlaylistTrack#_parseConfig
 * @param {AudioTrackConfig} config - The config to parse.
 * @private
 */
KEN.PlaylistTrack.prototype._parseConfig = function(config)
{
    this._unregister();
    this._uid = config["uid"];
    this._register();
    this._name = new KEN.LocaleString(this._viewer, config["name"]);
    this._author = new KEN.LocaleString(this._viewer, config["author"]);
    this._url = config["url"];
};

/**
 * Bind handlers on the sound
 * @method  KEN.PlaylistTrack#_bindEvents
 * @private
 */
KEN.PlaylistTrack.prototype._bindEvents = function()
{
    this._sound["onPlay"].add(this._onPlayHandler, this);
    this._sound["onStop"].add(this._onStopHandler, this);
    this._sound["onPause"].add(this._onPauseHandler, this);
    this._sound["onResume"].add(this._onResumeHandler, this);
    this._sound["onEnded"].add(this._onEndedHandler, this);
};

/**
 * Unbind handlers on the sound
 * @method  KEN.PlaylistTrack#_unbindEvents
 * @private
 */
KEN.PlaylistTrack.prototype._unbindEvents = function()
{
    this._sound["onPlay"].remove(this._onPlayHandler, this);
    this._sound["onStop"].remove(this._onStopHandler, this);
    this._sound["onPause"].remove(this._onPauseHandler, this);
    this._sound["onResume"].remove(this._onResumeHandler, this);
    this._sound["onEnded"].remove(this._onEndedHandler, this);
};

/**
 * Play handler to notify event to the playlist manager
 * @method  KEN.PlaylistTrack#_onPlayHandler
 * @private
 */
KEN.PlaylistTrack.prototype._onPlayHandler = function()
{
    this._viewer["playlists"]._notifyPlay();
};

/**
 * Stop handler to notify event to the playlist manager
 * @method  KEN.PlaylistTrack#_onStopHandler
 * @private
 */
KEN.PlaylistTrack.prototype._onStopHandler = function()
{
    this._viewer["playlists"]._notifyStop();
};

/**
 * Pause handler to notify event to the playlist manager
 * @method  KEN.PlaylistTrack#_onPauseHandler
 * @private
 */
KEN.PlaylistTrack.prototype._onPauseHandler = function()
{
    this._viewer["playlists"]._notifyPause();
};

/**
 * Resume handler to notify event to the playlist manager
 * @method  KEN.PlaylistTrack#_onResumeHandler
 * @private
 */
KEN.PlaylistTrack.prototype._onResumeHandler = function()
{
    this._viewer["playlists"]._notifyResume();
};

/**
 * Ended handler to notify event to the playlist manager
 * @method  KEN.PlaylistTrack#_onEndedHandler
 * @private
 */
KEN.PlaylistTrack.prototype._onEndedHandler = function()
{
    this._viewer["playlists"]._notifyEnded();
};

/**
 * Play the track.
 * @method KEN.PlaylistTrack#play
 */
KEN.PlaylistTrack.prototype.play = function()
{
    if(this._sound === null)
    {
        this._sound = new KEN.Sound(this._viewer, this._uid + "-sound", this._url);
        this._sound["volume"] = this._viewer["playlists"]["volume"];

        this._bindEvents();
    }    

    this._sound.play();
};

/**
 * Stop the track.
 * @method KEN.PlaylistTrack#stop
 */
KEN.PlaylistTrack.prototype.stop = function()
{
    if(this._sound !== null)
    {
        this._sound.stop();
    }
};

/**
 * Pause the track.
 * @method KEN.PlaylistTrack#pause
 */
KEN.PlaylistTrack.prototype.pause = function()
{
    if(this._sound !== null)
    {
        this._sound.pause();
    }
};

/**
 * Resume the track.
 * @method KEN.PlaylistTrack#resume
 */
KEN.PlaylistTrack.prototype.resume = function()
{
    if(this._sound !== null)
    {
        this._sound.resume();
    }
};

/**
 * Destroy sequence
 * @method  KEN.PlaylistTrack#destroy
 */
KEN.PlaylistTrack.prototype.destroy = function()
{
    this._viewer = null;

    this._config = null;

    this._name.destroy();
    this._name = null;

    this._author.destroy();
    this._author = null;

    if(this._sound !== null)
    {
        this._unbindEvents();

        this._sound.destroy();
        this._sound = null;
    }

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the name of the track.
 * @name  KEN.PlaylistTrack#name
 * @type {string}
 */
KEN.PlaylistTrack.prototype.name;
Object.defineProperty(KEN.PlaylistTrack.prototype, "name", 
{
    /** @this {KEN.PlaylistTrack} */
    get: function()
    {
        return this._name["value"];
    }
});

/**
 * Get the author of the track.
 * @name  KEN.PlaylistTrack#author
 * @type {string}
 */
KEN.PlaylistTrack.prototype.author;
Object.defineProperty(KEN.PlaylistTrack.prototype, "author", 
{
    /** @this {KEN.PlaylistTrack} */
    get: function()
    {
        return this._author["value"];
    }
});

/**
 * Get and set the current time of the track.
 * @name  KEN.PlaylistTrack#currentTime
 * @type {number}
 */
KEN.PlaylistTrack.prototype.currentTime;
Object.defineProperty(KEN.PlaylistTrack.prototype, "currentTime", 
{
    /** @this {KEN.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound["currentTime"];
        }

        return 0;
    },

    /** @this {KEN.PlaylistTrack} */
    set: function(value)
    {
        if(this._sound === null)
        {
            return;
        }

        this._sound["currentTime"] = value;
    }
});

/**
 * Get and set the volume of the track.
 * @name  KEN.PlaylistTrack#volume
 * @type {number}
 */
KEN.PlaylistTrack.prototype.volume;
Object.defineProperty(KEN.PlaylistTrack.prototype, "volume", 
{
    /** @this {KEN.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound["volume"];
        }

        return false;
    },

    /** @this {KEN.PlaylistTrack} */
    set: function(value)
    {
        if(this._sound === null)
        {
            return false;
        }

        this._sound["volume"] = value;
    }
});

/**
 * Get the ready status of the track.
 * @name KEN.PlaylistTrack#ready
 * @readonly
 * @type {boolean}
 */
KEN.PlaylistTrack.prototype.ready;
Object.defineProperty(KEN.PlaylistTrack.prototype, "ready", 
{
    /** @this {KEN.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound["ready"];
        }

        return false;
    }
});

/**
 * Get the decoded status of the track.
 * @name KEN.PlaylistTrack#decoded
 * @readonly
 * @type {boolean}
 */
KEN.PlaylistTrack.prototype.decoded;
Object.defineProperty(KEN.PlaylistTrack.prototype, "decoded", 
{
    /** @this {KEN.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound["decoded"];
        }

        return false;
    }
});

/**
 * Get the playing status of the track.
 * @name KEN.PlaylistTrack#playing
 * @readonly
 * @type {boolean}
 */
KEN.PlaylistTrack.prototype.playing;
Object.defineProperty(KEN.PlaylistTrack.prototype, "playing", 
{
    /** @this {KEN.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound["playing"];
        }

        return false;
    }
});

/**
 * Get the paused status of the track.
 * @name KEN.PlaylistTrack#paused
 * @readonly
 * @type {boolean}
 */
KEN.PlaylistTrack.prototype.paused;
Object.defineProperty(KEN.PlaylistTrack.prototype, "paused", 
{
    /** @this {KEN.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound["paused"];
        }

        return false;
    }
});

/**
 * Get the "onPlay" event {@link KEN.EventDispatcher} of the track.
 * @name KEN.PlaylistTrack#onPlay
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.PlaylistTrack.prototype.onPlay;
Object.defineProperty(KEN.PlaylistTrack.prototype, "onPlay", 
{
    /** @this {KEN.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound["onPlay"];
        }
        
        return;
    }
});

/**
 * Get the "onStop" event {@link KEN.EventDispatcher} of the track.
 * @name KEN.PlaylistTrack#onStop
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.PlaylistTrack.prototype.onStop;
Object.defineProperty(KEN.PlaylistTrack.prototype, "onStop", 
{
    /** @this {KEN.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound["onStop"];
        }
        
        return;
    }
});

/**
 * Get the "onPause" event {@link KEN.EventDispatcher} of the track.
 * @name KEN.PlaylistTrack#onPause
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.PlaylistTrack.prototype.onPause;
Object.defineProperty(KEN.PlaylistTrack.prototype, "onPause", 
{
    /** @this {KEN.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound["onPause"];
        }
        
        return;
    }
});

/**
 * Get the "onResume" event {@link KEN.EventDispatcher} of the track.
 * @name KEN.PlaylistTrack#onResume
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.PlaylistTrack.prototype.onResume;
Object.defineProperty(KEN.PlaylistTrack.prototype, "onResume", 
{
    /** @this {KEN.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound["onResume"];
        }
        
        return;
    }
});

/**
 * Get the "onEnded" event {@link KEN.EventDispatcher} of the track.
 * @name KEN.PlaylistTrack#onEnded
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.PlaylistTrack.prototype.onEnded;
Object.defineProperty(KEN.PlaylistTrack.prototype, "onEnded", 
{
    /** @this {KEN.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound["onEnded"];
        }
        
        return;
    }
});

/**
 * Direcotr's cut manager.
 * @constructor KEN.Director
 * @param {KEN.Viewer} viewer - Viewer reference.
 * @extends {KEN.BaseObject}
 */
KEN.Director = function(viewer)
{
    /**
     * Viewer reference.
     * @name KEN.Director#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Array of director tracks.
     * @name KEN.Director#_tracks
     * @type {Array<KEN.DirectorTrack>}
     * @private
     */
    this._tracks = null;

    /**
     * Current director track
     * @name  KEN.Director#_track
     * @type {?KEN.DirectorTrack}
     * @private
     */
    this._track = null;

    /**
     * This object handles the animation configuration
     * @name  KEN.Director#_animation
     * @type {?DirectorAnimationConfig}
     * @private
     */
    this._animation = null;

    /**
     * Timer reference used to trigger an animation after idle time
     * @name KEN.Director#_idleTimer
     * @type {KEN.Timer}
     * @private
     */
    this._idleTimer = null;

    KEN.BaseObject.call(this, "Director");

    this._boot();
};

KEN.Director.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Director.prototype.constructor = KEN.Director;

/**
 * Boot sequence
 * @method KEN.Director#_boot
 * @private
 */
KEN.Director.prototype._boot = function()
{
    this._tracks = [];

    this._idleTimer = this._viewer["clock"].create(false);

    this._viewer["tour"]["onSceneLoadComplete"].add(this._sceneLoadCompleteHandler, this);

    this._viewer["onReady"].add(this._onViewerReady, this);
};

/**
 * Viewer ready handler
 * @method KEN.Director#_onViewerReady
 * @private
 */
KEN.Director.prototype._onViewerReady = function()
{
    this._viewer["controllers"]["onControlStart"].add(this._controlStartHandler, this);
    this._viewer["controllers"]["onControlEnd"].add(this._controlEndHandler, this);
};

/**
 * Parse director tracks.
 * @method KEN.Director#parseConfig
 * @private
 * @param {DirectorConfig} config - The configuration object to parse.
 */
KEN.Director.prototype._parseConfig = function(config)
{
    // If there are dirctors tracks in the config, create the KEN.DirectorTrack objects.
    if(Array.isArray(config["tracks"]) === true)
    {
        for(var i = 0, ii = config["tracks"].length; i < ii; i++)
        {
            var track = new KEN.DirectorTrack(this._viewer, config["tracks"][i]);
            this._tracks.push(track);
        }
    }
};

/**
 * Event handler for scene load complete.
 * @method  KEN.Director#_sceneLoadCompleteHandler
 * @private
 */
KEN.Director.prototype._sceneLoadCompleteHandler = function()
{
    var scene = this._viewer["tour"]["scene"];

    if(typeof scene["config"]["director"] !== "undefined")
    {
        var director = scene["config"]["director"];

        if(typeof director["animation"] !== undefined && director["animation"] !== null)
        {
            this._parseAnimation(director["animation"]);
        }
    }
};

/**
 * Event handler for control start.
 * @method KEN.Director#_controlStartHandler
 * @private
 */
KEN.Director.prototype._controlStartHandler = function()
{
    if(this._animation !== null && this._animation.userCanStop === true)
    {
        this.stop();
        this._idleTimer.stop(true);
    }
};

/**
 * Event handler for control end.
 * @method KEN.Director#_controlEndHandler
 * @private
 */
KEN.Director.prototype._controlEndHandler = function()
{
    if(this._animation !== null && this._animation.idleTimer === true)
    {
        var timeToStart = (typeof this._animation.idleTimeToStart === "number") ? this._animation.idleTimeToStart : 3000;
        this._idleTimer.add(timeToStart, this._idleTimerCompleteHandler, this);
        this._idleTimer.start(); 
    }
};

/**
 * Event handler for idle timer complete.
 * @method KEN.Director#_idleTimerCompleteHandler
 * @private
 */
KEN.Director.prototype._idleTimerCompleteHandler = function()
{
    this.play();
    this._idleTimer.stop(true); 
};

/**
 * Animation parser.
 * @method KEN.Director#_parseAnimation
 * @private
 * @param {DirectorAnimationConfig} animation - The animation object to parse.
 */
KEN.Director.prototype._parseAnimation = function(animation)
{
    if(animation["enabled"] === false)
    {
        this._animation = null;
        return;
    }

    this._animation = animation;

    if(Array.isArray(this._animation["tracks"]) === true && this._animation["tracks"].length > 0)
    {
        var track = this._animation["tracks"][0];
        var loop = (typeof this._animation["loop"] !== "undefined") ? Boolean(this._animation["loop"]) : false;
        var tweenToStart = (typeof this._animation["tweenToStart"] !== "undefined") ? Boolean(this._animation["tweenToStart"]) : true;
        
        if(this._animation.autoplay === true)
        {
            this.play(track, tweenToStart, loop);   
        }
    }
};

/**
 * Add a tracks configuration object to the Director manager.
 * @method  KEN.Director#addConfig
 * @param {DirectorConfig} config - The tracks configuration object to add.
 */
KEN.Director.prototype.addConfig = function(config)
{
    this._parseConfig(config);
};

/**
 * Play a director track.
 * @method  KEN.Director#play
 * @param  {(string|KEN.DirectorTrack)=} value - The track uid or a {@link KEN.Director track} to play. 
 * @param  {boolean=} tweenToStart - Does the animation have to tween to the first waypoint?
 * @param  {boolean=} loop - Does the animation have to loop?
 */
KEN.Director.prototype.play = function(value, tweenToStart, loop)
{
    var track = null;
    tweenToStart = (typeof tweenToStart !== "undefined") ? Boolean(tweenToStart) : true;

    this.stop();

    if(typeof value === "string" && KEN.UID.isTypeOf(value, "DirectorTrack") === true)
    {
        track = KEN.UID.get(value);
    }
    else if(KEN.Utils.isTypeOf(value, "DirectorTrack") === true)
    {
        track = value;
    }
    else if(this._track !== null)
    {
        track = this._track;
    }

    if(track !== null)
    {
        this._track = track;
        this._track.play(tweenToStart, loop);
    }
    else
    {
        this.warn("No track matching the value passed in arguments to KEN.Director.play");
    }
};

/**
 * Stops the current animation.
 * @method KEN.Director#stop
 */
KEN.Director.prototype.stop = function()
{
    if(this._track !== null)
    {
        this._track.stop();
    }
};

/**
 * Destroy method.
 * @method  KEN.Director#destroy
 */
KEN.Director.prototype.destroy = function()
{
    this._viewer["onReady"].remove(this._onViewerReady, this);
    this._viewer = null;
    
    var count = this._tracks.length;
    while(count--)
    {
        this._tracks[count].destroy();
        this._tracks[count] = null;
    }
    this._tracks = null;

    this._track = null;  
    this._animation = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the tracks array
 * @name KEN.Director#tracks
 * @readonly
 * @type {Array<KEN.DirectorTrack>}
 */
KEN.Director.prototype.tracks;
Object.defineProperty(KEN.Director.prototype, "tracks", 
{
    /** @this {KEN.Director} */
    get: function()
    {
        return this._tracks;
    }
});

/**
 * Get the current animation.<br/>
 * @name KEN.Director#animation
 * @readonly
 * @type {DirectorAnimationConfig}
 */
KEN.Director.prototype.animation;
Object.defineProperty(KEN.Director.prototype, "animation", 
{
    /** @this {KEN.Director} */
    get: function()
    {
        return this._animation;
    }
});

/**
 * A director track is a set of waypoints that defines a camera animation.
 *
 * @constructor KEN.DirectorTrack
 * @param {KEN.Viewer} viewer - viewer reference.
 * @param {DirectorTrackConfig} config - Configuration of the track from the JSON file.
 * @extends {KEN.BaseObject}
 */
KEN.DirectorTrack = function(viewer, config)
{
    /**
     * Viewer reference.
     * @name KEN.DirectorTrack#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Configuration of the track from the JSON file.
     * @name KEN.DirectorTrack#_config
     * @type {DirectorTrackConfig}
     * @private
     */
    this._config = config;

    /**
     * Array of waypoints.
     * @name KEN.DirectorTrack#_waypoints
     * @type {Array<KEN.CameraWaypoint>}
     * @private
     */
    this._waypoints = null;

    /**
     * Name of this director track.
     * @name KEN.DirectorTrack#_name
     * @type {string}
     * @private
     */
    this._name = "";

    /**
     * Description of this director track.
     * @name KEN.DirectorTrack#_description
     * @type {string}
     * @private
     */
    this._description = "";

    /**
     * Smooth flag for the director track.<br>
     * if set to true, camera movements will be smoothed between each waypoints.
     * @name KEN.DirectorTrack#_smooth
     * @type {boolean}
     * @private
     */
    this._smooth = false;

    /**
     * Cancel roll flag for the director track.<br>
     * If set to true, camera roll movements will be canceled. (roll always at 0)<br>
     * If set to false, camera will auto roll between waypoint for a more natural movement effect.
     * @name KEN.DirectorTrack#_cancelRoll
     * @type {boolean}
     * @private
     */
    this._cancelRoll = true;

    /**
     * Easing method used to go from the original position to the first waypoint.<br>
     * Default is KEN.Easing.LINEAR but you can set it to KEN.Easing.SINE_IN to have an acceleration effect.
     * @name KEN.DirectorTrack#_easingStart
     * @type {Function}
     * @private
     */
    this._easingStart = null;

    /**
     * Easing method used to go from the before last waypoint to the last waypoint.<br>
     * Default is KEN.Easing.LINEAR but you can set it to KEN.Easing.SINE_OUT to have an deceleration effect.
     * @name KEN.DirectorTrack#_easingEnd
     * @type {Function}
     * @private
     */
    this._easingEnd = null;

    /**
     * Does the aniation have to tween to the first waypoint?
     * @name  KEN.DirectorTrack#_tweenToStart
     * @type {boolean}
     * @private
     */
    this._tweenToStart = false;

    /**
     * Does the aniation have to loop?
     * @name  KEN.DirectorTrack#_loop
     * @type {boolean}
     * @private
     */
    this._loop = false;

    /**
     * This is the number of times this director track has been played.
     * @name  KEN.DirectorTrack#_count
     * @type {number}
     * @private
     */
    this._count = 0;

    KEN.BaseObject.call(this, "DirectorTrack");

    this._boot();
};

KEN.DirectorTrack.prototype = Object.create(KEN.BaseObject.prototype);
KEN.DirectorTrack.prototype.constructor = KEN.DirectorTrack;

/**
 * Boot sequence.
 * @method  KEN.DirectorTrack#_boot
 * @private
 */
KEN.DirectorTrack.prototype._boot = function()
{
    this._waypoints = [];

    this._uid = this._config["uid"];
    this._tags = this._config["tags"];
    this._register();

    this._parseConfig(this._config);
};

/**
 * Configuration parser.
 * @method  KEN.DirectorTrack#_parseConfig
 * @param {DirectorTrackConfig} config - The configuration object to parse.
 * @private
 */
KEN.DirectorTrack.prototype._parseConfig = function(config)
{
    this._name = (typeof config["name"] !== "undefined") ? String(config["name"]) : this._name;
    this._description = (typeof config["description"] !== "undefined") ? String(config["description"]) : this._description;
    this._smooth = (typeof config.smooth !== "undefined") ? Boolean(config.smooth) : this._smooth;
    this._cancelRoll = (typeof config["cancelRoll"] !== "undefined") ? Boolean(config["cancelRoll"]) : this._cancelRoll;

    this._easingStart = KEN.Easing.SINE_IN;
    if(typeof config.easingStart === "string" && typeof KEN.Easing[config.easingStart] === "function")
    {
        this._easingStart = KEN.Easing[config.easingStart];
    }

    this._easingEnd = KEN.Easing.SINE_OUT;
    if(typeof config.easingEnd === "string" && typeof KEN.Easing[config.easingEnd] === "function")
    {
        this._easingEnd = KEN.Easing[config.easingEnd];
    }

    // If there are dirctors tracks in the config, create the KEN.DirectorTrack objects.
    if(Array.isArray(config["waypoints"]) === true)
    {
        for(var i = 0, ii = config["waypoints"].length; i < ii; i++)
        {
            var p = config["waypoints"][i];
            var ts = p["ts"] || p["time"] || p["timestamp"]; //Three aliases for time
            var wp = new KEN.CameraWaypoint( ts, p["yaw"], p["pitch"], p["roll"], p["fov"] );
            this._waypoints.push(wp);
        }
    }
};

/**
 * Event handler for camera animation complete
 * @method  KEN.DirectorTrack#_cameraAnimationCompleteHandler
 * @private
 */
KEN.DirectorTrack.prototype._cameraAnimationCompleteHandler = function()
{
    this._clearEvents();

    if(this._loop === true)
    {
        this.play(this._tweenToStart, this._loop);
    }
};

/**
 * Remove all events.
 * @method KEN.DirectorTrack#_clearEvents
 * @private
 */
KEN.DirectorTrack.prototype._clearEvents = function()
{
    this._viewer["renderer"]["camera"]["animation"]["onComplete"].remove(this._cameraAnimationCompleteHandler, this);
};

/**
 * Play the director track
 * @method  KEN.DirectorTrack#play
 * @param {boolean=} tweenToStart - Does the animation have to tween to the first waypoint?
 * @param {boolean=} loop - Does the animation have to loop?
 */
KEN.DirectorTrack.prototype.play = function(tweenToStart, loop)
{
    this._tweenToStart = (typeof tweenToStart !== "undefined") ? Boolean(tweenToStart) : this._tweenToStart;
    this._loop = (typeof loop !== "undefined") ? Boolean(loop) : this._loop;

    this._viewer["renderer"]["camera"]["animation"]["waypoints"] = this._waypoints;
    this._viewer["renderer"]["camera"]["animation"]["onComplete"].add(this._cameraAnimationCompleteHandler, this);
    this._viewer["renderer"]["camera"]["animation"].play(this._smooth, this._cancelRoll, this._easingStart, this._easingEnd, this._tweenToStart);

    this._count++;
};

/**
 * Stop the director track
 * @method  KEN.DirectorTrack#stop
 */
KEN.DirectorTrack.prototype.stop = function()
{
    this._clearEvents();
    this._viewer["renderer"]["camera"]["animation"].stop();
};

/**
 * Destroy sequence
 * @method KEN.DirectorTrack#destroy
 */
KEN.DirectorTrack.prototype.destroy = function()
{
    this._clearEvents();

    this._viewer = null;
    this._easingStart = null;
    this._easingEnd = null;
    this._waypoints = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the name of this director track.
 * @name KEN.DirectorTrack#name
 * @readonly
 * @type {string}
 */
KEN.DirectorTrack.prototype.name;
Object.defineProperty(KEN.DirectorTrack.prototype, "name",
{
    /** @this {KEN.DirectorTrack} */
    get: function()
    {
        return this._name;
    }
});

/**
 * Get the description of this director track.
 * @name KEN.DirectorTrack#description
 * @readonly
 * @type {string}
 */
KEN.DirectorTrack.prototype.description;
Object.defineProperty(KEN.DirectorTrack.prototype, "description",
{
    /** @this {KEN.DirectorTrack} */
    get: function()
    {
        return this._description;
    }
});

/**
 * Get the number of times this director track has been played.
 * @name KEN.DirectorTrack#count
 * @readonly
 * @type {number}
 */
KEN.DirectorTrack.prototype.count;
Object.defineProperty(KEN.DirectorTrack.prototype, "count",
{
    /** @this {KEN.DirectorTrack} */
    get: function()
    {
        return this._count;
    }
});

/**
 * Get and set the tween to start flag of the director track.
 * @name KEN.DirectorTrack#tweenToStart
 * @type {boolean}
 */
KEN.DirectorTrack.prototype.tweenToStart;
Object.defineProperty(KEN.DirectorTrack.prototype, "tweenToStart",
{
    /** @this {KEN.DirectorTrack} */
    get: function()
    {
        return this._tweenToStart;
    },

    /** @this {KEN.DirectorTrack} */
    set: function(value)
    {
        this._tweenToStart = Boolean(value);
    }
});

/**
 * Get and set the loop flag of the director track.
 * @name KEN.DirectorTrack#loop
 * @type {boolean}
 */
KEN.DirectorTrack.prototype.loop;
Object.defineProperty(KEN.DirectorTrack.prototype, "loop",
{
    /** @this {KEN.DirectorTrack} */
    get: function()
    {
        return this._loop;
    },

    /** @this {KEN.DirectorTrack} */
    set: function(value)
    {
        this._loop = Boolean(value);
    }
});

/**
 * A action set event dispatcher is in charge to triggers actions binded on an event.
 *
 * @constructor KEN.ActionEventDispatcher
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @param {string} name - The name of the event.
 * @extends {KEN.BaseObject}
 */
KEN.ActionEventDispatcher = function(viewer, name)
{
    /**
     * The viewer reference.
     * @name KEN.ActionEventDispatcher#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Event name
     * @name KEN.ActionEventDispatcher#_name
     * @type {string}
     * @private
     */
    this._name = name;

    /**
     * The actions uid list of the set.
     * @name  KEN.ActionEventDispatcher#_actions
     * @type {Array<string>}
     * @private
     */
    this._actions = [];

    KEN.BaseObject.call(this, "ActionEventDispatcher");
};

KEN.ActionEventDispatcher.prototype = Object.create(KEN.BaseObject.prototype);
KEN.ActionEventDispatcher.prototype.constructor = KEN.ActionEventDispatcher;

/**
 * Boot sequence.
 * @method KEN.ActionEventDispatcher#addActions
 * @param {(string|Array<string>)} actions - The actions uids you want to add
 */
KEN.ActionEventDispatcher.prototype.addActions = function(actions)
{
    if(KEN.Utils.isArrayOf(actions, "string") === true || KEN.Utils.isTypeOf(actions, "string"))
    {
        this._actions = this._actions.concat(actions);
    }
};

/**
 * This method execute every actions binded on this event dispatcher.
 * @method KEN.ActionEventDispatcher#dispatch
 */
KEN.ActionEventDispatcher.prototype.dispatch = function()
{
    for(var i = 0, ii = this._actions.length; i < ii; i++)
    {
        var action = this._viewer["actions"].get(this._actions[i]);

        if(typeof action !== "undefined" && action !== null)
        {
            action.execute();
        }
    }
};

/**
 * Destroy sequence.
 * @method  KEN.ActionEventDispatcher#destroy
 */
KEN.ActionEventDispatcher.prototype.destroy = function()
{
    this._viewer = null;

    KEN.BaseObject.prototype.destroy.call(this);
};


/**
 * An action is a description of a method to execute in reaction to an event.<br>
 * The method will be executed from a target.
 *
 * @constructor KEN.Action
 * @param {KEN.Viewer} viewer - The {@link KEN.Viewer} reference.
 * @param {ActionConfig} config - The config of the action.
 * @extends {KEN.BaseObject}
 */
KEN.Action = function(viewer, config)
{
    /**
     * The viewer reference.
     * @name KEN.Action#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The config of the action.
     * @name KEN.Action#_config
     * @type {ActionConfig}
     * @private
     */
    this._config = config;

    /**
     * The object related to this action.
     * @name KEN.Action#_object
     * @type {string}
     * @private
     */
    this._target = "";

    /**
     * The method name with args who will be executed.
     * @name KEN.Action#_method
     * @type {?ActionMethodConfig}
     * @private
     */
    this._method = null;

    /**
     * The property name who will be changed with the value.
     * @name KEN.Action#_property
     * @type {?ActionPropertyConfig}
     * @private
     */
    this._property = null;

    /**
     * The number of time this action has been executed
     * @name KEN.Action._count
     * @type {number}
     * @private
     */
    this._count = 0;

    KEN.BaseObject.call(this, "Action");

    this._boot();
};

KEN.Action.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Action.prototype.constructor = KEN.Action;

/**
 * List of possible operation when you affect a property.
 * @name  KEN.Action.operation
 * @type {Object}
 * @const
 */
KEN.Action.operation = {};

/**
 * Operation set is the default one, it will just set the value.
 * @name  KEN.Action.operation.SET
 * @type {string}
 * @const
 */
KEN.Action.operation.SET = "set";

/**
 * Operation addition.
 * @name  KEN.Action.operation.ADD
 * @type {string}
 * @const
 */
KEN.Action.operation.ADD = "add";

/**
 * Operation substract.
 * @name  KEN.Action.operation.SUBSTRACT
 * @type {string}
 * @const
 */
KEN.Action.operation.SUBSTRACT = "substract";

/**
 * Operation multiply.
 * @name  KEN.Action.operation.MULTIPLY
 * @type {string}
 * @const
 */
KEN.Action.operation.MULTIPLY = "multiply";

/**
 * Operation divide.
 * @name  KEN.Action.operation.DIVIDE
 * @type {string}
 * @const
 */
KEN.Action.operation.DIVIDE = "divide";

/**
 * Operation boolean toggle.
 * @name  KEN.Action.operation.TOGGLE
 * @type {string}
 * @const
 */
KEN.Action.operation.TOGGLE = "toggle";

/**
 * Boot sequence.
 * @method KEN.Action#_boot
 * @private
 */
KEN.Action.prototype._boot = function()
{
    this._parseConfig(this._config);
    this._register();
};

/**
 * Parse the action configuration object from the json
 * @method KEN.Action#_parseConfig
 * @param  {ActionConfig} config - Action configuration to parse
 * @private
 */
KEN.Action.prototype._parseConfig = function(config)
{
    this._uid = config["uid"];

    this._target = config["target"];

    this._method = (typeof config.method !== "undefined") ? config.method : null;

    this._property = (typeof config.property !== "undefined") ? config.property : null;
};

/**
 * Parse the target.<br>
 * If undefined action will be executed on "window".<br>
 * If target start by "this" keyword, method will be searched on the action set instance.<br>
 * Target can also be the id of a plugin.
 * @method KEN.Action#_parseTarget
 * @private
 * @param  {string} target - The target to parse.
 * @return {*} The target object.
 */
KEN.Action.prototype._parseTarget = function(target)
{
    var result = null;

    if(typeof target === "undefined")
    {
        result = window;
    }
    else
    {
        var targetByUid = KEN.UID.get(target);

        if(typeof targetByUid !== "undefined" && targetByUid !== null)
        {
            if(KEN.Utils.isTypeOf(targetByUid, "Plugin"))
            {
                result = targetByUid["instance"];
            }
            else
            {
                result = targetByUid;
            }
        }
        else
        {
            var path = target.split(".");

            if(path[0].toLowerCase() === "viewer")
            {
                result = this._viewer;

                for(var i = 1, ii = path.length; i < ii; i++)
                {
                    if(typeof result[path[i]] === "object")
                    {
                        result = result[path[i]];
                    }
                }
            }
        }
    }

    return result;
};

/**
 * Apply the property configuration to the target.
 * @method KEN.Action#_applyProperty
 * @param  {*} target - The target that own the desired method.
 * @param  {ActionPropertyConfig} property - The property configuration with its name and its arguments array
 * @private
 */
KEN.Action.prototype._applyProperty = function(target, property)
{
    if(typeof target[property["name"]] !== "undefined")
    {
        if(typeof property.operation === "undefined")
        {
            property.operation = KEN.Action.operation.SET;
        }

        switch(property.operation)
        {
            case KEN.Action.operation.SET:
                target[property["name"]] = property["value"];
                break;

            case KEN.Action.operation.ADD:
                target[property["name"]] += property["value"];
                break;

            case KEN.Action.operation.SUBSTRACT:
                target[property["name"]] -= property["value"];
                break;

            case KEN.Action.operation.MULTIPLY:
                target[property["name"]] *= property["value"];
                break;

            case KEN.Action.operation.DIVIDE:
                target[property["name"]] /= property["value"];
                break;

            case KEN.Action.operation.TOGGLE:
                target[property["name"]] = !target[property["name"]];
                break;
        }
    }
};

/**
 * Apply the method configuration to the target.
 * @method KEN.Action#_applyMethod
 * @param  {*} target - The target that own the desired method.
 * @param  {ActionMethodConfig} method - The method configuration with its name and its arguments array
 * @private
 */
KEN.Action.prototype._applyMethod = function(target, method)
{
    if(typeof target[method["name"]] === "function")
    {
        var args = (typeof method.args !== "undefined") ? method.args : null;
        target[method["name"]].apply(target, args);
    }
};

/**
 * The execute method will trigger the action, parse the target if necessary.
 * @method KEN.Action#execute
 */
KEN.Action.prototype.execute = function()
{
    //Get the target at the last time and do NOT keep a reference !
    var target = this._parseTarget(this._target);

    if(target !== null)
    {
        if(this._property !== null)
        {
            this._applyProperty(target, this._property);
        }

        if(this._method !== null)
        {
            this._applyMethod(target, this._method);
        }
    }
};

/**
 * Destroy sequence.
 * @method  KEN.Action#destroy
 */
KEN.Action.prototype.destroy = function()
{
    this._viewer = null;

    KEN.BaseObject.prototype.destroy.call(this);
};


/**
* Get the target of the action.
* @name KEN.Action#target
* @readonly
* @type {*}
*/
KEN.Action.prototype.target;
Object.defineProperty(KEN.Action.prototype, "target",
{
    /** @this {KEN.Action} */
    get: function ()
    {
        return this._parseTarget(this._target);
    }
});

/**
* Get the number of time this action has been executed.
* @name KEN.Action#count
* @readonly
* @type {number}
*/
KEN.Action.prototype.count;
Object.defineProperty(KEN.Action.prototype, "count",
{
    /** @this {KEN.Action} */
    get: function ()
    {
        return this._count;
    }
});


/**
 * Action manager
 * @constructor KEN.ActionManager
 * @param {KEN.Viewer} viewer - viewer reference.
 * @extends {KEN.BaseObject}
 */
KEN.ActionManager = function(viewer)
{
    /**
     * Viewer reference.
     * @name KEN.ActionManager#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Configuration of actions from the JSON
     * @name  KEN.ActionManager#_config
     * @type {Array<ActionConfig>}
     * @private
     */
    this._config = null;

    /**
     * Camera reference.
     * @name KEN.ActionManager#_actions
     * @type {Array}
     * @private
     */
    this._actions = [];

    /**
     * Event dispatcher for ready status.
     * @name KEN.ActionManager#_onReady
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onReady = null;

    KEN.BaseObject.call(this, "ActionManager");
};

KEN.ActionManager.prototype = Object.create(KEN.BaseObject.prototype);
KEN.ActionManager.prototype.constructor = KEN.ActionManager;

/**
 * Parse an array of configuration
 * @param {(Array<ActionConfig>|ActionConfig)} config - Array of action configurations or a single action configuration.
 * @private
 */
KEN.ActionManager.prototype._parseConfig = function(config)
{
    var action;

    // If it is an array of actions
    if(Array.isArray(config) === true)
    {
        for(var i = 0, ii = config.length; i < ii; i++)
        {
            action = new KEN.Action(this._viewer, config[i]);
            this._actions.push(action);
        }
    }
    // If it is a single action
    else
    {
        action = new KEN.Action(this._viewer, /** @type {ActionConfig} */ (config));
        this._actions.push(action);
    }
};

/**
 * Get an action by id.
 * @method KEN.ActionManager#get
 */
KEN.ActionManager.prototype.get = function(uid)
{
    return KEN.UID.get(uid, "Action");
};

/**
 * Boot sequence
 * @method KEN.ActionManager#boot
 */
KEN.ActionManager.prototype.boot = function()
{

};

/**
 * Add actions configuration
 * @param {(Array<ActionConfig>|ActionConfig)} config - Array of action configurations or a single action configuration.
 */
KEN.ActionManager.prototype.addConfig = function(config)
{
    this._parseConfig(config);
};

/**
 * A plugin object is an instance of a {@link KEN.PluginEngine} on top of the viewer.<br>
 * It can be visual (display a logo) or not (gyroscope, stats ...).
 *
 * @constructor KEN.Plugin
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @param {KEN.PluginEngine} engine - The engine used to instantiate tis plugin.
 * @param {PluginInstanceConfig} config - The config of the plugin instance.
 * @param {number} index - The index of the plugin, use for display order.
 * @extends {KEN.BaseObject}
 *
 * @todo  Scene array upgrade : Have a scene array with inclusive and exclusive uids
 * @todo  Same filter array for groups ?
 */
KEN.Plugin = function(viewer, engine, config, index)
{
    /**
     * The viewer reference.
     * @name KEN.Plugin#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The engine this plugin is based on.
     * @name  KEN.Plugin#_engine
     * @type {KEN.PluginEngine}
     * @private
     */
    this._engine = engine;

    /**
     * The instance config of the plugin.
     * @name  KEN.Plugin#_instanceConfig
     * @type {?PluginInstanceConfig}
     * @private
     */
    this._instanceConfig = config;

    /**
     * The contextual config is the plugin configuration specific to a scene or a group.<br/>
     * It doesn't last at scene change.
     * @name KEN.Plugin#_contextualConfig
     * @type {?PluginConfigurationConfig}
     * @private
     */
    this._contextualConfig = null;

    /**
     * This config will be the final config object that merges the default engine config, the instance config and the contextual config.
     * @name  KEN.Plugin#_config
     * @type {?PluginInstanceConfig}
     * @private
     */
    this._config = null;

    /**
     * The index of the plugin, used if the plugin is a visual one.
     * @name KEN.Plugin#_index
     * @type {number}
     * @private
     */
    this._index = index;

    /**
     * The options of this Plugin.
     * @name KEN.Plugin#_options
     * @type {Object}
     * @private
     */
    this._options = null;

    /**
     * The actions of this Plugin.
     * @name KEN.Plugin#_actions
     * @type {Object}
     * @private
     */
    this._actions = null;

    /**
     * Object that stores {@link KEN.ActionEventDispatcher}.
     * @name KEN.Plugin#_events
     * @type {Object<KEN.ActionEventDispatcher>}
     * @private
     */
    this._events = null;

    /**
     * Instance of the plugin engine constructor.
     * @name  KEN.Plugin#_instance
     * @type {?PluginStructure}
     * @private
     */
    this._instance = null;

    /**
     * Flag to tell if the instance is ready.<br>
     * It is the plugin developper that set the ready flag by calling the notifyInstanceReady method from its instance.
     * @name  KEN.Plugin#_instanceReady
     * @type {boolean}
     * @private
     */
    this._instanceReady = false;

    /**
     * A DOM id or a DOM element.<br>
     * Used to inject graphical plugins anywhere in the document (outside the viewer container).
     * @name  KEN.Plugin#_parent
     * @type {Element|HTMLElement|string}
     * @private
     */
    this._parent = null;

    /**
     * The display object container for this plugin if it is a graphical one.
     * @name KEN.Plugin#_container
     * @type {?KEN.DisplayObjectContainer}
     * @private
     */
    this._container = null;

    /**
     * Reference to the plugin object factory, every plugin have its own factory.
     * @name KEN.Plugin#_create
     * @type {KEN.PluginObjectFactory}
     * @private
     */
    this._create = null;

    /**
     * Scenes UID array, this plugin is allow to instantiate only on these scene if not null.
     * @name  KEN.Plugin#_scenes
     * @type {Array<string>}
     * @private
     */
    this._scenes = null;

    /**
     * Object to handle persistent data.
     * @name  KEN.Plugin#_persistentData
     * @type {Object}
     * @private
     */
    this._persistentData = null;

    /**
     * Is this plugin stay at the scene change event?
     * @name  KEN.Plugin#_keep
     * @type {boolean}
     * @private
     */
    this._keep = true;

    /**
     * Is this plugin have to reset between each scene?
     * @name  KEN.Plugin#_reset
     * @type {boolean}
     * @private
     */
    this._reset = true;

    /**
     * Event dispatcher for instance creation
     * @name  KEN.Plugin#_onInstanceCreate
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onInstanceCreate = null;

     /**
     * Event dispatcher for instance ready
     * @name  KEN.Plugin#_onInstanceReady
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onInstanceReady = null;

    KEN.BaseObject.call(this, "Plugin");

    this._boot();
};

KEN.Plugin.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Plugin.prototype.constructor = KEN.Plugin;

/**
 * Boot sequence
 * @method  KEN.Plugin#_boot
 * @private
 */
KEN.Plugin.prototype._boot = function()
{
    //First thing, very important is to register the plugin object!
    //We can't parse the rest of the config here, maybe the engine is not loaded yet.
    this._uid = this._instanceConfig["uid"];
    this._tags = this._instanceConfig["tags"];
    this._register();

    this._persistentData = {};
};

/**
 * Internal method to parse the config.
 * @method KEN.Plugin#_parseConfig
 * @private
 * @param {Object} config - The config object to parse.
 */
KEN.Plugin.prototype._parseConfig = function(config)
{
    //If there is a parent string in config, this should be an dom element id where to inject the plugin.
    if(typeof config["parent"] === "string")
    {
        this._parent = config["parent"];
    }

    this._keep = (typeof config["keep"] === "boolean") ? config["keep"] : true;
    this._reset = (typeof config["reset"] === "boolean") ? config["reset"] : true;

    //If there is no scenes array alerady set and if there is a scene array in the instance config.
    if(this._scenes === null && KEN.Utils.isArrayOf(config["scenes"], "string") === true)
    {
        this._scenes = config["scenes"];
    }

    this._mergeConfigurations();
};

/**
 * Merge the plugin configurations
 * @method KEN.Plugin#_mergeConfigurations
 * @private
 */
KEN.Plugin.prototype._mergeConfigurations = function()
{
    this._config = /** @type {PluginInstanceConfig} */ (KEN.Utils.extendMultipleObjects(this._engine["defaultConfig"], this._instanceConfig, this._contextualConfig));
    this._options = this._config["options"];
    this._data = this._config["data"];
    this._actions = this._config["actions"];

    this._clearEvents();
    this._createEvents(this._config["events"]);
};

/**
 * Create events dispatchers that the engine needs.
 * @method KEN.Plugin#_createEvents
 * @private
 * @param {Object} events - The events config of the plugin engine.
 */
KEN.Plugin.prototype._createEvents = function(events)
{
    this._events = {};

    var event;
    for(var e in events)
    {
        event = new KEN.ActionEventDispatcher(this._viewer, e);
        event.addActions(events[e]);
        this._events[e] = event;
    }
};

/**
 * Clear all plugin events.
 * @method KEN.Plugin#_clearEvents
 * @private
 */
KEN.Plugin.prototype._clearEvents = function()
{
    for(var e in this._events)
    {
        this._events[e].destroy();
        this._events[e] = null;
    }
};

/**
 * Instantiate the plugin engine if it is loaded, if not listen to the engine load complete to retry to instantiate.
 * @method KEN.Plugin#instantiate
 */
KEN.Plugin.prototype.instantiate = function()
{
    if(this._engine["loaded"] === true)
    {
        this._instantiatePlugin();
    }
    else
    {
        this._engine["onLoadComplete"].addOnce(this._engineLoadComplete, this);
    }
};

/**
 * Handler for engine load complete.
 * @method KEN.Plugin#_engineLoadComplete
 * @private
 */
KEN.Plugin.prototype._engineLoadComplete = function()
{
    this._instantiatePlugin();
};

/**
 * Parse the config then instantiate the plugin.
 * @method KEN.Plugin#_instantiatePlugin
 * @private
 */
KEN.Plugin.prototype._instantiatePlugin = function()
{
    this.log("Plugin._instantiatePlugin(); "+this._uid);

    this._parseConfig(this._instanceConfig);

    this._instance = this._engine.getNewInstance(this);

    this._instance.boot.call(this._instance);

    if(this._onInstanceCreate !== null)
    {
        this._onInstanceCreate.dispatch();
    }
};

/**
 * Instance can notify with this method that the instance is ready
 * @method KEN.Plugin.notifyInstanceReady
 */
KEN.Plugin.prototype.notifyInstanceReady = function()
{
    this._instanceReady = true;

    if(this._onInstanceReady !== null)
    {
        this._onInstanceReady.dispatch();
    }
};

/**
 * Update method called by the plugin manager.
 * @method KEN.Plugin#update
 */
KEN.Plugin.prototype.update = function()
{
    if(this._instance !== null)
    {
        this._instance.update.call(this._instance);
    }
};

/**
 * Reset the plugin to a specified configuration.
 * @method KEN.Plugin#reset
 */
KEN.Plugin.prototype.resetInstance = function()
{
    this._mergeConfigurations();

    if(this._instance !== null)
    {
        if(typeof this._instance["reset"] === "function")
        {
            this._instance["reset"].call(this._instance);
        }
        else
        {
            this.warn("There is no reset function on plugin "+this._engine["uid"]);
        }
    }
};

/**
 * Destroy method.
 * @method KEN.Plugin#destroy
 */
KEN.Plugin.prototype.destroy = function()
{
    if(this._alive === false)
    {
        return;
    }

    if(this._instance !== null)
    {
        this._instance["viewer"] = null;
        this._instance.plugin = null;

        this._instance.destroy();
        this._instance = null;
    }

    if(this._create !== null)
    {
        this._create.destroy();
        this._create = null;
    }

    if(this._container !== null)
    {
        this._container.destroy();
        this._container = null;
    }

    if(this._onInstanceCreate !== null)
    {
        this._onInstanceCreate.destroy();
        this._onInstanceCreate = null;
    }

    if(this._onInstanceReady !== null)
    {
        this._onInstanceReady.destroy();
        this._onInstanceReady = null;
    }

    var count = this._events.length;
    while(count--)
    {
        this._events[count].destroy();
    }
    this._events = null;

    this._viewer = null;

    this._persistentData = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the plugin full url.
 * @name KEN.Plugin#fullUrl
 * @readonly
 * @type {string}
 */
KEN.Plugin.prototype.fullUrl;
Object.defineProperty(KEN.Plugin.prototype, "fullUrl",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        return this._engine["fullUrl"];
    }
});

/**
 * Get the plugin options.
 * @name KEN.Plugin#options
 * @readonly
 * @type {Object}
 */
KEN.Plugin.prototype.options;
Object.defineProperty(KEN.Plugin.prototype, "options",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        return this._options;
    }
});

/**
 * Get the plugin actions.
 * @name KEN.Plugin#actions
 * @readonly
 * @type {Object}
 */
KEN.Plugin.prototype.actions;
Object.defineProperty(KEN.Plugin.prototype, "actions",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        return this._actions;
    }
});

/**
 * Get the plugin events.
 * @name KEN.Plugin#events
 * @readonly
 * @type {Object}
 */
KEN.Plugin.prototype.events;
Object.defineProperty(KEN.Plugin.prototype, "events",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        return this._events;
    }
});

/**
 * Get the scenes array. This plugin will be alive only on these scenes.
 * @name KEN.Plugin#scenes
 * @readonly
 * @type {Array}
 */
KEN.Plugin.prototype.scenes;
Object.defineProperty(KEN.Plugin.prototype, "scenes",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        return this._scenes;
    }
});

/**
 * Get and set pesistent data.
 * @name KEN.Plugin#persistentData
 * @type {Object}
 */
KEN.Plugin.prototype.persistentData;
Object.defineProperty(KEN.Plugin.prototype, "persistentData",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        return this._persistentData;
    },

    /** @this {KEN.Plugin} */
    set: function(value)
    {
        this._persistentData = value;
    }
});

/**
 * Get the plugin instance.
 * @name KEN.Plugin#instance
 * @readonly
 * @type {Object}
 */
KEN.Plugin.prototype.instance;
Object.defineProperty(KEN.Plugin.prototype, "instance",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        return this._instance;
    }
});

/**
 * Get the plugin instance ready flag.
 * @name KEN.Plugin#instanceReady
 * @readonly
 * @type {boolean}
 */
KEN.Plugin.prototype.instanceReady;
Object.defineProperty(KEN.Plugin.prototype, "instanceReady",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        return this._instanceReady;
    }
});

/**
 * Get the plugin container.
 * @name KEN.Plugin#container
 * @readonly
 * @type {KEN.DisplayObjectContainer}
 */
KEN.Plugin.prototype.container;
Object.defineProperty(KEN.Plugin.prototype, "container",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        if(this._container === null)
        {
            if(typeof this._parent === "string" && this._parent !== "")
            {
                this._parent = document.getElementById(this._parent);

                if(typeof this._parent === "undefined" || this._parent === null || KEN.Dom.isHtmlElement(this._parent) === false)
                {
                    throw "KEN.Plugin.boot : Plugin parent is invalid";
                }

                this._container = new KEN.DisplayObjectContainer(this._viewer, null, null, this._parent);
            }
            else
            {
                this._container = new KEN.DisplayObjectContainer(this._viewer);
                this._viewer["pluginContainer"].addChild(this._container);
                this._container.maximize(true);
            }

            this._container["id"] = this._uid;
            this._container["index"] = this._index;
        }

        return this._container;
    }
});

/**
 * Get the plugin object factory.
 * @name KEN.Plugin#create
 * @readonly
 * @type {KEN.PluginObjectFactory}
 */
KEN.Plugin.prototype.create;
Object.defineProperty(KEN.Plugin.prototype, "create",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        if(this._create === null)
        {
            this._create = new KEN.PluginObjectFactory(this._viewer, this);
        }

        return this._create;
    }
});

/**
 * Get the plugin keep flag.
 * @name KEN.Plugin#keep
 * @readonly
 * @type {boolean}
 */
KEN.Plugin.prototype.keep;
Object.defineProperty(KEN.Plugin.prototype, "keep",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        return this._keep;
    }
});

/**
 * Get the plugin reset flag.
 * @name KEN.Plugin#reset
 * @readonly
 * @type {boolean}
 */
KEN.Plugin.prototype.reset;
Object.defineProperty(KEN.Plugin.prototype, "reset",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        return this._reset;
    }
});

/**
 * Get the contextual config.
 * @name KEN.Plugin#contextualConfig
 * @type {Object}
 */
KEN.Plugin.prototype.contextualConfig;
Object.defineProperty(KEN.Plugin.prototype, "contextualConfig",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        return this._contextualConfig;
    },

    /** @this {KEN.Plugin} */
    set: function(value)
    {
        this._contextualConfig = value;
    }
});

/**
 * Get the instance config.
 * @name KEN.Plugin#instanceConfig.
 * @readonly
 * @type {Object}
 */
KEN.Plugin.prototype.instanceConfig;
Object.defineProperty(KEN.Plugin.prototype, "instanceConfig",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        return this._instanceConfig;
    }
});

/**
 * Get the final merged config.
 * @name KEN.Plugin#config
 * @readonly
 * @type {Object}
 */
KEN.Plugin.prototype.config;
Object.defineProperty(KEN.Plugin.prototype, "config",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        return this._config;
    }
});


/**
 * Get the "onInstanceCreate" {@link KEN.EventDispatcher} of the Plugin.
 * @name KEN.Plugin#onInstanceCreate
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Plugin.prototype.onInstanceCreate;
Object.defineProperty(KEN.Plugin.prototype, "onInstanceCreate",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        if(this._onInstanceCreate === null)
        {
            this._onInstanceCreate = new KEN.EventDispatcher(this, true);
        }

        return this._onInstanceCreate;
    }
});

/**
 * Get the "onInstanceReady" {@link KEN.EventDispatcher} of the Plugin.
 * @name KEN.Plugin#onInstanceReady
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Plugin.prototype.onInstanceReady;
Object.defineProperty(KEN.Plugin.prototype, "onInstanceReady",
{
    /** @this {KEN.Plugin} */
    get: function()
    {
        if(this._onInstanceReady === null)
        {
            this._onInstanceReady = new KEN.EventDispatcher(this, true);
        }

        return this._onInstanceReady;
    }
});

/**
 * A plugin Engine handle the javascript files to load, and the constructor.
 *
 * @constructor KEN.PluginEngine
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @extends {KEN.BaseObject}
 *
 * @todo  In the sources list (in plugin manifest), add possibility to specify type (script or css) for special cases.
 */
KEN.PluginEngine = function(viewer)
{
    KEN.BaseObject.call(this, "PluginEngine");

    /**
     * The viewer reference.
     * @name KEN.PluginEngine#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The config of the plugin engine.
     * @name  KEN.PluginEngine#_config
     * @type {?PluginEngineConfig}
     * @private
     */
    this._config = null;

    /**
     * The URL prefix for the engine, if not specified, will be the global URL prefix.
     * @name KEN.PluginEngine#_prefix
     * @type {string}
     * @private
     */
    this._prefix = "";

    /**
     * The url of the plugin engine relative to the prefix location.
     * @name  KEN.PluginEngine#_url
     * @type {?string}
     * @private
     */
    this._url = "";

    /**
     * The manifest json file name.
     * @name  KEN.PluginEngine#_manifest
     * @type {string}
     * @private
     */
    this._manifest = "";

    /**
     * The full url of the plugin folder (prefix + url)
     * @name KEN.PluginEngine#_fullUrl
     * @type {string}
     * @private
     */
    this._fullUrl = "";

    /**
     * The manifest is a json data that describes the plugin engine.
     * @name KEN.PluginEngine#_manifestData
     * @type {?PluginManifest}
     * @private
     */
    this._manifestData = null;

    /**
     * The name of the plugin engine.
     * @name KEN.PluginEngine#_name
     * @type {?string}
     * @private
     */
    this._name = "";

    /**
     * The version of the plugin engine.
     * @name KEN.PluginEngine#_version
     * @type {?string}
     * @private
     */
    this._version = "";

    /**
     * The sources of the plugin engine.
     * @name KEN.PluginEngine#_sources
     * @type {Array<string>}
     * @private
     */
    this._sources = null;

    /**
     * The name of the constructor of the plugin engine.
     * @name KEN.PluginEngine#_constructorName
     * @type {string}
     * @private
     */
    this._constructorName = "";

    /**
     * The constructor function reference of the plugin engine.
     * @name  KEN.PluginEngine#_constructorFunction
     * @type {Function}
     * @private
     */
    this._constructorFunction = null;

    /**
     * i18n configuration.
     * @name KEN.PluginEngine#_i18n
     * @type {Object}
     * @private
     */
    this._i18n = null;

    /**
     * Object that handles customization options.
     * @name KEN.PluginEngine#_options
     * @type {Object}
     * @private
     */
    this._options = null;

    /**
     * The events of the engine on which you can bind an action.
     * @name KEN.PluginEngine#_events
     * @type {Object}
     * @private
     */
    this._events = null;

    /**
     * On a plugin engine, actions is an array of exposed method names.
     * @name KEN.PluginEngine#_actions
     * @type {Array<Object>}
     * @private
     */
    this._actions = null;

    /**
     * Internal counter for loaded source files.
     * @name KEN.PluginEngine#_sourcesLoadedCount
     * @type {number}
     * @private
     */
    this._sourcesLoadedCount = 0;

    /**
     * Number of instances that are created from this engine.
     * @name KEN.PluginEngine#_instanceCount
     * @type {number}
     * @private
     */
    this._instancesCount = 0;

    /**
     * Is this plugin engine is considered as loaded.
     * @name KEN.PluginEngine#_loaded
     * @type {boolean}
     * @private
     */
    this._loaded = false;

    /**
     * Event dipatcher for load complete.
     * @name KEN.PluginEngine#_onLoadComplete
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onLoadComplete = null;
};

KEN.PluginEngine.prototype = Object.create(KEN.BaseObject.prototype);
KEN.PluginEngine.prototype.constructor = KEN.PluginEngine;

/**
 * List of required method on a plugn engine.
 * @name KEN.PluginEngine._REQUIRED
 * @type {Array<string>}
 * @const
 * @private
 */
KEN.PluginEngine._REQUIRED = ["boot", "update", "destroy"];

/**
 * List of reserved keyword on a plugn engine.
 * @name KEN.PluginEngine._RESERVED
 * @type {Array<string>}
 * @const
 * @private
 */
KEN.PluginEngine._RESERVED = ["viewer", "plugin"];

/**
 * Load a configuration for the plugin engine,<br>
 * the config describes the manifest url and the engine identification.
 * @method KEN.PluginEngine#load
 * @param {PluginEngineConfig} config - The config of the plugin engine.
 * @return {boolean} Returns true if the engine is loaded.
 */
KEN.PluginEngine.prototype.load = function(config)
{
    if(typeof config !== "undefined")
    {
        this._config = config;

        this._parseConfig(this._config);

        var manifestUrl = this._fullUrl + this._manifest;

        this._loadManifest(manifestUrl);

        return true;
    }

    return false;
};

/**
 * Get a new instance of the engine and associate it to a {@link KEN.Plugin} Object.
 * @method KEN.PluginEngine#getNewInstance
 * @param  {KEN.Plugin} plugin - The plugin who will represent this instance.
 * @return {?PluginStructure} Returns the instance of the engine.
 */
KEN.PluginEngine.prototype.getNewInstance = function(plugin)
{
    var instance = /** @type {PluginStructure} */ (new this._constructorFunction());

    if(this._validateInstance(instance))
    {
        instance._viewer = this._viewer;
        instance._plugin = plugin;

        this._instancesCount++;

        return instance;
    }

    return null;
};

/**
 * Parse a plugin engine configuration.
 * @method KEN.PluginEngine#_parseConfig
 * @param  {PluginEngineConfig} config - The configuration to parse.
 * @private
 */
KEN.PluginEngine.prototype._parseConfig = function(config)
{
    if(typeof config["uid"] === "undefined")
    {
        throw "Can't load a plugin engine, missing id in config";
    }

    this._uid = config["uid"];
    this._register();

    this._prefix = "./";
    if(typeof config.prefix === "string")
    {
        this._prefix = config.prefix;
    }
    else if(typeof this._viewer["config"]["plugins"] === "object" && typeof this._viewer["config"]["plugins"].prefix === "string")
    {
        this._prefix = this._viewer["config"]["plugins"].prefix;
    }

    if(typeof config["url"] === "undefined")
    {
        throw "Can't load a plugin engine, missing url in config";
    }
    this._url = config["url"];

    this._fullUrl = this._prefix + this._url;

    if(typeof config.manifest === "undefined")
    {
        throw "Can't load a plugin engine, missing manifest file name in config";
    }
    this._manifest = config.manifest;
};

/**
 * Internal method to load the engine manifest.
 * @method KEN.PluginEngine#_loadManifest
 * @param  {string} url - The url of the manifest to load.
 * @private
 */
KEN.PluginEngine.prototype._loadManifest = function(url)
{
    this._viewer["load"].json(this._uid, url, this._manifestLoadComplete, this);
};

/**
 * Handler for the manifest load complete.
 * @method KEN.PluginEngine#_manifestLoadComplete
 * @private
 * @param  {KEN.File} file - The  manifest {@link KEN.File}.
 */
KEN.PluginEngine.prototype._manifestLoadComplete = function(file)
{
    var json = this._viewer["cache"].get(KEN.Cache.types.JSON, file["key"]);

    this._manifestData = /** @type {PluginManifest} */ (json["data"]);
    this._parseManifest(this._manifestData);

    this.log("KEN.Plugin._manifestLoadComplete();");
};

/**
 * Internal method to parse the loaded manifest file.
 * @method KEN.PluginEngine#_parseManifest
 * @private
 * @param  {PluginManifest} manifest - Manifest object to parse.
 * @suppress {checkTypes}
 * @todo  need to change manifest.constructor to another keyword (not reserved)
 */
KEN.PluginEngine.prototype._parseManifest = function(manifest)
{
    if(this._uid !== manifest["uid"])
    {
        throw "Plugin Engine UID doesn't match with manifest UID";
    }

    if(this._versionCheck(manifest["viewer"]) === false)
    {
        this.warn("Version compatibility check for plugin "+manifest["uid"]+" failed!");
        this.warn(manifest["viewer"]);
        return;
    }

    if(this._deviceCheck(manifest.device) === false)
    {
        this.warn("Device compatibility check for plugin "+manifest["uid"]+" failed!");
        this.warn(manifest.device);
        return;
    }

    if(typeof manifest["options"] !== "undefined")
    {
        this._options = manifest["options"];
    }

    if(typeof manifest["data"] !== "undefined")
    {
        this._data = manifest["data"];
    }

    if(typeof manifest["actions"] !== "undefined")
    {
        this._actions = manifest["actions"];
    }

    if(typeof manifest["events"] !== "undefined")
    {
        this._events = manifest["events"];
    }

    this._name = manifest["name"];
    this._version = manifest.version;
    this._sources = manifest.sources;
    this._constructorName = manifest.constructor;
    this._i18n = this._parseLocales(manifest);

    this._loadSources(this._sources);
};

/**
 * Compare KEN version with a minimal and maximal compatibility version.
 * @method KEN.PluginEngine#_versionCheck
 * @private
 * @param  {Object} config - The viewer version configuration object that contain min and max compatible version of the viewer for the plugin.
 * @return {boolean} Returns true if the plugin is compatible with the current KEN version, false if not.
 */
KEN.PluginEngine.prototype._versionCheck = function(config)
{
    var min = "0.0.0";
    var max = "9.9.9";

    if(typeof config !== "undefined")
    {
        if(typeof config.min !== "undefined")
        {
            min = config.min;
        }

        if(typeof config.max !== "undefined")
        {
            max = config.max;
        }
    }

    var viewerVersion = KEN.VERSION.split(".");
    var minVersion = min.split(".");
    var maxVersion = max.split(".");
    var maxLength = Math.max(viewerVersion.length, minVersion.length, maxVersion.length);

    var viewerN = 0;
    var minN = 0;
    var maxN = 0;
    var inc = 1;
    for(var i = maxLength - 1; i >= 0; i--)
    {
        if(typeof viewerVersion[i] !== "undefined")
        {
            viewerN = parseInt(viewerVersion[i], 10);
        }
        if(typeof minVersion[i] !== "undefined")
        {
            minN = parseInt(minVersion[i], 10);
        }
        if(typeof maxVersion[i] !== "undefined")
        {
            maxN = parseInt(maxVersion[i], 10);
        }

        inc *= 10;
    }

    if(viewerN < minN || viewerN > maxN)
    {
        return false;
    }

    return true;
};

/**
 * Check device requirement for this plugin engine.
 * @method KEN.PluginEngine#_deviceCheck
 * @private
 * @param  {Object} config - The device requirement configuration object of the manifest.
 * @return {boolean} Returns true if the plugin is compatible with the device environment, false if not.
 */
KEN.PluginEngine.prototype._deviceCheck = function(config)
{
    //If configuration is undefined I guess that the plugin has no device limitations
    if(typeof config === "undefined")
    {
        return true;
    }

    for(var i in config)
    {
        if(typeof KEN.Device[i] === "undefined")
        {
            this.warn("Unable to check plugin device compatibility for: "+i);
        }
        else if(KEN.Device[i] !== config[i])
        {
            return false;
        }
    }

    return true;
};

/**
 * Internal method to load a list of sources files of the engine.
 * @method KEN.PluginEngine#_loadSources
 * @private
 * @param  {Array<string>} sources - Array of urls of files to load relative sto the base url of the engine.
 */
KEN.PluginEngine.prototype._loadSources = function(sources)
{
    var sourceUrl;
    for(var i = 0, ii = sources.length; i < ii; i++)
    {
        //If source is an absolute URL
        if(String(sources[i]).substring(0, 7) === "http://" || String(sources[i]).substring(0, 8) === "https://")
        {
            sourceUrl = sources[i];
        }
        // Else it is relative to the plugin folder
        else
        {
            sourceUrl = this._fullUrl + sources[i];
        }

        this._loadSource(sourceUrl);
    }
};

/**
 * Load a single source file file.
 * @method  KEN.PluginEngine#_loadSource
 * @private
 * @param {string} url - Url of the file to load.
 */
KEN.PluginEngine.prototype._loadSource = function(url)
{
    var parsedURL = KEN.URL.parse(url);

    if( parsedURL["extension"] === "css")
    {
        this._viewer["load"].css(url, this._loadSourceComplete, this);
    }
    else
    {
        this._viewer["load"].script(url, this._loadSourceComplete, this);
    }
};

/**
 * Handler for the load source complete.
 * @method KEN.PluginEngine#_loadSourceComplete
 * @private
 */
KEN.PluginEngine.prototype._loadSourceComplete = function()
{
    this._sourcesLoadedCount++;

    if(this._sourcesLoadedCount === this._sources.length)
    {
        this._constructorFunction = this._parseConstructor(this._constructorName);

        if(this._validateEngine() === true)
        {
            this._addLocales(this._i18n);

            this._loaded = true;

            if(this._onLoadComplete !== null)
            {
                this._onLoadComplete.dispatch();
            }
        }
    }
};

/**
 * Add the locale configuration to the i18n global manager.
 * @method KEN.PluginEngine#_addlocales
 * @private
 * @param {Object} i18n - The i18n config to add.
 */
KEN.PluginEngine.prototype._addLocales = function(i18n)
{
    if(i18n !== null)
    {
        this._viewer["i18n"].addConfig(i18n);
    }
};

/**
 * For i18n, we check nodes for files and redefine the url for the loading of files<br>
 * with a path relative to the base tour.
 * @method  KEN.PluginEngine#_parseLocales
 * @private
 * @param  {Object} manifest - The manifest passed by the main parser.
 * @return {Object} The updated i18n object with paths relative to the project.
 */
KEN.PluginEngine.prototype._parseLocales = function(manifest)
{
    var i18n = null;

    if(typeof manifest["i18n"] !== "undefined")
    {
        i18n = manifest["i18n"];
        if(typeof i18n["locales"] !== "undefined")
        {
            var locale;
            for(var i = 0, ii = i18n["locales"].length; i < ii; i++)
            {
                locale = i18n["locales"][i];
                if(typeof locale.files !== "undefined")
                {
                    var file;
                    for(var j = 0, jj = locale.files.length; j < jj; j++)
                    {
                        file = locale.files[j];
                        file["key"] = this._uid + "-" + file["key"];
                        file["url"] = this._fullUrl + file["url"];
                    }
                }
            }
        }
    }

    return i18n;
};

/**
 * Parse the constructor string.
 * @method KEN.PluginEngine#_parseConstructor
 * @param {string} constructorName - The constructor name to parse. (ex: "Namespace.PluginConstructor")
 * @return {Function} Return the found constructor function, null if not found
 * @private
 */
KEN.PluginEngine.prototype._parseConstructor = function(constructorName)
{
    if(typeof constructorName === "string" && constructorName !== "")
    {
        var pathArray = constructorName.split(".");
        var currentObject = window;
        for(var i = 0, ii = pathArray.length; i < ii; i++)
        {
            if(i === pathArray.length - 1 && typeof currentObject[pathArray[i]] === "function")
            {
                return currentObject[pathArray[i]];
            }
            else if(typeof currentObject[pathArray[i]] === "object")
            {
                currentObject = currentObject[pathArray[i]];
            }
            else
            {
                return null;
            }
        }
    }

    return null;
};

/**
 * Internal method to validate the instance.
 * @method KEN.PluginEngine#_validateEngine
 * @private
 * @return {boolean} Returns true if the engine instance is valid.
 */
KEN.PluginEngine.prototype._validateEngine = function()
{
    if(this._constructorFunction === null || typeof this._constructorFunction !== "function")
    {
        throw "Plugin engine "+this._uid+" can't find it's constructor";
    }

    for(var i = 0, ii = KEN.PluginEngine._REQUIRED.length; i < ii; i++)
    {
        if(typeof this._constructorFunction.prototype[KEN.PluginEngine._REQUIRED[i]] !== "function")
        {
            throw "KEN.PluginEngine engine validation failed, missing required method "+KEN.PluginEngine._REQUIRED[i]+" on plugin engine "+this._name;
        }
    }

    //Add a readonly reference of the viewer to the plugin engine instance.
    Object.defineProperty(this._constructorFunction.prototype, "viewer",
    {
        /** @this {KEN.PluginEngine} */
        get: function()
        {
            return this._viewer;
        }
    });

    //Add a readonly reference of the plugin to the plugin engine instance.
    Object.defineProperty(this._constructorFunction.prototype, "plugin",
    {
        // This annotation is not really true
        /** @this {KEN.PluginObjectFactory} */
        get: function()
        {
            return this._plugin;
        }
    });

    return true;
};

/**
 * Internal method to validate that the instance do not use one of the reserved keywords.
 * @method KEN.PluginEngine#_validateReserved
 * @private
 * @param  {Object} instance - The instance to validate.
 * @return {boolean} Returns true if no reserved keywords are in use on the instance.
 */
KEN.PluginEngine.prototype._validateReserved = function(instance)
{
    for(var i = 0, ii = KEN.PluginEngine._RESERVED.length; i < ii; i++)
    {
        if(typeof instance[KEN.PluginEngine._RESERVED[i]] !== "undefined")
        {
            throw "KEN.PluginEngine instance validation failed, "+KEN.PluginEngine._RESERVED[i]+" is reserved";
        }
    }

    return true;
};

/**
 * Internal method to validate that the actions listed on the manifest are part of the instance.
 * @method KEN.PluginEngine#_validateActions
 * @private
 * @param  {Object} instance - The instance to validate.
 * @return {boolean} Returns true if actions are valid on the instance.
 */
KEN.PluginEngine.prototype._validateActions = function(instance)
{
    if(this._actions === null)
    {
        return true;
    }

    for(var i = 0, ii = this._actions.length; i < ii; i++)
    {
        if(typeof instance[this._actions[i]] !== "function")
        {
            throw "KEN.PluginEngine instance validation failed, action "+this._actions[i]+" is undefined on plugin "+this._constructorName;
        }
    }

    return true;
};

/**
 * This method validate the instace by testing both reserved keywords and actions.
 * @method KEN.PluginEngine#_validateEngine
 * @private
 * @param  {Object} instance - The instance to validate.
 * @return {boolean} Returns true if the instance is valid.
 */
KEN.PluginEngine.prototype._validateInstance = function(instance)
{
    return (this._validateReserved(instance) === true && this._validateActions(instance) === true);
};

/**
 * Destroy method.
 * @method KEN.PluginEngine#destroy
 */
KEN.PluginEngine.prototype.destroy = function()
{
    this._viewer = null;
    this._config = null;
    this._manifestData = null;
    this._name = null;
    this._version = null;
    this._sources = null;
    this._constructorFunction = null;
    this._i18n = null;

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.destroy();
        this._onLoadComplete = null;
    }

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the name of this plugin engine.
 * @name KEN.PluginEngine#name
 * @readonly
 * @type {string}
 */
KEN.PluginEngine.prototype.name;
Object.defineProperty(KEN.PluginEngine.prototype, "name",
{
    /** @this {KEN.PluginEngine} */
    get: function()
    {
        return this._name;
    }
});

/**
 * Get the loaded status of this plugin engine.
 * True if the plugin is considered as loaded.
 * @name KEN.PluginEngine#loaded
 * @readonly
 * @type {boolean}
 */
KEN.PluginEngine.prototype.loaded;
Object.defineProperty(KEN.PluginEngine.prototype, "loaded",
{
    /** @this {KEN.PluginEngine} */
    get: function()
    {
        return this._loaded;
    }
});

/**
 * Get the base url of the plugin engine.
 * @name KEN.PluginEngine#url
 * @readonly
 * @type {string}
 */
KEN.PluginEngine.prototype.url;
Object.defineProperty(KEN.PluginEngine.prototype, "url",
{
    /** @this {KEN.PluginEngine} */
    get: function()
    {
        return this._url;
    }
});

/**
 * Get the base url of the plugin engine.
 * @name KEN.PluginEngine#fullUrl
 * @readonly
 * @type {string}
 */
KEN.PluginEngine.prototype.fullUrl;
Object.defineProperty(KEN.PluginEngine.prototype, "fullUrl",
{
    /** @this {KEN.PluginEngine} */
    get: function()
    {
        return this._fullUrl;
    }
});

/**
 * Get the options of the plugin engine.
 * @name KEN.PluginEngine#options
 * @readonly
 * @type {Object}
 */
KEN.PluginEngine.prototype.options;
Object.defineProperty(KEN.PluginEngine.prototype, "options",
{
    /** @this {KEN.PluginEngine} */
    get: function()
    {
        return this._options;
    }
});

/**
 * Get the available actions of the plugin engine.
 * @name KEN.PluginEngine#actions
 * @readonly
 * @type {Array<String>}
 */
KEN.PluginEngine.prototype.actions;
Object.defineProperty(KEN.PluginEngine.prototype, "actions",
{
    /** @this {KEN.PluginEngine} */
    get: function()
    {
        return this._actions;
    }
});

/**
 * Get the available events of the plugin engine.
 * @name KEN.PluginEngine#events
 * @readonly
 * @type {Object}
 */
KEN.PluginEngine.prototype.events;
Object.defineProperty(KEN.PluginEngine.prototype, "events",
{
    /** @this {KEN.PluginEngine} */
    get: function()
    {
        return this._events;
    }
});

/**
 * Get the default plugin configuration that contains (data + options + actions + events).
 * @name KEN.PluginEngine#defaultConfig
 * @readonly
 * @type {PluginConfiguration}
 */
KEN.PluginEngine.prototype.defaultConfig;
Object.defineProperty(KEN.PluginEngine.prototype, "defaultConfig",
{
    /** @this {KEN.PluginEngine} */
    get: function()
    {
        /** @type {PluginConfiguration} */
        var config =
        {
            data: /** @type {Object} */ (this._data),
            options: this._options,
            actions: this._actions,
            events: this._events
        };

        return config;
    }
});

/**
 * Get the on load complete {@link KEN.EventDispatcher} of the plugin engine.
 * @name KEN.PluginEngine#onLoadComplete
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.PluginEngine.prototype.onLoadComplete;
Object.defineProperty(KEN.PluginEngine.prototype, "onLoadComplete",
{
    /** @this {KEN.PluginEngine} */
    get: function()
    {
        if(this._onLoadComplete === null)
        {
            this._onLoadComplete = new KEN.EventDispatcher(this);
        }

        return this._onLoadComplete;
    }
});


/**
 * The KEN.PluginManager manages {@link KEN.PluginEngine} and {@link KEN.Plugin}.
 *
 * @constructor KEN.PluginManager
 * @param {KEN.Viewer} viewer - The {@link KEN.Viewer} reference.
 * @extends {KEN.BaseObject}
 */
KEN.PluginManager = function(viewer)
{
    KEN.BaseObject.call(this, "PluginManager");

    /**
     * The viewer reference.
     * @name KEN.PluginManager#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The engines list.
     * @name KEN.PluginManager#_engines
     * @type {KEN.Collection<KEN.PluginEngine>}
     * @private
     */
    this._engines = null;

    /**
     * The plugins list.
     * @name KEN.PluginManager#_plugins
     * @type {KEN.Collection<KEN.Plugin>}
     * @private
     */
    this._plugins = null;

    /**
     * Does the plugin manager is enabled ?
     * @name  KEN.PluginManager#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * Is booted?
     * @name KEN.PluginManager#_isBooted
     * @type {boolean}
     * @private
     */
    this._isBooted = false;

    /**
     * Event dispatcher for instance creation
     * @name  KEN.PluginManager#_onInstanceCreate
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onInstanceCreate = null;
};

KEN.PluginManager.prototype = Object.create(KEN.BaseObject.prototype);
KEN.PluginManager.prototype.constructor = KEN.PluginManager;

/**
 * Boot sequence.
 * @method KEN.PluginManager#_boot
 * @private
 */
KEN.PluginManager.prototype.boot = function()
{
    if(this._isBooted === true)
    {
        return;
    }

    if(typeof this._viewer["config"]["plugins"] === "object" && typeof this._viewer["config"]["plugins"]["enabled"] === "boolean")
    {
        this._enabled = this._viewer["config"]["plugins"]["enabled"];
    }

    this._engines = new KEN.Collection();

    this._plugins = new KEN.Collection();

    this._viewer["tour"]["onReady"].addOnce(this._tourReadyHandler, this);

    this._viewer["tour"]["onSceneLoadStart"].add(this._sceneLoadStartHandler, this);

    this._isBooted = true;
};

/**
 * Event handler for tour ready.
 * @method KEN.PluginManager#_tourReadyHandler
 * @private
 */
KEN.PluginManager.prototype._tourReadyHandler = function()
{
    if(this._enabled === true && typeof this._viewer["tour"]["config"]["plugins"] !== "undefined")
    {
        this._parseConfig(this._viewer["tour"]["config"]["plugins"]);
    }
};

/**
 * Event handler for scene load start.
 * @method KEN.PluginManager#_sceneLoadStartHandler
 * @private
 */
KEN.PluginManager.prototype._sceneLoadStartHandler = function(event)
{
    //Remove plugin taht have keep @ false and plugin that have scene restrictions.

    this._removeUnkeptPlugins(event["data"]["uid"]);

    //Add plugins =============================================

    if(this._enabled === true && typeof this._viewer["tour"]["config"]["plugins"] !== "undefined")
    {
        this._parseConfig(this._viewer["tour"]["config"]["plugins"]);
    }

    if(this._enabled === true && typeof this._viewer["tour"]["scene"]["config"]["plugins"] !== "undefined")
    {
        this._parseConfig(this._viewer["tour"]["scene"]["config"]["plugins"]);
    }

    //Reset plugins ============================================

    this._resetPlugins();

};

/**
 * Remove plugins that have a keep value @ false OR if the plugin have a scene restriction.
 * @method KEN.PluginManager#_removeUnkeptPlugins
 * @param {string} [sceneUid] The scene uid received on scene load start.
 * @private
 */
KEN.PluginManager.prototype._removeUnkeptPlugins = function(sceneUid)
{
    var plugin;
    var count = this._plugins["size"];

    while(count--)
    {
        plugin = this._plugins.get(count);

        if(plugin["keep"] === false || (plugin["scenes"] !== null && plugin["scenes"].indexOf(sceneUid) === -1))
        {
            this.remove(plugin["uid"]);
        }
    }
};

/**
 * This method will reset plugins that have a reset value @ true between each scene.
 * @method  KEN.PluginManager#_resetPlugins
 * @private
 */
KEN.PluginManager.prototype._resetPlugins = function()
{
    var plugin;
    var count = this._plugins["size"];

    while(count--)
    {
        plugin = this._plugins.get(count);

        if(plugin["reset"] === true)
        {
            plugin.resetInstance();
        }
    }
};

/**
 * Parse the plugin config.
 * @method KEN.PluginManager#_parseConfig
 * @param {PluginsConfig} config - The configuration of the main plugins node to parse.
 * @private
 */
KEN.PluginManager.prototype._parseConfig = function(config)
{
    this._parseEngines(config.engines);
    this._parseInstances(config.instances);
    this._parseConfigurations(config.configurations);
};

/**
 * Parse plugins engines in main config.
 * @method KEN.PluginManager#_parseEngines
 * @param  {Array<PluginEngineConfig>} engines - The engines object to parse.
 * @private
 */
KEN.PluginManager.prototype._parseEngines = function(engines)
{
    if(typeof engines !== "undefined")
    {
        for(var i = 0, ii = engines.length; i < ii; i++)
        {
            this._addEngine(engines[i]);
        }
    }
};

/**
 * Parse plugins instances in main config.
 * @method KEN.PluginManager#_parseInstances
 * @param  {Array<PluginInstanceConfig>} instances - The instances object to parse.
 * @private
 */
KEN.PluginManager.prototype._parseInstances = function(instances)
{
    if(typeof instances !== "undefined")
    {
        for(var i = 0, ii = instances.length; i < ii; i++)
        {
            var instanceUid = instances[i]["uid"];
            var enabled = (instances[i]["enabled"] !== false) ? true : false;
            var plugin = this.getById(instanceUid);

            var sceneUid = this._viewer["tour"]["sceneUid"];
            var scenes = (KEN.Utils.isArrayOf(instances[i]["scenes"], "string")) ? instances[i]["scenes"] : [];

            //Scene valid is true if there is no current scene AND there are no scene restriction for the instance,
            //OR if there is a scene restriction and the current scene UID is in the restriction array!
            var sceneValid = Boolean( scenes.length === 0 || (sceneUid === "" && scenes.length === 0) || scenes.indexOf(sceneUid) !== -1 );

            if(enabled === true && plugin === null && sceneValid === true)
            {
                this._addInstance(instances[i]);
            }
        }
    }
};

/**
 * Parse plugins configurations in main config.
 * @method KEN.PluginManager#_parseConfigurations
 * @param  {Array<PluginConfigurationConfig>} configurations - The configurations object to parse.
 * @private
 */
KEN.PluginManager.prototype._parseConfigurations = function(configurations)
{
    if(typeof configurations !== "undefined")
    {
        for(var i = 0, ii = configurations.length; i < ii; i++)
        {
            var uid = configurations[i]["instance"];
            var enabled = (configurations[i]["enabled"] !== false) ? true : false;
            var plugin = this.getById(uid);
            var config = null;

            if(enabled === true)
            {
                config = configurations[i];
            }

            if(plugin !== null)
            {
                plugin["contextualConfig"] = config;
            }
        }
    }
};

/**
 * Add an engine.
 * @method KEN.PluginManager#_addEngine
 * @param {PluginEngineConfig} config - The config to parse.
 * @private
 */
KEN.PluginManager.prototype._addEngine = function(config)
{
    if(typeof config["uid"] === "string" && KEN.UID.exists(config["uid"]) === false)
    {
        var engine = new KEN.PluginEngine(this._viewer);
        this._engines.add(engine);

        engine.load(config);
    }
};

/**
 * Get an engine.
 * @method KEN.PluginManager#_getEngine
 * @param {string} uid - The uid to search for.
 * @return {?KEN.PluginEngine} Returns the engine.
 * @private
 */
KEN.PluginManager.prototype._getEngine = function(uid)
{
    var engine = null;
    for(var i = 0, ii = this._engines["size"]; i < ii; i++)
    {
        engine = /** @type {KEN.PluginEngine} */ (this._engines.get(i));

        if(engine["uid"] === uid)
        {
            return engine;
        }
    }

    return null;
};

/**
 * Add a plugin instance.
 * @method KEN.PluginManager#_addInstance
 * @param {PluginInstanceConfig} config - The config to parse.
 * @private
 * @return {KEN.Plugin} The created plugin object.
 */
KEN.PluginManager.prototype._addInstance = function(config)
{
    if(typeof config.engine === "undefined")
    {
        throw "Can't create plugin instance, engineUid is undefined";
    }

    var engine = this._getEngine(config.engine);

    if(engine === null)
    {
        throw "Plugin Engine "+config.engine+" doesn't exist";
    }

    var index = typeof config["index"] === "number" ? config["index"] : this._plugins["size"];

    var plugin = new KEN.Plugin(this._viewer, engine, config, index);
    plugin["onInstanceCreate"].addOnce(this._onInstanceCreateHandler, this);
    this._plugins.add(plugin);

    plugin.instantiate();

    return plugin;
};

/**
 * Instance create handler, wil lredispatch from the plugin manager
 * @method KEN.PluginManager#_onInstanceCreateHandler
 * @param {KEN.Event} event
 * @private
 */
KEN.PluginManager.prototype._onInstanceCreateHandler = function(event)
{
    var plugin = event["emitter"];

    if(this._onInstanceCreate !== null)
    {
        this._onInstanceCreate.dispatch(plugin);
    }
};

/**
 * Get a plugin instance by uid.
 * @method KEN.PluginManager#getById
 * @param {string} uid - The uid to search for.
 * @return {KEN.Plugin} Returns the plugin.
 */
KEN.PluginManager.prototype.getById = function(uid)
{
    var plugin;
    for(var i = 0, ii = this._plugins["size"]; i < ii; i++)
    {
        plugin = /** @type {KEN.Plugin} */ (this._plugins.get(i));

        if(plugin["uid"] === uid)
        {
            return plugin;
        }
    }

    return null;
};

/**
 * Get a plugin instance by index.
 * @method KEN.PluginManager#getByIndex
 * @param {number} index - The index to search for.
 * @return {KEN.Plugin} Returns the plugin.
 */
KEN.PluginManager.prototype.getByIndex = function(index)
{
    var plugin = /** @type {KEN.Plugin} */ (this._plugins.get(index));

    if(typeof plugin !== "undefined")
    {
        return plugin;
    }
    else
    {
        return null;
    }
};

/**
 * Get a plugin instance by value.
 * @method KEN.PluginManager#get
 * @param {number|string} value - The index or uid to search for.
 * @return {KEN.Plugin} Returns the plugin.
 */
KEN.PluginManager.prototype.get = function(value)
{
    var plugin = null;

    if(typeof value === "string")
    {
        plugin = this.getById(value);
    }
    else if(typeof value === "number")
    {
        plugin = this.getByIndex(value);
    }

    return plugin;
};

/**
 * Remove a plugin instance.
 * @method KEN.PluginManager#remove
 * @param {string} uid - The uid to search for.
 */
KEN.PluginManager.prototype.remove = function(uid)
{
    var plugin = this.get(uid);

    plugin.destroy();

    this._plugins.remove(plugin);
};

/**
 * Update main loop for plugins.
 * @method KEN.PluginManager#update
 */
KEN.PluginManager.prototype.update = function()
{
    var plugin;
    for(var i = 0, ii = this._plugins["size"]; i < ii; i++)
    {
        plugin = this._plugins.get(i);
        plugin.update();
    }
};

/**
 * Render main loop for plugins.
 * @method KEN.PluginManager#render
 */
KEN.PluginManager.prototype.render = function()
{

};

/**
 * Destroy method.
 * @method KEN.PluginManager#destroy
 */
KEN.PluginManager.prototype.destroy = function()
{

    this._viewer = null;

    if(this._onInstanceCreate !== null)
    {
        this._onInstanceCreate.destroy();
        this._onInstanceCreate = null;
    }

    for(var i = 0, ii = this._engines["size"]; i < ii; i++)
    {
        this._engines.get(i).destroy();
    }
    this._engines = null;

    for(var j = 0, jj = this._plugins["size"]; j < jj; j++)
    {
        this._plugins.get(j).destroy();
    }
    this._plugins = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
* Get the all plugins.
* @name KEN.PluginManager#all
* @readonly
* @type {Array<KEN.Plugin>}
*/
KEN.PluginManager.prototype.all;
Object.defineProperty(KEN.PluginManager.prototype, "all",
{
    /** @this {KEN.PluginManager} */
    get: function()
    {
        return this._plugins;
    }
});

/**
 * Get the "onInstanceCreate" {@link KEN.EventDispatcher} of the PluginManager.
 * @name KEN.PluginManager#onInstanceCreate
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.PluginManager.prototype.onInstanceCreate;
Object.defineProperty(KEN.PluginManager.prototype, "onInstanceCreate",
{
    /** @this {KEN.PluginManager} */
    get: function()
    {
        if(this._onInstanceCreate === null)
        {
            this._onInstanceCreate = new KEN.EventDispatcher(this, true);
        }

        return this._onInstanceCreate;
    }
});




/**
 * Factory helper to create object inside plugins.<br>
 * The factory knows what objects are created for a plugin, so it can destroy all object of the plugin at plugin destroy.
 *
 * @constructor KEN.PluginObjectFactory
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @param {KEN.Plugin} plugin - The {@link KEN.Plugin} that will use this factory.
 * @extends {KEN.BaseObject}
 *
 * @todo add the file key restriction for i18n stuff
 */
KEN.PluginObjectFactory = function(viewer, plugin)
{
    /**
     * The viewer reference.
     * @name KEN.PluginEngine#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The plugin reference.
     * @name KEN.PluginEngine#_plugin
     * @type {KEN.Plugin}
     * @private
     */
    this._plugin = plugin;

    /**
     * The type of object list.
     * @name KEN.PluginEngine#_objects
     * @type {Array<Object>}
     * @private
     */
    this._objects = [];

    KEN.BaseObject.call(this, "PluginObjectFactory");
};

KEN.PluginObjectFactory.prototype = Object.create(KEN.BaseObject.prototype);
KEN.PluginObjectFactory.prototype.constructor = KEN.PluginObjectFactory;

/**
 * Search for an object into the list.
 * @method KEN.PluginObjectFactory#_indexOfObject
 * @param  {Object} obj - The object to look for.
 * @return {number} Returns the index of the object found, if not, returns -1.
 * @private
 */
KEN.PluginObjectFactory.prototype._indexOfObject = function(obj)
{
    var n = this._objects.length;
    var o;

    while(n--)
    {
        o = this._objects[n];

        if(o === obj)
        {
            return n;
        }
    }

    return -1;
};

/**
 * Internal handler on object destroy.
 * @method KEN.PluginObjectFactory#_destroyObjectHandler
 * @param  {KEN.Event} event - The event.
 * @private
 */
KEN.PluginObjectFactory.prototype._destroyObjectHandler = function(event)
{
    var o = event["emitter"];
    var i = this._indexOfObject(o);
    this._objects.splice(i, 1);
};

/**
 * Add a {@link KEN.LocaleString}.
 * @method KEN.PluginObjectFactory#string
 * @param  {string} key - Object key.
 * @return {KEN.LocaleString} Returns the created KEN.LocaleString.
 */
KEN.PluginObjectFactory.prototype.string = function(key)
{
    var string = new KEN.LocaleString(this._viewer, key);
    string["onDestroy"].addOnce(this._destroyObjectHandler, this);

    this._objects.push(string);
    return string;
};

/**
 * Add a {@link KEN.Textfield}.
 * @method KEN.PluginObjectFactory#textField
 * @param  {(string|TextFieldConfig)} config - Object configuration.
 * @return {KEN.TextField} Returns the created KEN.Textfield.
 */
KEN.PluginObjectFactory.prototype.textField = function(config)
{
    var textField = new KEN.TextField(this._viewer, config);
    textField["onDestroy"].addOnce(this._destroyObjectHandler, this);

    this._objects.push(textField);
    return textField;
};

/**
 * Add a {@link KEN.Sound}.
 * @method KEN.PluginObjectFactory#sound
 * @param {string} key - Object key.
 * @param {string} url - The sound url.
 * @return {KEN.Sound} Returns the created KEN.Sound.
 */
KEN.PluginObjectFactory.prototype.sound = function(key, url)
{
    var sound = new KEN.Sound(this._viewer, key, url);
    sound["onDestroy"].addOnce(this._destroyObjectHandler, this);

    this._objects.push(sound);
    return sound;
};

/**
 * Add a {@link KEN.DisplayObjectContainer}.
 * @method KEN.PluginObjectFactory#displayObjectContainer
 * @param  {Element|HTMLElement} dom - Dom object.
 * @return {KEN.DisplayObjectContainer} Returns the created KEN.DisplayObjectContainer.
 */
KEN.PluginObjectFactory.prototype.displayObjectContainer = function(dom)
{
    var displayObjectContainer = new KEN.DisplayObjectContainer(this._viewer, dom);
    displayObjectContainer["onDestroy"].addOnce(this._destroyObjectHandler, this);

    this._objects.push(displayObjectContainer);
    return displayObjectContainer;
};

/**
 * Add a {@link KEN.DisplayObject}.
 * @method KEN.PluginObjectFactory#displayObject
 * @param  {Element|HTMLElement} dom - Dom object.
 * @return {KEN.DisplayObject} Returns the created KEN.DisplayObject.
 */
KEN.PluginObjectFactory.prototype.displayObject = function(dom)
{
    var displayObject = new KEN.DisplayObject(this._viewer, dom);
    displayObject["onDestroy"].addOnce(this._destroyObjectHandler, this);

    this._objects.push(displayObject);
    return displayObject;
};

/**
 * Add a {@link KEN.Image}.
 * @method KEN.PluginObjectFactory#image
 * @param  {string|Object} config - URL of the image or an image configuration object.
 * @param  {boolean} relativeToPluginPath
 * @return {KEN.Image} Returns the created KEN.Image.
 */
KEN.PluginObjectFactory.prototype.image = function(config, relativeToPluginPath)
{
    var c = config;

    if(typeof config === "string")
    {
        c = {"key": null, "url": config};
    }

    c["key"] = this._plugin["uid"] + "-" + c["key"];

    if(relativeToPluginPath !== false)
    {
        c["url"] = this._plugin["fullUrl"] + c["url"];
    }

    var img = new KEN.Image(this._viewer, c);
    img["onDestroy"].addOnce(this._destroyObjectHandler, this);

    this._objects.push(img);
    return img;
};

/**
 * Add a {@link KEN.Sprite}.
 * @method KEN.PluginObjectFactory#sprite
 * @param  {Object} config - Sprite configuration object.
 * @param  {boolean} relativeToPluginPath
 * @return {KEN.Image} Returns the created KEN.Sprite.
 */
KEN.PluginObjectFactory.prototype.sprite = function(config, relativeToPluginPath)
{
    var c = config;

    c["key"] = this._plugin["uid"] + "-" + c["key"];

    if(relativeToPluginPath !== false)
    {
        c["url"] = this._plugin["fullUrl"] + c["url"];
        c["frames"] = this._plugin["fullUrl"] + c["frames"];
    }

    var sprite = new KEN.Sprite(this._viewer, c);
    sprite["onDestroy"].addOnce(this._destroyObjectHandler, this);

    this._objects.push(sprite);
    return sprite;
};

/**
 * Add a {@link KEN.Button}.
 * @method KEN.PluginObjectFactory#button
 * @param  {ButtonConfig} config - The button configuration object.
 * @return {KEN.Button} Returns the created KEN.Button.
 */
KEN.PluginObjectFactory.prototype.button = function(config)
{
    var button = new KEN.Button(this._viewer, config);
    button["onDestroy"].addOnce(this._destroyObjectHandler, this);

    this._objects.push(button);
    return button;
};

/**
 * Add a {@link KEN.Video}.
 * @method KEN.PluginObjectFactory#video
 * @param {string} key - The video Id reference.
 * @param {?(string|KEN.VideoQuality|Array<(KEN.VideoQuality|string)>)=} config - The video configuration object
 * @param {string=} format - The video format. Can be "HTML5" or "DASH".
 * @param {string=} qualityMode - The video quality mode. Can be "auto" or "manual".
 * @return {(KEN.VideoHTML5|KEN.VideoDash)} Returns the created KEN.Video object.
 */
KEN.PluginObjectFactory.prototype.video = function(key, config, format, qualityMode)
{
    var video;

    if(typeof format !== undefined && format === KEN.VideoFormat.DASH)
    {
        video = new KEN.VideoDash(this._viewer, key, config, qualityMode);
    }
    else
    {
        video = new KEN.VideoHTML5(this._viewer, key, config, qualityMode);
    }

    video["onDestroy"].addOnce(this._destroyObjectHandler, this);

    this._objects.push(video);
    return video;
};

/**
 * Add a {@link KEN.Canvas}.
 * @method KEN.PluginObjectFactory#canvas
 * @return {KEN.Canvas} Returns the created KEN.Canvas.
 */
KEN.PluginObjectFactory.prototype.canvas = function()
{
    var canvas = new KEN.Canvas(this._viewer);
    canvas["onDestroy"].addOnce(this._destroyObjectHandler, this);

    this._objects.push(canvas);
    return canvas;
};

/**
 * Add a {@link KEN.Tween}.
 * @method KEN.PluginObjectFactory#tween
 * @param {Object} object
 * @return {KEN.Tween} Returns the created KEN.Tween.
 */
KEN.PluginObjectFactory.prototype.tween = function(object)
{
    var tween = new KEN.Tween(this._viewer, object);
    tween["onDestroy"].addOnce(this._destroyObjectHandler, this);
    this._viewer["tween"].add(tween);

    this._objects.push(tween);
    return tween;
};

/**
 * Destroy all objects.
 * @method KEN.PluginObjectFactory#destroyAllObjects
 */
KEN.PluginObjectFactory.prototype.destroyAllObjects = function()
{
    this.log("destroyAllObjects();");

    var n = this._objects.length;

    while(n--)
    {
        this._objects[n].destroy();
    }
};

/**
 * Destroy method.
 * @method KEN.PluginObjectFactory#destroy
 */
KEN.PluginObjectFactory.prototype.destroy = function()
{
    this.destroyAllObjects();

    this._viewer = null;
    this._plugin = null;
    this._objects = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * @namespace KEN.Device
 */
KEN.Device = (function(c)
 {
    var Tmp = c();
    Tmp.prototype = Object.create(null);
    Tmp.prototype.constructor = Tmp;

    /**
     * Check which OS is running.
     * @method KEN.Device#_checkOS
     * @suppress {checkRegExp}
     * @private
     */
    Tmp.prototype._checkOS = function()
    {
        if (/Playstation Vita/.test(this.ua))
        {
            this.os = "Playstation Vita";
            this.vita = true;
        }
        else if (/Xbox/.test(this.ua))
        {
            this.os = "Xbox";
            this.xbox = true;
        }
        else if (/Kindle/.test(this.ua) || /\bKF[A-Z][A-Z]+/.test(this.ua) || /Silk.*Mobile Safari/.test(this.ua))
        {
            this.os = "Kindle";
            this.kindle = true;
        }
        else if ((/Windows Phone/i).test(this.ua) || (/IEMobile/i).test(this.ua))
        {
            this.os = "Windows Phone";
            this.windowsPhone = true;
            if (/Windows Phone (\d+)/.test(this.ua))
            {
                this.osVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (/Android/.test(this.ua))
        {
            this.os = "Android";
            this.android = true;
            if (/Android ([\.\_\d]+)/.test(this.ua))
            {
                this.osVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (/CrOS/.test(this.ua))
        {
            this.os = "Chrome OS";
            this.chromeOS = true;
        }
        else if (/iP[ao]d|iPhone/i.test(this.ua))
        {
            this.os = "iOS";
            this.iOS = true;
            if (/OS (\d+)/.test(navigator.appVersion))
            {
                this.osVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (/(Linux|X11)/.test(this.ua))
        {
            this.os = "Linux";
            this.linux = true;
        }
        else if (/Mac OS X/.test(this.ua))
        {
            this.os = "Mac OS X";
            this.macOS = true;
            if (/Mac OS X (10[\.\_\d]+)/.test(this.ua))
            {
                this.osVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (/Windows/.test(this.ua) || (/WPDesktop/i).test(this.ua))
        {
            if ((/WPDesktop/i).test(this.ua))
            {
                this.os = "Windows Phone";
                this.windowsPhone = true;
            }
            else
            {
                this.os = "Windows";
                this.windows = true;
            }
            if (/(Windows 10.0|Windows NT 10.0)/.test(this.ua))
            {
                this.osVersion = 10;
            }
            else if (/(Windows 8.1|Windows NT 6.3)/.test(this.ua) || /(Windows 8|Windows NT 6.2)/.test(this.ua))
            {
                this.osVersion = 8;
            }
            else if (/(Windows 7|Windows NT 6.1)/.test(this.ua))
            {
                this.osVersion = 7;
            }
        }
    };

    /**
     * Check which browser is running.
     * @method KEN.Device#_checkBrowsers
     * @suppress {checkRegExp}
     * @private
     */
    Tmp.prototype._checkBrowsers = function()
    {
        this.ie = /*@cc_on!@*/ false || typeof document["documentMode"] !== "undefined";
        this.edge = this.ie === false && Boolean(window["StyleMedia"]) === true;
        this.firefox = typeof window["InstallTrigger"] !== "undefined";
        this.opera = Boolean(window["opr"]) === true || this.ua.indexOf(" OPR/") >= 0 || this.ua.indexOf("Opera") >= 0;
        this.safari = Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") > 0;
        this.chrome = this.ie === false && this.edge === false && this.opera === false && (Boolean(window["chrome"]) === true || this.ua.indexOf("CriOS") >= 0);

        if (this.edge)
        {
            this.browser = "Edge";
            if (/Edge\/(\d+)/.test(this.ua))
            {
                this.browserVersion = this.edgeVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (this.chrome)
        {
            this.browser = "Chrome";
            if (/CriOS\/(\d+)/.test(this.ua))
            {
                this.browserVersion = this.chromeVersion = parseInt(RegExp.$1, 10);
            }
            else if (/Chrome\/(\d+)/.test(this.ua))
            {
                this.browserVersion = this.chromeVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (this.firefox)
        {
            this.browser = "Firefox";
            if (/Firefox\D+(\d+)/.test(this.ua))
            {
                this.browserVersion = this.firefoxVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (this.kindle)
        {
            // Silk gets its own if clause because its ua also contains 'Safari'
            if (/Silk/.test(this.ua))
            {
                this.browser = "Silk";
                this.silk = true;
            }
        }
        else if (this.ie)
        {
            this.browser = "Internet Explorer";
            if (/MSIE (\d+\.\d+);/.test(this.ua))
            {
                this.browserVersion = this.ieVersion = parseInt(RegExp.$1, 10);
            }
            else if (/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(this.ua))
            {
                this.browserVersion = this.ieVersion = parseInt(RegExp.$3, 10);
            }
        }
        else if (this.opera)
        {
            this.browser = "Opera";
            if (/OPR\/(\d+)/.test(this.ua))
            {
                this.browserVersion = this.operaVersion = parseInt(RegExp.$1, 10);
            }
            else if (this.ua.indexOf("Opera/") >= 0)
            {
                if (/Version\/(\d+)/.test(this.ua))
                {
                    this.browserVersion = this.operaVersion = parseInt(RegExp.$1, 10);
                }
            }
            else if (/Opera (\d+)/.test(this.ua))
            {
                this.browserVersion = this.operaVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (this.safari)
        {
            this.browser = "Safari";
            if ((/version\/(\d+(\.\d+)?)/i).test(this.ua))
            {
                this.browserVersion = this.safariVersion = parseInt(RegExp.$1, 10);
            }
        }
        else
        {
            var matches = this.ua.match(/Android.*AppleWebKit\/([\d.]+)/);
            if (matches && matches[1] < 537)
            {
                this.browser = "Android Stock";
                this.isAndroidStockBrowser = true;
                this.browserVersion = this.androidStockBrowserVersion = parseFloat(this.ua.slice(this.ua.indexOf("Android") + 8));
            }
        }
        //  WebApp mode
        if (navigator.standalone)
        {
            this.webApp = true;
        }

        this.quirksMode = (document.compatMode === "CSS1Compat") ? false : true;
    };

    /**
     * Check the device informations.
     * @method KEN.Device#_checkDevice
     * @private
     */
    Tmp.prototype._checkDevice = function()
    {
        this.pixelRatio = window.devicePixelRatio || 1;

        this.iPhone = this.iOS === true && this.ua.toLowerCase().indexOf("iphone") !== -1;
        this.iPod = this.iOS === true && this.ua.toLowerCase().indexOf("ipod") !== -1;
        this.iPad = this.iOS === true && this.ua.toLowerCase().indexOf("ipad") !== -1;
        this.retina = this.pixelRatio >= 2 && this.iOS === true;

        if ((this.windows && !this.windowsPhone) || this.macOS || (this.linux && !this.silk) || this.chromeOS)
        {
            this.desktop = true;
        }
        else if (/Mobi/i.test(this.ua) && this.iPad === false)
        {
            this.mobile = true;
        }
        else
        {
            this.tablet = true;
        }

        //smart TV, Playstation, Table Windows
        if (/TV/i.test(this.ua) || this.vita === true || this.xbox === true || (this.desktop && /Windows NT/i.test(this.ua) && /Touch/i.test(this.ua)))
        {
            this.other = true;
            this.mobile = false;
            this.tablet = false;
            this.desktop = false;
        }
    };

    /**
     * Check video support.
     * @method KEN.Device#_checkVideo
     * @private
     */
    Tmp.prototype._checkVideo = function()
    {
        var videoElement = document.createElement("video");

        try
        {
            if (typeof videoElement.canPlayType === "function")
            {
                if (videoElement.canPlayType("video/ogg; codecs=\"theora\"").replace(/^no$/, ""))
                {
                    this.oggVideo = true;
                }

                if (videoElement.canPlayType("video/mp4; codecs=\"avc1.42E01E\"").replace(/^no$/, ""))
                {
                    // without QuickTime, this value will be "undefined"
                    this.h264Video = true;
                    this.mp4Video = true;
                }

                if (videoElement.canPlayType("video/webm; codecs=\"vp8, vorbis\"").replace(/^no$/, ""))
                {
                    this.webmVideo = true;
                }

                if (videoElement.canPlayType("video/webm; codecs=\"vp9\"").replace(/^no$/, ""))
                {
                    this.vp9Video = true;
                }

                if (videoElement.canPlayType("application/x-mpegURL; codecs=\"avc1.42E01E\"").replace(/^no$/, ""))
                {
                    this.hlsVideo = true;
                }
            }
        }
        catch (e)
        {}
    };

    /**
     * Check audio support.
     * @method KEN.Device#_checkAudio
     * @private
     */
    Tmp.prototype._checkAudio = function()
    {
        this.audioTag = (typeof window.Audio !== "undefined");
        this.webAudio = (typeof window.AudioContext !== "undefined" || typeof window.webkitAudioContext !== "undefined");

        var audioElement = document.createElement("audio");

        try
        {
            if (typeof audioElement.canPlayType === "function")
            {
                if (audioElement.canPlayType("audio/ogg; codecs=\"vorbis\"").replace(/^no$/, ""))
                {
                    this.ogg = true;
                }

                if (audioElement.canPlayType("audio/mpeg;").replace(/^no$/, ""))
                {
                    this.mp3 = true;
                }

                if (audioElement.canPlayType("audio/ogg; codecs=\"opus\"").replace(/^no$/, "") || audioElement.canPlayType("audio/opus;").replace(/^no$/, ""))
                {
                    this.opus = true;
                }

                if (audioElement.canPlayType("audio/wav; codecs=\"1\"").replace(/^no$/, ""))
                {
                    this.wav = true;
                }

                if (audioElement.canPlayType("audio/aac;").replace(/^no$/, ""))
                {
                    this.aac = true;
                }

                if (audioElement.canPlayType("audio/x-m4a;") || audioElement.canPlayType("audio/m4a;") || audioElement.canPlayType("audio/aac;").replace(/^no$/, ""))
                {
                    this.m4a = true;
                }

                if (audioElement.canPlayType("audio/x-mp4;") || audioElement.canPlayType("audio/mp4;") || audioElement.canPlayType("audio/aac;").replace(/^no$/, ""))
                {
                    this.mp4 = true;
                }

                if (audioElement.canPlayType("audio/webm; codecs=\"vorbis\"").replace(/^no$/, ""))
                {
                    this.webm = true;
                    this.weba = true;
                }

            }
        }
        catch (e)
        {}
    };

    /**
     * Check the device features.
     * @method KEN.Device#_checkDeviceFeatures
     * @private
     */
    Tmp.prototype._checkDeviceFeatures = function()
    {
        this.vibrate = (typeof navigator.vibrate !== "undefined" || typeof navigator.webkitVibrate !== "undefined" || typeof navigator.mozVibrate !== "undefined" || typeof navigator.msVibrate !== "undefined");

        this.battery = (typeof navigator.getBattery === "function");
    };

    /**
     * Check HTML5 features.
     * @method KEN.Device#_checkFeatures
     * @private
     */
    Tmp.prototype._checkFeatures = function()
    {
        this["canvas"] = (typeof window.CanvasRenderingContext2D !== "undefined");
        if (this["canvas"] === true)
        {
            this.canvasText = (typeof document.createElement("canvas").getContext("2d").fillText === "function");
            var canvasCtx = document.createElement("canvas").getContext("2d");
            canvasCtx.rect(0, 0, 10, 10);
            canvasCtx.rect(2, 2, 6, 6);
            this.canvasWinding = (canvasCtx.isPointInPath(5, 5, "evenodd") === false);
        }

        try
        {
            this.localStorage = (typeof window.localStorage === "object" && typeof window.localStorage.getItem === "function");
        }
        catch (error)
        {
            this.localStorage = false;
        }

        this.mediaSource = (typeof window.MediaSource === "function");

        this.encryptedMedia = (typeof window.HTMLMediaElement === "function" && typeof window.MediaKeys === "function" && typeof window.MediaKeySystemAccess === "function" && typeof navigator.requestMediaKeySystemAccess === "function");

        this.applicationCache = (typeof window.applicationCache === "object");

        this.addEventListener = (typeof window.addEventListener === "function");

        this["raf"] = (typeof window.requestAnimationFrame === "function" || typeof window.webkitRequestAnimationFrame === "function" || typeof window.mozRequestAnimationFrame === "function");

        try
        {
            var canvas = document.createElement("canvas");
            /* Force screencanvas to false */
            canvas.screencanvas = false;
            this.webGL = (typeof canvas.getContext === "function" && typeof window.WebGLRenderingContext !== "undefined" && Boolean(canvas.getContext("webgl") || canvas.getContext("experimental-webgl")));
        }
        catch (e)
        {
            this.webGL = false;
        }

        if (typeof navigator.getVRDisplays === "function")
        {
            this.webVR = true;
        }
        else
        {
            this.webVR = false;
        }

        this.JSON = (typeof window.JSON === "object" && typeof window.JSON.parse === "function" && typeof window.JSON.stringify === "function");

        this.geolocation = (typeof navigator.geolocation === "object");

        this["history"] = (typeof window["history"] === "object" && typeof window["history"].pushState === "function");

        this.svg = (typeof document.createElementNS === "function" && typeof document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect === "function");

        this.contextMenu = (typeof document.documentElement.contextMenu !== "undefined" && typeof window.HTMLMenuItemElement === "function");
    };

    /**
     * Check the URL environment.
     * @method KEN.Device#_checkEnvironment
     * @private
     */
    Tmp.prototype._checkEnvironment = function()
    {
        this.isSecure = /^https/i.test(window.location["protocol"]);

        try
        {
            this.isIframe = (window.self !== window["top"]);
        }
        catch (e)
        {
            this.isIframe = true;
        }
    };

    /**
     * Check the various inputs.
     * @method KEN.Device#_checkInput
     * @private
     */
    Tmp.prototype._checkInput = function()
    {
        this.touch = (typeof window.ontouchstart !== "undefined" || typeof window.DocumentTouch !== "undefined" && document instanceof window.DocumentTouch || (typeof navigator.maxTouchPoints === "number" && navigator.maxTouchPoints > 0) || (typeof navigator.msMaxTouchPoints === "number" && navigator.msMaxTouchPoints > 0));

        // Test for Safari iOS touch force feature
        if (typeof window.onmouseforcewillbegin !== "undefined" || typeof window.onwebkitmouseforcewillbegin !== "undefined")
        {
            // Test if the browser provides thresholds defining a "force touch" from a normal touch/click event
            this.touchForce = Boolean(MouseEvent.WEBKIT_FORCE_AT_MOUSE_DOWN && MouseEvent.WEBKIT_FORCE_AT_FORCE_MOUSE_DOWN);
        }

        this.gamepad = (typeof navigator.getGamepads === "function" || typeof navigator.webkitGetGamepads === "function");
    };

    /**
     * Check the support of the full screen API.
     * @method KEN.Device#_checkFullscreenSupport
     * @private
     */
    Tmp.prototype._checkFullscreenSupport = function()
    {
        var requestFullscreen =
            [
                "requestFullscreen",
                "requestFullScreen",
                "webkitRequestFullscreen",
                "webkitRequestFullScreen",
                "mozRequestFullScreen",
                "mozRequestFullscreen",
                "msRequestFullscreen",
                "msRequestFullScreen"
            ];
        var exitFullscreen =
            [
                "cancelFullscreen",
                "cancelFullScreen",
                "exitFullscreen",
                "exitFullScreen",
                "webkitCancelFullscreen",
                "webkitCancelFullScreen",
                "webkitExitFullscreen",
                "webkitExitFullScreen",
                "mozCancelFullscreen",
                "mozCancelFullScreen",
                "mozExitFullscreen",
                "mozExitFullScreen",
                "msCancelFullscreen",
                "msCancelFullScreen",
                "msExitFullscreen",
                "msExitFullScreen"
            ];

        var element = document.createElement("div");

        for (var i = 0, ii = requestFullscreen.length; i < ii; i++)
        {
            if (element[requestFullscreen[i]])
            {
                this.requestFullscreen = requestFullscreen[i];
                break;
            }
        }
        for (var j = 0, jj = exitFullscreen.length; j < jj; j++)
        {
            if (document[exitFullscreen[j]])
            {
                this.exitFullscreen = exitFullscreen[j];
                break;
            }
        }

        // Keyboard Input on full screen mode?
        if (typeof window.Element === "function" && Element.ALLOW_KEYBOARD_INPUT)
        {
            this.fullscreenKeyboard = true;
        }

        var fullscreenElement =
            [
                "fullscreenElement",
                "mozFullScreenElement",
                "webkitFullscreenElement",
                "msFullscreenElement"
            ];

        for (var k = 0, kk = fullscreenElement.length; k < kk; k++)
        {
            if (typeof document[fullscreenElement[k]] !== "undefined")
            {
                this.fullscreenElement = fullscreenElement[k];
                break;
            }
        }

        var fullscreenEnabled =
            [
                "fullscreenEnabled",
                "mozFullScreenEnabled",
                "webkitFullscreenEnabled",
                "msFullscreenEnabled"
            ];

        for (var l = 0, ll = fullscreenEnabled.length; l < ll; l++)
        {
            if (typeof document[fullscreenEnabled[l]] !== "undefined")
            {
                this.fullscreenEnabled = fullscreenEnabled[l];
                break;
            }
        }
    };

    /**
     * Check browser APIs.
     * @method KEN.Device#_checkBrowserApi
     * @private
     */
    Tmp.prototype._checkBrowserApi = function()
    {
        //Page Visibility API
        var visibilityChange =
            [
                "visibilitychange",
                "mozvisibilitychange",
                "webkitvisibilitychange",
                "msvisibilitychange"
            ];
        var visibilityState =
            [
                "hidden",
                "mozHidden",
                "webkitHidden",
                "msHidden"
            ];
        for (var m = 0, mm = visibilityState.length; m < mm; m++)
        {
            if (typeof document[visibilityState[m]] !== "undefined")
            {
                this.visibilityState = visibilityState[m];
                this.visibilityChange = visibilityChange[m];
                break;
            }
        }

        //Screen orientation API
        var orientation =
            [
                "orientation",
                "mozOrientation",
                "msOrientation"
            ];
        for (var i = 0, ii = orientation.length; i < ii; i++)
        {
            if (typeof screen[orientation[i]] === "string")
            {
                this.orientation = orientation[i];
                break;
            }
        }

        this.screenOrientation = (typeof screen.orientation === "object" && typeof screen.orientation["type"] === "string" && typeof screen.orientation.lock === "function");

        var lockOrientation =
            [
                "lockOrientation",
                "mozLockOrientation",
                "msLockOrientation"
            ];
        var unlockOrientation =
            [
                "unlockOrientation",
                "mozUnlockOrientation",
                "msUnlockOrientation"
            ];
        for (var j = 0, jj = lockOrientation.length; j < jj; j++)
        {
            if (typeof screen[lockOrientation[j]] === "function")
            {
                this.lockOrientation = lockOrientation[j];
                this.unlockOrientation = unlockOrientation[j];
                break;
            }
        }

        //File API
        this.file = (typeof window.File !== "undefined" && typeof window.FileReader !== "undefined" && typeof window.FileList !== "undefined" && typeof window.Blob !== "undefined");
        this.fileSystem = (typeof window.requestFileSystem !== "undefined" || typeof window.webkitRequestFileSystem !== "undefined");

        //Pointer Lock API
        this.pointerLock = (typeof document.pointerLockElement !== "undefined" || typeof document.mozPointerLockElement !== "undefined" || typeof document.webkitPointerLockElement !== "undefined");
    };

    /**
     * Check CSS rules.
     * @method KEN.Device#_checkCss
     * @private
     */
    Tmp.prototype._checkCss = function()
    {
        // pointer events
        var cssStyle = document.createElement("a").style;
        cssStyle.cssText = "pointer-events:auto";
        this.cssPointerEvents = (cssStyle.pointerEvents === "auto");

        // rgba
        cssStyle.cssText = "background-color:rgba(150,255,150,.5)";
        this.cssRgba = (("" + cssStyle.backgroundColor).indexOf("rgba") > -1);

        this.cssAnimation = (typeof cssStyle.animationName !== "undefined" || typeof cssStyle.webkitAnimationName !== "undefined" || typeof cssStyle.mozAnimationName !== "undefined" || typeof cssStyle.msAnimationName !== "undefined");

        // css transform and css3D check
        var el = document.createElement("p");
        var has3d;
        var transforms = {
            "webkitTransform": "-webkit-transform",
            "OTransform": "-o-transform",
            "msTransform": "-ms-transform",
            "MozTransform": "-moz-transform",
            "transform": "transform"
        };

        // Add it to the body to get the computed style.
        document.body.insertBefore(el, null);
        for (var t in transforms)
        {
            if (typeof el.style[t] !== "undefined")
            {
                el.style[t] = "translate3d(1px,1px,1px)";
                has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]);
            }
        }
        document.body.removeChild(el);
        this.css3D = (typeof has3d !== "undefined" && has3d.length > 0 && has3d !== "none");
    };

    /**
     * Internal handler for Device Motion.
     * @method KEN.Device#_deviceMotionHandler
     * @param {Event} event DeviceMotionEvent
     * @private
     */
    Tmp.prototype._deviceMotionHandler = function(event)
    {

        if (event.rotationRate !== null && typeof event.rotationRate["alpha"] !== "undefined" && typeof event.rotationRate.beta !== "undefined" && typeof event.rotationRate.gamma !== "undefined")
        {
            this.deviceMotionRotationRate = true;
        }
        if (typeof event.acceleration !== "undefined" && typeof event.acceleration.x !== "undefined" && typeof event.acceleration.y !== "undefined" && typeof event.acceleration.z !== "undefined")
        {
            this.deviceMotionAcceleration = true;
        }

        this._removeDeviceMotionHandler();

        if (typeof this._deviceOrientationBind !== "function")
        {
            this._checkComplete();
        }
    };

    /**
     * Internal handler for Device Orientation.
     * @method KEN.Device#_deviceOrientationHandler
     * @param {Event} event DeviceOrientationEvent
     * @private
     */
    Tmp.prototype._deviceOrientationHandler = function(event)
    {
        if (typeof event["alpha"] !== "undefined" && typeof event.beta !== "undefined" && typeof event.gamma !== "undefined")
        {
            this.deviceOrientationMagnetometer = true;
        }

        this._removeDeviceOrientationHandler();

        if (typeof this._deviceMotionBind !== "function")
        {
            this._checkComplete();
        }
    };

    /**
     * Remove the device motion handler.
     * @method KEN.Device#_removeDeviceMotionHandler
     * @private
     */
    Tmp.prototype._removeDeviceMotionHandler = function()
    {
        window.removeEventListener("devicemotion", this._deviceMotionBind, false);
        this._deviceMotionBind = null;
    };

    /**
     * Remove the device orientation handler.
     * @method KEN.Device#_removeDeviceOrientationHandler
     * @private
     */
    Tmp.prototype._removeDeviceOrientationHandler = function()
    {
        window.removeEventListener("deviceorientation", this._deviceOrientationBind, false);
        this._deviceOrientationBind = null;
    };

    /**
     * Check the gyroscope support.
     * @method KEN.Device#_checkGyroscope
     * @private
     */
    Tmp.prototype._checkGyroscope = function()
    {
        this.deviceMotion = (typeof window.DeviceMotionEvent !== "undefined");
        this.deviceOrientation = (typeof window.DeviceOrientationEvent !== "undefined");

        window.addEventListener("deviceorientation", this._deviceOrientationBind, false);
        window.addEventListener("devicemotion", this._deviceMotionBind, false);
    };

    /**
     * Check the screen properties
     * @method KEN.Device#_checkScreen
     * @private
     */
    Tmp.prototype._checkScreen = function()
    {
        var div = document.createElement("div");
        div.style["width"] = "1in";
        div.style["height"] = "1in";
        document.body.appendChild(div);

        this.dpi = div.offsetWidth;

        document.body.removeChild(div);
        div = null;

        if (this.mobile)
        {
            this.screenWidth = Math.floor(Math.min(window.screen["width"], window.screen["height"]) * this.pixelRatio);
            this.screenHeight = Math.floor(Math.max(window.screen["width"], window.screen["height"]) * this.pixelRatio);
        }
        else
        {
            this.screenWidth = Math.floor(Math.max(window.screen["width"], window.screen["height"]) * this.pixelRatio);
            this.screenHeight = Math.floor(Math.min(window.screen["width"], window.screen["height"]) * this.pixelRatio);
        }
    };

    /**
     * Run the checks.
     * @method KEN.Device#_check
     * @private
     */
    Tmp.prototype._check = function()
    {
        this.ua = navigator["userAgent"];

        this.language = ((navigator.languages && navigator.languages[0]) || navigator.language || navigator.userLanguage || "");

        this._checkOS();
        this._checkBrowsers();
        this._checkDevice();
        this._checkAudio();
        this._checkVideo();
        this._checkDeviceFeatures();
        this._checkFeatures();
        this._checkEnvironment();
        this._checkBrowserApi();
        this._checkFullscreenSupport();
        this._checkInput();
        this._checkCss();

        // bind device motion and device orientation events
        this._deviceMotionBind = this._deviceMotionHandler.bind(this);
        this._deviceOrientationBind = this._deviceOrientationHandler.bind(this);
        this._checkGyroscope();
        this._checkScreen();

        //lock Device object
        if (this.deviceMotion === false && this.deviceOrientation === false)
        {
            this._checkComplete();
        }
    };

    /**
     * Finalize and set as singleton the Device object.
     * @method KEN.Device#_checkComplete
     * @private
     */
    Tmp.prototype._checkComplete = function()
    {
        if (typeof this._deviceMotionBind === "function")
        {
            this._removeDeviceMotionHandler();
        }
        if (typeof this._deviceOrientationBind === "function")
        {
            this._removeDeviceOrientationHandler();
        }

        if (this.deviceMotionRotationRate === true && this.deviceMotionAcceleration === true && this.deviceOrientationMagnetometer === true)
        {
            this.gyroscope = true;
        }

        this["ready"] = true;

        Object.freeze(KEN.Device);
    };

    /**
     * Check if the device can play audio.
     * @method KEN.Device#canPlayAudio
     * @param {string} type - One of 'mp3, 'ogg', 'm4a', 'wav', 'webm'.
     * @return {boolean}
     */
    Tmp.prototype.canPlayAudio = function(type)
    {
        if (type === "mp3" && this.mp3 === true)
        {
            return true;
        }
        else if (type === "ogg" && (this.ogg === true || this.opus === true))
        {
            return true;
        }
        else if (type === "m4a" && this.m4a === true)
        {
            return true;
        }
        else if (type === "mp4" && this.mp4 === true)
        {
            return true;
        }
        else if (type === "opus" && this.opus === true)
        {
            return true;
        }
        else if (type === "wav" && this.wav === true)
        {
            return true;
        }
        else if (type === "aac" && this.aac === true)
        {
            return true;
        }
        else if (type === "webm" && this.webm === true)
        {
            return true;
        }
        else if (type === "weba" && this.weba === true)
        {
            return true;
        }

        return false;
    };

    /**
     * Check If the device can play video files.
     * @method KEN.Device#canPlayVideo
     * @param {string} type - One of 'mp4, 'ogg', 'webm' or 'mpeg'.
     * @return {boolean}
     */
    Tmp.prototype.canPlayVideo = function(type)
    {
        if (type === "webm" && (this.webmVideo === true || this.vp9Video === true))
        {
            return true;
        }
        else if (type === "mp4" && (this.mp4Video === true || this.h264Video === true))
        {
            return true;
        }
        else if ((type === "ogg" || type === "ogv") && this.oggVideo === true)
        {
            return true;
        }
        else if (type === "mpeg" && this.hlsVideo === true)
        {
            return true;
        }

        return false;
    };

    /**
     * Check If the battery is low.<br>
     * Note "low" is defined as less than 20%.
     * @method KEN.Device#isLowBattery
     * @return {Promise<boolean>}
     */
    Tmp.prototype.isLowBattery = function()
    {
        var minLevel = 0.20, self = this;

        return navigator.getBattery()
            .then(function(battery)
            {
                return self.battery && !battery.charging && battery.level <= minLevel;
            }, function()
            {
                return false;
            });
    };

    return new Tmp();

})(function()
{
    return function()
    {
        /**
         * Is device detection done?
         * @name KEN.Device#ready
         * @type {boolean}
         */
        this["ready"] = false;

        /**
         * The user agent string.
         * @name KEN.Device#ua
         * @type {string}
         */
        this.ua = "";

        /**
         * The browser language.
         * @name KEN.Device#language
         * @type {string}
         */
        this.language = "";

        //OS

        /**
         * The OS name
         * @name KEN.Device#os
         * @type {string}
         */
        this.os = "";

        /**
         * The OS major version number.
         * @name KEN.Device#osVersion
         * @type {number}
         */
        this.osVersion = 0;

        /**
         * Is running on PS Vita?
         * @name KEN.Device#vita
         * @type {boolean}
         */
        this.vita = false;

        /**
         * Is running on XBox?
         * @name KEN.Device#xbox
         * @type {boolean}
         */
        this.xbox = false;

        /**
         * Is running on Kindle?
         * @name KEN.Device#kindle
         * @type {boolean}
         */
        this.kindle = false;

        /**
         * Is running on android?
         * @name KEN.Device#android
         * @type {boolean}
         */
        this.android = false;

        /**
         * Is running on chromeOS?
         * @name KEN.Device#chromeOS
         * @type {boolean}
         */
        this.chromeOS = false;

        /**
         * Is running on iOS?
         * @name KEN.Device#iOS
         * @type {boolean}
         */
        this.iOS = false;

        /**
         * Is running on Linux?
         * @name KEN.Device#linux
         * @type {boolean}
         */
        this.linux = false;

        /**
         * Is running on MacOS?
         * @name KEN.Device#macOS
         * @type {boolean}
         */
        this.macOS = false;

        /**
         * Is running on Windows?
         * @name KEN.Device#windows
         * @type {boolean}
         */
        this.windows = false;

        /**
         * Is running on Windows Phone?
         * @name KEN.Device#windowsPhone
         * @type {boolean}
         */
        this.windowsPhone = false;

        // Browsers

        /**
         * Is running in Firefox?
         * @name KEN.Device#firefox
         * @type {boolean}
         */
        this.firefox = false;

        /**
         * Firefox major version number.
         * @name KEN.Device#firefoxVersion
         * @type {number}
         */
        this.firefoxVersion = 0;

        /**
         * Is running in Chrome?
         * @name KEN.Device#chrome
         * @type {boolean}
         */
        this.chrome = false;

        /**
         * Chrome major version number.
         * @name KEN.Device#chromeVersion
         * @type {number}
         */
        this.chromeVersion = 0;

        /**
         * Is running in Internet Explorer?
         * @name KEN.Device#ie
         * @type {boolean}
         */
        this.ie = false;

        /**
         * Internet Explorer major version number.
         * @name KEN.Device#ieVersion
         * @type {number}
         */
        this.ieVersion = 0;

        /**
         * Is running in Opera?
         * @name KEN.Device#opera
         * @type {boolean}
         */
        this.opera = false;

        /**
         * Opera major version number.
         * @name KEN.Device#operaVersion
         * @type {number}
         */
        this.operaVersion = 0;

        /**
         * Is running in Edge?
         * @name KEN.Device#edge
         * @type {boolean}
         */
        this.edge = false;

        /**
         * Edge major version number.
         * @name KEN.Device#edgeVersion
         * @type {number}
         */
        this.edgeVersion = 0;

        /**
         * Is running in Safari?
         * @name KEN.Device#safari
         * @type {boolean}
         */
        this.safari = false;

        /**
         * Safari (or Mobile Safari) major version number.
         * @name KEN.Device#safariVersion
         * @type {number}
         */
        this.safariVersion = 0;

        /**
         * Is running in Silk (Kindle)?
         * @name KEN.Device#silk
         * @type {boolean}
         */
        this.silk = false;

        /**
         * The nick name of the browser.
         * @name KEN.Device#browser
         * @type {string}
         */
        this.browser = "";

        /**
         * The browser major version.
         * @name KEN.Device#browserVersion
         * @type {number}
         */
        this.browserVersion = 0;

        /**
         * Is running in a standalone app?
         * @name KEN.Device#webApp
         * @type {boolean}
         */
        this.webApp = false;

        /**
         * Detect if it's an Android Stock browser.
         * @name KEN.Device#isAndroidStockBrowser
         * @type {boolean}
         */
        this.isAndroidStockBrowser = false;

        /**
         * The Android version linked to the stock browser.
         * @name KEN.Device#androidStockBrowserVersion
         * @type {number}
         */
        this.androidStockBrowserVersion = 0;

        /**
         * Is the browser running in strict mode or quirks mode?
         * @name KEN.Device#quirksMode
         * @type {boolean}
         */
        this.quirksMode = false;

        // Capabilities

        /**
         * Does the browser support full screen API?
         * @name KEN.Device#fullscreenEnabled
         * @type {string}
         */
        this.fullscreenEnabled = "";

        /**
         * Request full screen method name.
         * @name KEN.Device#requestFullscreen
         * @type {string}
         */
        this.requestFullscreen = "";

        /**
         * Exit full screen method name.
         * @name KEN.Device#exitFullscreen
         * @type {string}
         */
        this.exitFullscreen = "";

        /**
         * fullscreenElement accessor name.
         * @name  KEN.Device#fullscreenElement
         * @type {string}
         */
        this.fullscreenElement = "";

        /**
         * Does the browser support keyboard during full screen mode?
         * @name KEN.Device#fullscreenKeyboard
         * @type {boolean}
         */
        this.fullscreenKeyboard = false;

        // Device

        /**
         * Is running on iPhone?
         * @name KEN.Device#iPhone
         * @type {boolean}
         */
        this.iPhone = false;

        /**
         * Is running on Apple Retina display?
         * @name KEN.Device#retina
         * @type {boolean}
         */
        this.retina = false;

        /**
         * Is running on iPod?
         * @name KEN.Device#iPod
         * @type {boolean}
         */
        this.iPod = false;

        /**
         * Is running on iPad?
         * @name KEN.Device#iPad
         * @type {boolean}
         */
        this.iPad = false;

        /**
         * Pixel ratio of the device.
         * @name KEN.Device#pixelRatio
         * @type {number}
         */
        this.pixelRatio = 1;

        /**
         * Does the device support the Vibration API?
         * @name KEN.Device#vibrate
         * @type {boolean}
         */
        this.vibrate = false;

        /**
         * Is the Battery API available?
         * @name KEN.Device#battery
         * @type {boolean}
         */
        this.battery = false;

        /**
         * Is running on a desktop?
         * @name KEN.Device#desktop
         * @type {boolean}
         */
        this.desktop = false;

        /**
         * Is running on a tablet?
         * @name KEN.Device#tablet
         * @type {boolean}
         */
        this.tablet = false;

        /**
         * Is running on a mobile?
         * @name KEN.Device#mobile
         * @type {boolean}
         */
        this.mobile = false;

        /**
         * Is running on a other device as smartTv...?
         * @name KEN.Device#other
         * @type {boolean}
         */
        this.other = false;

        // Inputs

        /**
         * Is Touch API available?
         * @name KEN.Device#touch
         * @type {boolean}
         */
        this.touch = false;

        /**
         * Is Gamepad API available?
         * @name KEN.Device#gamepad
         * @type {boolean}
         */
        this.gamepad = false;

        /**
         * Are Force Touch Events supported?
         * Force Touch events are available in OS X 10.11 and later on devices equipped with Force Touch trackpads.
         * @name KEN.Device#touchForce
         * @type {boolean}
         */
        this.touchForce = false;

        // Audio

        /**
         * Are Audio tags available?
         * @name KEN.Device#audioTag
         * @type {boolean}
         */
        this.audioTag = false;

        /**
         * Is the WebAudio API available?
         * @name KEN.Device#webAudio
         * @type {boolean}
         */
        this.webAudio = false;

        /**
         * Can play ogg files?
         * @name KEN.Device#ogg
         * @type {boolean}
         */
        this.ogg = false;

        /**
         * Can play mp3 files?
         * @name KEN.Device#mp3
         * @type {boolean}
         */
        this.mp3 = false;

        /**
         * Can play opus files?
         * @name KEN.Device#opus
         * @type {boolean}
         */
        this.opus = false;

        /**
         * Can play wav files?
         * @name KEN.Device#wav
         * @type {boolean}
         */
        this.wav = false;

        /**
         * Can play m4a files?
         * @name KEN.Device#m4a
         * @type {boolean}
         */
        this.m4a = false;

        /**
         * Can play mp4 files?
         * @name KEN.Device#mp4
         * @type {boolean}
         */
        this.mp4 = false;

        /**
         * Can play aac files?
         * @name KEN.Device#aac
         * @type {boolean}
         */
        this.aac = false;

        /**
         * Can play webm files?
         * @name KEN.Device#webm
         * @type {boolean}
         */
        this.webm = false;

        /**
         * Can play weba files?
         * @name KEN.Device#weba
         * @type {boolean}
         */
        this.weba = false;

        // Video

        /**
         * Can play ogg video files?
         * @name KEN.Device#oggVideo
         * @type {boolean}
         */
        this.oggVideo = false;

        /**
         * Can play h264 video files?
         * @name KEN.Device#h264Video
         * @type {boolean}
         */
        this.h264Video = false;

        /**
         * Can play mp4 video files?
         * @name KEN.Device#mp4Video
         * @type {boolean}
         */
        this.mp4Video = false;

        /**
         * Can play webm video files?
         * @name KEN.Device#webmVideo
         * @type {boolean}
         */
        this.webmVideo = false;

        /**
         * Can play vp9 video files?
         * @name KEN.Device#vp9Video
         * @type {boolean}
         */
        this.vp9Video = false;

        /**
         * Can play hls video files?
         * @name KEN.Device#hlsVideo
         * @type {boolean}
         */
        this.hlsVideo = false;

        // Features

        /**
         * Is canvas available?
         * @name KEN.Device#canvas
         * @type {boolean}
         */
        this["canvas"] = false;

        /**
         * Are winding rules for '<canvas>' (go clockwise or counterclockwise) available?
         * @name KEN.Device#canvasWinding
         * @type {boolean}
         */
        this.canvasWinding = false;

        /**
         * Is text API for canvas available?
         * @name KEN.Device#canvasText
         * @type {boolean}
         */
        this.canvasText = false;

        /**
         * Is native support of addEventListener available?
         * @name KEN.Device#addEventListener
         * @type {boolean}
         */
        this.addEventListener = false;

        /**
         * Is requestAnimationFrame API supported?
         * @name KEN.Device#raf
         * @type {boolean}
         */
        this["raf"] = false;

        /**
         * Is webGL available?
         * @name KEN.Device#webGL
         * @type {boolean}
         */
        this.webGL = false;

        /**
         * Is WebVR available?
         * @name KEN.Device#webVR
         * @type {boolean}
         */
        this.webVR = false;

        /**
         * Is file available?
         * @name KEN.Device#file
         * @type {boolean}
         */
        this.file = false;

        /**
         * Is fileSystem available?
         * @name KEN.Device#fileSystem
         * @type {boolean}
         */
        this.fileSystem = false;

        /**
         * Is localStorage available?
         * @name KEN.Device#localStorage
         * @type {boolean}
         */
        this.localStorage = false;

        /**
         * Is Application Cache supported to enable web-based applications run offline?
         * @name KEN.Device#applicationCache
         * @type {boolean}
         */
        this.applicationCache = false;

        /**
         * Is Geolocation API available?
         * @name KEN.Device#geolocation
         * @type {boolean}
         */
        this.geolocation = false;

        /**
         * Is pointerLock available?
         * @name KEN.Device#pointerLock
         * @type {boolean}
         */
        this.pointerLock = false;

        /**
         * Is context menu available?
         * @name KEN.Device#contextMenu
         * @type {boolean}
         */
        this.contextMenu = false;

        /**
         * Is Media Source Extensions API available?
         * @name  KEN.Device#mediaSource
         * @type {boolean}
         */
        this.mediaSource = false;

        /**
         * Is Encrypted Media Extensions API available?
         * @name  KEN.Device#encryptedMedia
         * @type {boolean}
         */
        this.encryptedMedia = false;

        /**
         * Is JSON native support available?
         * @name KEN.Device#JSON
         * @type {boolean}
         */
        this.JSON = false;

        /**
         * Is History API available?
         * @name KEN.Device#history
         * @type {boolean}
         */
        this["history"] = false;

        /**
         * Is SVG in '<embed>' or '<object>' supported?
         * @name KEN.Device#svg
         * @type {boolean}
         */
        this.svg = false;

        /**
         * Is the current page in secure mode?
         * @name KEN.Device#isSecure
         * @type {boolean}
         */
        this.isSecure = false;

        /**
         * Is the current page is into an Iframe ?
         * @name KEN.Device#isIframe
         * @type {boolean}
         */
        this.isIframe = false;

        /**
         * Hidden state name for the PageVisibility API.
         * @name KEN.Device#visibilityState
         * @type {string}
         */
        this.visibilityState = "";

        /**
         * Visibility change event name for the PageVisibility API.
         * @name KEN.Device#visibilityChange
         * @type {string}
         */
        this.visibilityChange = "";

        // CSS

        /**
         * Is css3D available?
         * @name KEN.Device#css3D
         * @type {boolean}
         */
        this.css3D = false;

        /**
         * Is rgba (alpha) available?
         * @name KEN.Device#cssRgba
         * @type {boolean}
         */
        this.cssRgba = false;

        /**
         * Is pointer-events available?
         * @name KEN.Device#cssPointerEvents
         * @type {boolean}
         */
        this.cssPointerEvents = false;

        /**
         * Are css animations (keyframes) supported?
         * @name KEN.Device#cssAnimation
         * @type {boolean}
         */
        this.cssAnimation = false;

        // Gyroscope

        /**
         * Device has a real gyroscope?
         * @name KEN.Device#gyroscope
         * @type {boolean}
         */
        this.gyroscope = false;

        /**
         * Is Device Motion Event supported? (Accelerometer)
         * @name KEN.Device#deviceMotion
         * @type {boolean}
         */
        this.deviceMotion = false;

        /**
         * Is Device Orientation Event supported? (Magnetometer)
         * @name KEN.Device#deviceOrientation
         * @type {boolean}
         */
        this.deviceOrientation = false;

        /**
         * Is Device Motion acceleration supported?
         * @name KEN.Device#deviceMotionAcceleration
         * @type {boolean}
         */
        this.deviceMotionAcceleration = false;

        /**
         * Is Device Motion rotation supported?
         * @name KEN.Device#deviceMotionRotationRate
         * @type {boolean}
         */
        this.deviceMotionRotationRate = false;

        /**
         * Is Device Orientation motion supported?
         * @name KEN.Device#deviceOrientationMagnetometer
         * @type {boolean}
         */
        this.deviceOrientationMagnetometer = false;

        /**
         * This is a copy of device motion handler with this as this reference (bind).
         * @name  KEN.System#_deviceMotionBind
         * @type {Function}
         * @default  null
         * @private
         */
        this._deviceMotionBind = null;

        /**
         * This is a copy of device orientation handler with this as this reference (bind).
         * @name  KEN.System#_deviceOrientationBind
         * @type {Function}
         * @default  null
         * @private
         */
        this._deviceOrientationBind = null;

        /**
         * Pixel density of the screen.
         * @name  KEN.Device#dpi
         * @type {number}
         */
        this.dpi = 0;

        /**
         * Device screen width in pixels.
         * @name  KEN.Device#screenWidth
         * @type {number}
         */
        this.screenWidth = 0;

        /**
         * Device screen height in pixels.
         * @name  KEN.Device#screenHeight
         * @type {number}
         */
        this.screenHeight = 0;

        /**
         * Is screen orienation API available?
         * @name  KEN.Device#screenOrientation
         * @type {boolean}
         */
        this.screenOrientation = false;

        /**
         * Screen orientation object name.
         * @name KEN.Device#orientation
         * @type {string}
         */
        this.orientation = "";

        /**
         * Lock screen orientation method name.
         * @name KEN.Device#lockOrientation
         * @type {string}
         */
        this.lockOrientation = "";

        /**
         * Unlock screen orientation method name.
         * @name KEN.Device#unlockOrientation
         * @type {string}
         */
        this.unlockOrientation = "";

        this._check();
    };
});


/**
 * Handle the main loop, choose between a requestAnimationFrame (RAF) or a setTimeout method.
 * @constructor KEN.RequestAnimationFrame
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 */
KEN.RequestAnimationFrame = function(viewer)
{
    /**
     * The viewer reference.
     * @name KEN.RequestAnimationFrame#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The timer reference.
     * @name KEN.RequestAnimationFrame#_timeOutId
     * @type {Object}
     * @private
     */
    this._timeOutId = null;

    /**
     * Is the current timer out?
     * @name KEN.RequestAnimationFrame#_isSetTimeOut
     * @type {boolean}
     * @private
     */
    this._isSetTimeOut = false;

    /**
     * The function to call on each loop.
     * @name KEN.RequestAnimationFrame#_onLoop
     * @type {?function(?number)}
     * @private
     */
    this._onLoop = null;

    /**
     * Is RAF running?
     * @name KEN.RequestAnimationFrame#_running
     * @type {boolean}
     * @private
     */
    this._running = false;

    /**
     * The number of loops.
     * @name KEN.RequestAnimationFrame#_called
     * @type {number}
     * @private
     */
    this._called = 0;

    /**
     * Request animation frame owner
     * @type {Object}
     * @private
     */
    this._owner = null;
};

KEN.RequestAnimationFrame.prototype.constructor = KEN.RequestAnimationFrame;

/**
 * Boot sequence.
 * @method KEN.RequestAnimationFrame#boot
 */
KEN.RequestAnimationFrame.prototype.boot = function()
{
    var vendors =
    [
        "ms",
        "moz",
        "webkit",
        "o"
    ];

    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++)
    {
        window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
        window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"];
    }

    this._owner = window;
};

/**
 * Start the RAF.
 * @method KEN.RequestAnimationFrame#start
 * @param {(Window|VRDisplay)=} owner request animation frame owner: window (default) or VRDisplay instance
 * @suppress {checkTypes}
 */
KEN.RequestAnimationFrame.prototype.start = function(owner)
{
    this._owner = (typeof owner !== "undefined" && (owner === window || owner instanceof VRDisplay)) ? owner : window;

    this._running = true;

    var _this = this;

    if (!this._owner.requestAnimationFrame || this._viewer["config"].update === "timeout")
    {
        this._isSetTimeOut = true;

        this._onLoop = function ()
        {
            if(_this._running === true)
            {
                return _this._updateSetTimeout();
            }
            return;
        };

        this._timeOutID = window.setTimeout(this._onLoop, 0);
    }
    else
    {
        this._isSetTimeOut = false;

        this._onLoop = function (time)
        {
            if(_this._running === true)
            {
                return _this._updateRAF(time);
            }
            return;
        };

        this._timeOutID = this._owner.requestAnimationFrame(this._onLoop);
    }
};

/**
 * Stop the RAF.
 * @method KEN.RequestAnimationFrame#stop
 */
KEN.RequestAnimationFrame.prototype.stop = function()
{
    if (this._isSetTimeOut)
    {
        clearTimeout(this._timeOutID);
    }
    else
    {
        this._owner.cancelAnimationFrame(this._timeOutID);
        this._timeOutID = null;
    }

    this._running = false;
};

/**
 * Update the RAF.
 * @method KEN.RequestAnimationFrame#_updateRAF
 * @param {number} time - The current time.
 * @suppress {checkTypes}
 * @private
 */
KEN.RequestAnimationFrame.prototype._updateRAF = function(time)
{
    this._called++;
    this._viewer.update(Math.floor(time));
    this._timeOutID = window.requestAnimationFrame(this._onLoop);
};

/**
 * Update the timer.<br>
 * Timer is based on 30ms.
 * @method KEN.RequestAnimationFrame#_updateSetTimeout
 * @private
 */
KEN.RequestAnimationFrame.prototype._updateSetTimeout = function()
{
    this._called++;
    this._viewer.update(0); //fake time
    this._timeOutID = window.setTimeout(this._onLoop, 1000/30);
};

/**
 * Destroy sequence.
 * @method KEN.RequestAnimationFrame#destroy
 * @suppress {checkTypes}
 */
KEN.RequestAnimationFrame.prototype.destroy = function()
{
    this.stop();
    this._viewer = null;
    this._timeOutId = null;
    this._onLoop = null;
    this._owner = null;
};

/**
 * Get the running flag of the request animation frame module.
 * @name  KEN.RequestAnimationFrame#running
 * @readonly
 * @type {boolean}
 */
KEN.RequestAnimationFrame.prototype.running;
Object.defineProperty(KEN.RequestAnimationFrame.prototype, "running",
{
    /** @this {KEN.RequestAnimationFrame} */
    get: function ()
    {
        return this._running;
    }
});



/**
 * Browser history managment, add slug name of scenes in URL.
 *
 * @constructor KEN.History
 * @param {KEN.Viewer} viewer - The viewer reference.
 * @extends KEN.BaseObject
 */
KEN.History = function(viewer)
{
    /**
    * The viewer reference. 
    * @name KEN.History#_viewer
    * @type {KEN.Viewer}
    * @private
    */
    this._viewer = viewer;

    /**
     * The history module enabled flag.
     * @name  KEN.History#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    KEN.BaseObject.call(this, "History");

    this._boot();
};

KEN.History.prototype = Object.create(KEN.BaseObject.prototype);
KEN.History.prototype.constructor = KEN.History;

/**
 * Boot sequence.
 * @method KEN.History#_boot
 * @private
 */
KEN.History.prototype._boot = function()
{   
    this._enabled = /** @type {boolean} */ (KEN.Utils.getObjectProperty(this._viewer["config"], "history.enabled", true));

    if(this._enabled === true)
    {
        this._viewer["tour"]["onSceneLoadStart"].add(this._sceneLoadStartHandler, this);
        this._viewer["i18n"]["onLocaleChangeComplete"].add(this._localeChangeCompleteHandler, this);
        window.addEventListener("popstate", this._onPopStateHandler, false);
    }
};

/**
 * Internal handler for scene load start.
 * @method KEN.History#_sceneLoadStartHandler
 * @private
 */
KEN.History.prototype._sceneLoadStartHandler = function()
{
    this._addState();
};

/**
 * Internal handler for locale change complete.
 * @method KEN.History#_localeChangeCompleteHandler
 * @private
 */
KEN.History.prototype._localeChangeCompleteHandler = function()
{
    this._updateState();
};

/**
 * Add a state into the history.
 * @method  KEN.History#_addState
 * @private
 */
KEN.History.prototype._addState = function()
{
    this.log("_addState");

    var scene = this._viewer["tour"]["scene"];
        
    var newState = 
    {
        "viewer":
        {
            uid: this._viewer["uid"]
        },

        "scene":
        {
            uid: scene["uid"]
        },

        "locale": this._viewer["i18n"].locale
    };

    var currentState = window["history"].state;

    if(currentState === null)
    {
        window["history"].replaceState(newState, scene["name"], this._generateHash(scene));
    }
    else if(currentState["scene"]["uid"] !== newState["scene"]["uid"])
    {
        window["history"].pushState(newState, scene["name"], this._generateHash(scene));
    }
};

/**
 * Update the current state with the correct slug name.
 * @method KEN.History#_updateState
 * @private
 */
KEN.History.prototype._updateState = function()
{
    this.log("_updateState");

    var currentState = /** @type {Object} */ (window["history"].state);

    if(this._isStateValid(currentState))
    {
        var scene = KEN.UID.get(currentState["scene"]["uid"]);
        currentState["locale"] = this._viewer["i18n"]["locale"];
        window["history"].replaceState(currentState, scene["name"], this._generateHash(/** @type {KEN.Scene} */ (scene)));
    }
};

/**
 * Generate a hash for the curretn scene with the i18n slug name and the scene uid.
 * @param  {KEN.Scene|Object} scene - The scene for which you want to generate a hash.
 * @return {string} The generated hash.
 * @private
 */
KEN.History.prototype._generateHash = function(scene)
{
    return "#"+scene["slug"]+"&uid="+scene["uid"];
};

/**
 * Internal handler for browser pop state event.<br>
 * This event occur when user click on back or next browser buttons.
 * @param  {Event} event - The pop state event.
 * @private
 */
KEN.History.prototype._onPopStateHandler = function(event)
{
    if(event.state === null)
    {
        return;
    }

    var viewer = KEN.UID.get(event.state["viewer"]["uid"]);
    var _this = viewer["history"];

    _this.log("_onPopStateHandler");

    viewer["tour"]["scene"] = event.state["scene"]["uid"];
};

/**
 * Method to check if a state is valid for the history module.
 * @param  {Object}  state - The state to check.
 * @return {boolean} Returns true if the state is valid, false if not.
 * @private
 */
KEN.History.prototype._isStateValid = function(state)
{   
    if(state === null)
    {
        return false;
    }

    var viewerValid = (typeof state["viewer"] !== "undefined" && typeof state["viewer"]["uid"] === "string");
    var sceneValid = (typeof state["scene"] !== "undefined" && typeof state["scene"]["uid"] === "string");

    return (viewerValid === true && sceneValid === true);
};

/**
 * Destroy sequence.
 * @method KEN.History#destroy
 */
KEN.History.prototype.destroy = function()
{
    this._viewer["tour"]["onSceneLoadStart"].remove(this._sceneLoadStartHandler, this);
    this._viewer["i18n"]["onLocaleChangeComplete"].remove(this._localeChangeCompleteHandler, this);
    window.removeEventListener("popstate", this._onPopStateHandler, false);

    this._viewer = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the enbled flag value of the history.
 * @name KEN.History#enabled
 * @readonly
 * @type {boolean}
 */
KEN.History.prototype.enabled;
Object.defineProperty(KEN.History.prototype, "enabled", 
{
    /** @this {KEN.History} */
    get: function()
    {
        return this._enabled;
    }
});


/**
 * KEN.EventDispatcher can dispatch and reference listeners.
 *
 * @constructor KEN.EventDispatcher
 * @param {Object} emitter - The object that wiil be considered as the emitter of the event.
 * @param {boolean=} memorize - Does the dispatcher should memorize the previous dispatcher ?
 * @extends {KEN.BaseObject}
 */
KEN.EventDispatcher = function(emitter, memorize)
{
    /**
     * The emitter reference.
     * @name  KEN.EventDispatcher#_emitter
     * @type {Object}
     * @private
     */
    this._emitter = emitter;

    /**
     * Does the dispatcher should memorize the previous dispatch?<br>
     * If true, will redispatch with the previous data when you add a listener to it.
     * @name  KEN.EventDispatcher#_memorize
     * @type {boolean}
     * @private
     */
    this._memorize = memorize || false;

    /**
     * A backup of previous dispatched data for memorized dispatcher.
     * @name KEN.EventDispatcher#_previousData
     * @type {*}
     * @private
     */
    this._previousData = null;

    /**
     * Array of {@link KEN.Listener}.
     * @name KEN.EventDispatcher#_listeners
     * @type {?Array<KEN.Listener>}
     * @private
     */
    this._listeners = null;

    /**
     * Is this event dipatcher is active?<br>
     * If not, it will ignore all dispatch calls.
     * @name KEN.EventDispatcher#_active
     * @type {boolean}
     * @private
     */
    this._active = true;

    KEN.BaseObject.call(this, "EventDispatcher");
};

KEN.EventDispatcher.prototype = Object.create(KEN.BaseObject.prototype);
KEN.EventDispatcher.prototype.constructor = KEN.EventDispatcher;

/**
 * Create the listeners array an push a new listener into it.
 *
 * @method KEN.EventDispatcher#_addListener
 * @private
 * @param {Function} listener - The listener to add.
 * @param {boolean} isOnce - Is the dispatcher should trigger this listener only one time?
 * @param {Object} context - The context in which the listener will be executed.
 * @param {number=} priority - The priority of the event.
 */
KEN.EventDispatcher.prototype._addListener = function(listener, isOnce, context, priority)
{
    if(typeof listener !== "function")
    {
        this.warn("You're trying to add an undefined listener");
        return;
    }

    if(this.has(listener, context) === true)
    {
        this.warn("You're trying to add a duplicate listener");
        return;
    }

    var lis = new KEN.Listener(this, listener, isOnce, context, priority);

    //register the listener with priority
    this._registerListener(lis);

    if(this._memorize === true && this._active === true && this._previousData !== null)
    {
        lis.execute(this._previousData);
    }

    return listener;
};

/**
 * Internal method to insert the listener into the array according to its priority.
 *
 * @method KEN.EventDispatcher#_registerListener
 * @private
 * @param  {KEN.Listener} listener - The object which handle the listener and it's context.
 */
KEN.EventDispatcher.prototype._registerListener = function(listener)
{
    if(this._listeners === null)
    {
        this._listeners = [];
    }

    if (this._listeners.length === 0)
    {
        this._listeners.push(listener);
        return;
    }

    var n = this._listeners.length;
    do
    {
        n--;
    }
    while(this._listeners[n] && listener._priority <= this._listeners[n]._priority);

    this._listeners.splice(n + 1, 0, listener);
};

/**
 * Internal method to get the index of a couple listener + context.
 *
 * @method KEN.EventDispatcher#_indexOfListener
 * @private
 * @param  {Function} listener - The listener function you need to find its index.
 * @param {Object} context - The context associated to the listener function.
 * @return {number} - The index of the couple listener + context if found, -1 if not.
 */
KEN.EventDispatcher.prototype._indexOfListener = function(listener, context)
{
    if(this._listeners === null)
    {
        return -1;
    }

    if ( typeof context === "undefined" )
    {
        context = null;
    }

    var _listener;

    for ( var i = 0, ii = this._listeners.length; i < ii; i++ )
    {
        _listener = this._listeners[i];

        if(_listener["listener"] === listener && _listener["context"] === context)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Add an event listener function.
 *
 * @method KEN.EventDispatcher#add
 * @param {Function} listener - Event handler callback function.
 * @param {Object} context - The context for the listener call.
 * @param {number=} priority - Priority level for the event to be execute.
 */
KEN.EventDispatcher.prototype.add = function(listener, context, priority)
{
    this._addListener(listener, false, context, priority);
};

/**
 * Add an event listener function that will be triggered only once.
 *
 * @method KEN.EventDispatcher#addOnce
 * @param {Function} listener - Event handler callback function.
 * @param {Object} context - The context for the listener call.
 * @param {number=} priority - Priority level for the event to be execute.
 */
KEN.EventDispatcher.prototype.addOnce = function(listener, context, priority)
{
    this._addListener(listener, true, context, priority);
};

/**
 * Remove a {@link KEN.Listener} from this event dispatcher.
 *
 * @method KEN.EventDispatcher#remove
 * @param  {Function} listener - The listener handler to be removed.
 * @param  {Object} context - The context of the handler to be removed.
 */
KEN.EventDispatcher.prototype.remove = function(listener, context)
{
    var i = this._indexOfListener(listener, context);

    if(i !== -1)
    {
        this._listeners[i].destroy();
        this._listeners.splice(i, 1);
    }
};

/**
 * Check if this event dispatcher has a specific listener.
 *
 * @method KEN.EventDispatcher#has
 * @param  {Function} listener - listener function to check.
 * @param  {Object} context - listener context to check.
 * @return {boolean} Returns true if the dispatcher has the listener, false if not.
 */
KEN.EventDispatcher.prototype.has = function(listener, context)
{
    return this._indexOfListener(listener, context) !== -1;
};

/**
 * Dispatch the event, will trigger all the listeners methods.
 *
 * @method KEN.EventDispatcher#dispatch
 * @param {*=} data - Any object or data you want to associate with the dispatched event.
 * @param {boolean=} async - Does the dispatch need to be async ?
 */
KEN.EventDispatcher.prototype.dispatch = function(data, async)
{
    if(this._memorize === true)
    {
        this._previousData = data === undefined ? null : data;
    }

    if(this._active === false || this._listeners === null)
    {
        return;
    }

    var n = this._listeners.length;

    while(n--)
    {
        this._listeners[n].execute(data, async);
    }

};

/**
 * Destroy method.
 * @method KEN.EventDispatcher#destroy
 */
KEN.EventDispatcher.prototype.destroy = function()
{
    if(this._alive === false)
    {
        return;
    }

    if(this._listeners !== null)
    {
        var n = this._listeners.length;
        while(n--)
        {
            this._listeners[n].destroy();
        }

        this._listeners = null;
    }

    this._emitter = null;
    this._previousData = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
* Get the emitter object associated to this event dispatcher.
* @name KEN.EventDispatcher#emitter
* @readonly
* @type {Object}
*/
KEN.EventDispatcher.prototype.emitter;
Object.defineProperty(KEN.EventDispatcher.prototype, "emitter",
{
    /** @this {KEN.EventDispatcher} */
    get: function()
    {
        return this._emitter;
    }
});

/**
* Get and set the memorize flag associated to this event dispatcher.
* @name KEN.EventDispatcher#memorized
* @type {boolean}
*/
KEN.EventDispatcher.prototype.memorize;
Object.defineProperty(KEN.EventDispatcher.prototype, "memorize",
{
    /** @this {KEN.EventDispatcher} */
    get: function()
    {
        return this._memorize;
    },

    /** @this {KEN.EventDispatcher} */
    set: function(value)
    {
        this._memorize = Boolean(value);
    }
});

/**
* Get and set the active flag associated to this event dispatcher.<br>
* If active is false, this dispatcher will not dispatch any event.
* @name KEN.EventDispatcher#active
* @type {boolean}
*/
KEN.EventDispatcher.prototype.active;
Object.defineProperty(KEN.EventDispatcher.prototype, "active",
{
    /** @this {KEN.EventDispatcher} */
    get: function()
    {
        return this._active;
    },

    /** @this {KEN.EventDispatcher} */
    set: function(value)
    {
        this._active = Boolean(value);
    }
});

/**
 * KEN.Event reference an emitter and eventually some data.
 *
 * @constructor KEN.Event
 * @param {Object} emitter - The object that will be considered as the emitter of the event.
 * @param {Object} data - Any data associated to this event.
 */
KEN.Event = function(emitter, data)
{
    /**
     * The object that will be considered as the emitter of the event.
     * @name KEN.Event#_emitter
     * @type {Object}
     * @private
     */
    this._emitter = emitter;

    /**
     * Any data associated to this event.
     * @name KEN.Event#_data
     * @type {?Object}
     * @private
     */
    this._data = data || null;
};


KEN.Event.prototype.constructor = KEN.Event;

/**
 * Get the event emitter.
 * @name  KEN.Event#emitter
 * @readonly
 * @type {Object}
 */
KEN.Event.prototype.emitter;
Object.defineProperty(KEN.Event.prototype, "emitter",
{
    /** @this {KEN.Event} */
    get: function ()
    {
        return this._emitter;
    }
});

/**
 * Get the data associated to the event.
 * @name  KEN.Event#data
 * @readonly
 * @type {?Object}
 */
KEN.Event.prototype.data;
Object.defineProperty(KEN.Event.prototype, "data",
{
    /** @this {KEN.Event} */
    get: function ()
    {
        return this._data;
    }
});


/**
 * Object that handle listener function and its context.
 *
 * @constructor KEN.Listener
 * @param {Function} listener - The handler function
 * @param {boolean} isOnce - If this listener will trigger only once, then delete itself from its dispatcher.
 * @param {Object} context - The context for listener execution.
 * @param {number=} priority - The priority of the listener.
 */
KEN.Listener = function(dispatcher, listener, isOnce, context, priority)
{
    /**
     * Reference to the {@link KEN.EvenDispatcher} this listener is attached to.
     * @name KEN.Listener#_dispatcher
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._dispatcher = dispatcher;

    /**
     * The callback function that will be triggered when event occurs.
     * @name KEN.Listener#_listener
     * @type {Function}
     * @private
     */
    this._listener = listener;

    /**
     * The context for listener execution.
     * @name KEN.Listener#_context
     * @type {?Object}
     * @private
     */
    this._context = context || null;

    /**
     * If this listener will trigger only once, then delete itself from its dispatcher.
     * @name KEN.Listener#_isOnce
     * @type {boolean}
     * @default false
     * @private
     */
    this._isOnce = isOnce || false;

    /**
     * The priority level of the event listener.<br>
     * Listeners with higher priority will be executed before listeners with lower priority.<br>
     * Listeners with same priority level will be executed at the same order as they were added. (default = 0).
     * @name KEN.Listener#_priority
     * @type {number}
     * @private
     */
    this._priority = priority || 0;

    /**
     * The number of times the listener has been called.
     * @name  KEN.Listener#_callCount
     * @type {number}
     * @private
     */
    this._callCount = 0;

    /**
     * The active state of the listener. Will be executed only if active.
     * @name  KEN.Listener#_active
     * @type {boolean}
     * @private
     */
    this._active = true;

    /**
     * Is the async process is busy?
     * @name  KEN.Listener#_asyncBusy
     * @type {boolean}
     * @private
     */
    this._asyncBusy = false;
};

KEN.Listener.prototype.constructor = KEN.Listener;

KEN.Listener.prototype._execute = function(data)
{
    var event = new KEN.Event(this._dispatcher["emitter"], data);
    this._listener.call(this._context, event);

    this._callCount++;

    if(this._isOnce === true)
    {
        this.detach();
    }

    this._asyncBusy = false; //reset the async busy flag to false in all cases
};

/**
* Call listener passing a data object.<br>
* If listener was added using EventDispatcher.addOnce() it will be automatically removed.
*
* @method KEN.Listener#execute
* @param {*=} data - Data that should be passed to the listener.
* @param {boolean=} async - Execute the listener in async mode (with a setTimeout at 0).
*/
KEN.Listener.prototype.execute = function(data, async)
{
    if(this._active === true && this._listener !== null)
    {
        if(async === true && this._asyncBusy === false)
        {
            this._asyncBusy = true;
            var executeBind = this._execute.bind(this, data);
            window.setTimeout(executeBind, 0);
        }
        else if(async !== true)
        {
            this._execute(data);
        }
    }
};

/**
 * Detach the listener from its event dispatcher.
 * @method KEN.Listener#detach
 */
KEN.Listener.prototype.detach = function()
{
    return this._dispatcher.remove(this._listener, this._context);
};

/**
 * Destroy method.
 * @method KEN.Listener#destroy
 */
KEN.Listener.prototype.destroy = function()
{
    this._dispatcher = null;
    this._listener = null;
    this._context = null;
};

/**
 * Get the listener function.
 * @name KEN.Listener#listener
 * @readonly
 * @type {Function}
 */
KEN.Listener.prototype.listener;
Object.defineProperty(KEN.Listener.prototype, "listener", {

    /** @this {KEN.Listener} */
    get: function ()
    {
        return this._listener;
    }
});

/**
 * Get the context object.
 * @name KEN.Listener#context
 * @readonly
 * @type {Object}
 */
KEN.Listener.prototype.context;
Object.defineProperty(KEN.Listener.prototype, "context", {

    /** @this {KEN.Listener} */
    get: function ()
    {
        return this._context;
    }
});

/**
 * Get the priority number.
 * @name KEN.Listener#priority
 * @readonly
 * @type {number}
 */
KEN.Listener.prototype.priority;
Object.defineProperty(KEN.Listener.prototype, "priority", {

    /** @this {KEN.Listener} */
    get: function ()
    {
        return this._priority;
    }
});

/**
 * Get the call count property value.
 * @name KEN.Listener#callCount
 * @readonly
 * @type {Object}
 */
KEN.Listener.prototype.callCount;
Object.defineProperty(KEN.Listener.prototype, "callCount", {

    /** @this {KEN.Listener} */
    get: function ()
    {
        return this._callCount;
    }
});


/**
 * Manager for the locales.
 *
 * @constructor  KEN.LocaleManager
 * @param {KEN.Viewer} viewer - Reference to the KEN.Viewer.
 * @extends {KEN.BaseObject}
 *
 * @todo Take into account that several configs could be loaded over time
 * @todo Find a behavior for default btw viewer config & tour config & plugins config ... into parse config method
 * @todo Separate load events from request and complete
 * @todo Test to embed HTML with special characters like "" and ''
 */
KEN.LocaleManager = function(viewer)
{
    /**
     * Viewer reference.
     * @name KEN.LocaleManager#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The configuration data for locales.
     * @name KEN.LocaleManager#_config
     * @type {I18nConfig}
     * @private
     */
    this._config = this._viewer["config"]["i18n"];

    /**
     * List of locales.
     * @name KEN.LocaleManager#_locales
     * @type {KEN.Collection}
     * @private
     */
    this._locales = null;

    /**
     * The current locale index.
     * @name KEN.LocaleManager#_localeIndex
     * @type {number}
     * @private
     */
    this._localeIndex = -1;

    /**
     * The default locale index.
     * Set once for all viewer data.
     * @name KEN.LocaleManager#_defaultLocale
     * @type {string}
     * @private
     */
    this._defaultLocale = "";

    /**
     * Auto detect the locale?
     * Set once for all viewer data.
     * @name KEN.LocaleManager#_autoDetect
     * @type {boolean}
     * @private
     */
    this._autoDetect = false;

    /**
     * Is i18n enabled?
     * Set once for all viewer data.
     * @name KEN.LocaleManager#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * On local change event dispatcher.
     * @name  KEN.LocaleManager#_onLocaleChangeRequest
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onLocaleChangeRequest = null;

    /**
     * On local change completed event dispatcher.
     * @name  KEN.LocaleManager#_onLocaleChangeComplete
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onLocaleChangeComplete = null;

    KEN.BaseObject.call(this, "LocaleManager");
};

KEN.LocaleManager.prototype = Object.create(KEN.BaseObject.prototype);
KEN.LocaleManager.prototype.constructor = KEN.LocaleManager;

/**
 * Boot sequence for viewer only.
 * @method KEN.LocaleManager#boot
 */
KEN.LocaleManager.prototype.boot = function()
{
    this.log("KEN.LocaleManager.boot();");

    this._locales = new KEN.Collection();

    this._parseMainConfig(this._config);
};

/**
 * Add i18n configuration data.
 * @method KEN.LocaleManager#addConfig
 * @param {I18nConfig} config - The configuration data.
 * @param {boolean=} force - Internal parameter to force the parse/update of the main i18n config.
 */
KEN.LocaleManager.prototype.addConfig = function(config, force)
{
    this._parseConfig(config, force);
};

/**
 * Parse the main configuration data.
 * @method KEN.LocaleManager#_parseMainConfig
 * @param {I18nConfig} config - The configuration data.
 * @private
 */
KEN.LocaleManager.prototype._parseMainConfig = function(config)
{
    if(typeof config === "undefined")
    {
        return;
    }

    if(typeof config["enabled"] !== "undefined")
    {
        this._enabled = config["enabled"];
    }

    if(typeof config.autoDetect !== "undefined" && config.autoDetect === true && KEN.Device.language !== "")
    {
        //change the default config option
        this._defaultLocale = KEN.Device.language;
    }
    else if(typeof config["default"] === "string")
    {
        this._defaultLocale = config["default"];
    }
};

/**
 * Parse the configuration data of a i18n node.
 * @method KEN.LocaleManager#_parseConfig
 * @param {I18nConfig} config - The configuration data.
 * @param {boolean=} force - Internal parameter to force the parse/update of the main i18n config.
 * @private
 */
KEN.LocaleManager.prototype._parseConfig = function(config, force)
{
    if(typeof config === "undefined")
    {
        return;
    }

    // force the parse of the main config
    if (force === true)
    {
        this._parseMainConfig(config);
    }

    if(this._enabled === false)
    {
        this.warn("KEN.LocaleManager: locale management is deactivated");
        return;
    }

    if(typeof config["locales"] !== "undefined")
    {
        var configLength = config["locales"].length;
        var currentLocaleLoaded = false;

        for(var i = 0, ii = configLength; i < ii; i++)
        {
            if(this._addLocale(config["locales"][i]) === true)
            {
                currentLocaleLoaded = true;
            }
        }

        // if nothing is loaded, load the first locale found
        if(currentLocaleLoaded === false)
        {
            // set the default locale for the manager only once
            if(this._indexOfLocale(this._defaultLocale) === -1)
            {
                this._defaultLocale = config["locales"][0]["name"];
            }
            this._setLocaleIndex(this._indexOfLocale(config["locales"][0]["name"]));
        }
    }
};

/**
 * Search index position for a locale.
 * @method KEN.LocaleManager#_indexOfLocale
 * @param {string} name - The locale name.
 * @private
 */
KEN.LocaleManager.prototype._indexOfLocale = function(name)
{
    var locale;

    for ( var i = 0, ii = this._locales["size"]; i < ii; i++)
    {
        locale = this._locales.get(i);

        if(locale["name"].toLowerCase() === name.toLowerCase())
        {
            return i;
        }
    }

    return -1;
};

/**
 * Set the index position for the locale.
 * @method KEN.LocaleManager#_setLocaleIndex
 * @param {number} index - The locale index.
 * @private
 */
KEN.LocaleManager.prototype._setLocaleIndex = function(index)
{
    if(index < 0 || index >= this._locales["size"])
    {
        throw "The locale you are trying to set doesn't exist";
    }

    if(this._localeIndex === index)
    {
        this.warn("KEN.LocaleManager: You're trying to set a locale that is already the actual locale");
        return;
    }

    this._localeIndex = index;

    if(this._onLocaleChangeRequest !== null)
    {
        this._onLocaleChangeRequest.dispatch();
    }

    this._locales.get(this._localeIndex).loadFiles();
};

/**
 * Add a locale.
 * @method KEN.LocaleManager#_addLocale
 * @param {I18nLocaleConfig} config - The configuration data.
 * @return {boolean} The current locale files have been loaded?
 * @private
 */
KEN.LocaleManager.prototype._addLocale = function(config)
{
    var locale;
    var i = this._indexOfLocale(config["name"]);

    if(i === -1)
    {
        locale = new KEN.Locale(this._viewer);
        locale.onLocaleAllFilesLoaded.add(this._localeAllFilesLoaded, this);

        i = this._locales.add(locale) - 1;
    }
    else
    {
        locale = this._locales.get(i);
    }

    locale.addConfig(config);

    // If this is the current locale in use, load the files
    if(i === this._localeIndex || this._defaultLocale.toLowerCase() === config["name"].toLowerCase())
    {
        locale.loadFiles();

        if(this._localeIndex === -1)
        {
            this._setLocaleIndex(i);
        }

        return true;
    }

    return false;
};

/**
 * Verify if all local files are loaded.
 * @method KEN.LocaleManager#_localeAllFilesLoaded
 * @private
 */
KEN.LocaleManager.prototype._localeAllFilesLoaded = function()
{
    this.log("KEN.LocaleManager._localeAllFilesLoaded();");

    if(this._onLocaleChangeComplete !== null)
    {
        this._onLocaleChangeComplete.dispatch();
    }
};

/**
 * Get value of for a selected locale.
 * @method KEN.LocaleManager#getValue
 * @param {string} key - The key to get locale data.
 * @param {?string} jsonKey - The json key to search into a specific file.
 * @return {string} Returns the locale value.
 */
KEN.LocaleManager.prototype.getValue = function(key, jsonKey)
{
    if(this._localeIndex === -1)
    {
        this.warn("KEN.LocaleManager: You trying to get a value with no locale selected!");
        return key;
    }

    var value = this._locales.get(this._localeIndex).getValue(key, jsonKey);
    var defaultLocalIndex = this._indexOfLocale(this._defaultLocale);
    if(this._localeIndex !== defaultLocalIndex && defaultLocalIndex !== -1 && value === key)
    {
        //if not found, get the default locale value
        value = this._locales.get(defaultLocalIndex).getValue(key, jsonKey);
    }
    return value;
};

/**
 * Is the selected locale has a value?
 * @method KEN.LocaleManager#hasValue
 * @param {string} key - The key to get locale data.
 * @param {?string} jsonKey - The json key to search into a specific file.
 * @return {boolean} Returns true if the locale has a value.
 */
KEN.LocaleManager.prototype.hasValue = function(key, jsonKey)
{
    if(this._localeIndex === -1)
    {
        return false;
    }

    var available = this._locales.get(this._localeIndex).hasValue(key, jsonKey);
    var defaultLocalIndex = this._indexOfLocale(this._defaultLocale);
    if(this._localeIndex !== defaultLocalIndex && defaultLocalIndex !== -1 && available === false)
    {
        //if not found, return result from the default locale
        available = this._locales.get(defaultLocalIndex).hasValue(key, jsonKey);
    }
    return available;
};

/**
 * Destroy method.
 * @method KEN.LocaleManager#destroy
 */
KEN.LocaleManager.prototype.destroy = function()
{
    this._viewer = null;

    for(var i=0, ii=this._locales["size"]; i<ii; i++)
    {
        this._locales[i].destroy();
    }
    this._locales = null;

    if(this._onLocaleChangeRequest !== null)
    {
        this._onLocaleChangeRequest.destroy();
        this._onLocaleChangeRequest = null;
    }

    if(this._onLocaleChangeComplete !== null)
    {
        this._onLocaleChangeComplete.destroy();
        this._onLocaleChangeComplete = null;
    }

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
* Get and set the locale name.
* @name KEN.LocaleManager#locale
* @type {string}
*/
KEN.LocaleManager.prototype.locale;
Object.defineProperty(KEN.LocaleManager.prototype, "locale",
{
    /** @this {KEN.LocaleManager} */
    get: function()
    {
        if(this._localeIndex !== -1)
        {
            return this._locales.get(this._localeIndex).name;
        }
        else
        {
            return "";
        }
    },

    /** @this {KEN.LocaleManager} */
    set: function(value)
    {
        var index;

        if(typeof value === "number" && value < this._locales["size"])
        {
            index = value;
        }
        else if(typeof value === "string")
        {
            index = this._indexOfLocale(value);
        }

        this._setLocaleIndex(index);
    }

});

/**
* Get and set the locale index.
* @name KEN.LocaleManager#localeIndex
* @type {string}
*/
KEN.LocaleManager.prototype.localeIndex;
Object.defineProperty(KEN.LocaleManager.prototype, "localeIndex",
{
    /** @this {KEN.LocaleManager} */
    get: function()
    {
        return this._localeIndex;
    },

    /** @this {KEN.LocaleManager} */
    set: function(value)
    {
        if(typeof value === "number" && value < this._locales["size"])
        {
            this._setLocaleIndex(value);
        }

    }

});

/**
* Get the current locale object.
* @name KEN.LocaleManager#localeObject
* @readonly
* @type {KEN.Locale}
*/
KEN.LocaleManager.prototype.localeObject;
Object.defineProperty(KEN.LocaleManager.prototype, "localeObject",
{
    /** @this {KEN.LocaleManager} */
    get: function()
    {
        return this._locales.get(this._localeIndex);
    }
});

/**
* Get and set the locales list.
* @name KEN.LocaleManager#locales
* @type {Array}
*/
KEN.LocaleManager.prototype.locales;
Object.defineProperty(KEN.LocaleManager.prototype, "locales",
{
    /** @this {KEN.LocaleManager} */
    get: function()
    {
        var locale;
        var locales = [];

        for ( var i = 0, ii = this._locales["size"]; i < ii; i++)
        {
            locale = this._locales.get(i);
            locales.push(locale["name"]);
        }

        return locales;
    }

});

/**
 * Get the "onLocaleChangeRequest" {@link KEN.EventDispatcher} of the LocaleManager.
 * @name KEN.LocaleManager#onLocaleChangeRequest
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.LocaleManager.prototype.onLocaleChangeRequest;
Object.defineProperty(KEN.LocaleManager.prototype, "onLocaleChangeRequest",
{
    /** @this {KEN.LocaleManager} */
    get: function()
    {
        if(this._onLocaleChangeRequest === null)
        {
            this._onLocaleChangeRequest = new KEN.EventDispatcher(this);
        }

        return this._onLocaleChangeRequest;
    }
});

/**
 * Get the "onLocaleChangeComplete" {@link KEN.EventDispatcher} of the LocaleManager.
 * @name KEN.LocaleManager#onLocaleChangeComplete
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.LocaleManager.prototype.onLocaleChangeComplete;
Object.defineProperty(KEN.LocaleManager.prototype, "onLocaleChangeComplete",
{
    /** @this {KEN.LocaleManager} */
    get: function()
    {
        if(this._onLocaleChangeComplete === null)
        {
            this._onLocaleChangeComplete = new KEN.EventDispatcher(this);
        }

        return this._onLocaleChangeComplete;
    }
});


/**
 * Locale string class.
 *
 * @constructor KEN.LocaleString
 * @param {KEN.Viewer} viewer {@link KEN.Viewer} reference.
 * @param {string=} key the i18n key of the locale.
 * @param {string=} jsonKey - The JSOn key to search for.
 * @param {string=} defaultStr - The default text to use.
 * @extends {KEN.BaseObject}
 * 
 * @todo Try to make strings that works with a specific key for the cache
 * @todo For example a plugin can declare an exclusive key to work with
 */
KEN.LocaleString = function(viewer, key, jsonKey, defaultStr)
{
    /**
     * Viewer reference.
     * @name KEN.LocaleString#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Key of the locale.
     * @name KEN.LocaleString#_key
     * @type {string|undefined}
     * @private
     */
    this._key = key;

    /**
     * JSON file key where to look for the locale.
     * @name KEN.LocaleString#_jsonKey
     * @type {string|undefined}
     * @private
     */
    this._jsonKey = jsonKey;

    /**
     * Default value for the locale string.
     * @name KEN.LocaleString#_defaultValue
     * @type {string|undefined}
     * @private
     */
    this._defaultValue = defaultStr;

    /**
     * Value of the locale.
     * @name KEN.LocaleString#_value
     * @type {?string}
     * @private
     */
    this._value = null;

    //this._locale = 0; // The current locale 
    KEN.BaseObject.call(this, "LocaleString");
};

KEN.LocaleString.prototype = Object.create(KEN.BaseObject.prototype);
KEN.LocaleString.prototype.constructor = KEN.LocaleString;

/**
 * Destroy method.
 * @method KEN.LocaleString#destroy
 */
KEN.LocaleString.prototype.destroy = function()
{
    this._viewer = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
* Get and set the key of the locale.
* @name KEN.LocaleString#key
* @type {string} 
*/
KEN.LocaleString.prototype.key;
Object.defineProperty(KEN.LocaleString.prototype, "key", {

    /** @this {KEN.LocaleString} */
    get: function () 
    {
        return this._key;
    },

    /** @this {KEN.LocaleString} */
    set: function (value) 
    {
        this._key = value;
    }

});

/**
* Get and set the JSON key of the locale.
* @name KEN.LocaleString#jsonKey
* @type {string} 
*/
KEN.LocaleString.prototype.jsonKey;
Object.defineProperty(KEN.LocaleString.prototype, "jsonKey", {

    /** @this {KEN.LocaleString} */
    get: function () 
    {
        return this._jsonKey;
    },

    /** @this {KEN.LocaleString} */
    set: function (value) 
    {
        this._jsonKey = value;
    }

});

/**
* Get the value of the locale.
* @name KEN.LocaleString#value
* @readonly
* @type {string} 
*/
KEN.LocaleString.prototype.value;
Object.defineProperty(KEN.LocaleString.prototype, "value", {

    /** @this {KEN.LocaleString} */
    get: function () 
    {
        // Check if the string is already populated.
        // Check if the locale is ok 
        // Populate the string value
        // Return the string value
        // If the string is not found return the key or an empty string ? 

        // Is the current locale value is the same than the manager one ?
        /*
        if(this._locale == this._viewer["i18n"]["locale"])
        {
            
        }
        */

        var locale = this._viewer["i18n"]["locale"];

        // if no locale is selected in the locale manager then return the default value or return the key!
        if(locale === "")
        {
            if(typeof this._defaultValue !== "undefined")
            {
                return this._defaultValue;
            }
            return this._key;
        }

        this._value = this._viewer["i18n"].getValue(/** @type {string} */ (this._key), this._jsonKey);

        // if no value are found for the key and a default value exists, return it.
        if (this._value === this._key && typeof this._defaultValue !== "undefined")
        {
            this._value = this._defaultValue;
        }

        return this._value;
    }

});

/**
* Get the loaded status of this locale string for the current locale.
* @name KEN.LocaleString#loaded
* @readonly
* @type {boolean} 
*/
KEN.LocaleString.prototype.loaded;
Object.defineProperty(KEN.LocaleString.prototype, "loaded",
{
    /** @this {KEN.LocaleString} */
    get: function()
    {
        var value = this._viewer["i18n"].getValue(/** @type {string} */ (this._key), this._jsonKey);
        return (typeof value !== "undefined" && value !== this._key);
    }
});

/**
 * Locale.
 * @constructor KEN.Locale
 * @param {KEN.Viewer} viewer - The {@link KEN.Viewer} reference.
 * @extends {KEN.BaseObject}
 *
 * @todo If you duplicate a plugin, locale file loaded count is superior than file count
 */
KEN.Locale = function(viewer)
{
    /**
     * Viewer reference.
     * @name KEN.Locale#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Name of the locale.
     * @name KEN.Locale#_name
     * @type {string}
     * @private
     */
    this._name = "";

    /**
     * List of the files.
     * @name KEN.Locale#_files
     * @type {KEN.Collection}
     * @private
     */
    this._files = null;

    /**
     * On file loaded event dispatcher.
     * @name  KEN.Locale#onLocaleFileLoaded
     * @type {KEN.EventDispatcher}
     */
    this.onLocaleFileLoaded = null;

    /**
     * On all files loaded event dispatcher.
     * @name  KEN.Locale#onLocaleAllFilesLoaded
     * @type {KEN.EventDispatcher}
     */
    this.onLocaleAllFilesLoaded = null;

    KEN.BaseObject.call(this, "Locale");

    this._boot();
};

KEN.Locale.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Locale.prototype.constructor = KEN.Locale;

/**
 * Boot sequence.
 * @method KEN.Locale#_boot
 * @private
 */
KEN.Locale.prototype._boot = function()
{
    this._files = new KEN.Collection();

    this.onLocaleFileLoaded = new KEN.EventDispatcher(this);

    this.onLocaleAllFilesLoaded = new KEN.EventDispatcher(this);
};

/**
 * Add configuration files.
 * @method KEN.Locale#addConfig
 * @param {I18nLocaleConfig} config - The configuration data.
 */
KEN.Locale.prototype.addConfig = function(config)
{
    if(this._name === "" && typeof config["name"] === "string")
    {
        this._name = config["name"];
    }

    if(typeof config.files !== "undefined")
    {
        var file;

        for(var i = 0, ii = config.files.length; i < ii; i++)
        {
            file = /** @type I18nLocaleFileConfig */ (config.files[i]);
            if(this._getFileByKey(file["key"]) === null)
            {
                file.loading = false;
                file["loaded"] = false;
                this._files.add(file);
            }
        }
    }

    this.log("Locale.addConfig(); number of files : "+this._files["size"]);
};

/**
 * Load configuration files.
 * @method KEN.Locale#loadFiles
 */
KEN.Locale.prototype.loadFiles = function()
{
    if(this._isAllFilesLoaded() === true)
    {
        this.onLocaleAllFilesLoaded.dispatch();
        return true;
    }

    var file;
    for(var i = 0, ii = this._files["size"]; i < ii; i++)
    {
        file = /** @type {KEN.File} */ (this._files.get(i));

        if(file.loading === false && file["loaded"] === false)
        {
            this._loadFile(file);
        }
    }
};

/**
 * Get a file by key.
 * @method KEN.Locale#_getFileByKey
 * @param {string} key - The key to search for a file.
 * @private
 */
KEN.Locale.prototype._getFileByKey = function(key)
{
    var file;

    for(var i = 0, ii = this._files["size"]; i < ii; i++)
    {
        file = this._files.get(i);

        if(file["key"] === key)
        {
            return file;
        }
    }

    return null;
};

/**
 * Load a file.
 * @method KEN.Locale#_loadFile
 * @param {KEN.File} file - The file to load.
 * @private
 */
KEN.Locale.prototype._loadFile = function(file)
{
    if(file.loading === false && file["loaded"] === false)
    {
        file.loading = true;
        this._viewer["load"].json(file["key"], file["url"], this._loadFileComplete, this);
    }
};

/**
 * Load of a file is completed.
 * @method KEN.Locale#_loadFileComplete
 * @param {KEN.File} file - The file loaded.
 * @private
 */
KEN.Locale.prototype._loadFileComplete = function(file)
{
    var _file = this._getFileByKey(file["key"]);
    _file.loading = false; //Loading is ended
    _file["loaded"] = true; //Load is complete

    this.log("loadFileComplete(); "+_file["key"]);

    this.onLocaleFileLoaded.dispatch();

    if(this._isAllFilesLoaded() === true)
    {
        this.onLocaleAllFilesLoaded.dispatch();
    }
};

/**
 * Verify if all files are loaded.
 * @method KEN.Locale#_isAllFilesLoaded
 * @return {boolean} Returns true if all files are loaded.
 * @private
 */
KEN.Locale.prototype._isAllFilesLoaded = function()
{
    var file;

    for(var i = 0, ii = this._files["size"]; i < ii; i++)
    {
        file = this._files.get(i);

        if(file["loaded"] === false)
        {
            return false;
        }
    }

    return true;
};

/**
 * Get the locale value.
 * @method KEN.Locale#getValue
 * @param {string} key - The key to search for a locale.
 * @param {?string=} jsonKey - The json key to search into a specific file.
 * @return {string} The key to search for a locale.
 */
KEN.Locale.prototype.getValue = function(key, jsonKey)
{
    var file, json;
    for(var i = 0, ii = this._files["size"]; i < ii; i++)
    {
        file = this._files.get(i);

        if(this._viewer["cache"].has(KEN.Cache.types.JSON, file["key"]) === true && (typeof jsonKey === "undefined" || jsonKey === file["key"]))
        {
            json = this._viewer["cache"].get(KEN.Cache.types.JSON, file["key"]);

            if(typeof json["data"][key] !== "undefined")
            {
                return json["data"][key];
            }
        }
    }

    if (typeof jsonKey !== "undefined")
    {
        this.warn("KEN.Locale: value not found into the specified JSON file, try to find it in all files.");
        this.getValue(key);
    }

    return key;
};

/**
 * Locale has a value?
 * @method KEN.Locale#hasValue
 * @param {string} key - The key to search for a locale.
 * @param {?string=} jsonKey - The json key to search into a specific file.
 * @return {boolean} Returns true if the locale has a value stored.
 */
KEN.Locale.prototype.hasValue = function(key, jsonKey)
{
    var file, json;
    for(var i = 0, ii = this._files["size"]; i < ii; i++)
    {
        file = this._files.get(i);

        if(this._viewer["cache"].has(KEN.Cache.types.JSON, file["key"]) === true && (typeof jsonKey === "undefined" || jsonKey === file["key"]))
        {
            json = this._viewer["cache"].get(KEN.Cache.types.JSON, file["key"]);

            if(typeof json["data"][key] !== "undefined")
            {
                return true;
            }
        }
    }

    if (typeof jsonKey !== "undefined")
    {
        this.warn("KEN.Locale: key not found into the specified JSON file, try to find it in all files.");
        this.hasValue(key);
    }

    return false;
};

/**
 * Get the key of an i18n value.
 * @method  KEN.Locale#getKey
 * @param  {string} value - The value associated to the key you want.
 * @param  {?string=} jsonKey - The json key to search into a specific file.
 * @return {string|undefined} Returns the key associated to the value if found, undefined if not.
 */
KEN.Locale.prototype.getKey = function(value, jsonKey)
{
    var file, json;
    for(var i = 0, ii = this._files["size"]; i < ii; i++)
    {
        file = /** @type {KEN.File} */ (this._files.get(i));

        if(this._viewer["cache"].has(KEN.Cache.types.JSON, file["key"]) === true && (typeof jsonKey === "undefined" || jsonKey === file["key"]))
        {
            json = this._viewer["cache"].get(KEN.Cache.types.JSON, file["key"]);

            for(var key in json["data"])
            {
                if(json["data"][key] === value)
                {
                    return key;
                }
            }
        }
    }

    if (typeof jsonKey !== "undefined")
    {
        this.warn("KEN.Locale: value not found into the specified JSON file, try to find it in all files.");
        this.getKey(value);
    }

    return undefined;
};

/**
 * Destroy method.
 * @method KEN.Locale#destroy
 */
KEN.Locale.prototype.destroy = function()
{
    this._viewer = null;
    this._files = null;

    this.onLocaleFileLoaded.destroy();
    this.onLocaleFileLoaded = null;

    this.onLocaleAllFilesLoaded.destroy();
    this.onLocaleAllFilesLoaded = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
* Get the name of the locale.
* @name KEN.Local#name
* @readonly
* @type {string}
*/
KEN.Locale.prototype.name;
Object.defineProperty(KEN.Locale.prototype, "name",
{
    /** @this {KEN.Locale} */
    get: function()
    {
        return this._name;
    }
});


/**
 * Keyboard Manager that handles keyboard events and manage {@link KEN.KeyBinding}s.
 *
 * @constructor KEN.Keyboard
 * @param {KEN.Viewer} viewer {@link KEN.Viewer} reference.
 * @extends {KEN.BaseObject}
 *
 * @todo  fix keyout for several keybinding on a same keycode but different keysout configuration ?
 */
KEN.Keyboard = function(viewer)
{
    /**
     * The viewer reference.
     * @name KEN.Keyboard#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Is the keyboard is enabled?
     * @name KEN.Keyboard#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * The array that handles the {@link KEN.KeyBinding} objects.
     * @name KEN.Keyboard#_keyBindings
     * @type {?Array<KEN.KeyBinding>}
     * @private
     */
    this._keyBindings = null;

    /**
     * The array that handles the key codes that are considered as pressed.
     * @name KEN.Keyboard#_keyPressed
     * @type {?Array<number>}
     * @private
     */
    this._keyPressed = null;

    /**
     * This is a copy of key down handler with this as this reference (bind).
     * @name  KEN.Drag#_keyDownBind
     * @type {Function}
     * @default  null
     * @private
     */
    this._keyDownBind = null;

    /**
     * This is a copy of key up handler with this as this reference (bind).
     * @name  KEN.Drag#_keyUpBind
     * @type {Function}
     * @default  null
     * @private
     */
    this._keyUpBind = null;

    KEN.BaseObject.call(this, "Keyboard");

    this._boot();
};

KEN.Keyboard.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Keyboard.prototype.constructor = KEN.Keyboard;

/**
 * Boot sequence.
 * @method KEN.Keyboard#_boot
 * @suppress {checkTypes}
 * @private
 */
KEN.Keyboard.prototype._boot = function()
{
    this._keyBindings = [];
    this._keyPressed = [];

    this._keyDownBind = this._keyDownHandler.bind(this);
    this._keyUpBind = this._keyUpHandler.bind(this);

    window.addEventListener("keydown", this._keyDownBind, false);
    window.addEventListener("keyup", this._keyUpBind, false);
};

/**
 * Event handler for key down, listening on window.<br>
 * This handler is copied in _keyDownBind, for custom this reference.
 * @method KEN.Keyboard#_keyDownHandler
 * @private
 * @param  {KeyboardEvent} event - the native HTML KeyboardEvent
 */
KEN.Keyboard.prototype._keyDownHandler = function(event)
{
    this._processKeyDown(event);
};

/**
 * Event handler for key up, listening on window.<br>
 * This handler is copied in _keyUpBind, for custom this reference.
 * @method KEN.Keyboard#_keyUpHandler
 * @private
 * @param  {KeyboardEvent} event - the native HTML KeyboardEvent
 */
KEN.Keyboard.prototype._keyUpHandler = function(event)
{
    this._processKeyUp(event);
};

/**
 * Update method called by the viewer main loop.
 * @method KEN.Keyboard#update
 */
KEN.Keyboard.prototype.update = function()
{
    var keyBinding;

    for(var i = 0, ii = this._keyBindings.length; i < ii; i++)
    {
        keyBinding = this._keyBindings[i];

        if(keyBinding["pressed"] === true)
        {
            if(keyBinding["hasToWaitToHold"] === true && keyBinding["downComplete"] === false)
            {
                return;
            }

            keyBinding.hold();
        }
    }
};

/**
 * Get the index of a KeyBinding.
 * @method KEN.Keyboard#_indexOfBinding
 * @private
 * @param  {KEN.KeyBinding|number} value - The KeyBinding or a keyCode (Number).
 * @return {number} Returns the searched index if found, if not, returns -1.
 */
KEN.Keyboard.prototype._indexOfBinding = function(value)
{
    if(this._keyBindings === null || this._keyBindings.length === 0)
    {
        return -1;
    }

    if(typeof value === "object" && value["type"] === "KeyBinding")
    {
        return this._keyBindings.indexOf(value);
    }

    if(typeof value === "number")
    {
        for(var i = 0, ii = this._keyBindings.length; i < ii; i++)
        {
            if(this._keyBindings[i].hasKeyIn(value) === true)
            {
                return i;
            }
        }
    }

    return -1;
};

/**
 * Add a keyCode to the keyPressed array if it's not already in.
 * @method KEN.Keyboard#_addKeyPressed
 * @private
 * @param {number} keyCode - The keyCode you want to add.
 * @returns {boolean} Returns true if it's correctly added, false if it's already in.
 */
KEN.Keyboard.prototype._addKeyPressed = function(keyCode)
{
    if(this._keyPressed.indexOf(keyCode) === -1)
    {
        this._keyPressed.push(keyCode);
        return true;
    }

    return false;
};

/**
 * Remove a keyCode from the keyPressed array.
 * @method KEN.Keyboard#_removeKeyPressed
 * @private
 * @param  {number} keyCode - The keyCode you want to remove.
 * @return {boolean} Return true if it's succesfuly removed, false if not found.
 */
KEN.Keyboard.prototype._removeKeyPressed = function(keyCode)
{
    var index = this._keyPressed.indexOf(keyCode);

    if(index !== -1)
    {
        this._keyPressed.splice(index, 1);
        return true;
    }

    return false;
};

/**
 * Ask if a keyCode is in the keyPressed array.
 * @method KEN.Keyboard#isKeyPressed
 * @param  {number} keyCode - The keyCode you want to know if it's in the keyPressed array.
 * @return {boolean} Returns true if the keyCode is considered as a keyPressed, false if not.
 */
KEN.Keyboard.prototype.isKeyPressed = function(keyCode)
{
    return this._keyPressed.indexOf(keyCode) !== -1;
};

/**
 * Ask if a keyCode is considered as a keyOut at this time.
 * @method KEN.Keyboard#isKeyOut
 * @param  {number}  keyCode - The keyCode you want to know if it's a key out.
 * @return {boolean} Returns true if keyCode is considered as a keyOut, false if not.
 */
KEN.Keyboard.prototype.isKeyOut = function(keyCode)
{
    var keyBinding;

    for(var i = 0, ii = this._keyBindings.length; i < ii; i++)
    {
        keyBinding = this._keyBindings[i];

        if(keyBinding["pressed"] === true && keyBinding.hasKeyOut(keyCode) === true)
        {
            return true;
        }
    }

    return false;
};

/**
 * Add a KeyBinding to the Keyboard's keyBinding array.
 * @method KEN.Keyboard#addBinding
 * @param {KEN.KeyBinding} keyBinding - The KEN.KeyBinding you want to add.
 * @return {boolean} Returns true if it's correctly added, false if it's already in or if wrong type.
 */
KEN.Keyboard.prototype.addBinding = function(keyBinding)
{
    if(typeof keyBinding !== "object" && keyBinding["type"] !== "KeyBinding")
    {
        return false;
    }

    var index = this._indexOfBinding(keyBinding);

    if(index === -1)
    {
        this._keyBindings.push(keyBinding);
        return true;
    }

    return false;
};

/**
 * Remove a {@link KEN.KeyBinding} from the {@link KEN.Keyboard} object.
 * @method KEN.Keyboard#removeBinding
 * @param  {KEN.KeyBinding|number} value - A {@link KEN.KeyBinding} or a Number that represent a key code.
 * @return {boolean} Returns true if it's removed, false if not found.
 */
KEN.Keyboard.prototype.removeBinding = function(value)
{
    var index = this._indexOfBinding(value);

    if(index !== -1)
    {
        this._keyBindings[index].destroy();
        this._keyBindings.splice(index, 1);
        return true;
    }

    return false;
};

/**
 * Know if the keyboard has a KeyBinding Object or if there already one for a key code.
 * @method KEN.KeyBoard#hasBinding
 * @param  {KEN.KeyBinding}  value - A KEN.KeyBinding Object or a key code.
 * @return {boolean} Returns true if a KeyBinding is found, false if not.
 */
KEN.Keyboard.prototype.hasBinding = function(value)
{
    return this._indexOfBinding(value) !== -1;
};

/**
 * Get a {@link KEN.KeyBinding} associated to a key code.
 * @method  KEN.Keyboard#getBindings
 * @param  {number} keyCode - The key code for which you search a {@link KEN.KeyBinding}.
 * @return {Array<KEN.KeyBinding>} Returns a {@link KEN.KeyBinding} object if found, null if not.
 */
KEN.Keyboard.prototype.getBindings = function(keyCode)
{
    var bindings = [];

    for(var i = 0, ii = this._keyBindings.length; i < ii; i++)
    {
        if(this._keyBindings[i].hasKeyIn(keyCode) === true)
        {
            bindings.push(this._keyBindings[i]);
        }
    }

    return bindings;
};

/**
 * Event handler for keydown event.
 * @method KEN.Keyboard#_processKeyDown
 * @private
 * @param  {KeyboardEvent} event - The native KeyboardEvent from the down action.
 */
KEN.Keyboard.prototype._processKeyDown = function(event)
{
    if(this._enabled === false)
    {
        return;
    }

    var keyCode = event.keyCode;

    this.log("keyDown "+keyCode);

    if(this._addKeyPressed(keyCode) === true)
    {
        this._applyKeyDown(keyCode);
    }
};

/**
 * If the processed keydown event is valid it's applied by this method.
 * @method KEN.Keyboard#_applyKeyDown
 * @private
 * @param  {number} keyCode - The key code that has been validated as a pressed key.
 */
KEN.Keyboard.prototype._applyKeyDown = function(keyCode)
{
    if(this.isKeyOut(keyCode) === true)
    {
        return;
    }

    var keyBindings = this.getBindings(keyCode);
    var keyBinding;

    for(var i = 0, ii = keyBindings.length; i < ii; i++)
    {
        keyBinding = keyBindings[i];

        if(keyBinding["pressed"] === false)
        {
            keyBinding.down();
        }
    }
};

/**
 * Event handler for keyup event.
 * @method KEN.Keyboard#_processKeyUp
 * @private
 * @param  {KeyboardEvent} event - The native KeyboardEvent from the up action.
 */
KEN.Keyboard.prototype._processKeyUp = function(event)
{
    if(this._enabled === false)
    {
        return;
    }

    var keyCode = event.keyCode;

    this.log("keyUp "+keyCode);

    if(this._removeKeyPressed(keyCode) === true)
    {
        this._applyKeyUp(keyCode);
    }
};

/**
 * If the processed keyup event is valid it's applied by this method.
 * @method KEN.Keyboard#_applyKeyUp
 * @private
 * @param  {number} keyCode - The key code that has been validated as a released key.
 */
KEN.Keyboard.prototype._applyKeyUp = function(keyCode)
{
    if(this.isKeyOut(keyCode) === true)
    {
        return;
    }

    var keyBindings = this.getBindings(keyCode);
    var keyBinding;

    for(var i = 0, ii = keyBindings.length; i < ii; i++)
    {
        keyBinding = keyBindings[i];

        //Is there any valid keycode down for this keyBinding ?
        //If so, just return and consider this binding still down
        for(var j = 0, jj = this._keyPressed.length; j < jj; j++)
        {
            if(keyBinding.hasKeyIn(this._keyPressed[j]))
            {
                return;
            }
        }

        //If not, execute the up callback for the keybinding
        keyBinding.up();

        //When a key is up, activate the down effect for keycodes
        //that were considered as "out" before the key up.
        for(var k = 0, kk = this._keyPressed.length; k < kk; k++)
        {
            if(keyBinding.hasKeyOut(this._keyPressed[k]))
            {
                this._applyKeyDown(this._keyPressed[k]);
            }
        }
    }
};

/**
 * Destroy sequence.
 * @method KEN.Keyboard#destroy
 */
KEN.Keyboard.prototype.destroy = function()
{
    this._viewer = null;

    window.removeEventListener("keydown", this._keyDownBind, false);
    window.removeEventListener("keyup", this._keyUpBind, false);

    var i = this._keyBindings.length;
    while(i--)
    {
        this.removeBinding(this._keyBindings[i]);
    }
    this._keyBindings = null;

    this._keyDownBind = null;
    this._keyUpBind = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
* Gets or sets the enabled status of the keyboard.
* @name KEN.Keyboard#enabled
* @type {boolean}
*/
KEN.Keyboard.prototype.enabled;
Object.defineProperty(KEN.Keyboard.prototype, "enabled",
{
    /** @this {KEN.Keyboard} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {KEN.Keyboard} */
    set: function(value)
    {
        this._enabled = Boolean(value);
    }
});


/**
 * Key Binding object that handles keyboard event handlers for a list of keycodes.
 * To use a Key Binding you have to add it to the {@link KEN.Keyboard}.
 * 
 * @constructor KEN.KeyBinding
 * @param {Array|number} keysIn The key code or array of key codes associated to this KeyBinding.
 * @param {?Function} down The callback function that will be called on a keydown event.
 * @param {?Function} up The callback function that will be called on a keyup event.
 * @param {?Function} hold The callback function that will be called if a key down is hold.
 * @param {?Array|number} keysOut The key code or array of key codes that will be rejected if this KeyBinding is pressed.
 * @param {Object=} context - The context in which you want your "down", "hold" & up callbacks to execute
 * @extends {KEN.BaseObject}
 */
KEN.KeyBinding = function(keysIn, down, up, hold, keysOut, context)
{
    /**
     * The key code or array of key codes associated to this KeyBinding.
     * @name KEN.KeyBinding#_keysIn
     * @type {?Array|number}
     * @private
     */
    this._keysIn = keysIn || [];

    /**
     * The callback function that will be called on a keydown event.
     * @name KEN.KeyBinding#_down
     * @type {?Function}
     * @private
     */
    this._down = down || null;

    /**
     * The callback function that will be called on a keyup event.
     * @name KEN.KeyBinding#_up
     * @type {?Function}
     * @private
     */
    this._up = up || null;

    /**
     * The callback function that will be called if a key down is holded.
     * @name KEN.KeyBinding#_hold
     * @type {?Function}
     * @private
     */
    this._hold = hold || null;

    /**
     * The key code or array of key codes that will be rejected if this KeyBinding is pressed.
     * @name KEN.KeyBinding#_keysOut
     * @type {?Array|number}
     * @private
     */
    this._keysOut = keysOut || null;

    /**
     * The context in which we execute down, up and hold callback.
     * @name  KEN.KeyBinding#_context
     * @type {Object}
     * @private
     */
    this._context = context || this;

    /**
     * Flag to know if we have to wait to consider a down event as a holded one.
     * @name KEN.KeyBinding#_waitToHold
     * @type {boolean}
     * @default
     * @private
     */
    this._waitToHold = false;

    /**
     * Flag to know if we have this key binding is considered as pressed.<br>
     * It should be pressed if any of keysIn are pressed.
     * @name KEN.KeyBinding#_pressed
     * @type {boolean}
     * @default
     * @private
     */
    this._pressed = false;

    /**
     * When a key binding have to wait to be considered as holded this flag is check to know if down action is complete.
     * @name KEN.KeyBinding#_downComplete
     * @type {boolean}
     * @default
     * @private
     */
    this._downComplete = false;

    /**
     * Count of down.
     * @name KEN.KeyBinding#_downCount
     * @type {number}
     * @default
     * @private
     */
    this._downCount = 0;

    /**
     * Count of hold.
     * @name KEN.KeyBinding#_holdCount
     * @type {number}
     * @default
     * @private
     */
    this._holdCount = 0;

    /**
     * Count of up.
     * @name KEN.KeyBinding#_upCount
     * @type {number}
     * @default
     * @private
     */
    this._upCount = 0;

    KEN.BaseObject.call(this, "KeyBinding");
};

KEN.KeyBinding.prototype = Object.create(KEN.BaseObject.prototype);
KEN.KeyBinding.prototype.constructor = KEN.KeyBinding;

/**
 * Know if a key code is associated to this KeyBinding.
 * @method KEN.KeyBinding#hasKeyIn
 * @param  {number}  keyCode The key code you want to know if it is associated to this KeyBinding.
 * @return {boolean} Returns true if the keycode is associated as a key in to this KeyBinding.
 */
KEN.KeyBinding.prototype.hasKeyIn = function(keyCode)
{
    if(typeof this._keysIn === "number" && this._keysIn === keyCode)
    {
        return true;
    }
    else if (typeof this._keysIn.indexOf === "function")
    {
        return this._keysIn.indexOf(keyCode) !== -1;
    }

    return false;
};

/**
 * Know if a key code is considered as a key out for this KeyBinding.
 * @method KEN.KeyBinding#hasKeyOut
 * @param  {number}  keyCode The key code you want to know if it is considered as a key out for this KeyBinding.
 * @return {boolean} Returns true if the key code is considered as a key out for this KeyBinding.
 */
KEN.KeyBinding.prototype.hasKeyOut = function(keyCode)
{ 
    if(this._keysOut === null)
    {
        return false;
    }
    else if(typeof this._keysOut === "number" && this._keysOut === keyCode)
    {
        return true;
    }
    else if (typeof this._keysOut.indexOf === "function")
    {
        return this._keysOut.indexOf(keyCode) !== -1;
    }

    return false;
};

/**
 * This method is called by the {@link KEN.Keyboard} when a key down event is applied.<br>
 * This triggers the down callback associated to this KeyBinding and increase the downCount value.
 * @method KEN.KeyBinding#down
 */
KEN.KeyBinding.prototype.down = function()
{
    this._downCount++;
    this._pressed = true;

    if(typeof this._down === "function")
    {
        this._down.call(this._context, this);
    }
};

/**
 * This method has to be called by the user down callback to specify that the key down have to wait to be considered as holded.<br>
 * This gives in return a callback to set the down as complete.
 * @method KEN.KeyBinding#waitToHold
 * @return {Function} Returns a callback function that the user have to call to set the down as complete to allow hold.
 */
KEN.KeyBinding.prototype.waitToHold = function()
{
    this._waitToHold = true;

    var _downCount = this._downCount;
    var _this = this;
    var downCompleteCallback = function()
    {
        _this.log("downCompleteCallback "+_downCount+" "+_this._downCount);

        if(_downCount === _this._downCount)
        {
            _this._downComplete = true;
        } 
    };

    return downCompleteCallback;
};

/**
 * This method is called by the {@link KEN.Keyboard} when a key up event is applied.<br>
 * This triggers the up callback associated to this KeyBinding and increase the upCount value.
 * @method KEN.KeyBinding#up
 */
KEN.KeyBinding.prototype.up = function()
{
    this._upCount++;
    this._pressed = false;
    this._downComplete = false;

    if(typeof this._up === "function")
    {
        this._up.call(this._context, this);
    }
};

/**
 * This method is called by the {@link KEN.Keyboard} when a key hold event is applied.<br>
 * This triggers the hold callback associated to this KeyBinding and increase the holdCount value.
 * @method KEN.KeyBinding#hold
 */
KEN.KeyBinding.prototype.hold = function()
{
    this._holdCount++;

    if(typeof this._hold === "function")
    {
        this._hold.call(this._context, this);
    }
};

/**
 * Destroy sequence.
 * @method  KEN.KeyBinding#destroy
 */
KEN.KeyBinding.prototype.destroy = function()
{
    this._keysIn = null;
    this._down = null;
    this._up = null;
    this._hold = null;
    this._keysOut = null;
    this._context = null;

    KEN.BaseObject.prototype.destroy.call(this);
};  

/**
* Gets the pressed status of this KeyBinding.
* @name KEN.KeyBinding#pressed
* @readonly
* @type {boolean} 
*/
KEN.KeyBinding.prototype.pressed;
Object.defineProperty(KEN.KeyBinding.prototype, "pressed", 
{
    /** @this {KEN.KeyBinding} */
    get: function()
    {
        return this._pressed;
    }
});

/**
* Gets the down count value.
* @name KEN.KeyBinding#downCount
* @readonly
* @type {number} 
*/
KEN.KeyBinding.prototype.downCount;
Object.defineProperty(KEN.KeyBinding.prototype, "downCount", 
{
    /** @this {KEN.KeyBinding} */
    get: function()
    {
        return this._downCount;
    }
});

/**
* Gets the up count value.
* @name KEN.KeyBinding#upCount
* @readonly
* @type {number} 
*/
KEN.KeyBinding.prototype.upCount;
Object.defineProperty(KEN.KeyBinding.prototype, "upCount", 
{
    /** @this {KEN.KeyBinding} */
    get: function()
    {
        return this._upCount;
    }
});

/**
* Gets the hold count value.
* @name KEN.KeyBinding#holdCount
* @readonly
* @type {number} 
*/
KEN.KeyBinding.prototype.holdCount;
Object.defineProperty(KEN.KeyBinding.prototype, "holdCount", 
{
    /** @this {KEN.KeyBinding} */
    get: function()
    {
        return this._holdCount;
    }
});

/**
* Gets the hasToWaitToHold value.
* @name KEN.KeyBinding#hasToWaitToHold
* @readonly
* @type {boolean} 
*/
KEN.KeyBinding.prototype.hasToWaitToHold;
Object.defineProperty(KEN.KeyBinding.prototype, "hasToWaitToHold", 
{
    /** @this {KEN.KeyBinding} */
    get: function()
    {
        return this._waitToHold;
    }
});

/**
* Gets the downComplete value.
* @name KEN.KeyBinding#downComplete
* @readonly
* @type {boolean} 
*/
KEN.KeyBinding.prototype.downComplete;
Object.defineProperty(KEN.KeyBinding.prototype, "downComplete", 
{
    /** @this {KEN.KeyBinding} */
    get: function()
    {
        return this._downComplete;
    } 
});


/**
 * Drag manager module
 * @constructor KEN.Drag
 * @param {KEN.DisplayObject} displayObject - The display object concerned by the drag.
 * @extends {KEN.BaseObject}
 *
 * @todo  work also with rectangle for constrain
 */
KEN.Drag = function(displayObject)
{
    /**
     * The display object taht will be moved during the drag.
     * @name  KEN.Drag#_displayObject
     * @type {KEN.DisplayObject}
     * @private
     */
    this._displayObject = displayObject;

    /**
     * The object that will be litening to mouse down.<br>
     * This is the handle object that initiate the drag.<br>
     * By default, this is the same object that the display object. 
     * @name  KEN.Drag#_handleObject
     * @type {KEN.DisplayObject}
     * @private
     */
    this._handleObject = displayObject;

    /**
     * Is the drag is enabled ?
     * @name KEN.Drag#_enabled
     * @type {boolean}
     * @default  false
     * @private
     */
    this._enabled = false;

    /**
     * The display object taht will be used as constrain.
     * @name  KEN.Drag#_constrain
     * @type {KEN.DisplayObject}
     * @default  null
     * @private
     */
    this._constrain = null;

    /**
     * The axis constrain.<br>
     * This could be "x" or "y" or "" an empty string will remove the axis constrain.
     * @name  KEN.Drag#_axis
     * @type {string}
     * @default ""
     * @private
     */
    this._axis = "";

    /**
     * The position of the object on start drag.
     * @name  KEN.Drag#_startPostion
     * @type {Object}
     * @property {number} x - The x position.
     * @property {number} y - The y position.
     * @default  null
     * @private
     */
    this._startPostion = null;

    /**
     * The last  mouse position during drag.<br>
     * This is used to calculate distances.
     * @name  KEN.Drag#_lastMousePosition
     * @type {Object}
     * @property {number} x - The x position.
     * @property {number} y - The y position.
     * @default null
     * @private
     */
    this._lastMousePosition = null;

    /**
     * Flag for dragging.
     * @name  KEN.Drag#_dragging
     * @type {boolean}
     * @default  false
     * @private
     */
    this._dragging = false;

    /**
     * Flag to know if the displayObject have to revert position after drag stop.
     * @name  KEN.Drag#_revert
     * @type {boolean}
     * @default  false
     * @private
     */
    this._revert = false;

    /**
     * Flag to know if the displayObject is currently reverting its position.
     * @name  KEN.Drag#_reverting
     * @type {boolean}
     * @default  false
     * @private
     */
    this._reverting = false;

    /**
     * Tween used to revert the dispay object position after drag stops.
     * @name  KEN.Drag#_revertTween
     * @type {KEN.Tween}
     * @private
     */
    this._revertTween = null;

    /**
     * The revert duration in milliseconds.
     * @name KEN.Drag#_revertDuration
     * @type {number}
     * @default 200
     * @private
     */
    this._revertDuration = 200;

    /**
     * This is a backup of the original alpha when alpha is altered during drag.
     * @name  KEN.Drag#_originalAlpha
     * @type {number}
     * @private
     */
    this._originalAlpha = 1;

    /**
     * This is the alpha that will be applied to the display object during drag.
     * @name KEN.Drag#_alpha
     * @type {number}
     * @private
     */
    this._alpha = 1;

    /**
     * The revert easing method.
     * @name KEN.Drag#_revertEasing
     * @type {Function}
     * @default  {@link KEN.Easing.LINEAR}
     * @private
     */
    this._revertEasing = KEN.Easing.LINEAR;

    /**
     * On start event dispatcher.
     * @name  KEN.Drag#_onStart
     * @type {KEN.EventDispatcher}
     * @default  null
     * @private
     */
    this._onStart = null;

    /**
     * On drag event dispatcher.
     * @name  KEN.Drag#_onDrag
     * @type {KEN.EventDispatcher}
     * @default  null
     * @private
     */
    this._onDrag = null;

    /**
     * On stop event dispatcher.
     * @name  KEN.Drag#_onStop
     * @type {KEN.EventDispatcher}
     * @default  null
     * @private
     */
    this._onStop = null;

    /**
     * On revert event dispatcher.
     * @name  KEN.Drag#_onRevert
     * @type {KEN.EventDispatcher}
     * @default  null
     * @private
     */
    this._onRevert = null;

    KEN.BaseObject.call(this, "Drag");

    this._boot();
};

KEN.Drag.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Drag.prototype.constructor = KEN.Drag;

/**
 * Boot sequence
 * @method KEN.Drag#_boot
 * @private
 */
KEN.Drag.prototype._boot = function()
{
    this._alpha = this._displayObject["alpha"];
};

/**
 * Set the object that will be the handle object.<br>
 * Sets up mouse events on the handle.
 * @method  KEN.Drag#_setHandleObject
 * @private
 * @param {KEN.DisplayObject} displayObject - The {@link KEN.DisplayObject} that will be the handle.
 */
KEN.Drag.prototype._setHandleObject = function(displayObject)
{
    if(this._handleObject !== null)
    {
        this._unsetHandleObject();
    }

    this._handleObject = displayObject;

    this._handleObject["pointer"]["enabled"] = true;
    this._handleObject["pointer"]["onPanStart"].add(this._panStartHandler, this);
    this._handleObject["pointer"]["onPanMove"].add(this._panMoveHandler, this);
    this._handleObject["pointer"]["onPanEnd"].add(this._panEndHandler, this);
};

/**
 * Unset the handle object.<br>
 * Remove mouse events on the previous handle.
 * @method  KEN.Drag#_unsetHandleObject
 * @private
 */
KEN.Drag.prototype._unsetHandleObject = function()
{
    if(this._handleObject !== null)
    {
        this._handleObject["pointer"]["onPanStart"].remove(this._panStartHandler, this);
        this._handleObject["pointer"]["onPanMove"].remove(this._panMoveHandler, this);
        this._handleObject["pointer"]["onPanEnd"].remove(this._panEndHandler, this); 
    }

    this._handleObject = null;
};

/**
 * Internal pan start handler, this event is on the handle object.
 * 
 * @method  KEN.Drag#_panStartHandler
 * @private
 * @param  {MouseEvent} event - The resulting event object from pan start.
 */
KEN.Drag.prototype._panStartHandler = function(event)
{
    this.log("_panStartHandler");

    var hammerEvent = event["data"];
    var mouseEvent = event["data"]["srcEvent"];

    //If it is a touch event we need to get the coordinate from the first touch
    if(typeof mouseEvent.touches !== "undefined" && typeof mouseEvent.touches[0] === "object")
    {
        mouseEvent = mouseEvent.touches[0];
    }

    //Cancel the drag if reverting OR if its not the target OR if its start position isn't valid
    if(this._reverting === true || hammerEvent["target"] !== this._handleObject["dom"] || this._isPositionValid() === false)
    {
        return;
    }

    this._dragging = true;

    this._startPostion = {x: this._displayObject.x, y: this._displayObject.y};
    
    this._displayObject["top"] = null;
    this._displayObject["right"] = null;
    this._displayObject["bottom"] = null;
    this._displayObject["left"] = null;

    this._lastMousePosition = {x: mouseEvent.pageX, y: mouseEvent.pageY};

    this._originalAlpha = this._displayObject["alpha"];
    this._displayObject["alpha"] = this._alpha;

    if(this._onStart !== null)
    {
        this._onStart.dispatch();
    }
};

/**
 * Internal pan end handler.
 * @method  KEN.Drag#_panEndHandler
 * @private
 */
KEN.Drag.prototype._panEndHandler = function()
{
    this.log("_panEndHandler");

    if(this._dragging !== true)
    {
        return;
    }

    this._dragging = false;

    if(this._onStop !== null)
    {
        this._onStop.dispatch();
    }

    if(this._revert === true && this._revertTween !== null)
    {
        this._reverting = true;
        this._revertTween.to({x: this._startPostion.x, y: this._startPostion.y}, this._revertDuration, this._revertEasing).start();
    }
    else
    {
        this._displayObject["alpha"] = this._originalAlpha;
    }

    this._startPostion = null;
    
    this._lastMousePosition = null;
};

/**
 * Internal pointer pan move handler.
 *
 * @method  KEN.Drag#_panMoveHandler
 * @private
 * @param  {MouseEvent} event - The resulting event object from pan move.
 */
KEN.Drag.prototype._panMoveHandler = function(event)
{
    this.log("_panMoveHandler");

    if(this._dragging !== true)
    {
        return;
    }

    var mouseEvent = event["data"]["srcEvent"];

    //If it is a touch event we need to get the coordinate from the first touch
    if(typeof mouseEvent.touches !== "undefined" && typeof mouseEvent.touches[0] === "object")
    {
        mouseEvent = mouseEvent.touches[0];
    }

    var position = {x: mouseEvent.pageX, y: mouseEvent.pageY};
    var dx = position.x - this._lastMousePosition.x;
    var dy = position.y - this._lastMousePosition.y;

    this._lastMousePosition = position;

    if(this._constrain !== null)
    {
        var o = this._displayObject["globalOffset"]; // o = offset
        var po = this._displayObject["parent"]["globalOffset"]; // po = parent offset
        var co = this._constrain["globalOffset"]; // co = constrain offset

        if(this._axis === "" || this._axis === "x")
        {
            if(o["left"] + dx < co["left"])
            {
                this.log("out left");
                this._displayObject.x = Math.abs(po["left"] - co["left"]);
            }
            else if(o["left"] + dx + this._displayObject["pixelWidth"] > co["left"] + this._constrain["innerWidth"])
            {
                this.log("out right");
                this._displayObject.x = Math.abs(po["left"] - co["left"]) + this._constrain["innerWidth"] - this._displayObject["pixelWidth"];
            }
            else
            {
                this._displayObject.x += dx;
            }
        }
        
        if(this._axis === "" || this._axis === "y")
        {
            if(o["top"] + dy < co["top"])
            {
                this.log("out top");
                this._displayObject.y = Math.abs(po["top"] - co["top"]);
            }
            else if(o["top"] + dy + this._displayObject["pixelHeight"] > co["top"] + this._constrain["innerHeight"])
            {
                this.log("out bottom");
                this._displayObject.y = Math.abs(po["top"] - co["top"]) + this._constrain["innerHeight"] - this._displayObject["pixelHeight"];
            }
            else
            {
                this._displayObject.y += dy;
            }
        }
    }
    else
    {
        if(this._axis === "" || this._axis === "x")
        {
            this._displayObject.x += dx;
        }
        
        if(this._axis === "" || this._axis === "y")
        {
            this._displayObject.y += dy;
        }
    }

    if(this._onDrag !== null)
    {
        this._onDrag.dispatch();
    }
};

/**
 * Internal handler for the revert tween complete.
 * @method  KEN.Drag#_revertCompleteHandler
 * @private
 */
KEN.Drag.prototype._revertCompleteHandler = function()
{
    this.log("_revertCompleteHandler");

    this._reverting = false;
    this._displayObject["alpha"] = this._originalAlpha;

    if(this._onRevert !== null)
    {
        this._onRevert.dispatch();
    }
};

/**
 * Helper that check if the display object position is valid.<br>
 * By valid I mean in its constrain if it have one.
 * @method  KEN.Drag#_isPositionValid
 * @private
 * @return {boolean} Returns true if the current dragged object position is valid, false if not.
 */
KEN.Drag.prototype._isPositionValid = function()
{
    //If no constrain, the position is always valid.
    if(this._constrain === null)
    {
        return true;
    }

    var o = this._displayObject["globalOffset"]; // o = offset
    var co = this._constrain["globalOffset"]; // co = constrain offset

    //Is it out of bound for left, right, top & bottom?
    var left = (o["left"] < co["left"]);
    var right = (o["left"] + this._displayObject["pixelWidth"] > co["left"] + this._constrain["innerWidth"]);
    var top = (o["top"] < co["top"]);
    var bottom = (o["top"] + this._displayObject["pixelHeight"] > co["top"] + this._constrain["innerHeight"]);

    if(left === true || right === true || top === true || bottom === true)
    {
        return false;
    }
        
    return true;
};

/**
 * Enable the drag on its display object
 * @method KEN.Drag.enable
 */
KEN.Drag.prototype.enable = function()
{
    this._enabled = true;
    this._setHandleObject(this._handleObject);
};

/**
 * Disable the drag on its display object
 * @method KEN.Drag.disable
 */
KEN.Drag.prototype.disable = function()
{
    this._enabled = false;
};

/**
 * Destroy sequence
 * @method KEN.Drag#destroy
 */
KEN.Drag.prototype.destroy = function()
{
    this["revert"] = false; //This unbind events and nullify revertTween

    if(this._onStart !== null)
    {
        this._onStart.destroy();
        this._onStart = null;
    }

    if(this._onDrag !== null)
    {
        this._onDrag.destroy();
        this._onDrag = null;
    }

    if(this._onStop !== null)
    {
        this._onStop.destroy();
        this._onStop = null;
    }

    if(this._onRevert !== null)
    {
        this._onRevert.destroy();
        this._onRevert = null;
    }

    this._handleObject = null;
    this._displayObject = null;
    this._constrain = null;

    this._lastMousePosition = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Enabled flag for the drag module
 * @name KEN.Drag#enabled
 * @type {boolean} 
 * @default false
 */
KEN.Drag.prototype.enabled;
Object.defineProperty(KEN.Drag.prototype, "enabled", 
{
    /** @this {KEN.Drag} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {KEN.Drag} */
    set: function(value)
    {
        var enabled = Boolean(value);

        if(enabled === true)
        {
            this.enable();
        }
        else
        {
            this.disable();
        }
    }
});

/**
 * Dragging flag for the drag module
 * @name KEN.Drag#dragging
 * @readonly
 * @type {boolean} 
 */
KEN.Drag.prototype.dragging;
Object.defineProperty(KEN.Drag.prototype, "dragging", 
{
    /** @this {KEN.Drag} */
    get: function()
    {
        return this._dragging;
    }
});

/**
 * Get and set the handle object
 * @name KEN.Drag#handle
 * @type {KEN.DisplayObject} 
 */
KEN.Drag.prototype.handle;
Object.defineProperty(KEN.Drag.prototype, "handle", 
{
    /** @this {KEN.Drag} */
    get: function()
    {
        return this._handleObject;
    },

    /** @this {KEN.Drag} */
    set: function(value)
    {
        this._setHandleObject(value);
    }
});

/**
 * Get and set the constrain object
 * @name KEN.Drag#constrain
 * @type {KEN.DisplayObject} 
 * @default  null
 */
KEN.Drag.prototype.constrain;
Object.defineProperty(KEN.Drag.prototype, "constrain", 
{
    /** @this {KEN.Drag} */
    get: function()
    {
        return this._constrain;
    },

    /** @this {KEN.Drag} */
    set: function(value)
    {
        this._constrain = value;
    }
});

/**
 * Get the progress of the drag position on its contrain on two axes.<br>
 * If no constrain, this wiil return undefined.
 * @name  KEN.Drag#progress
 * @readonly
 * @type {Object}
 * @property {number} [x] The progress on x axis between 0 and 1.
 * @property {number} [y] The progress on y axis between 0 and 1.
 */
KEN.Drag.prototype.progress;
Object.defineProperty(KEN.Drag.prototype, "progress", 
{
    /** @this {KEN.Drag} */
    get: function()
    {
        if(this._constrain === null)
        {
            return undefined;
        }

        var o = this._displayObject["globalOffset"]; // o = offset
        var co = this._constrain["globalOffset"]; // co = constrain offset
        var progressX = (o["left"] - co["left"]) / (this._constrain["innerWidth"] - this._displayObject["pixelWidth"]);
        var progressY = (o["top"] - co["top"]) / (this._constrain["innerHeight"] - this._displayObject["pixelHeight"]);
        return {x: progressX, y: progressY};
    }
});

/**
 * Get and set the axis constrains.<br>
 * Values can be "x" or "y".<br>
 * To disable axis constrain, you can set an empty string or anything else.
 * @name KEN.Drag#axis
 * @type {string} 
 * @default  "empty string"
 */
KEN.Drag.prototype.axis;
Object.defineProperty(KEN.Drag.prototype, "axis", 
{
    /** @this {KEN.Drag} */
    get: function()
    {
        return this._axis;
    },

    /** @this {KEN.Drag} */
    set: function(value)
    {
        if(value === "x" || value === "y")
        {
            this._axis = value;
        }
        else
        {
            this._axis = "";
        }
    }
});

/**
 * Get and set the alpha of the display object during drag
 * Value can be between 0 and 1.
 * @name KEN.Drag#alpha
 * @type {number} 
 * @default 1
 */
KEN.Drag.prototype.alpha;
Object.defineProperty(KEN.Drag.prototype, "alpha", 
{
    /** @this {KEN.Drag} */
    get: function()
    {
        return this._alpha;
    },

    /** @this {KEN.Drag} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._alpha = value;
        }
    }
});

/**
 * Reverting flag for the drag module
 * @name KEN.Drag#reverting
 * @readonly
 * @type {boolean} 
 */
KEN.Drag.prototype.reverting;
Object.defineProperty(KEN.Drag.prototype, "reverting", 
{
    /** @this {KEN.Drag} */
    get: function()
    {
        return this._reverting;
    }
});

/**
 * Get and set the revert flag.
 * If revert is at true, the display object will revert its position to its original position after the drag stop.
 * @name KEN.Drag#revert
 * @type {boolean} 
 * @default  false
 */
KEN.Drag.prototype.revert;
Object.defineProperty(KEN.Drag.prototype, "revert", 
{
    /** @this {KEN.Drag} */
    get: function()
    {
        return this._revert;
    },

    /** @this {KEN.Drag} */
    set: function(value)
    {
        this._revert = Boolean(value);

        if(this._revert === true && this._revertTween === null)
        {
            this._revertTween = new KEN.Tween(this._displayObject["viewer"], this._displayObject);
            this._revertTween["onComplete"].add(this._revertCompleteHandler, this);
            this._displayObject["viewer"]["tween"].add(this._revertTween);
        }
        else if(this._revert === false && this._revertTween !== null)
        {
            this._displayObject["viewer"]["tween"].remove(this._revertTween);
            this._revertTween["onComplete"].remove(this._revertCompleteHandler, this);
            this._revertTween.destroy();
            this._revertTween = null;
        }
    }
});

/**
 * Get and set the revert duration in milliseconds
 * @name KEN.Drag#revertDuration
 * @type {number} 
 * @default  200
 */
KEN.Drag.prototype.revertDuration;
Object.defineProperty(KEN.Drag.prototype, "revertDuration", 
{
    /** @this {KEN.Drag} */
    get: function()
    {
        return this._revertDuration;
    },

    /** @this {KEN.Drag} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._revertDuration = value;
        }
    }
});

/**
 * Get and set the revert easing method
 * @name KEN.Drag#revertEasing
 * @type {Function} 
 * @default KEN.Easing.LINEAR
 */
KEN.Drag.prototype.revertEasing;
Object.defineProperty(KEN.Drag.prototype, "revertEasing", 
{
    /** @this {KEN.Drag} */
    get: function()
    {
        return this._revertEasing;
    },

    /** @this {KEN.Drag} */
    set: function(value)
    {
        if(typeof value === "function")
        {
            this._revertEasing = value;
        }
    }
});


/**
 * Get the onStart {@link KEN.EventDispatcher}.
 * @name  KEN.Drag#onStart
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Drag.prototype.onStart;
Object.defineProperty(KEN.Drag.prototype, "onStart", 
{
    /** @this {KEN.Drag} */
    get: function()
    {
        if(this._onStart === null)
        {
            this._onStart = new KEN.EventDispatcher(this._displayObject);
        }
        
        return this._onStart;
    }
});

/**
 * Get the onDrag {@link KEN.EventDispatcher}.
 * @name  KEN.Drag#onDrag
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Drag.prototype.onDrag;
Object.defineProperty(KEN.Drag.prototype, "onDrag", 
{
    /** @this {KEN.Drag} */
    get: function()
    {
        if(this._onDrag === null)
        {
            this._onDrag = new KEN.EventDispatcher(this._displayObject);
        }
        
        return this._onDrag;
    }
});

/**
 * Get the onStop {@link KEN.EventDispatcher}.
 * @name  KEN.Drag#onStop
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Drag.prototype.onStop;
Object.defineProperty(KEN.Drag.prototype, "onStop", 
{
    /** @this {KEN.Drag} */
    get: function()
    {
        if(this._onStop === null)
        {
            this._onStop = new KEN.EventDispatcher(this._displayObject);
        }
        
        return this._onStop;
    }
});

/**
 * Get the onRevert {@link KEN.EventDispatcher}.
 * @name  KEN.Drag#onRevert
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Drag.prototype.onRevert;
Object.defineProperty(KEN.Drag.prototype, "onRevert", 
{
    /** @this {KEN.Drag} */
    get: function()
    {
        if(this._onRevert === null)
        {
            this._onRevert = new KEN.EventDispatcher(this._displayObject);
        }
        
        return this._onRevert;
    }
});



/**
 * Pointer input management, work with mouse and touch screen (using Hammer.js)
 * @constructor KEN.Pointer
 * @param {KEN.DisplayObject} displayObject - The display object on which you want to listen to pointer events
 * @extends {KEN.BaseObject}
 *
 * @todo prevent event binding if not supported (ex: prevent pinch if not touch screen)
 */
KEN.Pointer = function(displayObject)
{
    /**
     * The {@link KEN.DisplayObject} on which events will be listened.
     * @name KEN.Pointer#_displayObject
     * @type {KEN.DisplayObject}
     * @private
     */
    this._displayObject = displayObject;

    /**
     * Enabled flag for pointer module
     * @name  KEN.Pointer#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = false;

    /**
     * Cursor css string.
     * @name KEN.Pointer#_cursor
     * @type {string}
     * @private
     */
    this._cursor = KEN.Pointer.cursors.DEFAULT;

    /**
     * Hammer manager reference.
     * @name KEN.Pointer#_hammer
     * @type {Hammer.Manager}
     * @private
     */
    this._hammer = null;

    /**
     * Array that keeps reference to listeners.
     * @name KEN.Pointer#_listeners
     * @type {Array}
     * @private
     */
    this._listeners = [];

    /**
     * Hammer Tap recognizer
     * @name KEN.Pointer._tap
     * @type {Hammer.Tap}
     * @private
     */
    this._tap = null;

    /**
     * Hammer Double tap recognizer
     * @name KEN.Pointer._doubleTap
     * @type {Hammer.Tap}
     * @private
     */
    this._doubleTap = null;

    /**
     * Hammer Press recognizer
     * @name KEN.Pointer._press
     * @type {Hammer.Press}
     * @private
     */
    this._press = null;

    /**
     * Hammer Pan recognizer
     * @name KEN.Pointer._pan
     * @type {Hammer.Pan}
     * @private
     */
    this._pan = null;

    /**
     * Hammer Pinch recognizer
     * @name KEN.Pointer._pinch
     * @type {Hammer.Pinch}
     * @private
     */
    this._pinch = null;

    /**
     * Hammer Rotate recognizer
     * @name KEN.Pointer._rotate
     * @type {Hammer.Rotate}
     * @private
     */
    this._rotate = null;

    /**
     * Hammer Swipe recognizer
     * @name KEN.Pointer._swipe
     * @type {Hammer.Swipe}
     * @private
     */
    this._swipe = null;

    /**
     * {@link KEN.EventDispatcher} for the enable event.
     * @name KEN.Pointer#_onEnable
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onEnable = null;

    /**
     * {@link KEN.EventDispatcher} for the disable event.
     * @name KEN.Pointer#_onDisable
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onDisable = null;

    /**
     * {@link KEN.EventDispatcher} for the tap event.
     * @name KEN.Pointer#_onTap
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onTap = null; //alias onClick

    /**
     * {@link KEN.EventDispatcher} for the double tap event.
     * @name KEN.Pointer#_onDoubleTap
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onDoubleTap = null; //alias onDoubleClick

    /**
     * {@link KEN.EventDispatcher} for the press start event.
     * @name KEN.Pointer#_onPressStart
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPressStart = null; //alias onMouseDown

    /**
     * {@link KEN.EventDispatcher} for the press end event.
     * @name KEN.Pointer#_onPressEnd
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPressEnd = null; //alias onMouseUp

    /**
     * {@link KEN.EventDispatcher} for the pan start event.
     * @name KEN.Pointer#_onPanStart
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPanStart = null;

    /**
     * {@link KEN.EventDispatcher} for the pan move event.
     * @name KEN.Pointer#_onPanMove
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPanMove = null;

    /**
     * {@link KEN.EventDispatcher} for the pan end event.
     * @name KEN.Pointer#_onPanEnd
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPanEnd = null;

    /**
     * {@link KEN.EventDispatcher} for the pinch start event.
     * @name KEN.Pointer#_onPinchStart
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPinchStart = null;

    /**
     * {@link KEN.EventDispatcher} for the pinch move event.
     * @name KEN.Pointer#_onPinchMove
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPinchMove = null;

    /**
     * {@link KEN.EventDispatcher} for the pinch end event.
     * @name KEN.Pointer#_onPinchEnd
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPinchEnd = null;

    /**
     * {@link KEN.EventDispatcher} for the rotate start event.
     * @name KEN.Pointer#_onRotateStart
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onRotateStart = null;

    /**
     * {@link KEN.EventDispatcher} for the rotate move event.
     * @name KEN.Pointer#_onRotateMove
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onRotateMove = null;

    /**
     * {@link KEN.EventDispatcher} for the rotate end event.
     * @name KEN.Pointer#_onRotateEnd
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onRotateEnd = null;

    /**
     * {@link KEN.EventDispatcher} for the swipe event.
     * @name KEN.Pointer#_onSwipe
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onSwipe = null;

    /**
     * {@link KEN.EventDispatcher} for the enter event.
     * @name KEN.Pointer#_onEnter
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onEnter = null;

    /**
     * {@link KEN.EventDispatcher} for the leave event.
     * @name KEN.Pointer#_onLeave
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onLeave = null;

    /**
     * {@link KEN.EventDispatcher} for the over event.
     * @name KEN.Pointer#_onOver
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onOver = null;

    /**
     * {@link KEN.EventDispatcher} for the out event.
     * @name KEN.Pointer#_onOut
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onOut = null;

    /**
     * {@link KEN.EventDispatcher} for the move event.
     * @name KEN.Pointer#_onMove
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onMove = null;

    /**
     * {@link KEN.EventDispatcher} for the wheel event.
     * @name KEN.Pointer#_onWheel
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onWheel = null;

    KEN.BaseObject.call(this, "Pointer");

    this._boot();
};

KEN.Pointer.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Pointer.prototype.constructor = KEN.Pointer;

/**
 * Boot sequence
 * @method  KEN.Pointer#_boot
 * @private
 */
KEN.Pointer.prototype._boot = function()
{
    //Create a Hammer manager
    this._hammer = new Hammer.Manager(this._displayObject["dom"]);
    //Disabled by default
    this._hammer.set({ enable: false });
};

/**
 * Get the index of a listener (event + callback + type), internal only.
 * @method KEN.Pointer#_indexOfListener
 * @private
 * @param  {string} event - The event name ("tap", "swipe", click", "mousedown", "mouseover" ...).
 * @param  {Function} callback - The function that handles the event, this is one of the private function like _tapHandler for tap & click event.
 * @param  {number} type - The type of listener (could be 0 for native or 1 for hammer)
 * @return {number} Returns the index of the reserached listener if found, -1 if not.
 */
KEN.Pointer.prototype._indexOfListener = function(event, callback, type)
{
    var listener;

    for ( var i = 0, ii = this._listeners.length; i < ii; i++ )
    {
        listener = this._listeners[i];

        if(listener.event === event && listener.callback === callback && listener["type"] === type)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Add a callback function associated to an event name.
 * @method KEN.Pointer#_addListener
 * @private
 * @param  {string} event - The event name ("tap", "swipe", click", "mousedown", "mouseover" ...).
 * @param  {Function} callback - The function that handles the event, this is one of the private function like _tapHandler for tap & click event.
 * @param  {number} type - The type of listener (could be 0 for native or 1 for hammer)
 * @return {boolean} Returns true if the listener is successfully added, false if not.
 */
KEN.Pointer.prototype._addListener = function(event, callback, type)
{
    var index = this._indexOfListener(event, callback, type);

    if(index === -1)
    {
        this._listeners.push({ event: event, callback: callback, type: type });

        if(type === KEN.Pointer.listenerTypes.NATIVE)
        {
            this._displayObject["dom"].addEventListener(event, Hammer.bindFn(callback, this)); 
        }
        else if(type === KEN.Pointer.listenerTypes.HAMMER)
        {
            this._hammer.on(event, Hammer.bindFn(callback, this));
        }

        return true;
    }
    
    return false;
};

/**
 * Remove a lister function associated to an HTML DOM mouse related event name.
 * @method KEN.Pointer#_removeListener
 * @private
 * @param  {string} event - The event name ("tap", "swipe", click", "mousedown", "mouseover" ...).
 * @param  {Function} callback - The function that handles the event, this is one of the private function like _tapHandler for tap & click event.
 * @param  {number} type - The type of listener (could be 0 for native or 1 for hammer)
 * @return {boolean} Returns true if the listener is successfully removed, false if not.
 */
KEN.Pointer.prototype._removeListener = function(event, callback, type)
{
    var index = this._indexOfListener(event, callback, type);

    if(index !== -1)
    {
        this._listeners.splice(index, 1);

        if(type === KEN.Pointer.listenerTypes.NATIVE)
        {
            this._displayObject["dom"].removeEventListener(event, callback); 
        }
        else if(type === KEN.Pointer.listenerTypes.HAMMER)
        {
            this._hammer.off(event);
        }

        return true;
    }
    
    return false;
};

/**
 * Handler to remove event listener on mouse events.
 * @method KEN.Pointer#_generateDestroyCallback
 * @private
 * @param  {string} event - The event name ("tap", "swipe", click", "mousedown", "mouseover" ...).
 * @param  {Function} callback - The function that handles the event, this is one of the private function like _tapHandler for tap & click event.
 * @param  {number} type - The type of listener (could be 0 for native or 1 for hammer)
 */
KEN.Pointer.prototype._generateDestroyCallback = function(event, callback, type)
{
    var destroyCallback = function destroyCallback()
    { 
        this._removeListener(event, callback, type); 
    };

    return destroyCallback;
};

/**
 * Internal handler for the "tap" event.
 * @method KEN.Pointer#_tapHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
KEN.Pointer.prototype._tapHandler = function(event)
{   
    if(this._onTap !== null && this._enabled === true)
    {
        this._onTap.dispatch(event);
    }
};

/**
 * Internal handler for the "doubletap" event.
 * @method KEN.Pointer#_doubleTapHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
KEN.Pointer.prototype._doubleTapHandler = function(event)
{   
    if(this._onDoubleTap !== null && this._enabled === true)
    {
        this._onDoubleTap.dispatch(event);
    }
};

/**
 * Internal handler for the "pressstart" event.
 * @method KEN.Pointer#_pressStartHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
KEN.Pointer.prototype._pressStartHandler = function(event)
{
    if(this._onPressStart !== null && this._enabled === true)
    {
        this._onPressStart.dispatch(event);
    }
};

/**
 * Internal handler for the "pressend" event.
 * @method KEN.Pointer#_pressEndHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
KEN.Pointer.prototype._pressEndHandler = function(event)
{
    if(this._onPressEnd !== null && this._enabled === true)
    {
        this._onPressEnd.dispatch(event);
    }
};

/**
 * Internal handler for the "panstart" event.
 * @method KEN.Pointer#_panStartHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
KEN.Pointer.prototype._panStartHandler = function(event)
{
    if(this._onPanStart !== null && this._enabled === true)
    {
        this._onPanStart.dispatch(event);
    }
};

/**
 * Internal handler for the "panmove" event.
 * @method KEN.Pointer#_panMoveHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
KEN.Pointer.prototype._panMoveHandler = function(event)
{
    if(this._onPanMove !== null && this._enabled === true)
    {
        this._onPanMove.dispatch(event);
    }
};

/**
 * Internal handler for the "panend" event.
 * @method KEN.Pointer#_panEndHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
KEN.Pointer.prototype._panEndHandler = function(event)
{
    if(this._onPanEnd !== null && this._enabled === true)
    {
        this._onPanEnd.dispatch(event);
    }
};

/**
 * Internal handler for the "pinchstart" event.
 * @method KEN.Pointer#_pinchStartHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
KEN.Pointer.prototype._pinchStartHandler = function(event)
{
    if(this._onPinchStart !== null && this._enabled === true)
    {
        this._onPinchStart.dispatch(event);
    }
};

/**
 * Internal handler for the "pinchmove" event.
 * @method KEN.Pointer#_pinchMoveHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
KEN.Pointer.prototype._pinchMoveHandler = function(event)
{
    if(this._onPinchMove !== null && this._enabled === true)
    {
        this._onPinchMove.dispatch(event);
    }
};

/**
 * Internal handler for the "pinchend" event.
 * @method KEN.Pointer#_pinchEndHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
KEN.Pointer.prototype._pinchEndHandler = function(event)
{
    if(this._onPinchEnd !== null && this._enabled === true)
    {
        this._onPinchEnd.dispatch(event);
    }
};

/**
 * Internal handler for the "rotatestart" event.
 * @method KEN.Pointer#_rotateStartHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
KEN.Pointer.prototype._rotateStartHandler = function(event)
{
    if(this._onRotateStart !== null && this._enabled === true)
    {
        this._onRotateStart.dispatch(event);
    }
};

/**
 * Internal handler for the "rotatemove" event.
 * @method KEN.Pointer#_rotateMoveHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
KEN.Pointer.prototype._rotateMoveHandler = function(event)
{
    if(this._onRotateMove !== null && this._enabled === true)
    {
        this._onRotateMove.dispatch(event);
    }
};

/**
 * Internal handler for the "rotateend" event.
 * @method KEN.Pointer#_rotateEndHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
KEN.Pointer.prototype._rotateEndHandler = function(event)
{
    if(this._onRotateEnd !== null && this._enabled === true)
    {
        this._onRotateEnd.dispatch(event);
    }
};

/**
 * Internal handler for the "swipe" event.
 * @method KEN.Pointer#_swipeHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
KEN.Pointer.prototype._swipeHandler = function(event)
{
    if(this._onSwipe !== null && this._enabled === true)
    {
        this._onSwipe.dispatch(event);
    }
};

/**
 * Internal handler for the "mouseenter" event.
 * @method KEN.Pointer#_enterHandler
 * @private
 * @param  {MouseEvent} event - The mouse event.
 */
KEN.Pointer.prototype._enterHandler = function(event)
{
    if(this._onEnter !== null && this._enabled === true)
    {
        this._onEnter.dispatch(event);
    }
};

/**
 * Internal handler for the "mouseleave" event.
 * @method KEN.Pointer#_leaveHandler
 * @private
 * @param  {Object} event - The mouse event.
 */
KEN.Pointer.prototype._leaveHandler = function(event)
{
    if(this._onLeave !== null && this._enabled === true)
    {
        this._onLeave.dispatch(event);
    }
};

/**
 * Internal handler for the "mouseover" event.
 * @method KEN.Pointer#_overHandler
 * @private
 * @param  {Object} event - The mouse event.
 */
KEN.Pointer.prototype._overHandler = function(event)
{
    if(this._onOver !== null && this._enabled === true)
    {
        this._onOver.dispatch(event);
    }
};

/**
 * Internal handler for the "mouseout" event.
 * @method KEN.Pointer#_outHandler
 * @private
 * @param  {Object} event - The mouse event.
 */
KEN.Pointer.prototype._outHandler = function(event)
{
    if(this._onOut !== null && this._enabled === true)
    {
        this._onOut.dispatch(event);
    }
};

/**
 * Internal handler for the "mousemove" event.
 * @method KEN.Pointer#_moveHandler
 * @private
 * @param  {Object} event - The mouse event.
 */
KEN.Pointer.prototype._moveHandler = function(event)
{
    if(this._onMove !== null && this._enabled === true)
    {
        this._onMove.dispatch(event);
    }
};

/**
 * Internal handler for the "wheel" event.
 * @method KEN.Pointer#_wheelHandler
 * @private
 * @param  {Object} event - The mouse event.
 */
KEN.Pointer.prototype._wheelHandler = function(event)
{
    if(this._onWheel !== null && this._enabled === true)
    {
        this._onWheel.dispatch(event);
    }
};

/**
 * Enable the pointer module
 * @method  KEN.Pointer#enable
 */
KEN.Pointer.prototype.enable = function()
{
    if(KEN.Device.cssPointerEvents === true)
    {
        this._displayObject["dom"].style.pointerEvents = "auto";
    }

    this._hammer.set({ enable: true });

    if(this._tap === null)
    {
        this._tap = new Hammer.Tap();
        this._hammer.add(this._tap);    
    }

    if(this._doubleTap === null)
    {
        this._doubleTap = new Hammer.Tap({ event: KEN.Pointer.events.DOUBLE_TAP, taps: 2}).recognizeWith(this._tap);
        this._hammer.add(this._doubleTap);
    }

    if(this._press === null)
    {
        this._press = new Hammer.Press().recognizeWith(this._tap); //{ time: 0 }
        this._hammer.add(this._press);
    }

    if(this._pan === null)
    {
        this._pan = new Hammer.Pan();
        this._hammer.add(this._pan);
    }

    if(this._pinch === null)
    {
        this._pinch = new Hammer.Pinch();
        this._hammer.add(this._pinch);
    }

    if(this._rotate === null)
    {
        this._rotate = new Hammer.Rotate().recognizeWith(this._pinch);
        this._hammer.add(this._rotate);
    }

    if(this._swipe === null)
    {
        this._swipe = new Hammer.Swipe().recognizeWith(this._pan);
        this._hammer.add(this._swipe);
    }

    this._enabled = true;

    if(this._onEnable !== null)
    {
        this._onEnable.dispatch();
    }
};

/**
 * Disable the pointer module
 * @method  KEN.Pointer#disable
 */
KEN.Pointer.prototype.disable = function()
{
    if(KEN.Device.cssPointerEvents === true)
    {
        this._displayObject["dom"].style.pointerEvents = "none";
    }

    this._enabled = false;

    this._hammer.set({ enable: false });

    if(this._onDisable !== null)
    {
        this._onDisable.dispatch();
    }
};

/**
 * Destroy sequence
 * @method  KEN.Pointer#destroy
 */
KEN.Pointer.prototype.destroy = function()
{
    this.disable();

    this._tap = null;
    this._doubleTap = null;
    this._press = null;
    this._pan = null;
    this._pinch = null;
    this._rotate = null;
    this._swipe = null;

    if(this._onEnable !== null)
    {
        this._onEnable.destroy();
        this._onEnable = null;
    }

    if(this._onDisable !== null)
    {
        this._onDisable.destroy();
        this._onDisable = null;
    }

    if(this._onTap !== null)
    {
        this._onTap.destroy();
        this._onTap = null;
    }

    if(this._onDoubleTap !== null)
    {
        this._onDoubleTap.destroy();
        this._onDoubleTap = null;
    }

    if(this._onPressStart !== null)
    {
        this._onPressStart.destroy();
        this._onPressStart = null;
    }

    if(this._onPressEnd !== null)
    {
        this._onPressEnd.destroy();
        this._onPressEnd = null;
    }

    if(this._onPanStart !== null)
    {
        this._onPanStart.destroy();
        this._onPanStart = null;
    }

    if(this._onPanMove !== null)
    {
        this._onPanMove.destroy();
        this._onPanMove = null;
    }

    if(this._onPanEnd !== null)
    {
        this._onPanEnd.destroy();
        this._onPanEnd = null;
    }

    if(this._onPinchStart !== null)
    {
        this._onPinchStart.destroy();
        this._onPinchStart = null;
    }

    if(this._onPinchMove !== null)
    {
        this._onPinchMove.destroy();
        this._onPinchMove = null;
    }

    if(this._onPinchEnd !== null)
    {
        this._onPinchEnd.destroy();
        this._onPinchEnd = null;
    }

    if(this._onRotateStart !== null)
    {
        this._onRotateStart.destroy();
        this._onRotateStart = null;
    }

    if(this._onRotateMove !== null)
    {
        this._onRotateMove.destroy();
        this._onRotateMove = null;
    }

    if(this._onRotateEnd !== null)
    {
        this._onRotateEnd.destroy();
        this._onRotateEnd = null;
    }

    if(this._onSwipe !== null)
    {
        this._onSwipe.destroy();
        this._onSwipe = null;
    }

    if(this._onEnter !== null)
    {
        this._onEnter.destroy();
        this._onEnter = null;
    }

    if(this._onLeave !== null)
    {
        this._onLeave.destroy();
        this._onLeave = null;
    }

    if(this._onOver !== null)
    {
        this._onOver.destroy();
        this._onOver = null;
    }

    if(this._onOut !== null)
    {
        this._onOut.destroy();
        this._onOut = null;
    }

    if(this._onMove !== null)
    {
        this._onMove.destroy();
        this._onMove = null;
    }

    if(this._onWheel !== null)
    {
        this._onWheel.destroy();
        this._onWheel = null;
    }

    this._displayObject = null;
};

/**
* Get or set the enabled flag.
* @name KEN.Pointer#enabled
* @type {boolean} 
*/
KEN.Pointer.prototype.enabled;
Object.defineProperty(KEN.Pointer.prototype, "enabled",
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {KEN.Pointer} */
    set: function(value)
    {
        if(Boolean(value) === true)
        {
            this.enable();
        }
        else
        {
            this.disable();
        }
    }
});

/**
* Get or set the cursor value.<br>
* Use the constant {@link KEN.Pointer.cursors} to set a valid cursor.
* @name KEN.Pointer#cursor
* @type {string} 
*/
KEN.Pointer.prototype.cursor;
Object.defineProperty(KEN.Pointer.prototype, "cursor", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        return this._cursor;
    },

    /** @this {KEN.Pointer} */
    set: function(value)
    {
        this._displayObject["dom"].style["cursor"] = value;

        //On webkit browsers some cursors have to have -webkit prefix
        //If invalid cursor value, webkit will leave an empty string or the previous value intact.
        if(value !== this._displayObject["dom"].style["cursor"] || this._displayObject["dom"].style["cursor"] === "")
        {
            this._displayObject["dom"].style["cursor"] = "-webkit-"+value;
        }

        this._cursor = value;
    }
});

/**
* Gets the onEnable {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.
* @name KEN.Pointer#onEnable
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onEnable;
Object.defineProperty(KEN.Pointer.prototype, "onEnable", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onEnable === null)
        {
            this._onEnable = new KEN.EventDispatcher(this);
        }

        return this._onEnable;
    }
});

/**
* Gets the onDisable {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.
* @name KEN.Pointer#onDisable
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onDisable;
Object.defineProperty(KEN.Pointer.prototype, "onDisable", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onDisable === null)
        {
            this._onDisable = new KEN.EventDispatcher(this);
        }

        return this._onDisable;
    }
});

/**
* Gets the onTap {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.
* @name KEN.Pointer#onTap
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onTap;
Object.defineProperty(KEN.Pointer.prototype, "onTap", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onTap === null)
        {
            this._onTap = new KEN.EventDispatcher(this._displayObject);
            this._onTap["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.TAP, this._tapHandler, KEN.Pointer.listenerTypes.HAMMER), this );
            this._addListener(KEN.Pointer.events.TAP, this._tapHandler, KEN.Pointer.listenerTypes.HAMMER);
        }

        return this._onTap;
    }
});

/**
* Gets the onClick {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* This is an alias for onTap.
* @name KEN.Pointer#onClick
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onClick;
Object.defineProperty(KEN.Pointer.prototype, "onClick", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        return this["onTap"];
    }
});

/**
* Gets the onDoubleTap {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.
* @name KEN.Pointer#onDoubleTap
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onDoubleTap;
Object.defineProperty(KEN.Pointer.prototype, "onDoubleTap", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onDoubleTap === null)
        {
            this._onDoubleTap = new KEN.EventDispatcher(this._displayObject);
            this._onDoubleTap["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.DOUBLE_TAP, this._doubleTapHandler, KEN.Pointer.listenerTypes.HAMMER), this );
            this._addListener(KEN.Pointer.events.DOUBLE_TAP, this._doubleTapHandler, KEN.Pointer.listenerTypes.HAMMER);
        }

        return this._onDoubleTap;
    }
});

/**
* Gets the onDoubleClick {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* This is an alias for onDoubleTap.
* @name KEN.Pointer#onDoubleClick
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onDoubleClick;
Object.defineProperty(KEN.Pointer.prototype, "onDoubleClick", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        return this["onDoubleTap"];
    }
});

/**
* Gets the onPressStart {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onPressStart
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onPressStart;
Object.defineProperty(KEN.Pointer.prototype, "onPressStart", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onPressStart === null)
        {
            this._onPressStart = new KEN.EventDispatcher(this._displayObject);
            this._onPressStart["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.PRESS_START, this._pressStartHandler, KEN.Pointer.listenerTypes.HAMMER), this );
            this._addListener(KEN.Pointer.events.PRESS_START, this._pressStartHandler, KEN.Pointer.listenerTypes.HAMMER);
        }

        return this._onPressStart;
    }
});

/**
* Gets the onDown {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* This is an alias for onPressStart.
* @name KEN.Pointer#onDown
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onDown;
Object.defineProperty(KEN.Pointer.prototype, "onDown", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        return this["onPressStart"];
    }
});

/**
* Gets the onPressEnd {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onPressEnd
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onPressEnd;
Object.defineProperty(KEN.Pointer.prototype, "onPressEnd", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onPressEnd === null)
        {
            this._onPressEnd = new KEN.EventDispatcher(this._displayObject);
            this._onPressEnd["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.PRESS_END, this._pressEndHandler, KEN.Pointer.listenerTypes.HAMMER), this );
            this._addListener(KEN.Pointer.events.PRESS_END, this._pressEndHandler, KEN.Pointer.listenerTypes.HAMMER);
        }

        return this._onPressEnd;
    }
});

/**
* Gets the onUp {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* This is an alias for onPressEnd.
* @name KEN.Pointer#onUp
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onUp;
Object.defineProperty(KEN.Pointer.prototype, "onUp", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        return this["onPressEnd"];
    }
});

/**
* Gets the onPanStart {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onPanStart
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onPanStart;
Object.defineProperty(KEN.Pointer.prototype, "onPanStart", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onPanStart === null)
        {
            this._onPanStart = new KEN.EventDispatcher(this._displayObject);
            this._onPanStart["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.PAN_START, this._panStartHandler, KEN.Pointer.listenerTypes.HAMMER), this );
            this._addListener(KEN.Pointer.events.PAN_START, this._panStartHandler, KEN.Pointer.listenerTypes.HAMMER);
        }

        return this._onPanStart;
    }
});

/**
* Gets the onPanMove {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onPanMove
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onPanMove;
Object.defineProperty(KEN.Pointer.prototype, "onPanMove", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onPanMove === null)
        {
            this._onPanMove = new KEN.EventDispatcher(this._displayObject);
            this._onPanMove["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.PAN_MOVE, this._panMoveHandler, KEN.Pointer.listenerTypes.HAMMER), this );
            this._addListener(KEN.Pointer.events.PAN_MOVE, this._panMoveHandler, KEN.Pointer.listenerTypes.HAMMER);
        }

        return this._onPanMove;
    }
});

/**
* Gets the onPanEnd {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onPanEnd
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onPanEnd;
Object.defineProperty(KEN.Pointer.prototype, "onPanEnd", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onPanEnd === null)
        {
            this._onPanEnd = new KEN.EventDispatcher(this._displayObject);
            this._onPanEnd["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.PAN_END, this._panEndHandler, KEN.Pointer.listenerTypes.HAMMER), this );
            this._addListener(KEN.Pointer.events.PAN_END, this._panEndHandler, KEN.Pointer.listenerTypes.HAMMER);
        }

        return this._onPanEnd;
    }
});

/**
* Gets the onPinchStart {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onPinchStart
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onPinchStart;
Object.defineProperty(KEN.Pointer.prototype, "onPinchStart", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onPinchStart === null)
        {
            this._onPinchStart = new KEN.EventDispatcher(this._displayObject);
            this._onPinchStart["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.PINCH_START, this._pinchStartHandler, KEN.Pointer.listenerTypes.HAMMER), this );
            this._addListener(KEN.Pointer.events.PINCH_START, this._pinchStartHandler, KEN.Pointer.listenerTypes.HAMMER);
        }

        return this._onPinchStart;
    }
});

/**
* Gets the onPinchMove {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onPinchMove
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onPinchMove;
Object.defineProperty(KEN.Pointer.prototype, "onPinchMove", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onPinchMove === null)
        {
            this._onPinchMove = new KEN.EventDispatcher(this._displayObject);
            this._onPinchMove["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.PINCH_MOVE, this._pinchMoveHandler, KEN.Pointer.listenerTypes.HAMMER), this );
            this._addListener(KEN.Pointer.events.PINCH_MOVE, this._pinchMoveHandler, KEN.Pointer.listenerTypes.HAMMER);
        }

        return this._onPinchMove;
    }
});

/**
* Gets the onPinchEnd {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onPinchEnd
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onPinchEnd;
Object.defineProperty(KEN.Pointer.prototype, "onPinchEnd", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onPinchEnd === null)
        {
            this._onPinchEnd = new KEN.EventDispatcher(this._displayObject);
            this._onPinchEnd["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.PINCH_END, this._pinchEndHandler, KEN.Pointer.listenerTypes.HAMMER), this );
            this._addListener(KEN.Pointer.events.PINCH_END, this._pinchEndHandler, KEN.Pointer.listenerTypes.HAMMER);
        }

        return this._onPinchEnd;
    }
});

/**
* Gets the onRotateStart {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onRotateStart
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onRotateStart;
Object.defineProperty(KEN.Pointer.prototype, "onRotateStart", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onRotateStart === null)
        {
            this._onRotateStart = new KEN.EventDispatcher(this._displayObject);
            this._onRotateStart["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.ROTATE_START, this._rotateStartHandler, KEN.Pointer.listenerTypes.HAMMER), this );
            this._addListener(KEN.Pointer.events.ROTATE_START, this._rotateStartHandler, KEN.Pointer.listenerTypes.HAMMER);
        }

        return this._onRotateStart;
    }
});

/**
* Gets the onRotateMove {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onRotateMove
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onRotateMove;
Object.defineProperty(KEN.Pointer.prototype, "onRotateMove", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onRotateMove === null)
        {
            this._onRotateMove = new KEN.EventDispatcher(this._displayObject);
            this._onRotateMove["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.ROTATE_MOVE, this._rotateMoveHandler, KEN.Pointer.listenerTypes.HAMMER), this );
            this._addListener(KEN.Pointer.events.ROTATE_MOVE, this._rotateMoveHandler, KEN.Pointer.listenerTypes.HAMMER);
        }

        return this._onRotateMove;
    }
});

/**
* Gets the onRotateEnd {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onRotateEnd
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onRotateEnd;
Object.defineProperty(KEN.Pointer.prototype, "onRotateEnd", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onRotateEnd === null)
        {
            this._onRotateEnd = new KEN.EventDispatcher(this._displayObject);
            this._onRotateEnd["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.ROTATE_END, this._rotateEndHandler, KEN.Pointer.listenerTypes.HAMMER), this );
            this._addListener(KEN.Pointer.events.ROTATE_END, this._rotateEndHandler, KEN.Pointer.listenerTypes.HAMMER);
        }

        return this._onRotateEnd;
    }
});

/**
* Gets the onSwipe {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onSwipe
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onSwipe;
Object.defineProperty(KEN.Pointer.prototype, "onSwipe", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onSwipe === null)
        {
            this._onSwipe = new KEN.EventDispatcher(this._displayObject);
            this._onSwipe["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.SWIPE, this._swipeHandler, KEN.Pointer.listenerTypes.HAMMER), this );
            this._addListener(KEN.Pointer.events.SWIPE, this._swipeHandler, KEN.Pointer.listenerTypes.HAMMER);
        }

        return this._onSwipe;
    }
});

/**
* Gets the onEnter {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onEnter
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onEnter;
Object.defineProperty(KEN.Pointer.prototype, "onEnter", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onEnter === null)
        {
            this._onEnter = new KEN.EventDispatcher(this._displayObject);
            this._onEnter["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.ENTER, this._enterHandler, KEN.Pointer.listenerTypes.NATIVE), this );
            this._addListener(KEN.Pointer.events.ENTER, this._enterHandler, KEN.Pointer.listenerTypes.NATIVE);
        }

        return this._onEnter;
    }
});

/**
* Gets the onLeave {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onLeave
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onLeave;
Object.defineProperty(KEN.Pointer.prototype, "onLeave", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onLeave === null)
        {
            this._onLeave = new KEN.EventDispatcher(this._displayObject);
            this._onLeave["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.LEAVE, this._leaveHandler, KEN.Pointer.listenerTypes.NATIVE), this );
            this._addListener(KEN.Pointer.events.LEAVE, this._leaveHandler, KEN.Pointer.listenerTypes.NATIVE);
        }

        return this._onLeave;
    }
});

/**
* Gets the onOver {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onOver
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onOver;
Object.defineProperty(KEN.Pointer.prototype, "onOver", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onOver === null)
        {
            this._onOver = new KEN.EventDispatcher(this._displayObject);
            this._onOver["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.OVER, this._overHandler, KEN.Pointer.listenerTypes.NATIVE), this );
            this._addListener(KEN.Pointer.events.OVER, this._overHandler, KEN.Pointer.listenerTypes.NATIVE);
        }

        return this._onOver;
    }
});

/**
* Gets the onOut {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onOut
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onOut;
Object.defineProperty(KEN.Pointer.prototype, "onOut", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onOut === null)
        {
            this._onOut = new KEN.EventDispatcher(this._displayObject);
            this._onOut["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.OUT, this._outHandler, KEN.Pointer.listenerTypes.NATIVE), this );
            this._addListener(KEN.Pointer.events.OUT, this._outHandler, KEN.Pointer.listenerTypes.NATIVE);
        }

        return this._onOut;
    }
});

/**
* Gets the onMove {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onMove
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onMove;
Object.defineProperty(KEN.Pointer.prototype, "onMove", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onMove === null)
        {
            this._onMove = new KEN.EventDispatcher(this._displayObject);
            this._onMove["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.MOVE, this._moveHandler, KEN.Pointer.listenerTypes.NATIVE), this );
            this._addListener(KEN.Pointer.events.MOVE, this._moveHandler, KEN.Pointer.listenerTypes.NATIVE);
        }

        return this._onMove;
    }
});

/**
* Gets the onWheel {@link KEN.EventDispatcher}.<br> 
* The {@link KEN.EventDispatcher} is created only if you ask for it.<br>
* @name KEN.Pointer#onWheel
* @type {KEN.EventDispatcher} 
*/
KEN.Pointer.prototype.onWheel;
Object.defineProperty(KEN.Pointer.prototype, "onWheel", 
{
    /** @this {KEN.Pointer} */
    get: function()
    {
        if(this._onWheel === null)
        {
            this._onWheel = new KEN.EventDispatcher(this._displayObject);
            this._onWheel["onDestroy"].addOnce( this._generateDestroyCallback(KEN.Pointer.events.WHEEL, this._wheelHandler, KEN.Pointer.listenerTypes.NATIVE), this );
            this._addListener(KEN.Pointer.events.WHEEL, this._wheelHandler, KEN.Pointer.listenerTypes.NATIVE);
        }

        return this._onWheel;
    }
});

/**
 * @name KEN.Pointer.listenerTypes
 * @type {Object}
 * @const
 */
KEN.Pointer.listenerTypes = {};

/**
 * @name KEN.Pointer.listenerTypes.NATIVE
 * @type {number}
 * @const
 */
KEN.Pointer.listenerTypes.NATIVE = 0;

/**
 * @name KEN.Pointer.listenerTypes.HAMMER
 * @type {number}
 * @const
 */
KEN.Pointer.listenerTypes.HAMMER = 1;


/**
 * @name KEN.Pointer.events
 * @type {Object}
 * @const
 */
KEN.Pointer.events = {};

/**
 * @name KEN.Pointer.events.TAP
 * @type {string}
 * @const
 */
KEN.Pointer.events.TAP = "tap";

/**
 * @name KEN.Pointer.events.DOUBLE_TAP
 * @type {string}
 * @const
 */
KEN.Pointer.events.DOUBLE_TAP = "doubletap";

/**
 * @name KEN.Pointer.events.PRESS_START
 * @type {string}
 * @const
 */
KEN.Pointer.events.PRESS_START = "press";

/**
 * @name KEN.Pointer.events.PRESS_END
 * @type {string}
 * @const
 */
KEN.Pointer.events.PRESS_END = "pressup";

/**
 * @name KEN.Pointer.events.PAN_START
 * @type {string}
 * @const
 */
KEN.Pointer.events.PAN_START = "panstart";

/**
 * @name KEN.Pointer.events.PAN_MOVE 
 * @type {string}
 * @const
 */
KEN.Pointer.events.PAN_MOVE = "panmove";

/**
 * @name KEN.Pointer.events.PAN_END
 * @type {string}
 * @const
 */
KEN.Pointer.events.PAN_END = "panend";

/**
 * @name KEN.Pointer.events.PINCH_START
 * @type {string}
 * @const
 */
KEN.Pointer.events.PINCH_START = "pinchstart";

/**
 * @name KEN.Pointer.events.PINCH_MOVE
 * @type {string}
 * @const
 */
KEN.Pointer.events.PINCH_MOVE = "pinchmove";

/**
 * @name KEN.Pointer.events.PINCH_END
 * @type {string}
 * @const
 */
KEN.Pointer.events.PINCH_END = "pinchend";

/**
 * @name KEN.Pointer.events.ROTATE_START 
 * @type {string}
 * @const
 */
KEN.Pointer.events.ROTATE_START = "rotatestart";

/**
 * @name KEN.Pointer.events.ROTATE_MOVE
 * @type {string}
 * @const
 */
KEN.Pointer.events.ROTATE_MOVE = "rotatemove";

/**
 * @name KEN.Pointer.events.ROTATE_END
 * @type {string}
 * @const
 */
KEN.Pointer.events.ROTATE_END = "rotateend";

/**
 * @name KEN.Pointer.events.SWIPE
 * @type {string}
 * @const
 */
KEN.Pointer.events.SWIPE = "swipe";

/**
 * @name KEN.Pointer.events.ENTER
 * @type {string}
 * @const
 */
KEN.Pointer.events.ENTER = "mouseenter";

/**
 * @name KEN.Pointer.events.LEAVE
 * @type {string}
 * @const
 */
KEN.Pointer.events.LEAVE = "mouseleave";

/**
 * @name KEN.Pointer.events.OVER 
 * @type {string}
 * @const
 */
KEN.Pointer.events.OVER = "mouseover";

/**
 * @name KEN.Pointer.events.OUT
 * @type {string}
 * @const
 */
KEN.Pointer.events.OUT = "mouseout";

/**
 * @name KEN.Pointer.events.MOVE 
 * @type {string}
 * @const
 */
KEN.Pointer.events.MOVE = "mousemove";

/**
 * @name KEN.Pointer.events.WHEEL
 * @type {string}
 * @const
 */
KEN.Pointer.events.WHEEL = "wheel";


/**
 * @name KEN.Pointer.cursors
 * @type {Object}
 * @const
 */
KEN.Pointer.cursors = {};

/**
 * @name KEN.Pointer.cursors.DEFAULT
 * @type {string}
 * @const
 */
KEN.Pointer.cursors.DEFAULT = "default";

/**
 * @name KEN.Pointer.cursors.POINTER
 * @type {string}
 * @const
 */
KEN.Pointer.cursors.POINTER = "pointer";

/**
 * @name KEN.Pointer.cursors.GRAB
 * @type {string}
 * @const
 */
KEN.Pointer.cursors.GRAB = "grab";

/**
 * @name KEN.Pointer.cursors.GRABBING
 * @type {string}
 * @const
 */
KEN.Pointer.cursors.GRABBING = "grabbing";


/**
 * Manage Display Objects list and fullscreen events.
 * @constructor KEN.DisplayList
 * @extends {KEN.BaseObject}
 * @param {KEN.Viewer} viewer - Viewer reference.
 */
KEN.DisplayList = function(viewer)
{
    /**
     * The viewer reference.
     * @name  KEN.DisplayList#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Array that references all the display objects.
     * @name  KEN.DisplayList#_objects
     * @type {Array<KEN.DisplayObject>}
     * @private
     */
    this._objects = [];

    /**
     * Array that references the display objects that needs to be updated.
     * @name  KEN.DisplayList#_objectsToUpdate
     * @type {Array<Object>}
     * @private
     */
    this._objectsToUpdate = [];

    /**
     * fullscreen change handler binded to this context.
     * @name KEN.DisplayList#_fullScreenChangeBind
     * @type {Function}
     * @private
     */
    this._fullScreenChangeBind = null;

    /**
     * The object that is currently in fullscreen.
     * @name KEN.DisplayObject#_fullscreenObject
     * @type {KEN.DisplayObject}
     * @private
     */
    this._fullscreenObject = null;

    KEN.BaseObject.call(this, "DisplayList");

    this._boot();
};

KEN.DisplayList.prototype = Object.create(KEN.BaseObject.prototype);
KEN.DisplayList.prototype.constructor = KEN.DisplayList;

/**
 * Boot sequence
 * @method KEN.DisplayList#_boot
 * @private
 */
KEN.DisplayList.prototype._boot = function()
{
    this._fullScreenChangeBind = this._fullScreenChangeHandler.bind(this);

    //Listen to all kind of events for cross browser compatibility
    document.addEventListener("fullscreenchange", this._fullScreenChangeBind, false);
    document.addEventListener("mozfullscreenchange", this._fullScreenChangeBind, false);
    document.addEventListener("webkitfullscreenchange", this._fullScreenChangeBind, false);
    document.addEventListener("MSFullscreenChange", this._fullScreenChangeBind, false);
};

/**
 * Event handler for full screen change.
 * @name  KEN.DisplayList#_fullScreenChangeHandler
 * @private
 */
KEN.DisplayList.prototype._fullScreenChangeHandler = function()
{
    this.log("_fullScreenChangeHandler");

    if(document[KEN.Device.fullscreenElement] !== null)
    {
        var obj;
        var n = this._objects.length;

        while(n--)
        {
            obj = this._objects[n];

            if(obj["dom"] === document[KEN.Device.fullscreenElement])
            {
                this._fullscreenObject = obj;
                this._fullscreenObject._notifyFullscreenEnter();  
                break; 
            }
        }
    }
    else
    {
        this._fullscreenObject._notifyFullscreenExit();
        this._fullscreenObject = null;
    }
};

/**
 * Registers a display object in the display list.
 * @method  KEN.DisplayList#register
 * @param  {KEN.DisplayObject} object - The display object to register.
 * @param  {boolean=} update - Is this display object needs to be updated updated?
 */
KEN.DisplayList.prototype.register = function(object, update)
{
    this._objects.push(object);

    if(update === true)
    {
        this._objectsToUpdate.push(object);        
    }
};

/**
 * Unregister a display object from the display list.
 * @method  KEN.DisplayList#unregister
 * @param {KEN.DisplayObject} object - The object to unregister from the display list.
 */
KEN.DisplayList.prototype.unregister = function(object)
{
    this._objects.splice(this._objects.indexOf(object), 1);


    var index = this._objectsToUpdate.indexOf(object);

    if(index !== -1)
    {
        this._objectsToUpdate.splice(index, 1);
    }
};

/**
 * Update method of the DisplayList
 * @method KEN.DispalyList#update
 */
KEN.DisplayList.prototype.update = function()
{
    for(var i = 0, ii = this._objectsToUpdate.length; i < ii; i++)
    {
        this._objectsToUpdate[i].update();
    }
};

/**
 * Destroy sequence
 * @method KEN.DisplayList#destroy
 */
KEN.DisplayList.prototype.destroy = function()
{
    var objCount = this._objects.length;
    while(objCount--)
    {
        this._objects[objCount].destroy();
    }

    this._objects = [];
    this._objectsToUpdate = [];

    document.removeEventListener("fullscreenchange", this._fullScreenChangeBind, false);
    document.removeEventListener("mozfullscreenchange", this._fullScreenChangeBind, false);
    document.removeEventListener("webkitfullscreenchange", this._fullScreenChangeBind, false);
    document.removeEventListener("MSFullscreenChange", this._fullScreenChangeBind, false);

    this._fullScreenChangeBind = null;
    this._fullscreenObject = null;
};

/**
 * Types of display objects.
 * @name  KEN.DisplayList.types
 * @type {Array<string>}
 */
KEN.DisplayList.types = 
[
    "DisplayObject", 
    "DisplayObjectContainer", 
    "Image", 
    "TextField", 
    "Button", 
    "Video", 
    "Canvas", 
    "Sprite", 
    "Iframe"
];

/**
 * A display object is a visual element which has width / height and coordianate x / y in space.<br>
 * It's a way to create and manipulate a div element, many other class inherit from this one.
 *
 * @constructor KEN.DisplayObject
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @param {Element|HTMLElement=} dom - Use a specific dom element to be the display object, if undefined a div will be created.
 * @param {string=} className - The className of the object as long as many other object inherits from this one.
 * @extends {KEN.BaseObject}
 *
 * @todo Define a better behavior for anchors / margins. If we set a top and a bottom anchor what happen ?
 * @todo Do the last anchor have the priority ? Does the DisplayObject will change its height if a top and a bottom anchors are set ?
 * @todo  Remove the _borderUpdate, at least find a way to do it properly ?!
 */
KEN.DisplayObject = function(viewer, dom, className)
{
    /**
     * The viewer reference.
     * @name KEN.DisplayObject#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The dom element that represent the display object.
     * @name KEN.DisplayObject#_dom
     * @type {Element|HTMLElement}
     * @private
     */
    this._dom = dom || null;

    /**
     * The parent element of the display object, generally it is a {@link KEN.DisplayObjectContainer}.
     * @name KEN.DisplayObject#_parent
     * @type {?KEN.DisplayObjectContainer|HTMLElement}
     * @private
     */
    this._parent = null;

    /**
     * The index of the display object, understand it as the z-index CSS property.
     * @name KEN.DisplayObject#_index
     * @type {number}
     * @private
     */
    this._index = 0;

    /**
     * The id of the display object, this id is associated to the dom element.
     * @name  KEN.DisplayObject#_id
     * @type {string}
     * @private
     */
    this._id = "";

    /**
     * The x position of the display object relative to it's parent origin.
     * @name  KEN.DisplayObject#_x
     * @type {number}
     * @private
     */
    this._x = 0;

    /**
     * The x position of the display object relative to it's parent origin.
     * @name  KEN.DisplayObject#_y
     * @type {number}
     * @private
     */
    this._y = 0;

    /**
     * Does this display object have to automatically keeps its ratio when width or height change?
     * @name  KEN.DisplayObject#_keepRatio
     * @type {boolean}
     * @private
     */
    this._keepRatio = false;

    /**
     * The width of the display object whatever is its unit, it can be pixel or percent.
     * @name  KEN.DisplayObject#_width
     * @type {number}
     * @private
     */
    this._width = 0;

    /**
     * The unit of the display object's width, it can be "px" or "%".
     * @name  KEN.DisplayObject#_unitWidth
     * @type {string}
     * @private
     */
    this._unitWidth = "px";

    /**
     * The display object's scale width.
     * @name  KEN.DisplayObject#_scaleWidth
     * @type {number}
     * @private
     */
    this._scaleWidth = 1;

    /**
     * The height of the display object whatever is its unit, it can be pixel or percent.
     * @name  KEN.DisplayObject#_height
     * @type {number}
     * @private
     */
    this._height = 0;

    /**
     * The unit of the display object's height, it can be "px" or "%".
     * @name  KEN.DisplayObject#_unitHeight
     * @type {string}
     * @private
     */
    this._unitHeight = "px";

    /**
     * The display object's scale height.
     * @name  KEN.DisplayObject#_scaleHeight
     * @type {number}
     * @private
     */
    this._scaleHeight = 1;

    /**
     * Does this display object have to center (horizontally) itself inside its parent?
     * @name  KEN.DisplayObject#_horizontalCenter
     * @type {boolean}
     * @private
     */
    this._horizontalCenter = false;

    /**
     * Does this display object have to center (vertically) itself inside its parent?
     * @name  KEN.DisplayObject#_verticalCenter
     * @type {boolean}
     * @private
     */
    this._verticalCenter = false;

    /**
     * The top anchor of the display object inside its parent? It can be null.
     * @name  KEN.DisplayObject#_top
     * @type {?number}
     * @private
     */
    this._top = null;

    /**
     * The right anchor of the display object inside its parent? It can be null.
     * @name  KEN.DisplayObject#_right
     * @type {?number}
     * @private
     */
    this._right = null;

    /**
     * The bottom anchor of the display object inside its parent? It can be null.
     * @name  KEN.DisplayObject#_bottom
     * @type {?number}
     * @private
     */
    this._bottom = null;

    /**
     * The left anchor of the display object inside its parent? It can be null.
     * @name  KEN.DisplayObject#_left
     * @type {?number}
     * @private
     */
    this._left = null;

    /**
     * The alpha value of the display object (0 to 1).
     * @name  KEN.DisplayObject#_alpha
     * @type {number}
     * @private
     */
    this._alpha = 1;

    /**
     * The rotation value of the display object (in degree).
     * @name  KEN.DisplayObject#_rotation
     * @type {number}
     * @private
     */
    this._rotation = 0;

    /**
     * The {@link KEN.Pointer} reference for this display object.
     * @name  KEN.DisplayObject#_pointer
     * @type {KEN.Pointer}
     * @private
     */
    this._pointer = null;

    /**
     * The {@link KEN.Drag} module reference for this display Object.
     * @name KEN.DisplayObject#_drag
     * @type {KEN.Drag}
     * @private
     */
    this._drag = null;

    /**
     * The background CSS value for this display object.
     * @name  KEN.DisplayObject#_background
     * @type {string}
     * @private
     */
    this._background = "";

    /**
     * The border-style CSS value for this display object.
     * @name  KEN.DisplayObject#_borderStyle
     * @type {string}
     * @private
     */
    this._borderStyle = "solid";

    /**
     * The border-width CSS value for this display object.
     * @name  KEN.DisplayObject#_borderWidth
     * @type {number}
     * @private
     */
    this._borderWidth = 0;

    /**
     * The border-color CSS value for this display object.
     * @name  KEN.DisplayObject#_borderColor
     * @type {string}
     * @private
     */
    this._borderColor = "rgb(0, 0, 0)";

    /**
     * The border-radius CSS value for this display object.
     * @name  KEN.DisplayObject#_borderRadius
     * @type {number}
     * @private
     */
    this._borderRadius = 0;

    /**
     * Does this display object have to be maximized (in size) inside its parent.
     * @name  KEN.DisplayObject#_maximized
     * @type {boolean}
     * @private
     */
    this._maximized = false;

    /**
     * The tooltip of this display object. It's the "title" value of the dom element.
     * @name  KEN.DisplayObject#_tooltip
     * @type {string}
     * @private
     */
    this._tooltip = "";

    /**
     * Any custom data you want to associate to this display object.
     * @name  KEN.DisplayObject#_data
     * @type {?Object}
     * @private
     */
    this._data = null;

    /**
     * Is this display object is ready?
     * @name  KEN.DisplayObject#_ready
     * @type {boolean}
     * @private
     */
    this._ready = false;

    /**
     * Does the display object have to put some properties in pending ?
     * @name KEN.DisplayObject#_needPending
     * @type {boolean}
     * @private
     */
    this._needPending = true;

    /**
     * This object save pending values to be applied after the display object will be ready.
     * @name  KEN.DisplayObject#_pending
     * @type {?Object}
     * @private
     */
    this._pending = null;

    /**
     * This is a flag to set if the display object is currently applying its pending values when ready.
     * @name  KEN.DisplayObject#_pendingApplying
     * @type {boolean}
     * @private
     */
    this._pendingApplying = false;

    /**
     * This object is here to store data when fullscreen state changes.<br>
     * @name  KEN.DisplayObject#_fullscreenData
     * @type {Object}
     * @private
     */
    this._fullscreenData = null;

    /**
     * On ready event dispatcher.
     * @name  KEN.DisplayObject#_onReady
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onReady = null;

    /**
     * On resize event dispatcher.
     * @name  KEN.DisplayObject#_onResize
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onResize = null;

    /**
     * On border resize event dispatcher.
     * @name KEN.DisplayObject#_onBorderResize
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onBorderResize = null;

    /**
     * On move event dispatcher.
     * @name  KEN.DisplayObject#_onMove
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onMove = null;

    /**
     * On added to parent event dispatcher
     * @name  KEN.DisplayObject#_onAddedToParent
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onAddedToParent = null;

    /**
     * On added to dom event dispatcher
     * @name  KEN.DisplayObject#_onAddedToDom
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onAddedToDom = null;

    /**
     * On show event dispatcher
     * @name  KEN.DisplayObject#_onShow
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onShow = null;

    /**
     * On hide event dispatcher
     * @name  KEN.DisplayObject#_onHide
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onHide = null;

    /**
     * On fullscreen enter event dispatcher
     * @name  KEN.DisplayObject#_onFullscreenEnter
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onFullscreenEnter = null;

    /**
     * On fullscreen exit event dispatcher
     * @name  KEN.DisplayObject#_onFullscreenExit
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onFullscreenExit = null;

    KEN.BaseObject.call(this, className || "DisplayObject");

    this._boot();
};

KEN.DisplayObject.prototype = Object.create(KEN.BaseObject.prototype);
KEN.DisplayObject.prototype.constructor = KEN.DisplayObject;

/**
 * Boot sequence.
 * @method KEN.DisplayObject#_boot
 * @private
 */
KEN.DisplayObject.prototype._boot = function()
{
    if(this._ready === true)
    {
        return;
    }

    this._createDom();

    this._pending = [];

    //Many object extends the DisplayObject, it's the only one that can be ready here!
    if(this._className === "DisplayObject")
    {
        this._viewer["display"].register(this);
        this._notifyReady();
        this._applyPending(false);
    }
};

/**
 * Create the dom if not specified, apply default CSS.
 * @method KEN.DisplayObject#_createDom
 * @private
 */
KEN.DisplayObject.prototype._createDom = function()
{
    if(typeof this._dom === "undefined" || this._dom === null)
    {
        this._dom = document.createElement("div");
    }
    else
    {
        //Dom is predifined we have to determine width height stuff
        this._width = KEN.Dom.getValueWidth(this._dom);
        this._unitWidth = KEN.Dom.getUnitWidth(this._dom);

        this._height = KEN.Dom.getValueHeight(this._dom);
        this._unitHeight = KEN.Dom.getUnitHeight(this._dom);
    }

    this._dom.style["width"] = this._width+""+this._unitWidth;
    this._dom.style["height"] = this._height+""+this._unitHeight;

    this._dom.style["display"] = "block";
    this._dom.style["position"] = "relative";
    this._dom.style.margin = "0px";
    this._dom.style["padding"] = "0px";
    this._dom.style["top"] = this._y+"px";
    this._dom.style["left"] = this._x+"px";
    this._dom.style["overflow"] = "hidden";
    this._dom.style.boxSizing = "border-box";

    if(KEN.Device.cssPointerEvents === true)
    {
        this._dom.style.pointerEvents = "none";
    }

    this._dom.style.userSelect = "none";
    this._dom.style.webkitUserSelect = "none";
    this._dom.style.mozUserSelect = "none";
    this._dom.style.msUserSelect = "none";
    this._dom.style.webkitTouchCallout = "none";

    this._dom.style["borderStyle"] = this._borderStyle;
    this._dom.style["borderWidth"] = this._borderWidth+"px";
    this._dom.style["borderColor"] = this._borderColor;
    this._dom.style["background"] = this._background;
};

/**
 * Method to notify that the display object is ready !<br>
 * This part of of code is here to be overrided by object that inherits from display object.
 * @method  KEN.DisplayObject#_notifyReady
 * @private
 */
KEN.DisplayObject.prototype._notifyReady = function()
{
    if(this._ready === true)
    {
        return;
    }

    this.log("_notifyReady");
    this._ready = true;

    if(this._onReady !== null)
    {
        this._onReady.dispatch();
    }
};

/**
 * Internal method used by parents to notify that this DisplayObject has been added to DOM.
 * @method KEN.DisplayObject#_notifyAddedToDom
 * @private
 */
KEN.DisplayObject.prototype._notifyAddedToDom = function()
{
    this.log("_notifyAddedToDom");

    if(this._onAddedToDom !== null)
    {
        this._onAddedToDom.dispatch();
    }
};

/**
 * Notify that the visibility of this DisplayObject has changed to visible.
 * @method KEN.DisplayObject#_notifyShow
 * @private
 */
KEN.DisplayObject.prototype._notifyShow = function()
{
    this.log("_notifyShow");

    if(this.isInDom() === false)
    {
        return;
    }

    if(this._onShow !== null && this["visible"] === true)
    {
        this._onShow.dispatch();
    }
};

/**
 * Notify that the visibility of this DisplayObject has changed to invisible.
 * @method KEN.DisplayObject#_notifyHide
 * @private
 */
KEN.DisplayObject.prototype._notifyHide = function()
{
    this.log("_notifyHide");

    if(this._onHide !== null && this["visible"] === false)
    {
        this._onHide.dispatch();
    }
};

/**
 * Method to notify that borders has been resized.<br>
 * This can be override by other class that inherits from DisplayObject.
 * @method  KEN.DisplayObject#_notifyBorderResize
 * @private
 */
KEN.DisplayObject.prototype._notifyBorderResize = function()
{
    if(this._onBorderResize !== null)
    {
        this._onBorderResize.dispatch();
    }
};

/**
 * Method used by parents to adapt size and position.
 * @method KEN.DisplayObject#_notifyParentResize
 * @private
 * @param {PropertyToUpdate} data - The data contains the property that have changed.
 */
KEN.DisplayObject.prototype._notifyParentResize = function(data)
{
    if(this._maximized === true)
    {
        this.maximize(this._maximized);
    }

    this._updatePercentValues(data.property);
    this._updateAnchors();
};

/**
 * Notify that the dispay object has been resized.<br>
 * This method can be overrided by object that extends KEN.DisplayObject.
 * @method  KEN.DisplayObject#_notifyResize
 * @private
 * @param {PropertyToUpdate} data - The data contains the property that have changed.
 */
KEN.DisplayObject.prototype._notifyResize = function(data)
{
    this._updateAnchors();

    if(this._onResize !== null)
    {
        this._onResize.dispatch(data);
    }
};

/**
 * Notify the display object that it entered in fullscreen.
 * @method KEN.DisplayObject#_notifyfullscreenEnter
 * @private
 */
KEN.DisplayObject.prototype._notifyFullscreenEnter = function()
{
    this.log("_notifyFullscreenEnter");

    this._fullscreenSaveData();

    if(this._onFullscreenEnter !== null)
    {
        this._onFullscreenEnter.dispatch();
    }
};

/**
 * Notify the display object that it left fullscreen mode.
 * @method KEN.DisplayObject#_notifyFullscreenExit
 * @private
 */
KEN.DisplayObject.prototype._notifyFullscreenExit = function()
{
    this.log("_notifyFullscreenChange");

    this._fullscreenRestoreData();

    if(this._onFullscreenExit !== null)
    {
        this._onFullscreenExit.dispatch();
    }
};

/**
 * Save the display object state into fullscreenData for further restoration.<br>
 * Set the object's dom css to be in fullscreen.
 * @method KEN.DisplayObject#_fullscreenSaveData
 * @private
 */
KEN.DisplayObject.prototype._fullscreenSaveData = function()
{
    this.log("_fullscreenSaveData");

    this._fullscreenData =
    {
        x: this._x,
        y: this._y,

        width: this._width,
        unitWidth: this._unitWidth,
        height: this._height,
        unitHeight: this._unitHeight,

        top: this._top,
        right: this._right,
        bottom: this._bottom,
        left: this._left
    };

    this._x = 0;
    this._y = 0;

    this._width = screen["width"];
    this._unitWidth = "px";
    this._dom.style["width"] = this._width+"px";

    this._height = screen["height"];
    this._unitHeight = "px";
    this._dom.style["height"] = this._height+"px";

    this._top = null;
    this._right = null;
    this._bottom = null;
    this._left = null;

    this._dom.style["top"] = "0";
    this._dom.style["left"] = "0";

    this._notifyResize({property: "both"});
};

/**
 * Restore the object state at what it was before fullscreen.
 * Happens on fullscreen exit.
 * @method KEN.DisplayObject#_fullscreenRestoreData
 * @private
 */
KEN.DisplayObject.prototype._fullscreenRestoreData = function()
{
    this.log("_fullscreenRestoreData");

    this._x = this._fullscreenData.x;
    this._dom.style["left"] = this._x+"px";
    this._y = this._fullscreenData.y;
    this._dom.style["top"] = this._y+"px";

    this._width = this._fullscreenData["width"];
    this._unitWidth = this._fullscreenData["unitWidth"];
    this._dom.style["width"] = this["pixelWidth"]+"px";

    this._height = this._fullscreenData["height"];
    this._unitHeight = this._fullscreenData["unitHeight"];
    this._dom.style["height"] = this["pixelHeight"]+"px";

    this._top = this._fullscreenData["top"];
    this._right = this._fullscreenData["right"];
    this._bottom = this._fullscreenData["bottom"];
    this._left = this._fullscreenData["left"];

    //this._updateAnchors();
    this._notifyResize({property: "both"});

    this._fullscreenData = null;
};

/**
 * Apply anchor values. Adapt the position of the display object according to its anchors and its alignement flags.
 * @method KEN.DisplayObject#_updateAnchors
 * @private
 */
KEN.DisplayObject.prototype._updateAnchors = function()
{
    //No need to update anchors if has no parent or no size!
    if(this._parent === null || this._width === 0 || this._height === 0)
    {
        return;
    }

    this.log("_updateAnchors");

    if(this._horizontalCenter === true)
    {
        this["horizontalCenter"] = true;
    }
    else
    {
        this["left"] = this._left;
        this["right"] = this._right;
    }

    if(this._verticalCenter === true)
    {
        this["verticalCenter"] = true;
    }
    else
    {
        this["top"] = this._top;
        this["bottom"] = this._bottom;
    }
};

/**
 * Update width or height if it's set in percent. It happened when a parent is set or if the parent is resize.
 * @method KEN.DisplayObject#_updatePercentValues
 * @private
 * @param {string} property - The property that have changed.
 */
KEN.DisplayObject.prototype._updatePercentValues = function(property)
{
    var widthRelated = property.toLowerCase().indexOf("width") !== -1 || property === "both";
    var heightRelated = property.toLowerCase().indexOf("height") !== -1 || property === "both";

    if(widthRelated === true && this._unitWidth === "%")
    {
        this._dom.style["width"] = this["pixelWidth"]+"px";
        this._dom["width"] = this["pixelWidth"];
        this._notifyResize({ property: "width" });
    }

    if(heightRelated === true && this._unitHeight === "%")
    {
        this._dom.style["height"] = this["pixelHeight"]+"px";
        this._dom["height"] = this["pixelHeight"];
        this._notifyResize({ property: "height" });
    }
};

/**
 * Internal method that add a pending value for a specific property.
 * @method KEN.DisplayObject#_addPending
 * @private
 * @param {string} prop - The property name for the pending value.
 * @param {*} value - The value you want to associate to the property.
 */
KEN.DisplayObject.prototype._addPending = function(prop, value)
{
    //this._pending[prop] = value;
    this._pending.push(
    {
        prop: prop,
        value: value
    });
};

/**
 * Internal method to known if a property have a pending value.
 * @method KEN.DisplayObject#_hasPending
 * @private
 * @param {string} prop - The property name for the pending value.
 * @return {boolean} Returns true if the property have a pending value, false if not.
 */
KEN.DisplayObject.prototype._hasPending = function(prop)
{
    //return (typeof this._pending[prop] !== "undefined");
    for(var i = 0, ii = this._pending.length; i < ii; i++)
    {
        if(this._pending[i].prop === prop)
        {
            return true;
        }
    }

    return false;
};

/**
 * Method to clear a specific property from the pending list
 * @method  KEN.DisplayObject#_clearPending
 * @private
 * @param  {string=} prop - The prop to clear, if not specified clear all the pending
 */
KEN.DisplayObject.prototype._clearPending = function(prop)
{
    if(typeof prop === "string")
    {
        //delete this._pending[prop];
        var i = this._pending.length;

        while(i--)
        {
            if(this._pending[i].prop === prop)
            {
                this._pending.splice(i, 1);
            }
        }
    }
    else
    {
        this._pending = [];
    }
};

/**
 * Apply all the pending values then reset the object that stores these values.
 * @method KEN.DisplayObject#_applyPending
 * @private
 * @param {boolean} needPending - does it need pending ?
 */
KEN.DisplayObject.prototype._applyPending = function(needPending)
{
    this.log("_applyPending");

    this._needPending = needPending;

    if(this._pending === null || this._pending.length === 0)
    {
        return;
    }

    this._pendingApplying = true;

    // for(var prop in this._pending)
    // {
    //     this[prop] = this._pending[prop];
    // }

    for(var i = 0, ii = this._pending.length; i < ii; i++)
    {
        this[this._pending[i].prop] = this._pending[i]["value"];
    }

    this._pendingApplying = false;

    this._clearPending();
};

/**
 * Show this display object.
 * @method KEN.DisplayObject#show
 */
KEN.DisplayObject.prototype.show = function()
{
    this._dom.style["display"] = "block";
    this._notifyShow();
};

/**
 * Hide this display object.
 * @method KEN.DisplayObject#hide
 */
KEN.DisplayObject.prototype.hide = function()
{
    this._dom.style["display"] = "none";
    this._notifyHide();
};

/**
 * Toggles th visibility of this display object.
 * @method  KEN.DisplayObject#toggleVisibility
 */
KEN.DisplayObject.prototype.toggleVisibility = function()
{
    this["visible"] = !this["visible"];
};

/**
 * Maximize the size of this display object to the size of its parent.
 * @method KEN.DisplayObject#maximize
 * @param {boolean} keepMaximized - Set this param to true if you want that this display object auto resize to max when its parent is resized.
 */
KEN.DisplayObject.prototype.maximize = function(keepMaximized)
{
    if(keepMaximized === true)
    {
        this._maximized = true;

        if(this._needPending === true)
        {
            this._addPending("maximized", true);
        }
    }

    if(this._parent !== null)
    {
        this._keepRatio = false;

        var width = this["pixelWidth"];
        this._width = this._parent["innerWidth"];
        this._unitWidth = "px";
        this._dom.style["width"] = this._parent["innerWidth"]+"px";
        this._dom["width"] = this._parent["innerWidth"];

        if(width !== this["pixelWidth"])
        {
            this._notifyResize({ property: "width" });
        }

        var height = this["pixelHeight"];
        this._height = this._parent["innerHeight"];
        this._unitHeight = "px";
        this._dom.style["height"] = this._parent["innerHeight"]+"px";
        this._dom["height"] = this._parent["innerHeight"];

        if(height !== this["pixelHeight"])
        {
            this._notifyResize({ property: "height" });
        }
    }
};

/**
 * Method to know if a display object is in dom.
 * @method  KEN.DisplayObject#isInDom
 * @return {boolean} Returns true if the display Object is in DOM, false if not.
 */
KEN.DisplayObject.prototype.isInDom = function()
{
    return KEN.Dom.has(this._dom);
};

/**
 * Resize this display object to a given width / height.
 * @method KEN.DisplayObject#resize
 * @param {number|string} width - The width you want to set, it can be for example 10, "10px" or "10%".
 * @param {number|string} height - The height you want to set, it can be for example 10, "10px" or "10%".
 */
KEN.DisplayObject.prototype.resize = function(width, height)
{
    if(width !== null && typeof width !== "undefined")
    {
        this["width"] = width;
    }

    if(height !== null && typeof height !== "undefined")
    {
        this["height"] = height;
    }
};

/**
 * Request a fullscreen enter on this display object.
 * @method  KEN.DisplayObject#fullscreenEnter
 */
KEN.DisplayObject.prototype.fullscreenEnter = function()
{
    if(document[KEN.Device.fullscreenEnabled] === true && this.isFullscreen() === false)
    {
        this._dom[KEN.Device.requestFullscreen]();
    }
};

/**
 * Request a fullscreen exit on this display object.
 * @method  KEN.DisplayObject#fullscreenExit
 */
KEN.DisplayObject.prototype.fullscreenExit = function()
{
    if(document[KEN.Device.fullscreenEnabled] === true && this.isFullscreen() === true)
    {
        document[KEN.Device.exitFullscreen]();
    }
};

/**
 * Know if this display object is in fullscreen
 * @method  KEN.DisplayObject#isFullscreen
 * @return {boolean}
 */
KEN.DisplayObject.prototype.isFullscreen = function()
{
    return document[KEN.Device.fullscreenElement] === this._dom;
};

/**
 * Destroy method.
 * @method KEN.DisplayObject#destroy
 */
KEN.DisplayObject.prototype.destroy = function()
{
    if(this._alive === false)
    {
        return;
    }

    this._viewer["display"].unregister(this);

    if(this._parent !== null)
    {
        this._parent.removeChild(this, false);
        this._parent = null;
    }

    if(this._pointer !== null)
    {
        this._pointer.destroy();
        this._pointer = null;
    }

    if(this._drag !== null)
    {
        this._drag.destroy();
        this._drag = null;
    }

    if(this._onResize !== null)
    {
        this._onResize.destroy();
        this._onResize = null;
    }

    if(this._onBorderResize !== null)
    {
        this._onBorderResize.destroy();
        this._onBorderResize = null;
    }

    if(this._onReady !== null)
    {
        this._onReady.destroy();
        this._onReady = null;
    }

    if(this._onAddedToParent !== null)
    {
        this._onAddedToParent.destroy();
        this._onAddedToParent = null;
    }

    if(this._onAddedToDom !== null)
    {
        this._onAddedToDom.destroy();
        this._onAddedToDom = null;
    }

    if(this._onFullscreenEnter !== null)
    {
        this._onFullscreenEnter.destroy();
        this._onFullscreenEnter = null;
    }

    if(this._onFullscreenExit !== null)
    {
        this._onFullscreenExit.destroy();
        this._onFullscreenExit = null;
    }

    this._dom = null;

    this._data = null;

    this._viewer = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the viewer reference object.
 * @name KEN.DisplayObject#viewer
 * @readonly
 * @type {KEN.Viewer}
 */
KEN.DisplayObject.prototype.viewer;
Object.defineProperty(KEN.DisplayObject.prototype, "viewer",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._viewer;
    }
});

/**
 * Get the dom element that compose this display object.
 * @name KEN.DisplayObject#dom
 * @readonly
 * @type {Element|HTMLElement}
 */
KEN.DisplayObject.prototype.dom;
Object.defineProperty(KEN.DisplayObject.prototype, "dom",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._dom;
    }
});

/**
 * Get and set the id of this display object.
 * @name KEN.DisplayObject#id
 * @type {string}
 */
KEN.DisplayObject.prototype.id;
Object.defineProperty(KEN.DisplayObject.prototype, "id",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._id;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        this._id = value;
        this._dom["id"] = this._id;
    }
});

/**
 * Get the ready status of this display object.
 * @name KEN.DisplayObject#ready
 * @readonly
 * @type {boolean}
 */
KEN.DisplayObject.prototype.ready;
Object.defineProperty(KEN.DisplayObject.prototype, "ready",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._ready;
    }
});

/**
 * Get and set the parent of this display object.
 * @name KEN.DisplayObject#parent
 * @type {KEN.DisplayObjectContainer}
 *
 * @todo  Find a clean way to identify DisplayObjectContainer and other class that inherits from.
 */
KEN.DisplayObject.prototype.parent;
Object.defineProperty(KEN.DisplayObject.prototype, "parent",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._parent;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "object" || Array.isArray(value["children"]) === false || value === this._parent)
        {
            return;
        }

        this._parent = value;
        this._dom.style["position"] = "absolute";

        if(this._maximized === true)
        {
            this.maximize(this._maximized);
        }

        this._updatePercentValues("both");
        this._updateAnchors();

        if(this._onAddedToParent !== null)
        {
            this._onAddedToParent.dispatch();
        }

        if(this._parent.isInDom() === true)
        {
            this._notifyAddedToDom();
            this._notifyShow();
        }
    }
});

/**
 * Get and set the visibility of this display object.
 * @name KEN.DisplayObject#visible
 * @type {boolean}
 */
KEN.DisplayObject.prototype.visible;
Object.defineProperty(KEN.DisplayObject.prototype, "visible",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._dom.style["display"] === "block";
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        if(value === true)
        {
            this.show();
        }
        else
        {
            this.hide();
        }
    }
});

/**
 * Get and set the x position of this display object.
 * @name KEN.DisplayObject#x
 * @type {number}
 */
KEN.DisplayObject.prototype.x;
Object.defineProperty(KEN.DisplayObject.prototype, "x",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._x;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        var x = this._x;
        this._x = value;
        this._dom.style["left"] = this._x+"px";

        if(this._onMove !== null && x !== this._x)
        {
            this._onMove.dispatch({ property: "x" });
        }
    }
});

/**
 * Get and set the y position of this display object.
 * @name KEN.DisplayObject#y
 * @type {number}
 */
KEN.DisplayObject.prototype.y;
Object.defineProperty(KEN.DisplayObject.prototype, "y",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._y;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        var y = this._y;
        this._y = value;
        this._dom.style["top"] = this._y+"px";

        if(this._onMove !== null && y !== this._y)
        {
            this._onMove.dispatch({ property: "y" });
        }
    }
});

/**
 * Get and set the keepRatio status of this display object.
 * @name KEN.DisplayObject#keepRatio
 * @type {boolean}
 */
KEN.DisplayObject.prototype.keepRatio;
Object.defineProperty(KEN.DisplayObject.prototype, "keepRatio",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._keepRatio;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "boolean" || value === this._keepRatio)
        {
            return;
        }

        this._keepRatio = value;
    }
});

/**
 * Get and set the width of this display object.
 * The getter will always return a number, but you can pass to the setter either a number like 10 or a string like "10px" or "10%".
 * @name KEN.DisplayObject#width
 * @type {number|string}
 */
KEN.DisplayObject.prototype.width;
Object.defineProperty(KEN.DisplayObject.prototype, "width",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._width;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        var width = this._width;
        var unitWidth = this._unitWidth;

        if(typeof value === "string")
        {
            var size = KEN.Utils.parseSizeString(value);

            if(size["value"] === null || size.unit === null)
            {
                throw "KEN.DisplayObject.width value "+value+" is incorrect";
            }

            this._unitWidth = size.unit;
            this._width = size["value"];
        }
        else if(typeof value === "number")
        {
            this._width = value;
        }
        else
        {
            return;
        }

        if(this._needPending === true)
        {
            this._addPending("width", this._width);
            return;
        }

        this._maximized = false;

        this._dom.style["width"] = this["pixelWidth"]+"px";
        this._dom["width"] = this["pixelWidth"];

        if((width !== this._width || unitWidth !== this._unitWidth) || this._pendingApplying === true)
        {
            this._notifyResize({ property: "width" });
        }
    }
});

/**
 * Get and set the width of this display object in pixel only.
 * @name KEN.DisplayObject#pixelWidth
 * @type {number}
 */
KEN.DisplayObject.prototype.pixelWidth;
Object.defineProperty(KEN.DisplayObject.prototype, "pixelWidth",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._unitWidth === "px")
        {
            return this._width;
        }
        else if (this._unitWidth === "%")
        {
            if(this._parent !== null)
            {
                return this._parent["innerWidth"] * this._width / 100;
            }
            else
            {
                return 0;
            }
        }
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        var width = this._width;
        var unitWidth = this._unitWidth;

        this._width = value;
        this._unitWidth = "px";

        if(this._needPending === true)
        {
            this._addPending("pixelWidth", value);
            return;
        }

        this._maximized = false;

        this._dom.style["width"] = this["pixelWidth"]+"px";
        this._dom["width"] = this["pixelWidth"];

        if((width !== this._width || unitWidth !== "px") || this._pendingApplying === true)
        {
            this._notifyResize({ property: "pixelWidth" });
        }
    }
});

/**
 * Get and set the width of this display object in percent only.
 * @name KEN.DisplayObject#percentWidth
 * @type {number}
 */
KEN.DisplayObject.prototype.percentWidth;
Object.defineProperty(KEN.DisplayObject.prototype, "percentWidth",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._unitWidth === "%")
        {
            return this._width;
        }
        else if(this._unitWidth === "px")
        {
            if(this._parent !== null)
            {
                return this._width / this._parent["innerWidth"] * 100;
            }
            else
            {
                return 0;
            }
        }
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        var width = this._width;
        var unitWidth = this._unitWidth;

        this._width = value;
        this._unitWidth = "%";

        if(this._needPending === true)
        {
            this._addPending("percentWidth", value);
            return;
        }

        this._maximized = false;

        this._dom.style["width"] = this["pixelWidth"]+"px";
        this._dom["width"] = this["pixelWidth"];

        if((width !== this._width || unitWidth !== "%") || this._pendingApplying === true)
        {
            this._notifyResize({ property: "percentWidth" });
        }
    }
});

/**
 * Get and set the width unit of this display object.
 * @name KEN.DisplayObject#unitWidth
 * @type {string}
 */
KEN.DisplayObject.prototype.unitWidth;
Object.defineProperty(KEN.DisplayObject.prototype, "unitWidth",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._unitWidth;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "string" || (value !== "px" && value !== "%"))
        {
            return;
        }

        var unitWidth = this._unitWidth;

        this._unitWidth = value;

        if(this._needPending === true)
        {
            this._addPending("unitWidth", value);
            return;
        }

        this._maximized = false;

        this._dom.style["width"] = this["pixelWidth"]+"px";
        this._dom["width"] = this["pixelWidth"];

        if(unitWidth !== this._unitWidth || this._pendingApplying === true)
        {
            this._notifyResize({ property: "unitWidth" });
        }
    }
});

/**
 * Get the inner width (understand width without borders) of this DisplayObject.
 * @name  KEN.DisplayObject#innerWidth
 * @readonly
 * @type {number}
 */
KEN.DisplayObject.prototype.innerWidth;
Object.defineProperty(KEN.DisplayObject.prototype, "innerWidth",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this["pixelWidth"] - (this._borderWidth * 2);
    }
});

/**
 * Get and set the height of this display object.
 * The getter will always return a number, but you can pass to the setter either a number like 10 or a string like "10px" or "10%".
 * @name KEN.DisplayObject#height
 * @type {number|string}
 */
KEN.DisplayObject.prototype.height;
Object.defineProperty(KEN.DisplayObject.prototype, "height",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._height;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        var height = this._height;
        var unitHeight = this._unitHeight;

        if(typeof value === "string")
        {
            var size = KEN.Utils.parseSizeString(value);

            if(size["value"] === null || size.unit === null)
            {
                throw "KEN.DisplayObject.height value "+value+" is incorrect";
            }

            this._unitHeight = size.unit;
            this._height = size["value"];
        }
        else if(typeof value === "number")
        {
            this._height = value;
        }
        else
        {
            return;
        }

        if(this._needPending === true)
        {
            this._addPending("height", this._height);
            return;
        }

        this._maximized = false;

        this._dom.style["height"] = this["pixelHeight"]+"px";
        this._dom["height"] = this["pixelHeight"];

        if((height !== this._height || unitHeight !== this._unitHeight) || this._pendingApplying === true)
        {
            this._notifyResize({ property: "height" });
        }
    }
});

/**
 * Get and set the height of this display object in pixel only.
 * @name KEN.DisplayObject#pixelHeight
 * @type {number}
 */
KEN.DisplayObject.prototype.pixelHeight;
Object.defineProperty(KEN.DisplayObject.prototype, "pixelHeight",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._unitHeight === "px")
        {
            return this._height;
        }
        else if (this._unitHeight === "%")
        {
            if(this._parent !== null)
            {
                return this._parent["innerHeight"] * this._height / 100;
            }
            else
            {
                return 0;
            }
        }
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        var height = this._height;
        var unitHeight = this._unitHeight;

        this._height = value;
        this._unitHeight = "px";

        if(this._needPending === true)
        {
            this._addPending("pixelHeight", value);
            return;
        }

        this._maximized = false;

        this._dom.style["height"] = this["pixelHeight"]+"px";
        this._dom["height"] = this["pixelHeight"];

        if((height !== this._height || unitHeight !== "px") || this._pendingApplying === true)
        {
            this._notifyResize({ property: "pixelHeight" });
        }
    }
});

/**
 * Get and set the height of this display object in percent only.
 * @name KEN.DisplayObject#percentHeight
 * @type {number}
 */
KEN.DisplayObject.prototype.percentHeight;
Object.defineProperty(KEN.DisplayObject.prototype, "percentHeight",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._unitHeight === "%")
        {
            return this._height;
        }
        else if(this._unitHeight === "px")
        {
            if(this._parent !== null)
            {
                return this._height / this._parent["innerHeight"] * 100;
            }
            else
            {
                return 0;
            }
        }
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        var height = this._height;
        var unitHeight = this._unitHeight;

        this._height = value;
        this._unitHeight = "%";

        if(this._needPending === true)
        {
            this._addPending("percentHeight", value);
            return;
        }

        this._maximized = false;

        this._dom.style["height"] = this["pixelHeight"]+"px";
        this._dom["height"] = this["pixelHeight"];

        if((height !== this._height || unitHeight !== "%") || this._pendingApplying === true)
        {
            this._notifyResize({ property: "percentHeight" });
        }
    }
});

/**
 * Get and set the height unit of this display object.
 * @name KEN.DisplayObject#unitHeight
 * @type {string}
 */
KEN.DisplayObject.prototype.unitHeight;
Object.defineProperty(KEN.DisplayObject.prototype, "unitHeight",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._unitHeight;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        var unitHeight = this._unitHeight;

        this._unitHeight = value;

        if(this._needPending === true)
        {
            this._addPending("unitHeight", value);
            return;
        }

        this._maximized = false;

        this._dom.style["height"] = this["pixelHeight"]+"px";
        this._dom["height"] = this["pixelHeight"];

        if(unitHeight !== this._unitHeight || this._pendingApplying === true)
        {
            this._notifyResize({ property: "unitHeight" });
        }
    }
});

/**
 * Get the inner height in pixels (understand height without borders) of this DisplayObject.
 * @name  KEN.DisplayObject#innerHeight
 * @readonly
 * @type {number}
 */
KEN.DisplayObject.prototype.innerHeight;
Object.defineProperty(KEN.DisplayObject.prototype, "innerHeight",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this["pixelHeight"] - (this._borderWidth * 2);
    }
});

/**
 * Get and set the maximized status of this display object.
 * @name KEN.DisplayObject#maximized
 * @type {boolean}
 */
KEN.DisplayObject.prototype.maximized;
Object.defineProperty(KEN.DisplayObject.prototype, "maximized",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._maximized;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._maximized = value;

        if(this._maximized === true)
        {
            this.maximize(true);
        }
    }
});


/**
 * Get and set the horizontal center status of this display object.
 * @name KEN.DisplayObject#horizontalCenter
 * @type {boolean}
 */
KEN.DisplayObject.prototype.horizontalCenter;
Object.defineProperty(KEN.DisplayObject.prototype, "horizontalCenter",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._horizontalCenter;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._horizontalCenter = value;

        if(this._horizontalCenter === true)
        {
            this._left = null;
            this._right = null;
        }

        if(this._parent === null)
        {
            return;
        }

        var x = this._x;
        this._x = (this._parent["innerWidth"] -this["pixelWidth"]) / 2;
        this._dom.style["left"] = this._x+"px";

        if(this._onMove !== null && x !== this._x)
        {
            this._onMove.dispatch({ property: "x" });
        }
    }
});

/**
 * Get and set the vertical center status of this display object.
 * @name KEN.DisplayObject#verticalCenter
 * @type {boolean}
 */
KEN.DisplayObject.prototype.verticalCenter;
Object.defineProperty(KEN.DisplayObject.prototype, "verticalCenter",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._verticalCenter;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._verticalCenter = value;

        if(this._verticalCenter === true)
        {
            this._top = null;
            this._bottom = null;
        }

        if(this._parent === null)
        {
            return;
        }

        var y = this._y;
        this._y = (this._parent["innerHeight"] - this["pixelHeight"]) / 2;
        this._dom.style["top"] = this._y+"px";

        if(this._onMove !== null && y !== this._y)
        {
            this._onMove.dispatch({ property: "y" });
        }
    }
});

/**
 * Get and set the top anchor of this display object.
 * @name KEN.DisplayObject#top
 * @type {?number}
 */
KEN.DisplayObject.prototype.top;
Object.defineProperty(KEN.DisplayObject.prototype, "top",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._top;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number" && value !== null)
        {
            return;
        }

        this._top = value;
        this._verticalCenter = false;

        if(this._parent === null || this._top === null)
        {
            return;
        }

        var y = this._y;
        this._y = value;
        this._dom.style["top"] = this._y+"px";

        if(this._onMove !== null && y !== this._y)
        {
            this._onMove.dispatch({ property: "y" });
        }
    }
});

/**
 * Get and set the right anchor of this display object.
 * @name KEN.DisplayObject#right
 * @type {?number}
 */
KEN.DisplayObject.prototype.right;
Object.defineProperty(KEN.DisplayObject.prototype, "right",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._right;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number" && value !== null)
        {
            return;
        }

        this._right = value;
        this._horizontalCenter = false;

        if(this._parent === null || this._right === null)
        {
            return;
        }

        var x = this._x;
        this._x = this._parent["innerWidth"] - this["pixelWidth"] - value;
        this._dom.style["left"] = this._x+"px";

        if(this._onMove !== null && x !== this._x)
        {
            this._onMove.dispatch({ property: "x" });
        }
    }
});

/**
 * Get and set the bottom anchor of this display object.
 * @name KEN.DisplayObject#bottom
 * @type {?number}
 */
KEN.DisplayObject.prototype.bottom;
Object.defineProperty(KEN.DisplayObject.prototype, "bottom",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._bottom;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number" && value !== null)
        {
            return;
        }

        this._bottom = value;
        this._verticalCenter = false;

        if(this._parent === null || this._bottom === null)
        {
            return;
        }

        var y = this._y;
        this._y = this._parent["innerHeight"] - this["pixelHeight"] - value;
        this._dom.style["top"] = this._y+"px";

        if(this._onMove !== null && y !== this._y)
        {
            this._onMove.dispatch({ property: "y" });
        }
    }
});

/**
 * Get and set the left anchor of this display object.
 * @name KEN.DisplayObject#left
 * @type {?number}
 */
KEN.DisplayObject.prototype.left;
Object.defineProperty(KEN.DisplayObject.prototype, "left",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._left;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number" && value !== null)
        {
            return;
        }

        this._left = value;
        this._horizontalCenter = false;

        if(this._parent === null || this._left === null)
        {
            return;
        }

        var x = this._x;
        this._x = value;
        this._dom.style["left"] = this._x+"px";

        if(this._onMove !== null && x !== this._x)
        {
            this._onMove.dispatch({ property: "x" });
        }
    }
});

/**
 * Get and set the left alpha of this display object. (between 0 and 1).
 * @name KEN.DisplayObject#alpha
 * @type {number}
 */
KEN.DisplayObject.prototype.alpha;
Object.defineProperty(KEN.DisplayObject.prototype, "alpha",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._alpha;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number" || value === this._alpha)
        {
            return;
        }

        this._alpha = value;
        this._dom.style["opacity"] = this._alpha;
    }
});

/**
 * Get and set the rotation of this display object. (in degree).
 * @name KEN.DisplayObject#rotation
 * @type {number}
 */
KEN.DisplayObject.prototype.rotation;
Object.defineProperty(KEN.DisplayObject.prototype, "rotation",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._rotation;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number" || value === this._rotation)
        {
            return;
        }

        this._rotation = value;
        this._dom.style.transform = "rotate("+this._rotation+"deg)";
    }
});

/**
 * Get and set the backgound CSS value of this display object.
 * @name KEN.DisplayObject#background
 * @type {string}
 */
KEN.DisplayObject.prototype.background;
Object.defineProperty(KEN.DisplayObject.prototype, "background",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._background;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "string" || value === this._background)
        {
            return;
        }

        this._background = value;
        this._dom.style["background"] = this._background;
    }
});

/**
 * Get and set the border-style CSS value of this display object.
 * @name KEN.DisplayObject#borderStyle
 * @type {string}
 */
KEN.DisplayObject.prototype.borderStyle;
Object.defineProperty(KEN.DisplayObject.prototype, "borderStyle",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._borderStyle;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        var borderStyles =
        [
            "none",
            "dotted",
            "dashed",
            "solid",
            "double",
            "groove",
            "ridge",
            "inset",
            "outset"
        ];

        if(borderStyles.indexOf(value) === -1 || value === this._borderStyle)
        {
            return;
        }

        this._borderStyle = value;

        if(this._needPending === true)
        {
            this._addPending("borderStyle", value);
            return;
        }

        this._dom.style["borderStyle"] = this._borderStyle;
    }
});

/**
 * Get and set the border-width CSS value of this display object.
 * @name KEN.DisplayObject#borderWidth
 * @type {number}
 */
KEN.DisplayObject.prototype.borderWidth;
Object.defineProperty(KEN.DisplayObject.prototype, "borderWidth",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._borderWidth;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        var borderWidth = this._borderWidth;

        this._borderWidth = value;

        if(this._needPending === true)
        {
            this._addPending("borderWidth", value);
            return;
        }

        this._dom.style["borderWidth"] = this._borderWidth+"px";

        if(borderWidth !== this._borderWidth || this._pendingApplying === true)
        {
            this._notifyBorderResize();
        }
    }
});

/**
 * Get and set the border-color CSS value of this display object.
 * @name KEN.DisplayObject#borderColor
 * @type {string}
 */
KEN.DisplayObject.prototype.borderColor;
Object.defineProperty(KEN.DisplayObject.prototype, "borderColor",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._borderColor;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "string" || value === this._borderColor)
        {
            return;
        }

        this._borderColor = value;
        this._dom.style["borderColor"] = this._borderColor;
    }
});

/**
 * Get and set the border-radius CSS value of this display object.
 * @name KEN.DisplayObject#borderRadius
 * @type {number}
 */
KEN.DisplayObject.prototype.borderRadius;
Object.defineProperty(KEN.DisplayObject.prototype, "borderRadius",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._borderRadius;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if((typeof value !== "number" && typeof value !== "string") || value === this._borderRadius)
        {
            return;
        }

        if (typeof value === "string")
        {
            value = parseInt(value, 10);
        }

        if (isNaN(value))
        {
            return;
        }

        this._borderRadius = value;
        this._dom.style["borderRadius"] = this._borderRadius + "px";
    }
});

/**
 * Get the global offset
 * @name KEN.DisplayObject#globalOffset
 * @readonly
 * @type {{top:number,left:number}}
 */
KEN.DisplayObject.prototype.globalOffset;
Object.defineProperty(KEN.DisplayObject.prototype, "globalOffset",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        var element = this._dom;
        var top = 0, left = 0;

        do
        {
            top += element.offsetTop || 0;
            left += element.offsetLeft || 0;
            element = element.offsetParent;
        }
        while(element);

        return { top: top, left: left };
    }
});

/**
 * Get and set the tooltip value of this display object. This is the title dom property.
 * @name KEN.DisplayObject#tooltip
 * @type {string}
 */
KEN.DisplayObject.prototype.tooltip;
Object.defineProperty(KEN.DisplayObject.prototype, "tooltip",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._tooltip;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "string" || value === this._tooltip)
        {
            return;
        }

        this._tooltip = value;
        this._dom.title = this._tooltip;
    }
});

/**
 * Get and set the index value of this display object. This is the z-index CSS property.
 * @name KEN.DisplayObject#index
 * @type {number}
 */
KEN.DisplayObject.prototype.index;
Object.defineProperty(KEN.DisplayObject.prototype, "index",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        return this._index;
    },

    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number" || value === this._index)
        {
            return;
        }

        this._index = value;
        this._dom.style.zIndex = this._index;
    }
});

/**
 * Set the fullscreen property of this display object.
 * @name KEN.DisplayObject#fullscreen
 * @type {boolean}
 */
KEN.DisplayObject.prototype.fullscreen;
Object.defineProperty(KEN.DisplayObject.prototype, "fullscreen",
{
    /** @this {KEN.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        if(value === true)
        {
            this.fullscreenEnter();
        }
        else
        {
            this.fullscreenExit();
        }
    }
});

/**
 * Get the {@link KEN.Pointer} object that handles mouse and touch events for this display object.
 * @name KEN.DisplayObject#pointer
 * @readonly
 * @type {KEN.Pointer}
 */
KEN.DisplayObject.prototype.pointer;
Object.defineProperty(KEN.DisplayObject.prototype, "pointer",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._pointer === null)
        {
            this._pointer = new KEN.Pointer(this);
        }

        return this._pointer;
    }
});

/**
 * Get the {@link KEN.Drag} object that handles drag events for this display object.
 * @name KEN.DisplayObject#drag
 * @readonly
 * @type {KEN.Drag}
 */
KEN.DisplayObject.prototype.drag;
Object.defineProperty(KEN.DisplayObject.prototype, "drag",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._drag === null)
        {
            this._drag = new KEN.Drag(this);
        }

        return this._drag;
    }
});

/**
 * Get the "onResize" {@link KEN.EventDispatcher} of this display object.
 * @name KEN.DisplayObject#onResize
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.DisplayObject.prototype.onResize;
Object.defineProperty(KEN.DisplayObject.prototype, "onResize",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._onResize === null)
        {
            this._onResize = new KEN.EventDispatcher(this);
        }

        return this._onResize;
    }
});

/**
 * Get the "onBorderResize" {@link KEN.EventDispatcher} of this display object.
 * @name KEN.DisplayObject#onBorderChange
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.DisplayObject.prototype.onBorderResize;
Object.defineProperty(KEN.DisplayObject.prototype, "onBorderResize",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._onBorderResize === null)
        {
            this._onBorderResize = new KEN.EventDispatcher(this);
        }

        return this._onBorderResize;
    }
});

/**
 * Get the "onMove" {@link KEN.EventDispatcher} of this display object.<br>
 * This event is triggered when object's coordinate (x, y) changed.
 * @name KEN.DisplayObject#onMove
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.DisplayObject.prototype.onMove;
Object.defineProperty(KEN.DisplayObject.prototype, "onMove",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._onMove === null)
        {
            this._onMove = new KEN.EventDispatcher(this);
        }

        return this._onMove;
    }
});

/**
 * Get the "onReady" {@link KEN.EventDispatcher} of this display object.
 * @name KEN.DisplayObject#onReady
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.DisplayObject.prototype.onReady;
Object.defineProperty(KEN.DisplayObject.prototype, "onReady",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._onReady === null)
        {
            this._onReady = new KEN.EventDispatcher(this, true);
        }

        return this._onReady;
    }
});

/**
 * Get the "onAddedToParent" {@link KEN.EventDispatcher} of this display object.
 * @name KEN.DisplayObject#onAddedToParent
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.DisplayObject.prototype.onAddedToParent;
Object.defineProperty(KEN.DisplayObject.prototype, "onAddedToParent",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._onAddedToParent === null)
        {
            this._onAddedToParent = new KEN.EventDispatcher(this);
        }

        return this._onAddedToParent;
    }
});

/**
 * Get the "onAddedToDom" {@link KEN.EventDispatcher} of this display object.
 * @name KEN.DisplayObject#onAddedToDom
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.DisplayObject.prototype.onAddedToDom;
Object.defineProperty(KEN.DisplayObject.prototype, "onAddedToDom",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._onAddedToDom === null)
        {
            this._onAddedToDom = new KEN.EventDispatcher(this);
        }

        return this._onAddedToDom;
    }
});

/**
 * Get the "onShow" {@link KEN.EventDispatcher} of this display object.
 * @name KEN.DisplayObject#onShow
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.DisplayObject.prototype.onShow;
Object.defineProperty(KEN.DisplayObject.prototype, "onShow",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._onShow === null)
        {
            this._onShow = new KEN.EventDispatcher(this);
        }

        return this._onShow;
    }
});

/**
 * Get the "onHide" {@link KEN.EventDispatcher} of this display object.
 * @name KEN.DisplayObject#onHide
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.DisplayObject.prototype.onHide;
Object.defineProperty(KEN.DisplayObject.prototype, "onHide",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._onHide === null)
        {
            this._onHide = new KEN.EventDispatcher(this);
        }

        return this._onHide;
    }
});

/**
 * Get the "onFullscreenEnter" {@link KEN.EventDispatcher} of this display object.
 * @name KEN.DisplayObject#onFullscreenEnter
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.DisplayObject.prototype.onFullscreenEnter;
Object.defineProperty(KEN.DisplayObject.prototype, "onFullscreenEnter",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._onFullscreenEnter === null)
        {
            this._onFullscreenEnter = new KEN.EventDispatcher(this);
        }

        return this._onFullscreenEnter;
    }
});

/**
 * Get the "onFullscreenExit" {@link KEN.EventDispatcher} of this display object.
 * @name KEN.DisplayObject#onFullscreenExit
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.DisplayObject.prototype.onFullscreenExit;
Object.defineProperty(KEN.DisplayObject.prototype, "onFullscreenExit",
{
    /** @this {KEN.DisplayObject} */
    get: function()
    {
        if(this._onFullscreenExit === null)
        {
            this._onFullscreenExit = new KEN.EventDispatcher(this);
        }

        return this._onFullscreenExit;
    }
});



/**
 * A display object container is a {@link KEN.DisplayObject} that can contains other {@link KEN.DisplayObject} as children.
 *
 * @constructor KEN.DisplayObjectContainer
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @param {?(Element|HTMLElement)=} dom - Use a specific dom element to be the display object, if undefined a div will be created.
 * @param {?string=} className - Define a className of object for objects that extends DisplayObjectContainer.
 * @param {(Element|HTMLElement)=} root - Is this container a root? Root is the main viewer container or any container<br>
 * that haven't a KEN.DisplayObject as parent but a dom element that is not a ken object.
 * @extends {KEN.DisplayObject}
 *
 * @todo Delete children on demand (recursive) + remove only children (recursive)
 */
KEN.DisplayObjectContainer = function(viewer, dom, className, root)
{
    /**
     * Array of {@link KEN.DisplayObject} of this display object container.
     * @name KEN.DisplayObjectContainer#_children
     * @type {Array<KEN.DisplayObject>}
     * @private
     */
    this._children = [];

    /**
     * Is this container a root one?
     * @name  KEN.DisplayObjectContainer#_root
     * @type {Element|HTMLElement}
     * @private
     */
    this._root = (typeof root !== "undefined") ? root : null;

    /**
     * This object handles all variables related to a root resizable container.
     * @name  KEN.DisplayObjectContainer#_rootData
     * @type {?RootData}
     * @private
     */
    this._rootData = null;

    /**
     * Fit has been already applied on the container?
     * @name  KEN.DisplayObjectContainer#_fitted
     * @type {boolean}
     * @private
     */
    this._fitted = false;

    /**
     * The overflow mode of the container (CSS property)
     * @name  KEN.DisplayObjectContainer#_overflow
     * @type {string}
     * @private
     */
    this._overflow = "hidden";

    KEN.DisplayObject.call(this, viewer, dom, className || "DisplayObjectContainer");
};

KEN.DisplayObjectContainer.prototype = Object.create(KEN.DisplayObject.prototype);
KEN.DisplayObjectContainer.prototype.constructor = KEN.DisplayObjectContainer;


/**
 * Boot sequence
 * @method  KEN.DisplayObjectContainer#_boot
 * @private
 */
KEN.DisplayObjectContainer.prototype._boot = function()
{
    KEN.DisplayObject.prototype._boot.call(this);

    if(this._className === "DisplayObjectContainer")
    {
        //root container have to be updated
        var needsUpdate = this._root !== null;

        if(needsUpdate === true)
        {
            this._rootData =
            {
                originalWidth: this._root.clientWidth,
                originalHeight: this._root.clientHeight,
                currentWidth: this._root.clientWidth,
                currentHeight: this._root.clientHeight,
                scaleWidth: 1,
                scaleHeight: 1,

                frameCount: 0, //Current frame count
                frameInterval: 10 //Number of frame needed to check size
            };

            this._width = this._rootData.currentWidth;
            this._dom.style["width"] = this["pixelWidth"]+"px";

            this._height = this._rootData.currentHeight;
            this._dom.style["height"] = this["pixelHeight"]+"px";

            this._root.style["position"] = "relative";
            this._dom.style["position"] = "absolute";

            this._root.appendChild(this._dom);
        }

        this._viewer["display"].register(this, needsUpdate);
        this._notifyReady();
        this._applyPending(false);
    }
};

/**
 * Notify that the dispay object has been resized.<br>
 * This method ovverrides the {@link KEN.DisplayObject} method.<br>
 * The parent will notify their children of its resize.
 * @method  KEN.DisplayObjectContainer#_notifyResize
 * @private
 * @param {PropertyToUpdate} data - The data contains the property that have changed.
 */
KEN.DisplayObjectContainer.prototype._notifyResize = function(data)
{
    for(var i = 0, ii = this._children.length; i < ii; i++)
    {
        this._children[i]._notifyParentResize(data);
    }

    KEN.DisplayObject.prototype._notifyResize.call(this, data);
};


/**
 * Internal method used by parents to notify that this DisplayObject has been added to DOM.
 * It notifies all children in addition of the usual behavior.
 * @method KEN.DisplayObject#_notifyAddedToDom
 * @private
 */
KEN.DisplayObjectContainer.prototype._notifyAddedToDom = function()
{
    KEN.DisplayObject.prototype._notifyAddedToDom.call(this);

    for(var i = 0, ii = this._children.length; i < ii; i++)
    {
        this._children[i]._notifyAddedToDom();
    }
};

/**
 * Notify that the visibility of this DisplayObjectContainer has changed to visible.<br>
 * This method overrides the DisplayObject's one.<br>
 * It notifies all children in addition of the usual behavior.
 * @method KEN.DisplayObjectContainer#_notifyShow
 * @private
 */
KEN.DisplayObjectContainer.prototype._notifyShow = function()
{
    KEN.DisplayObject.prototype._notifyShow.call(this);

    for(var i = 0, ii = this._children.length; i < ii; i++)
    {
        this._children[i]._notifyShow();
    }
};

/**
 * Notify that the visibility of this DisplayObjectContainer has changed to invisible.<br>
 * This method overrides the DisplayObject's one.<br>
 * It notifies all children in addition of the usual behavior.
 * @method KEN.DisplayObjectContainer#_notifyHide
 * @private
 */
KEN.DisplayObjectContainer.prototype._notifyHide = function()
{
    KEN.DisplayObject.prototype._notifyHide.call(this);

    for(var i = 0, ii = this._children.length; i < ii; i++)
    {
        this._children[i]._notifyHide();
    }
};

/**
 * Get the index of a child.
 * @method  KEN.DisplayObjectContainer#_indexOfChild
 * @private
 * @param  {KEN.DisplayObject} child - The child you search for.
 * @return {number} Returns index of the searched child if found, -1 if not found.
 */
KEN.DisplayObjectContainer.prototype._indexOfChild = function(child)
{
    if(this._children === null)
    {
        return -1;
    }

    for(var i = 0, ii = this._children.length; i < ii; i++)
    {
        if(this._children[i] === child)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Apply the index of the children.
 * @method  KEN.DisplayObjectContainer#_applyChildrenIndexes
 * @private
 */
KEN.DisplayObjectContainer.prototype._applyChildrenIndexes = function()
{
    var child;
    for(var i = 0, ii = this._children.length; i < ii; i++)
    {
        child = this._children[i];
        child["index"] = i;
    }
};

/**
 * Update method that is called only if the container is a root container.
 * @method KEN.DisplayObjectContainer#update
 */
KEN.DisplayObjectContainer.prototype.update = function()
{
    this._rootData.frameCount++;

    //trigger update every X frames defined by this._frameInterval
    if(this._rootData.frameCount < this._rootData.frameInterval)
    {
        return;
    }

    this._rootData.frameCount = 0;

    var w = this._root.clientWidth;
    var h = this._root.clientHeight;

    var resized = false;

    if(w !== this._rootData.currentWidth)
    {
        this._rootData.currentWidth = w;
        this._rootData["scaleWidth"] = this._rootData.currentWidth / this._rootData["originalWidth"];
        resized = true;
    }

    if(h !== this._rootData.currentHeight)
    {
        this._rootData.currentHeight = h;
        this._rootData["scaleHeight"] = this._rootData.currentHeight / this._rootData["scaleHeight"];
        resized = true;
    }

    if(resized === true)
    {
        this.resize(this._rootData.currentWidth, this._rootData.currentHeight);
    }
};

/**
 * Add a child to this display object container.
 * @method  KEN.DisplayObjectContainer#addChild
 * @param {KEN.DisplayObject} child - The {@link KEN.DisplayObject} you want to add to this display object container.
 */
KEN.DisplayObjectContainer.prototype.addChild = function(child)
{
    if(child === this)
    {
        throw "You can't add a KEN.DisplayObjectContainer to itself!";
    }

    /** @type {KEN.DisplayObject} */
    var c = child;

    // If a DOM Element is added, convert it to a display object.
    if(child instanceof Element)
    {
        c = new KEN.DisplayObject(child);
    }

    //Add dom element to the container dom
    this._dom.appendChild(c["dom"]);

    //Affect the parent value (it triigers the added to parent event so it is important to be in DOM before!)
    c["parent"] = this;

    //Set the index
    var index = this._children.push(c) - 1;
    if(c["index"] === null)
    {
        c["index"] = index;
    }

    //this._fitToContent(this._children);
};

/**
 * Add a child to this display object container at a specific index.
 * @method  KEN.DisplayObjectContainer#addChild
 * @param {KEN.DisplayObject} child - The {@link KEN.DisplayObject} you want to add to this display object container.
 * @param {number} index - The index you want to apply to your child.
 */
KEN.DisplayObjectContainer.prototype.addChildAt = function(child, index)
{
    var c = child;

    // If a DOM Element is added, convert it to a display object.
    if(child instanceof Element)
    {
        c = new KEN.DisplayObject(child);
    }

    //Add dom element to the container dom
    this._dom.appendChild(c["dom"]);

    //Affect the parent value (it triggers the added to parent event so it is important to be in DOM before!)
    c["parent"] = this;

    //Set the index
    this._children.splice(index, 0, c);
    c["index"] = index;

    this._applyChildrenIndexes();

    //this._fitToContent(this._children);
};

/**
 * Make the container to fit content.
 * @method  KEN.DisplayObjectContainer#fitToContent
 */
KEN.DisplayObjectContainer.prototype.fitToContent = function()
{
    var children = this._children;

    if(children.length > 0)
    {
        this._fitted = true;

        for(var i = 0, ii = children.length; i < ii; i++)
        {
            if(children[i].isInDom() === true && children[i]["visible"] === true)
            {
                //@todo what happens if visible or isInDOM are set after?

                var maxWidth = Math.max(children[i]["width"] + children[i].x, children[i]["width"] + children[i]["left"], children[i]["width"] + children[i]["right"]);
                var maxHeight = Math.max(children[i]["height"] + children[i].y, children[i]["height"] + children[i]["top"], children[i]["height"] + children[i]["bottom"]);
                if(maxWidth > this["pixelWidth"])
                {
                    this["width"] = maxWidth;
                }
                if(maxHeight > this["pixelHeight"])
                {
                    this["height"] = maxHeight;
                }
            }
        }
    }

    if(this["parent"] !== null && KEN.Utils.isTypeOf(this["parent"], "DisplayObjectContainer") === true && this["parent"]._fitted === true)
    {
        //recursive to parent
        this["parent"].fitToContent();
    }
};

/**
 * Remove a child from this display object container.
 * @method  KEN.DisplayObjectContainer#removeChild
 * @param {KEN.DisplayObject} child - The {@link KEN.DisplayObject} you want to remove from this display object container.
 * @param {boolean=} destroy - Does the container have to destroy the child that is removed.
 */
KEN.DisplayObjectContainer.prototype.removeChild = function(child, destroy)
{
    var index = this._indexOfChild(child);

    if(index !== -1)
    {
        this.removeChildAt(index, destroy);
    }
};

/**
 * Remove child at a specific index.
 * @method  KEN.DisplayObjectContainer#removeChildAt
 * @param  {number} index - The index at which you want to remove the child .
 * @param  {boolean=} destroy - Does the method should destroy the child in addtion of removing of the display list.
 */
KEN.DisplayObjectContainer.prototype.removeChildAt = function(index, destroy)
{
    if(index >= 0 && index < this._children.length)
    {
        var child = this._children[index];

        this._children.splice(index, 1);

        this._dom.removeChild(child["dom"]);

        if(typeof destroy === "undefined" || destroy === true)
        {
            child.destroy();
        }

        // reset container size if fit to content
        if(this._fitted === true && this._children.length === 0)
        {
            this["width"] = 0;
            this["height"] = 0;
        }
    }
};

/**
 * Remove all children.
 * @method  KEN.DisplayObjectContainer#empty
 * @param  {boolean} destroy - Does the method should destroy the children in addtion of removing of the display list.
 */
KEN.DisplayObjectContainer.prototype.empty = function(destroy)
{
    var index = this._children.length;

    while(index--)
    {
        this.removeChildAt(index, destroy);
    }
};

/**
 * Check if a {@link KEN.DisplayObject} is a child of this display object container.
 * @method  KEN.DisplayObjectContainer#hasChild
 * @param {KEN.DisplayObject} child - The {@link KEN.DisplayObject} you want to check.
 */
KEN.DisplayObjectContainer.prototype.hasChild = function(child)
{
    return this._indexOfChild(child) !== -1;
};

/**
 * Destroy method.
 * @method KEN.DisplayObjectContainer#destroy
 */
KEN.DisplayObjectContainer.prototype.destroy = function()
{
    this.empty(false);

    this._children = null;

    this._root = null;
    this._rootData = null;

    KEN.DisplayObject.prototype.destroy.call(this);
};

/**
* Get the children array.
* @name KEN.DisplayObjectContainer#children
* @readonly
* @type {Array}
*/
KEN.DisplayObjectContainer.prototype.children;
Object.defineProperty(KEN.DisplayObjectContainer.prototype, "children",
{
    /** @this {KEN.DisplayObjectContainer} */
    get: function()
    {
        return this._children;
    }
});

/**
* Get and set the overflow property.
* @name KEN.DisplayObjectContainer#oveflow
* @type {string}
*/
KEN.DisplayObjectContainer.prototype.overflow;
Object.defineProperty(KEN.DisplayObjectContainer.prototype, "overflow",
{
    /** @this {KEN.DisplayObjectContainer} */
    get: function()
    {
        return this._overflow;
    },

    /** @this {KEN.DisplayObjectContainer} */
    set: function(value)
    {
        var values = ["hidden", "visible", "scroll"];

        if(values.indexOf(value) !== -1)
        {
            this._overflow = value;
            this._dom.style["overflow"] = value;
        }

    }
});


/**
 * An image is a display object with an internationalizable image source.
 *
 * @constructor KEN.Image
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @param {(ImageConfig|string)=} config - The image configuration to load.
 * @param {string=} className - The className of the object.
 * @extends {KEN.DisplayObject}
 */
KEN.Image = function(viewer, config, className)
{
    /**
     * Image configuration
     * @name  KEN.Image#_config
     * @type {?Object|string}
     * @property {string} key - The cache key associated to this image.
     * @property {string} url - The URL of the image if not i18n
     * @property {string} i18n - The i18n key to find the URL of an i18n image.
     * @private
     */
    this._config = config || null;

    /**
     * The key associated to this image.
     * @name  KEN.Image#_imageKey
     * @type {string}
     * @private
     */
    this._imageKey = "";

    /**
     * The url of this image.
     * @name  KEN.Image#_imageUrl
     * @type {string}
     * @private
     */
    this._imageUrl = "";

    /**
     * Is this image is internationnalized?
     * @name  KEN.Image#_i18n
     * @type {boolean}
     * @private
     */
    this._i18n = false;

    /**
     * The i18n key associated to the image ressource in cache.
     * @name  KEN.Image#_i18nImageKey
     * @type {string}
     * @private
     */
    this._i18nImageKey = "";

    /**
     * The i18n key associated to the url.
     * @name  KEN.Image#_i18nImageUrl
     * @type {string}
     * @private
     */
    this._i18nImageUrl = "";

    /**
     * The {@link KEN.LocaleString} that handles the different url for different languages.
     * @name  KEN.Image#_i18nImageUrlLocaleString
     * @type {?KEN.LocaleString}
     * @private
     */
    this._i18nImageUrlLocaleString = null;

    /**
     * The HTML Image object from the cache source.
     * @name KEN.Image#_img
     * @type {?Element|HTMLImageElement}
     * @private
     */
    this._img = null;

    /**
     * Is the Image source is loaded?
     * @name  KEN.Image#_imageLoaded
     * @type {boolean}
     * @private
     */
    this._imageLoaded = false;

    /**
     * The frame represent the portion of the image source that will be used as background for dom.<br>
     * A frame is described like this : {x: 0, y: 0, w: 0, h: 0}.
     * @name  KEN.Image#_frame
     * @type {?ImageFrame}
     * @private
     */
    this._frame = null;

    /**
     * An image can have different frames.<br>
     * This array contains all available frames for this image.
     * @type {Array<ImageFrameConfig>}
     * @private
     */
    this._frames = null;

    /**
     * This is the url of the frames JSON file.
     * @name  KEN.Image#_framesUrl
     * @type {string}
     * @private
     */
    this._framesUrl = "";

    /**
     * Flag to know if the frames are loaded.<br>
     * If there are no frames, they are considered as loaded.
     * @name KEN.Image#_framesLoaded
     * @type {boolean}
     * @private
     */
    this._framesLoaded = false;

    /**
     * Is the current ressource is loaded.
     * @name KEN.Image#_loaded
     * @type {boolean}
     * @private
     */
    this._loaded = false;

    /**
     * Auto width flag, default to true
     * @name  KEN.Image#_autoWidth
     * @type {boolean}
     * @private
     */
    this._autoWidth = true;

    /**
     * Auto height flag, default to true
     * @name  KEN.Image#_autoHeight
     * @type {boolean}
     * @private
     */
    this._autoHeight = true;

    /**
     * Which render mode is used for image rendering?.<br>
     * Available render modes are listed in a constant KEN.Image.renderModes
     * and the default mode is stored in KEN.Image.renderMode.
     * @name  KEN.Image#_renderMode
     * @type {string}
     * @private
     */
    this._renderMode = KEN.Image.renderMode;

    /**
     * If the renderMode is CANVAS, you'll need a canvas element, so this is the canvas reference.
     * @name  KEN.Image#_canvas
     * @type {Element|HTMLCanvasElement}
     * @private
     */
    this._canvas = null;

    /**
     * On load start event dispatcher.
     * @name  KEN.Image#_onLoadStart
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onLoadStart = null;

    /**
     * On load complete event dispatcher.
     * @name  KEN.Image#_onLoadComplete
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onLoadComplete = null;

    KEN.DisplayObject.call(this, viewer, null, className || "Image");
};

KEN.Image.prototype = Object.create(KEN.DisplayObject.prototype);
KEN.Image.prototype.constructor = KEN.Image;

/**
 * Render modes list.
 * @name KEN.Image.renderModes
 * @type {Object}
 * @const
 */
KEN.Image.renderModes = {};

/**
 * @name KEN.Image.renderModes.CSS
 * @type {string}
 * @const
 */
KEN.Image.renderModes.CSS = "css";

/**
 * @name KEN.Image.renderModes.CANVAS
 * @type {string}
 * @const
 */
KEN.Image.renderModes.CANVAS = "canvas";

/**
 * Default render mode.
 * @name KEN.Image.renderModes
 * @type {string}
 */
KEN.Image.renderMode = KEN.Image.renderModes.CSS;

/**
 * Boot sequence.
 * @method KEN.Image#_boot
 * @private
 */
KEN.Image.prototype._boot = function()
{
    KEN.DisplayObject.prototype._boot.call(this);

    //Images keeps ratio by default
    this._keepRatio = true;

    if(this._renderMode === KEN.Image.renderModes.CSS)
    {
        this._dom.style.backgroundRepeat = "no-repeat";
    }
    else if(this._renderMode === KEN.Image.renderModes.CANVAS)
    {
        this._canvas = document.createElement("canvas");
        this._canvas.style["position"] = "absolute";
        this._canvas.style["top"] = "0px";
        this._canvas.style["left"] = "0px";
        this._dom.appendChild(this._canvas);
    }

    if(this._config !== null)
    {
        this.load(this._config);
    }

    this._viewer["display"].register(this);
    this._notifyReady();
};

/**
 * Notify that the dispay object has been resized.<br>
 * This method ovverrides the {@link KEN.DisplayObject} method.
 * @method  KEN.Image#_notifyResize
 * @private
 * @param  {PropertyToUpdate} data - The data contains the property that have changed.
 */
KEN.Image.prototype._notifyResize = function(data)
{
    var property = data.property;

    //If property is related to width except autoWidth
    if(property.toLowerCase().indexOf("width") !== -1 && property !== "autoWidth")
    {
        this._autoWidth = false;
    }

    //If property is related to height except autoHeight
    if(property.toLowerCase().indexOf("height") !== -1 && property !== "autoHeight")
    {
        this._autoHeight = false;
    }

    if(this._img === null)
    {
        return;
    }

    if(this._renderMode === KEN.Image.renderModes.CSS)
    {
        this._updateBackgroundSize();
        this._updateBackgroundPosition();
    }
    else if(this._renderMode === KEN.Image.renderModes.CANVAS)
    {
        if(this._frame !== null)
        {
            this._drawFrame(this._frame);
        }
    }

    if(this._keepRatio === true)
    {
        if(property.toLowerCase().indexOf("width") !== -1)
        {
            this._updateScaleWidth();
        }
        else if(property.toLowerCase().indexOf("height") !== -1)
        {
            this._updateScaleHeight();
        }
    }

    KEN.DisplayObject.prototype._notifyResize.call(this, data);
};

/**
 * Internal method that updates image position to be centered in this borders.<br>
 * this is an override of the DisplayObject method
 * @method KEN.Image#_notifyBorderResize
 * @private
 */
KEN.Image.prototype._notifyBorderResize = function()
{
    if(this._renderMode === KEN.Image.renderModes.CSS)
    {
        this._dom.style.backgroundPosition = (- this._borderWidth)+"px "+(- this._borderWidth)+"px";
    }
    else if(this._renderMode === KEN.Image.renderModes.CANVAS)
    {
        this._canvas.style["top"] = - this._borderWidth+"px";
        this._canvas.style["left"] = - this._borderWidth+"px";
    }

    KEN.DisplayObject.prototype._notifyBorderResize.call(this);
};

/**
 * Internal method that notify the load complete.<br>
 * this method can be overrided by a class that extends Image.
 * @method KEN.Image#_notifyLoadComplete
 * @private
 */
KEN.Image.prototype._notifyLoadComplete = function()
{
    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.dispatch();
    }
};

/**
 * Get the cache key for a specific locale.
 * @method KEN.Image#_getLocalizedCacheKey
 * @private
 * @param  {string} locale - The locale of the cache key you ask for.
 * @return {string} The cache key for the locale you asked.
 */
KEN.Image.prototype._getLocalizedCacheKey = function(locale)
{
    return this._imageKey + "_" + locale;
};

/**
 * Handler for locale change.
 * @method KEN.Image#_localeChangeComplete
 * @private
 */
KEN.Image.prototype._localeChangeComplete = function()
{
    var key = this._getLocalizedCacheKey(this._viewer["i18n"]["locale"]);

    if(key === this._i18nImageKey)
    {
        return;
    }

    this._i18nImageKey = key;

    if(this._viewer["i18n"].hasValue(this._i18nImageUrl) === true)
    {
        var url = this._i18nImageUrlLocaleString["value"];
        this._loadImage(key, url);
    }
};

/**
 * Set the image frame.<br>
 * The frame is the source rctangle that is used as background image.
 * @method  KEN.Image#_setFrame
 * @private
 * @param {ImageFrame} frame - A frame is described like this : {x: 0, y: 0, w: 0, h: 0}.
 */
KEN.Image.prototype._setFrame = function(frame)
{
    this._frame = frame;

    if(this._autoWidth === true)
    {
        this._width = this._frame.w;
        this._unitWidth = "px";
        this._dom.style["width"] = this["pixelWidth"]+"px";
    }

    if(this._autoHeight === true)
    {
        this._height = this._frame.h;
        this._unitHeight = "px";
        this._dom.style["height"] = this["pixelHeight"]+"px";
    }

    if(this._renderMode === KEN.Image.renderModes.CSS)
    {
        this._updateBackgroundSize();
        this._updateBackgroundPosition();
    }
    else if(this._renderMode === KEN.Image.renderModes.CANVAS)
    {
        this._drawFrame(this._frame);
    }
};

/**
 * Method to draw the frame if render mode is CANVAS.
 * @method KEN.Image#_drawFrame
 * @private
 * @param  {Object} frame - The frame to draw
 */
KEN.Image.prototype._drawFrame = function(frame)
{
    if(this._img === null || this._imageLoaded === false)
    {
        return;
    }

    this._canvas["width"] = this["innerWidth"];
    this._canvas["height"] = this["innerHeight"];

    var ctx = this._canvas.getContext("2d");
    ctx.clearRect(0, 0, this["innerWidth"], this["innerHeight"]);
    ctx.drawImage(this._img, frame.x, frame.y, frame.w, frame.h, 0, 0, this["innerWidth"], this["innerHeight"]);
};

/**
 * Internal method to update the background image size.
 * @method KEN.Image#_updateBackgroundSize
 * @private
 */
KEN.Image.prototype._updateBackgroundSize = function()
{
    var backgroundWidth = (this["pixelWidth"] / this._frame.w) * this._img.naturalWidth;
    var backgroundHeight = (this["pixelHeight"] / this._frame.h) * this._img.naturalHeight;
    this._dom.style.backgroundSize = backgroundWidth+"px "+backgroundHeight+"px";
};

/**
 * Internal method to update the background image position.
 * @method KEN.Image#_updateBackgroundPosition
 * @private
 */
KEN.Image.prototype._updateBackgroundPosition = function()
{
    var posX = (- this._frame.x - this._borderWidth) * (this["pixelWidth"] / this._frame.w);
    var posY = (- this._frame.y - this._borderWidth) * (this["pixelHeight"] / this._frame.h);
    this._dom.style.backgroundPosition = posX+"px "+posY+"px";
};

/**
 * Update the size of the image based on scale width.
 * @method  KEN.Image#_updateScaleWidth
 * @private
 */
KEN.Image.prototype._updateScaleWidth = function()
{
    var scaleWidth = this["pixelWidth"] / this._frame.w;

    if(scaleWidth === this._scaleWidth)
    {
        return;
    }

    this._scaleWidth = scaleWidth;

    if(this._keepRatio === true)
    {
        this._scaleHeight = scaleWidth;
        this["height"] = this._frame.h * this._scaleHeight;
    }
};

/**
 * Update the size of the image based on scale height.
 * @method  KEN.Image#_updateScaleHeight
 * @private
 */
KEN.Image.prototype._updateScaleHeight = function()
{
    var scaleHeight = this["pixelHeight"] / this._frame.h;

    if(scaleHeight === this._scaleHeight)
    {
        return;
    }

    this._scaleHeight = scaleHeight;

    if(this._keepRatio === true)
    {
        this._scaleWidth = scaleHeight;
        this["width"] = this._frame.w * this._scaleWidth;
    }
};

/**
 * Internal method to load an image asset.
 * @method KEN.Image#_load
 * @private
 * @param {string} key - The key associated to the asset for cache.
 * @param {string} url - The URL of the asset.
 */
KEN.Image.prototype._loadImage = function(key, url)
{
    this._loaded = false;
    this._viewer["load"].image(key, url, this._loadImageComplete, this);
};

/**
 * Event handler for image load complete.
 * @method KEN.Image#_loadImageComplete
 * @private
 */
KEN.Image.prototype._loadImageComplete = function(file)
{
    //If image is destroy during loading time, don't execute the callback
    if(this._alive === false)
    {
        return;
    }

    this._img = file["data"];

    if(this._renderMode === KEN.Image.renderModes.CSS)
    {
        this._dom.style.backgroundImage = "url('"+file["url"]+"')";
    }

    this._imageLoaded = true;

    this._loadComplete();
};

/**
 * Method to load frames data.
 * @method  KEN.Image#_loadFrames
 * @param  {string} url - Url of the JSON file taht handles frame data.
 * @private
 */
KEN.Image.prototype._loadFrames = function(url)
{
    this._loaded = false;

    var key = this._imageKey+"-frames";
    this._viewer["load"].json(key, url, this._loadFramesComplete, this);
};

/**
 * Event handler for frame data load complete.
 * @method  KEN.Image#_loadFramesComplete
 * @param  {KEN.File} file - The file that is loaded
 * @private
 */
KEN.Image.prototype._loadFramesComplete = function(file)
{
    if(typeof file["data"]["frames"] !== "undefined")
    {
        this._frames = file["data"]["frames"];
        //this._setFrame(this._frames[0]["frame"]);
    }
    else
    {
        this.warn("No frames found in file!");
    }

    this._framesLoaded = true;

    this._loadComplete();
};

/**
 * This method validate the complete loading of all the assets (image + frames)
 * @method KEN.Image#_loadComplete
 * @private
 */
KEN.Image.prototype._loadComplete = function()
{
    if(this._loaded === true)
    {
        return;
    }

    if(this._imageLoaded === true && this._framesLoaded === true)
    {
        this._loaded = true;

        var frame;

        if(this._frame !== null)
        {
            frame = this._frame;
        }
        else
        {
            if(this._frames !== null)
            {
                frame = this._frames[0]["frame"];
            }
            else
            {
                frame =
                {
                    x: 0,
                    y: 0,
                    w: this._img.naturalWidth,
                    h: this._img.naturalHeight
                };
            }
        }

        this._setFrame(frame);

        this._updateAnchors();

        this._applyPending(false);

        this._notifyLoadComplete();
    }
};

/**
 * Inner method that parse an image configuration.
 * @method KEN.Image#_parseConfig
 * @param  {ImageConfig|string} config - Image configuration object
 * @private
 */
KEN.Image.prototype._parseConfig = function(config)
{
    if(typeof config === "object" && config !== null)
    {
        this._imageKey = config["key"] || "";

        this._i18n = config["i18n"] || false;

        if(this._i18n === true)
        {
            this._imageUrl = "";
            this._i18nImageUrl = config["url"];
        }
        else
        {
            this._imageUrl = config["url"];
        }

        this._frame = config["frame"] || null;

        if(typeof config["frames"] === "string")
        {
            this._framesUrl = config["frames"];
        }
        else if(typeof config["frames"] === "object" && config["frames"] !== null)
        {
            this._frames = config["frames"];
        }

        //Applying style in config
        this["alpha"] = config["alpha"];
        this["keepRatio"] = config["keepRatio"];
        this["maximized"] = config["maximized"];
        this["width"] = config["width"];
        this["height"] = config["height"];
    }
    else
    {
        this._imageKey = "";
        this._imageUrl = "";
        this._i18n = false;

        if(typeof config === "string")
        {
            this._imageUrl = config;
        }
    }
};

/**
 * Internal method to load an image asset.
 * @method KEN.Image#load
 * @param {string|ImageConfig} config - The config to load, can be an url or a configuration object.
 */
KEN.Image.prototype.load = function(config)
{
    this._loaded = false;
    this._imageLoaded = false;
    this._framesLoaded = false;

    this._parseConfig(config);

    var imageKey = this._imageKey;
    var imageUrl = this._imageUrl;

    if(this._i18n === true && typeof this._i18nImageUrl === "string")
    {
        this._i18nImageUrlLocaleString = new KEN.LocaleString(this._viewer, this._i18nImageUrl);

        if(this._viewer["i18n"]["onLocaleChangeComplete"].has(this._localeChangeComplete, this) === false)
        {
            this._viewer["i18n"]["onLocaleChangeComplete"].add(this._localeChangeComplete, this);
        }

        var locale = this._viewer["i18n"]["locale"];
        if(locale !== "")
        {
            imageKey = this._getLocalizedCacheKey(locale);
        }

        if(this._viewer["i18n"].hasValue(this._i18nImageUrl) === true)
        {
            imageUrl = this._i18nImageUrlLocaleString["value"];
        }
    }

    if(imageUrl !== "")// && typeof imageUrl !== "undefined")
    {
        this._loadImage(imageKey, imageUrl);
    }
    else
    {
        this._imageLoaded = true;
    }

    if(typeof this._framesUrl === "string" && this._framesUrl !== "")
    {
        this._loadFrames(this._framesUrl);
    }
    else
    {
        this._framesLoaded = true; //Consider frames as loaded if there are no frames
    }
};

/**
 * Unload the image background from the DOM object.
 * @method  KEN.Image#unload
 */
KEN.Image.prototype.unload = function()
{
    this._dom.style.backgroundImage = "";
    this._img = null;
};

/**
 * Destroy method.
 * @method KEN.Image#destroy
 * @param {boolean=} clearCache - Does the destroy sequence have to clear the image cache?
 */
KEN.Image.prototype.destroy = function(clearCache)
{
    if(this._alive === false)
    {
        return;
    }

    if(this._i18nImageUrlLocaleString !== null)
    {
        this._i18nImageUrlLocaleString.destroy();
        this._i18nImageUrlLocaleString = null;
        this._viewer["i18n"]["onLocaleChangeComplete"].remove(this._localeChangeComplete, this);
    }

    if(this._onLoadStart !== null)
    {
        this._onLoadStart.destroy();
        this._onLoadStart = null;
    }

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.destroy();
        this._onLoadComplete = null;
    }

    this._img = null;

    if(typeof clearCache === "undefined" || clearCache === true)
    {
        if(this._i18n === true)
        {
            var locales = this._viewer["i18n"]["locales"];
            var cacheKey;
            for(var i = 0, ii = locales.length; i < ii; i++)
            {
                cacheKey = this._getLocalizedCacheKey(locales[i]);
                this._viewer["cache"].remove(KEN.Cache.types.IMAGE, cacheKey);
            }
        }
        else
        {
            this._viewer["cache"].remove(KEN.Cache.types.IMAGE, this._imageKey);
        }
    }

    KEN.DisplayObject.prototype.destroy.call(this);
};

/**
* Get the loaded status of the image.
* @name KEN.Image#loaded
* @readonly
* @type {boolean}
*/
KEN.Image.prototype.loaded;
Object.defineProperty(KEN.Image.prototype, "loaded",
{
    /** @this {KEN.Image} */
    get: function()
    {
        return this._loaded;
    }
});

/**
* Get the current image element.
* @name KEN.Image#element
* @readonly
* @type {number}
*/
KEN.Image.prototype.element;
Object.defineProperty(KEN.Image.prototype, "element",
{
    /** @this {KEN.Image} */
    get: function()
    {
        return this._img;
    }
});

/**
* Get and set the current frame {x: 0, y: 0, w: 0, h: 0}.
* @name KEN.Image#frame
* @type {Object}
*/
KEN.Image.prototype.frame;
Object.defineProperty(KEN.Image.prototype, "frame",
{
    /** @this {KEN.Image} */
    get: function()
    {
        return this._frame;
    },

    /** @this {KEN.Image} */
    set: function(frame)
    {
        this._setFrame(frame);
    }
});

/**
* Get the frames array.
* @name KEN.Image#frames
* @readonly
* @type {Array<ImageFrameConfig>}
*/
KEN.Image.prototype.frames;
Object.defineProperty(KEN.Image.prototype, "frames",
{
    /** @this {KEN.Image} */
    get: function()
    {
        return this._frames;
    }
});

/**
* Get the original width of the image.
* @name KEN.Image#originalWidth
* @readonly
* @type {number}
*/
KEN.Image.prototype.originalWidth;
Object.defineProperty(KEN.Image.prototype, "originalWidth",
{
    /** @this {KEN.Image} */
    get: function()
    {
        if(this._img !== null)
        {
            return this._img.naturalWidth;
        }
    }
});

/**
* Get the original height of the image.
* @name KEN.Image#originalHeight
* @readonly
* @type {number}
*/
KEN.Image.prototype.originalHeight;
Object.defineProperty(KEN.Image.prototype, "originalHeight",
{
    /** @this {KEN.Image} */
    get: function()
    {
        if(this._img !== null)
        {
            return this._img.naturalHeight;
        }
    }
});

/**
* Get the onLoadStart {@link KEN.EventDispatcher}.
* @name KEN.Image#onLoadStart
* @readonly
* @type {KEN.EventDispatcher}
*/
KEN.Image.prototype.onLoadStart;
Object.defineProperty(KEN.Image.prototype, "onLoadStart",
{
    /** @this {KEN.Image} */
    get: function()
    {
        if(this._onLoadStart === null)
        {
            this._onLoadStart = new KEN.EventDispatcher(this);
        }

        return this._onLoadStart;
    }
});

/**
* Get the onLoadComplete {@link KEN.EventDispatcher}.
* @name KEN.Image#onLoadComplete
* @readonly
* @type {KEN.EventDispatcher}
*/
KEN.Image.prototype.onLoadComplete;
Object.defineProperty(KEN.Image.prototype, "onLoadComplete",
{
    /** @this {KEN.Image} */
    get: function()
    {
        if(this._onLoadComplete === null)
        {
            this._onLoadComplete = new KEN.EventDispatcher(this);
        }

        return this._onLoadComplete;
    }
});

/**
 * Scalable Image.
 *
 * @constructor KEN.ImageScalable
 * @param {KEN.Viewer} viewer - The Viewer reference.
 * @param {(string|ImageConfig)} config - Image configuration object or just tan image URL.
 * @extends {KEN.Image}
 */
KEN.ImageScalable = function(viewer, config)
{
    /**
     * Scale width
     * @name KEN.ImageScalable#_scaleWidth
     * @type {number}
     * @private
     */
    this._scaleWidth = 1;

    /**
     * Scale height
     * @name KEN.ImageScalable#_scaleHeight
     * @type {number}
     * @private
     */
    this._scaleHeight = 1;

    /**
     * Initial size
     * @name KEN.ImageScalable#_initialSize
     * @type {KEN.Size}
     * @private
     */
    this._initialSize = null;

    KEN.Image.call(this, viewer, config, "ImageScalable");

    this._boot();
};

KEN.ImageScalable.prototype = Object.create(KEN.Image.prototype);
KEN.ImageScalable.prototype.constructor = KEN.ImageScalable;

/**
 * Boot Sequence
 * @method KEN.ImageScalable#_boot
 * @private
 */
KEN.ImageScalable.prototype._boot = function()
{
    this.warn(this._className + " test both render modes");
    this._renderMode = KEN.Image.renderModes.CANVAS;

    KEN.Image.prototype._boot.call(this);
};

/**
 * Event handler for image load complete.
 * @method KEN.ImageScalable#_loadImageComplete
 * @private
 */
KEN.ImageScalable.prototype._loadImageComplete = function(file)
{
    var image = file["data"];

    this._initialSize = new KEN.Size(image.naturalWidth, image.naturalHeight);

    KEN.Image.prototype._loadImageComplete.call(this, file);
};

/**
 * Method to draw the frame if render mode is CANVAS.
 * @method KEN.ImageScalable#_drawFrame
 * @param  {Object} frame - The frame to draw
 * @private
 */
KEN.ImageScalable.prototype._drawFrame = function(frame)
{
    this.log(frame);

    if (this._renderMode !== KEN.Image.renderModes.CANVAS)
    {
        this.warn ("Invalid render mode for " + this._className);
        return;
    }

    if(this._img === null || this._imageLoaded === false)
    {
        return;
    }

    this._width = this._canvas["width"] = this._initialSize["width"] * this._scaleWidth;
    this._dom.style["width"] = this._canvas["width"] + "px";

    this._height = this._canvas["height"] = this._initialSize["height"] * this._scaleHeight;
    this._dom.style["height"] = this._canvas["height"] + "px";

    var ctx = this._canvas.getContext("2d");
    ctx.clearRect(0, 0, this._canvas["width"], this._canvas["height"]);
    ctx.drawImage(this._img, 0, 0, this._initialSize["width"], this._initialSize["height"], 0, 0, this._canvas["width"], this._canvas["height"]);
};

/**
 * Destroy method
 * @method  KEN.ImageScalable#destroy
 */
KEN.ImageScalable.prototype.destroy = function()
{
    this._initialSize = null;

    KEN.Image.prototype.destroy.call(this);
};

/**
 * Get/Set scale width
 * @name  KEN.ImageScalable#scaleWidth
 * @type {number}
 */
KEN.ImageScalable.prototype.scaleWidth;
Object.defineProperty(KEN.ImageScalable.prototype, "scaleWidth",
{
    /** @this {KEN.ImageScalable} */
    get: function()
    {
        return this._scaleWidth;
    },
    /** @this {KEN.ImageScalable} */
    set: function(value)
    {
        value = Math.max(Number.EPSILON, value);

        if (this._scaleWidth !== value)
        {
            this._scaleWidth = value;
            this._drawFrame(this["frame"]);
        }
    }
});


/**
 * Get/Set scale height
 * @name  KEN.ImageScalable#scaleHeight
 * @type {number}
 */
KEN.ImageScalable.prototype.scaleHeight;
Object.defineProperty(KEN.ImageScalable.prototype, "scaleHeight",
{
    /** @this {KEN.ImageScalable} */
    get: function()
    {
        return this._scaleHeight;
    },
    /** @this {KEN.ImageScalable} */
    set: function(value)
    {
        value = Math.max(Number.EPSILON, value);

        if (this._scaleHeight !== value)
        {
            this._scaleHeight = value;
            this._drawFrame(this["frame"]);
        }
    }
});


/**
 * A Sprite is like an Image, except it can have animations.
 *
 * @constructor KEN.Sprite
 * @param {KEN.Viewer} viewer - The Viewer reference.
 * @param {(string|ImageConfig)} config - Configuration object.
 * @extends {KEN.Image}
 */
KEN.Sprite = function(viewer, config)
{
    /**
     * Animation manager
     * @name  KEN.Sprite#_animations
     * @type {KEN.AnimationManager}
     * @private
     */
    this._animations = null;

    KEN.Image.call(this, viewer, config, "Sprite");
};

KEN.Sprite.prototype = Object.create(KEN.Image.prototype);
KEN.Sprite.prototype.constructor = KEN.Sprite;

/**
 * Boot Sequence
 * @method KEN.Sprite#_boot
 * @private
 */
KEN.Sprite.prototype._boot = function()
{
    this._renderMode = KEN.Image.renderModes.CANVAS;

    KEN.Image.prototype._boot.call(this);

    this._animations = new KEN.AnimationManager(this);
    this._viewer["display"].register(this, true);
};

/**
 * Play an animation.<br>
 * This is a proxy to the {@link KEN.AnimationManager} play method.
 * @method  KEN.Sprite#play
 * @param  {string=} [animation] - The animation name you want to play. Default is the current animation.
 * @param  {boolean=} [loop=false] - Does the animation should loop?
 * @param  {number=} [index=0] - The frame index on which to start playing the animation.
 */
KEN.Sprite.prototype.play = function(animation, loop, index)
{
    this._animations.play(animation, loop, index);
};

/**
 * Pauses the current animation.<br>
 * This is a proxy to the {@link KEN.AnimationManager} pause method.
 * @method KEN.Sprite#pause
 * @param  {number=} index - The frame index on which to pause the animation. Default will be the current frame.
 */
KEN.Sprite.prototype.pause = function(index)
{
    this._animations.pause(index);
};

/**
 * Resume the current animation.<br>
 * This is a proxy to the {@link KEN.AnimationManager} resume method.
 * @method KEN.Sprite.resume
 * @param  {number=} index - The frame index on which to resume the animation. Default will be the current frame.
 */
KEN.Sprite.prototype.resume = function(index)
{
    this._animations.resume(index);
};

/**
 * Stops the current animation.<br>
 * This is a proxy to the {@link KEN.AnimationManager} stop method.
 * @method KEN.Sprite.stop
 */
KEN.Sprite.prototype.stop = function()
{
    this._animations.stop();
};

/**
 * Update method called by the display list.
 * @method KEN.Sprite#update
 */
KEN.Sprite.prototype.update = function()
{
    this._animations.update();
};

/**
 * Destroy method
 * @method  KEN.Sprite#destroy
 */
KEN.Sprite.prototype.destroy = function()
{
    if(this._alive === false)
    {
        return;
    }

    this._animations.destroy();
    this._animations = null;
    
    KEN.Image.prototype.destroy.call(this);
};

/**
 * Get the animation manager of this Sprite.
 * @name  KEN.Sprite#animations
 * @readonly
 * @type {KEN.AnimationManager}
 */
KEN.Sprite.prototype.animations;
Object.defineProperty(KEN.Sprite.prototype, "animations",
{
    /** @this {KEN.Sprite} */
    get: function()
    {
        return this._animations;
    }
});

/**
 * Get the curretn animation of this Sprite.
 * @name  KEN.Sprite#animation
 * @readonly
 * @type {KEN.Animation}
 */
KEN.Sprite.prototype.animation;
Object.defineProperty(KEN.Sprite.prototype, "animation",
{
    /** @this {KEN.Sprite} */
    get: function()
    {
        return this._animations["currentAnimation"];
    }
});


/**
 * Iframe display object.<br>
 * Can load an exteranl web page with i18n url.
 * @constructor KEN.Iframe
 * @param {KEN.Viewer} viewer - The viewer reference.
 * @param {(IframeConfig|string)=} config - Iframe configuration.
 * @extends {KEN.DisplayObject}
 */
KEN.Iframe = function(viewer, config)
{
    /**
     * The iframe html element
     * @name  KEN.Iframe#_element
     * @type {Element|HTMLIFrameElement}
     * @private
     */
    this._element = null;

    /**
     * The configuration object.
     * @name  KEN.Iframe#_config
     * @type {?(IframeConfig|string)}
     * @private
     */
    this._config = config || null;

    /**
     * The current url of the Iframe element.
     * @name KEN.Iframe#_url
     * @type {string}
     * @private
     */
    this._url = "";

    /**
     * The i18n flag of this display object.
     * @name KEN.Iframe#_i18n
     * @type {boolean}
     * @private
     */
    this._i18n = false;

    /**
     * The i18n key for the url to load into the iframe.
     * @name KEN.Iframe#_i18nUrl
     * @type {string}
     * @private
     */
    this._i18nUrl = "";

    /**
     * The i18n locale string used to translate the url to load into the iframe.
     * @name KEN.Iframe#_i18nUrlLocaleString
     * @type {KEN.LocaleString}
     * @private
     */
    this._i18nUrlLocaleString = null;

    /**
     * This is copy of load complete handler with this as this reference (bind).
     * @name  KEN.Iframe#_loadCompleteBind
     * @type {Function}
     * @default  null
     * @private
     */
    this._loadCompleteBind = null;

    /**
     * Is the current web content of the iframe is loaded.
     * @name KEN.Iframe#_loaded
     * @type {boolean}
     * @private
     */
    this._loaded = false;

    /**
     * On load start event dispatcher.
     * @name  KEN.Iframe#_onLoadStart
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onLoadStart = null;

    /**
     * On load complete event dispatcher.
     * @name  KEN.Iframe#_onLoadComplete
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onLoadComplete = null;

    KEN.DisplayObject.call(this, viewer, null, "Iframe");
};

KEN.Iframe.prototype = Object.create(KEN.DisplayObject.prototype);
KEN.Iframe.prototype.constructor = KEN.Iframe;

/**
 * Boot sequence.
 * @method KEN.Iframe#_boot
 * @private
 */
KEN.Iframe.prototype._boot = function()
{
    KEN.DisplayObject.prototype._boot.call(this);

    this._loadCompleteBind = this._loadCompleteHandler.bind(this);

    this._element = document.createElement("iframe");
    this._element.style["width"] = "100%";
    this._element.style["height"] = "100%";
    this._element.style.border = 0;
    this._element.style["overflow"] = "hidden";
    this._element.addEventListener("load", this._loadCompleteBind, this !== null && this !== undefined);
    this._element.setAttribute("allowFullScreen", "");
    this._dom.appendChild(this._element);

    if(this._config !== null)
    {
        this.load(this._config);
    }

    this._viewer["display"].register(this);
    this._notifyReady();
    this._applyPending(false);
};

/**
 * Handler for locale change.
 * @method KEN.Iframe#_localeChangeComplete
 * @private
 */
KEN.Iframe.prototype._localeChangeComplete = function()
{
    this.log("_localeChangeComplete");

    if(this._viewer["i18n"].hasValue(this._i18nUrl) === true)
    {
        var url = this._i18nUrlLocaleString["value"];
        this._loadIframe(url);
    }
};

/**
 * Load iframe content
 * @method  KEN.Iframe#_loadIframe
 * @param  {string} url - The url you want to load in the iframe.
 * @private
 */
KEN.Iframe.prototype._loadIframe = function(url)
{
    this.log("_loadIframe url: "+url);
    this._loaded = false;

    if(this._onLoadStart !== null)
    {
        this._onLoadStart.dispatch();
    }

    this._url = url;
    this._element.src = this._url;
};

/**
 * Internal handler for load complete.
 * This method is copied in _loadCompleteBind on boot with a new this reference!
 * @method  KEN.Iframe#_loadCompleteHandler
 * @private
 */
KEN.Iframe.prototype._loadCompleteHandler = function()
{
    //At creation the iframe load an empty url?
    //Just to prevent false load complete notification
    if(this._url === "")
    {
        return;
    }

    this.log("_loadCompleteHandler url: "+this._url);
    this._loaded = true;

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.dispatch();
    }
};

/**
 * Parse the iframe configuration.
 * @method  KEN.Iframe#_parseConfig
 * @param {(IframeConfig|string)} config - The configuration object to parse.
 * @private
 */
KEN.Iframe.prototype._parseConfig = function(config)
{
    if(typeof config === "object" && config !== null)
    {
        this._i18n = config["i18n"] || false;

        if(this._i18n === true)
        {
            this._url = "";
            this._i18nUrl = config["url"];
        }
        else
        {
            this._url = config["url"];
        }
    }
    else
    {
        this._i18n = false;
        this._url = "";

        if(typeof config === "string")
        {
            this._url = config;
        }
    }
};

/**
 * Add locale change complete listener.
 * @method KEN.Iframe#_addLocaleChangeListener
 * @private
 */
KEN.Iframe.prototype._addLocaleChangeListener = function()
{
    if(this._viewer["i18n"]["onLocaleChangeComplete"].has(this._localeChangeComplete, this) === false)
    {
        this._viewer["i18n"]["onLocaleChangeComplete"].add(this._localeChangeComplete, this);
    }
};

/**
 * Load an iframe configuration.
 * @method  KEN.Iframe#load
 * @param {(string|IframeConfig)} config - The url string or the configuration object to load.
 */
KEN.Iframe.prototype.load = function(config)
{
    this._parseConfig(config);

    var url;
    if(this._i18n === true && (typeof this._i18nUrl === "string" && this._i18nUrl !== ""))
    {
        this._i18nUrlLocaleString = new KEN.LocaleString(this._viewer, this._i18nUrl);

        this._addLocaleChangeListener();

        url = this._i18nUrlLocaleString["value"];
    }
    else if(typeof this._url === "string" && this._url !== "")
    {
        url = this._url;
    }

    if(typeof url !== "undefined")
    {
        this._loadIframe(url);
    } 
};

/**
 * Destroy method.
 * @method KEN.Iframe#destroy
 */
KEN.Iframe.prototype.destroy = function()
{
    if(this._alive === false)
    {
        return;
    }

    if(this._i18nUrlLocaleString !== null)
    {
        this._i18nUrlLocaleString.destroy();
        this._i18nUrlLocaleString = null;
        this._viewer["i18n"]["onLocaleChangeComplete"].remove(this._localeChangeComplete, this);
    }

    if(this._onLoadStart !== null)
    {
        this._onLoadStart.destroy();
        this._onLoadStart = null;
    }

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.destroy();
        this._onLoadComplete = null;
    }

    this._element = null;
    this._loadCompleteBind = null;

    KEN.DisplayObject.prototype.destroy.call(this);
};

/**
* Get and set the i18n iframe url.
* @name KEN.Iframe#i18nUrl
* @type {string} 
*/
KEN.Iframe.prototype.i18nUrl;
Object.defineProperty(KEN.Iframe.prototype, "i18nUrl", 
{
    /** @this {KEN.Iframe} */
    get: function()
    {
        return this._i18nUrl;
    },

    /** @this {KEN.Iframe} */
    set: function(value)
    {
        if(typeof value === "string")
        {
            this._i18n = true;
            this._i18nUrl = value;

            var url;
            if(this._i18nUrl !== "")
            {
                this._i18nUrlLocaleString = new KEN.LocaleString(this._viewer, this._i18nUrl);

                this._addLocaleChangeListener();

                url = this._i18nUrlLocaleString["value"];
            }

            if(typeof url !== "undefined")
            {
                this._loadIframe(url);
            }
        }
    }
});

/**
* Get and set the iframe url.<br>
* You'll lose the i18n behavior if you use this setter.
* @name KEN.Iframe#url
* @type {string} 
*/
KEN.Iframe.prototype.url;
Object.defineProperty(KEN.Iframe.prototype, "url", 
{
    /** @this {KEN.Iframe} */
    get: function()
    {
        return this._url;
    },

    /** @this {KEN.Iframe} */
    set: function(value)
    {
        if(typeof value === "string")
        {
            this._i18n = false;
            this._loadIframe(value);
        }
    }
});

/**
* Get the loaded status of the iframe.
* @name KEN.Iframe#loaded
* @readonly
* @type {boolean} 
*/
KEN.Iframe.prototype.loaded;
Object.defineProperty(KEN.Iframe.prototype, "loaded", 
{
    /** @this {KEN.Iframe} */
    get: function()
    {
        return this._loaded;
    }
});

/**
* Get the onLoadStart {@link KEN.EventDispatcher}.
* @name KEN.Iframe#onLoadStart
* @readonly
* @type {KEN.EventDispatcher} 
*/
KEN.Iframe.prototype.onLoadStart;
Object.defineProperty(KEN.Iframe.prototype, "onLoadStart", 
{
    /** @this {KEN.Iframe} */
    get: function()
    {
        if(this._onLoadStart === null)
        {
            this._onLoadStart = new KEN.EventDispatcher(this);
        }
        
        return this._onLoadStart;
    }
});

/**
* Get the onLoadComplete {@link KEN.EventDispatcher}.
* @name KEN.Iframe#onLoadComplete
* @readonly
* @type {KEN.EventDispatcher} 
*/
KEN.Iframe.prototype.onLoadComplete;
Object.defineProperty(KEN.Iframe.prototype, "onLoadComplete", 
{
    /** @this {KEN.Iframe} */
    get: function()
    {
        if(this._onLoadComplete === null)
        {
            this._onLoadComplete = new KEN.EventDispatcher(this);
        }
        
        return this._onLoadComplete;
    }
});


/**
 * A KEN.TextField is a display object that displays an internationalizable string.
 *
 * @constructor KEN.TextField
 * @param {KEN.Viewer} viewer {@link KEN.Viewer} reference.
 * @param {(TextFieldConfig|string)=} config - The text field config.
 * @extends {KEN.DisplayObject}
 *
 * @todo    vertical-align ?
 * @todo    NO WILL DO A FONT MANAGER web-fonts with <link>
 * @todo    why +1 into _updateDom method
 * @todo    DONE _updateDom and auto size won't work if not displayed
 * @todo    I don't think that margin has to be part of any display object as long as all is postionned in x/y
 * @todo  clarify _updateTextarea "calc thing"
 */
KEN.TextField = function(viewer, config)
{
    //CONTAINER @todo
    //margin
    //padding
    //shadow + range + angle + color + alpha : box-shadow: none|     h-shadow v-shadow blur spread color [inset]    |initial|inherit;

    //GOOGLE FONT @todo
    //to add :
    //<link href='https://fonts.googleapis.com/css?family=Open+Sans&subset=latin,vietnamese' rel='stylesheet' type='text/css'>
    //@import url(https://fonts.googleapis.com/css?family=Open+Sans&subset=latin,vietnamese);
    //to use
    //font-family: 'Open Sans', sans-serif;
    //
    // this._webfont = ""; //@todo test with google font url + font name (and options) as attributes
    // this._stdfont = "sans-serif";

    //_editable
    //todo editable => textarea with some css values + boxSizing + parent width and height if no values
    //ENTER => validate save data and set it as textfield.

    /**
     * Button Configuration object.
     * @name  KEN.TextField#_config
     * @type {(TextFieldConfig|string|undefined)}
     * @private
     */
    this._config = config;

    /**
     * i18n key for internationalizable strings.
     * @name  KEN.TextField#_i18nKey
     * @type {string}
     * @private
     */
    this._i18nKey = "";

    /**
     * Flag to know if the textfield is in i18n mode.
     * @name KEN.TextField#_i18n
     * @type {boolean}
     * @private
     */
    this._i18n = false;

    /**
     * Internal {@link KEN.LocaleString} reference.
     * @name  KEN.TextField#_i18nLocaleString
     * @type {KEN.LocaleString}
     * @private
     */
    this._i18nLocaleString = null;

    /**
     * Internal reference to the string that the text field have to display.
     * @name  KEN.TextField#_value
     * @type {string}
     * @private
     */
    this._value = "";

    /**
     * Internal reference to the color of the displayed string, can be any CSS value.
     * @name  KEN.TextField#_color
     * @type {string}
     * @private
     */
    this._color = "rgb(0, 0, 0)";

    /**
     * Does the text field manages its width automatically?
     * @name  KEN.TextField#_autoWidth
     * @type {boolean}
     * @private
     */
    this._autoWidth = true;

    /**
     * Does the text field manages its height automatically?
     * @name  KEN.TextField#_autoHeight
     * @type {boolean}
     * @private
     */
    this._autoHeight = true;

    /**
     * Margin of the text.
     * @name  KEN.TextField#_margin
     * @type {number}
     * @private
     */
    //this._margin = 0;

    /**
     * Padding of the text.
     * @name  KEN.TextField#_padding
     * @type {(number|string)}
     * @private
     */
    this._padding = 0;

    /**
     * Is the text is user selectable?
     * @name  KEN.TextField#_selectable
     * @type {boolean}
     * @private
     */
    this._selectable = false;

    /**
     * Is the text is user editable?<br>
     * When edited the textfield is converted into a textarea element until the ENTER key is pressed.
     * @name  KEN.TextField#_editable
     * @type {boolean}
     * @private
     */
    this._editable = false;

    /**
     * Reference to the keybinding used for the editable feature.
     * @name  KEN.TextField#_editableKeyBinding
     * @type {KEN.KeyBinding}
     * @private
     */
    this._editableKeyBinding = null;

    /**
     * Is the text can be breaked when reach the max width ?<br>
     * Will be unactive if autoWidth is set to true.
     * @name  KEN.TextField#_wordWrap
     * @type {boolean}
     * @private
     */
    this._wordWrap = false;

    /**
     * The text-align CSS value. Can be "", "inherit", "left", "right", "center" and "justify".
     * @name  KEN.TextField#_textAlign
     * @type {string}
     * @private
     */
    this._textAlign = "";

    /**
     * The text-decoration CSS value. Can be "", "inherit", "none", "underline", "overline" and "line-through".
     * @name  KEN.TextField#_textDecoration
     * @type {string}
     * @private
     */
    this._textDecoration = "";

    /**
     * The text-shadow CSS value. Can be "", "inherit", "none" or a properties list. The properties that can be set, are (in order): "h-shadow v-shadow blur-radius color".
     * @name  KEN.TextField#_textShadow
     * @type {string}
     * @private
     */
    this._textShadow = "";

    /**
     * The text-transform CSS value. Can be "", "inherit", "none", "capitalize", "uppercase" or "lowercase".
     * @name  KEN.TextField#_textTransform
     * @type {string}
     * @private
     */
    this._textTransform = "";

    /**
     * The text-overflow CSS value. Can be "", "clip", "ellipsis", "initial", "inherit" or a string to render the clip.
     * @name  KEN.TextField#_textOverflow
     * @type {string}
     * @private
     */
    this._textOverflow = "";

    /**
     * The white-space CSS value. Can be "", "normal", "nowrap", "pre", "pre-line", "pre-wrap", "initial" or "inherit".
     * @name  KEN.TextField#_whiteSpace
     * @type {string}
     * @private
     */
    this._whiteSpace = "";

    /**
     * The font CSS value. Can be "", "inherit" or a properties list. The properties that can be set, are (in order): "font-style font-variant font-weight font-size/line-height font-family".<br>
     * The font-size and font-family values are required.
     * @name  KEN.TextField#_font
     * @type {string}
     * @private
     */
    this._font = "";

    /**
     * The font-family CSS value. Can be "", inherit" or a web safe font family name.<br>
     * List of the web safe fonts :<br>
     * Serif<br>
     * - "Times New Roman", Times, serif<br>
     * - Georgia, serif<br>
     * - "Palatino Linotype", "Book Antiqua", Palatino, serif<br>
     * Sans-serif<br>
     * - Arial, Helvetica, sans-serif<br>
     * - Verdana, Geneva, sans-serif<br>
     * - "Arial Black", Gadget, sans-serif<br>
     * - "Comic Sans MS", cursive, sans-serif<br>
     * - Impact, Charcoal, sans-serif<br>
     * - "Lucida Sans Unicode", "Lucida Grande", sans-serif<br>
     * - Tahoma, Geneva, sans-serif<br>
     * - "Trebuchet MS", Helvetica, sans-serif<br>
     * Monospace<br>
     * - "Courier New", Courier, monospace<br>
     * - "Lucida Console", Monaco, monospace
     * @name  KEN.TextField#_font
     * @type {string}
     * @private
     */
    this._fontFamily = "";

    /**
     * The font-size CSS value. Can be "", "inherit", "medium", "xx-small", "x-small", "small", "large", "x-large", "xx-large", "smaller", "larger", % or length.
     * @name  KEN.TextField#_fontSize
     * @type {(number|string)}
     * @private
     */
    this._fontSize = "";

    /**
     * The font-style CSS value. Can be "", "inherit", "normal" or "italic".
     * @name  KEN.TextField#_fontStyle
     * @type {string}
     * @private
     */
    this._fontStyle = "";

    /**
     * The font-weight CSS value. Can be "", "inherit", "normal" (400), "bold" (700), "bolder", "lighter" or a value between 100 and 900.
     * @name  KEN.TextField#_fontWeight
     * @type {(string|number)}
     * @private
     */
    this._fontWeight = "";

    /**
     * The font-variant CSS value. Can be "", "inherit", "normal" or "small-caps".
     * @name  KEN.TextField#_fontVariant
     * @type {string}
     * @private
     */
    this._fontVariant = "";

    /**
     * The line-height CSS value. Can be "", "inherit", "normal", % or length.
     * @name  KEN.TextField#_lineHeight
     * @type {(string|number)}
     * @private
     */
    this._lineHeight = "";

    /**
     * This is the dom element into which the value will be injected
     * @name  KEN.TextField#_span
     * @type {(Element|HTMLSpanElement)}
     * @private
     */
    this._span = null;

    /**
     * The textarea element to replace the textfield once set as "editable".
     * @name KEN.TextField#_textArea
     * @type {(Element|HTMLTextAreaElement)}
     * @private
     */
    this._textArea = null;

    /**
     * This is a reference to clickHandler function but with a different this bind reference.
     * @name  KEN.TextField#_clickBind
     * @type {Function}
     * @private
     */
    this._clickBind = null;

    /**
     * This is a reference to changeHandler function but with a different this bind reference.
     * @name  KEN.TextField#_changeBind
     * @type {Function}
     * @private
     */
    this._changeBind = null;

    /**
     * This is a reference to blurHandler function but with a different this bind reference.
     * @name  KEN.TextField#_blurBind
     * @type {Function}
     * @private
     */
    this._blurBind = null;

    /**
     * Has this TextField loaded its configuration?
     * @name  KEN.TextField#_loaded
     * @type {boolean}
     * @private
     */
    this._loaded = false;

    /**
     * Event dispatcher for onValueChange event
     * @name  KEN.TextField#_onValueChange
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onValueChange = null;

    /**
     * Event dispatcher for onLoadComplete event
     * @name  KEN.TextField#_onLoadComplete
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onLoadComplete = null;

    KEN.DisplayObject.call(this, viewer, null, "TextField");
};


KEN.TextField.prototype = Object.create(KEN.DisplayObject.prototype);
KEN.TextField.prototype.constructor = KEN.TextField;

/**
 * Boot sequence.
 * @method KEN.TextField#_boot
 * @private
 */
KEN.TextField.prototype._boot = function()
{
    KEN.DisplayObject.prototype._boot.call(this);

    this._clickBind = this._clickHandler.bind(this);
    this._changeBind = this._changeHandler.bind(this);
    this._blurBind = this._blurHandler.bind(this);

    this._span = document.createElement("span");
    this._dom.appendChild(this._span);

    if(typeof this._config !== "undefined" && this._config !== null)
    {
        this.load(this._config);
    }

    this._viewer["display"].register(this);
    this._notifyReady();
    this._applyPending(false);
};

/**
 * Notify that the dispay object has been resized.<br>
 * This method ovverrides the {@link KEN.DisplayObject} method.
 * @method  KEN.TextField#_notifyResize
 * @private
 * @param  {PropertyToUpdate} data - The data contains the property that have changed.
 */
KEN.TextField.prototype._notifyResize = function(data)
{
    var property = data.property;

    //If property is related to width except autoWidth
    if(property.toLowerCase().indexOf("width") !== -1 && property !== "autoWidth")
    {
        this._autoWidth = false;
    }

    //If property is related to height except autoHeight
    if(property.toLowerCase().indexOf("height") !== -1 && property !== "autoHeight")
    {
        this._autoHeight = false;
    }

    //this._updateTextarea();

    KEN.DisplayObject.prototype._notifyResize.call(this, data);
};

/**
 * Notify that the dispay object is now visible.<br>
 * This method ovverrides the {@link KEN.DisplayObject} method.
 * @method  KEN.TextField#_notifyShow
 * @private
 */
KEN.TextField.prototype._notifyShow = function()
{
    this._updateAutoSize();

    KEN.DisplayObject.prototype._notifyShow.call(this);
};

/**
 * Update the dom with a new value.
 * @method KEN.TextField#_updateValue
 * @param {(number|string)} value - The new value to display.
 * @private
 */
KEN.TextField.prototype._updateValue = function(value)
{
    if(value !== this._value)
    {
        this._value = String(value);
        this._span.innerHTML = value;
        this._updateAutoSize();
        this._updateAnchors();

        if(this._onValueChange !== null)
        {
            this._onValueChange.dispatch();
        }
    }

    if(this._i18n === false || (this._i18n === true && this._i18nLocaleString["loaded"] === true))
    {
        this._loaded = true;

        if(this._onLoadComplete !== null)
        {
            this._onLoadComplete.dispatch();
        }
    }
};

/**
 * Update auto sizes, ajust width and height if auto size is enabled.
 * @method  KEN.TextField#_updateAutoSize
 * @private
 */
KEN.TextField.prototype._updateAutoSize = function()
{
    //If not in dom, no need to update autosize!
    if(this.isInDom() === false)
    {
        return;
    }

    if(this._autoWidth === true)
    {
        var width = this["pixelWidth"];
        this._dom.style["width"] = "";

        //increment the width by 1 to follow the possible float value returned by the browser
        var w = this._dom.offsetWidth;
        if(w > 0)
        {
            w += 1;
        }

        this._width = w;
        this._unitWidth = "px";
        this._dom.style["width"] = this._width+"px";

        if(width !== this._width)
        {
            this._notifyResize({ property: "autoWidth" });
        }
    }

    if(this._autoHeight === true)
    {
        var height = this["pixelHeight"];
        this._dom.style["height"] = "";

        //increment the height by 1 to follow the possible float value returned by the browser
        var h = this._dom.offsetHeight;
        if(h > 0)
        {
            h += 1;
        }

        this._height = h;
        this._unitHeight = "px";
        this._dom.style["height"] = this._height+"px";

        if(height !== this._height)
        {
            this._notifyResize({ property: "autoHeight" });
        }
    }
};

/**
 * Create an internal {@link KEN.LocaleString} for internationalization.
 * @method KEN.TextField#_createLocaleString
 * @private
 */
KEN.TextField.prototype._createLocaleString = function()
{
    if(this._i18nLocaleString === null)
    {
        this._i18nLocaleString = new KEN.LocaleString(this._viewer, this._i18nKey);
    }

    this._updateValue(this._i18nLocaleString["value"]);
};

/**
 * Binds an event listener for locale change.
 * @method KEN.TextField#_createLocaleStringEvent
 * @private
 */
KEN.TextField.prototype._createLocaleStringEvent = function()
{
    if(this._viewer["i18n"]["onLocaleChangeComplete"].has(this._localeChangeComplete, this) === false)
    {
        this._viewer["i18n"]["onLocaleChangeComplete"].add(this._localeChangeComplete, this);
    }
};

/**
 * Event handler for locale change.
 * @method KEN.TextField#_localeChangeComplete
 * @private
 */
KEN.TextField.prototype._localeChangeComplete = function()
{
    this.log("_localeChangeComplete");

    if(this._viewer["i18n"].hasValue(this._i18nKey) === true)
    {
        this["value"] = this._i18nLocaleString["value"];
    }
};

/**
 * Handler for textarea linked to the textfield if "editable" is set to true.
 * @method KEN.TextField#_textareaResizeHandler
 * @private
 */
KEN.TextField.prototype._updateTextarea = function()
{
    // if(this._editable === false)
    // {
    //     return;
    // }

    // if(this["pixelWidth"] !== 0)
    // {
    //     this._textArea.style["width"] = this["pixelWidth"]+"px";
    // }
    // else
    // {
    //     this._textArea.style["width"] = "calc(100% - "+(this._dom.style.marginLeft+this._dom.style.marginRight)+")";
    // }

    // if(this["pixelHeight"] !== 0)
    // {
    //     this._textArea.style["height"] = this["pixelHeight"]+"px";
    // }
    // else
    // {
    //     this._textArea.style["height"] = "calc(100% - "+(this._dom.style.marginTop+this._dom.style.marginBottom)+")";
    // }
};

/**
 * Event handler on textarea for keyup event.
 * @method KEN.TextField#_textareaInput
 * @param  {Event} event - The onkeyup event.
 * @private
 */
// KEN.TextField.prototype._textareaInput = function(event)
// {
//     if(event.keyCode === 13 && event.shiftKey === false && event.ctrlKey === false)
//     {
//         this.tfElement["value"] = this["value"];

//         this.tfElement["editable"] = false;

//     }
//     else if(event.keyCode === 13)
//     {
//         this["value"] = this["value"] + "\n";
//     }
//     else if(event.keyCode === 27)
//     {
//         this.tfElement["editable"] = false;
//     }
// };

/**
 * Event handler for click on the textfield, to switch to editable mode.
 * @method  KEN.TextField#_clickHandler
 * @private
 */
KEN.TextField.prototype._clickHandler = function()
{
    if(this._editable === true && this._textArea === null)
    {
        this._createInput();
        this._textArea.focus();
    }
};

/**
 * Event handler for input change on the textarea.
 * @method  KEN.TextField#_changeHandler
 * @private
 */
KEN.TextField.prototype._changeHandler = function()
{
    this._updateValue(this._textArea["value"]);
};

/**
 * Event handler for blut on textaera, will quit edit mode on blur.
 * @method KEN.TextField#_blurHandler
 * @private
 */
KEN.TextField.prototype._blurHandler = function()
{
    this._destroyInput();
};

/**
 * Create a textarea to enter in editable mode.
 * @method KEN.TextField#_createInput
 * @private
 */
KEN.TextField.prototype._createInput = function()
{
    this._editing = true;

    this._textArea = document.createElement("textarea");

    this._textArea.style["position"] = "absolute";
    this._textArea.style["top"] = "0px";
    this._textArea.style["left"] = "0px";
    this._textArea.style["width"] = "100%"; //this["innerWidth"]+"px";
    this._textArea.style["height"] = "100%"; //this["innerHeight"]+"px";
    this._textArea.style.resize = "none"; // Prevent the browser resize corner
    this._textArea.style.margin = "0px";
    this._textArea.style["padding"] = "0px";
    this._textArea.style.overflowX = "hidden";
    this._textArea.style.overflowY = "auto";
    this._textArea.style.boxSizing = "border-box";

    this._textArea["value"] = this._value;

    this._textArea.addEventListener("input", this._changeBind, false);
    this._textArea.addEventListener("blur", this._blurBind, false);

    this._dom.appendChild(this._textArea);
};

/**
 * Destroy the textarea to leave the editable mode.
 * @method KEN.TextField#_destroyInput
 * @private
 */
KEN.TextField.prototype._destroyInput = function()
{
    this._editing = false;

    if(this._textArea !== null)
    {
        this._textArea.removeEventListener("input", this._changeBind, false);
        this._textArea.removeEventListener("blur", this._blurBind, false);
        this._dom.removeChild(this._textArea);
        this._textArea = null;
    }
};

/**
 * Parse the TextField configuration.
 * @method  KEN.TextField#_parseConfig
 * @private
 * @param  {(TextFieldConfig|string)} config - The TextField object config or a string that is an i18n key.
 */
KEN.TextField.prototype._parseConfig = function(config)
{
    if(typeof config === "object" && config !== null)
    {
        if(config["color"])
        {
            this["color"] = config["color"];
        }
        if(config["font"])
        {
            this["font"] = config["font"];
        }
        if(config["fontFamily"])
        {
            this["fontFamily"] = config["fontFamily"];
        }
        if(config["fontWeight"])
        {
            this["fontWeight"] = config["fontWeight"];
        }
        if(config["fontSize"])
        {
            this["fontSize"] = config["fontSize"];
        }
        if(config["fontStyle"])
        {
            this["fontStyle"] = config["fontStyle"];
        }
        if(config["fontVariant"])
        {
            this["fontVariant"] = config["fontVariant"];
        }
        if(config["textAlign"])
        {
            this["textAlign"] = config["textAlign"];
        }
        if(config["textShadow"])
        {
            this["textShadow"] = config["textShadow"];
        }
        if(config["textDecoration"])
        {
            this["textDecoration"] = config["textDecoration"];
        }
        if(config["textOverflow"])
        {
            this["textOverflow"] = config["textOverflow"];
        }
        if(config["textTransform"])
        {
            this["textTransform"] = config["textTransform"];
        }
        if(config["whiteSpace"])
        {
            this["whiteSpace"] = config["whiteSpace"];
        }
        if(config["wordWrap"])
        {
            this["wordWrap"] = config["wordWrap"];
        }
        if(config["lineHeight"])
        {
            this["lineHeight"] = config["lineHeight"];
        }
        if(config["autoWidth"])
        {
            this["autoWidth"] = config["autoWidth"];
        }
        if(config["autoHeight"])
        {
            this["autoHeight"] = config["autoHeight"];
        }
        if(config["padding"])
        {
            this["padding"] = config["padding"];
        }
        if(config["selectable"])
        {
            this["selectable"] = config["selectable"];
        }
        if(config["editable"])
        {
            this["editable"] = config["editable"];
        }

        this._i18n = config["i18n"] || false;

        //If there is a i18n key in the configuration
        if(this._i18n === true)
        {
            this._i18nKey = config["value"];
        }
        else
        {
            this["value"] = config["value"];
        }
    }
    else if(typeof config === "string")
    {
        this._i18n = false;
        this["value"] = config;
    }
};

/**
 * Load a textfield configuration.
 * @method  KEN.TextField#load
 * @param  {(TextFieldConfig|string)} config - The config object to load, if it's a simple string will try to get i18n from the string.
 */
KEN.TextField.prototype.load = function(config)
{
    this._loaded = false;

    this._parseConfig(config);

    if(this._i18n === true && (typeof this._i18nKey === "string" && this._i18nKey !== ""))
    {
        this._createLocaleString();
        this._createLocaleStringEvent();
    }
};

/**
 * Destroy method.
 * @method KEN.TextField#destroy
 */
KEN.TextField.prototype.destroy = function()
{
    if(this._alive === false)
    {
        return;
    }

    if(this._i18nLocaleString !== null)
    {
        this._i18nLocaleString.destroy();
        this._i18nLocaleString = null;
        this._viewer["i18n"]["onLocaleChangeComplete"].remove(this._localeChangeComplete, this);
    }

    this._destroyInput();

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.destroy();
        this._onLoadComplete = null;
    }

    if(this._onValueChange !== null)
    {
        this._onValueChange.destroy();
        this._onValueChange = null;
    }

    KEN.DisplayObject.prototype.destroy.call(this);
};

/**
* Get and set the i18n key of the textfield value.
* @name KEN.TextField#i18nValue
* @type {string}
*/
KEN.TextField.prototype.i18nValue;
Object.defineProperty(KEN.TextField.prototype, "i18nValue",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._i18nKey;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        if(this._i18nKey === "")
        {
            this._createLocaleStringEvent();
        }

        this._i18n = true;
        this._i18nKey = value;

        this._createLocaleString();
    }
});

/**
 * Get the flag to know if this TextField works in i18n mode.
 * @name  KEN.TextField#i18n
 * @type {boolean}
 * @readonly
 */
KEN.TextField.prototype.i18n;
Object.defineProperty(KEN.TextField.prototype, "i18n",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._i18n;
    }
});

/**
* Get and set the value displayed by the text field.<br>
* You'll lose the i18n behavior if you use this setter.
* @name KEN.TextField#value
* @type {string}
*/
KEN.TextField.prototype.value;
Object.defineProperty(KEN.TextField.prototype, "value",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._value;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if((typeof value !== "string" && typeof value !== "number"))
        {
            return;
        }

        this._i18n = false;
        this._updateValue(value);
    }
});

/**
* Get and set the color CSS of the text.
* @name KEN.TextField#color
* @type {string}
*/
KEN.TextField.prototype.color;
Object.defineProperty(KEN.TextField.prototype, "color",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._color;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._color = value;
        this._dom.style["color"] = this._color;
    }
});

/**
* Get and set the font CSS of the text.
* @name KEN.TextField#font
* @type {string}
*/
KEN.TextField.prototype.font;
Object.defineProperty(KEN.TextField.prototype, "font",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._font;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        var valueArray = value.split(" ").toString();
        if(valueArray.length < 2)
        {
            return;
        }

        this._font = value.replace(/"/g, "\"");
        this._dom.style["font"] = this._font;

        //this._updateAutoSize();
    }
});

/**
* Get and set the font-family CSS of the text.
* @name KEN.TextField#fontFamily
* @type {string}
*/
KEN.TextField.prototype.fontFamily;
Object.defineProperty(KEN.TextField.prototype, "fontFamily",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._fontFamily;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._fontFamily = value.replace(/"/g, "\"");
        this._dom.style["fontFamily"] = this._fontFamily;

        this._updateAutoSize();
    }
});

/**
* Get and set the line-height CSS of the text.
* @name KEN.TextField#fontSize
* @type {(number|string)}
*/
KEN.TextField.prototype.fontSize;
Object.defineProperty(KEN.TextField.prototype, "fontSize",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._fontSize;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "number" && typeof value !== "string")
        {
            return;
        }

        if (typeof value === "number")
        {
            value = value+"px";
        }

        this._fontSize = value;
        this._dom.style["fontSize"] = this._fontSize;

        //this._updateAutoSize();
    }
});

/**
* Get and set the font-style CSS of the text.
* @name KEN.TextField#fontStyle
* @type {string}
*/
KEN.TextField.prototype.fontStyle;
Object.defineProperty(KEN.TextField.prototype, "fontStyle",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._fontStyle;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._fontStyle = value;
        this._dom.style["fontStyle"] = this._fontStyle;

        //this._updateAutoSize();
    }
});

/**
* Get and set the font-weight CSS of the text.
* @name KEN.TextField#fontWeight
* @type {(string|number)}
*/
KEN.TextField.prototype.fontWeight;
Object.defineProperty(KEN.TextField.prototype, "fontWeight",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._fontWeight;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "string" || typeof value !== "number")
        {
            return;
        }

        this._fontWeight = value;
        this._dom.style["fontWeight"] = this._fontWeight;

        //this._updateAutoSize();
    }
});

/**
* Get and set the font-variant CSS of the text.
* @name KEN.TextField#fontVariant
* @type {string}
*/
KEN.TextField.prototype.fontVariant;
Object.defineProperty(KEN.TextField.prototype, "fontVariant",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._fontVariant;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._fontVariant = value;
        this._dom.style["fontVariant"] = this._fontVariant;
    }
});

/**
* Get and set the line-height CSS of the text.
* @name KEN.TextField#lineHeight
* @type {(number|string)}
*/
KEN.TextField.prototype.lineHeight;
Object.defineProperty(KEN.TextField.prototype, "lineHeight",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._lineHeight;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "number" && typeof value !== "string")
        {
            return;
        }

        if (typeof value === "number")
        {
            value = value+"px";
        }

        this._lineHeight = value;
        this._dom.style["lineHeight"] = this._lineHeight;
    }
});

/**
* Get and set the text-align CSS of the text.
* @name KEN.TextField#textAlign
* @type {string}
*/
KEN.TextField.prototype.textAlign;
Object.defineProperty(KEN.TextField.prototype, "textAlign",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._textAlign;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._textAlign = value;
        this._dom.style["textAlign"] = this._textAlign;
    }
});

/**
* Get and set the text-shadow CSS of the text.
* @name KEN.TextField#textShadow
* @type {string}
*/
KEN.TextField.prototype.textShadow;
Object.defineProperty(KEN.TextField.prototype, "textShadow",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._textShadow;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._textShadow = value;
        this._dom.style["textShadow"] = this._textShadow;
    }
});

/**
* Get and set the text-decoration CSS of the text.
* @name KEN.TextField#textDecoration
* @type {string}
*/
KEN.TextField.prototype.textDecoration;
Object.defineProperty(KEN.TextField.prototype, "textDecoration",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._textDecoration;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._textDecoration = value;
        this._dom.style["textDecoration"] = this._textDecoration;
    }
});

/**
* Get and set the text-transform CSS of the text.
* @name KEN.TextField#textTransform
* @type {string}
*/
KEN.TextField.prototype.textTransform;
Object.defineProperty(KEN.TextField.prototype, "textTransform",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._textTransform;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._textTransform = value;
        this._dom.style["textTransform"] = this._textTransform;
    }
});

/**
* Get and set the flag for auto size on width.
* @name KEN.TextField#autoWidth
* @type {boolean}
*/
KEN.TextField.prototype.autoWidth;
Object.defineProperty(KEN.TextField.prototype, "autoWidth",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._autoWidth;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._autoWidth = value;

        this._updateAutoSize();
    }
});

/**
* Get and set the flag for auto size on height.
* @name KEN.TextField#autoHeight
* @type {boolean}
*/
KEN.TextField.prototype.autoHeight;
Object.defineProperty(KEN.TextField.prototype, "autoHeight",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._autoHeight;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._autoHeight = value;

        this._updateAutoSize();
    }
});

/**
* Get and set the padding CSS value of the text.
* @name KEN.TextField#padding
* @type {(number|string)}
*/
KEN.TextField.prototype.padding;
Object.defineProperty(KEN.TextField.prototype, "padding",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._padding;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "number" && typeof value !== "string")
        {
            return;
        }

        if (typeof value === "string")
        {
            var valueArray = value.split(" ", 4).toString();
            value = valueArray.replace(/,/g, " ");
        }
        else
        {
            value = value+"px";
        }

        this._padding = value;
        this._dom.style["padding"] = this._padding;
    }
});

/**
* Get and set the selectable property of the text.
* @name KEN.TextField#selectable
* @type {boolean}
*/
KEN.TextField.prototype.selectable;
Object.defineProperty(KEN.TextField.prototype, "selectable",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._selectable;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._selectable = value;
        if(this._selectable === false)
        {
            if(this._editable === false && this._restoreMouse === true)
            {
                this["pointer"]["enabled"] = false;
                this._restoreMouse = false;
            }

            this._dom.style.userSelect = "none";
            this._dom.style.webkitUserSelect = "none";
            this._dom.style.mozUserSelect = "none";
            this._dom.style.msUserSelect = "none";
            this._dom.style.webkitTouchCallout = "none";
        }
        else
        {
            if(this["pointer"]["enabled"] === false)
            {
                this["pointer"]["enabled"] = true;
                this._restoreMouse = true;
            }

            this._dom.style.userSelect = "text";
            this._dom.style.webkitUserSelect = "text";
            this._dom.style.mozUserSelect = "text";
            this._dom.style.msUserSelect = "text";
            this._dom.style.webkitTouchCallout = "inherit";
        }
    }
});

/**
* Get and set the word-wrap CSS property of the text.
* @name KEN.TextField#wordWrap
* @type {boolean}
*/
KEN.TextField.prototype.wordWrap;
Object.defineProperty(KEN.TextField.prototype, "wordWrap",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._wordWrap;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._wordWrap = value;
        if(this._wordWrap === false)
        {
            this._dom.style["wordWrap"] = "normal";
        }
        else
        {
            this._dom.style["wordWrap"] = "break-word";
        }
    }
});

/**
* Get and set the white-space CSS property of the text.
* @name KEN.TextField#whiteSpace
* @type {string}
*/
KEN.TextField.prototype.whiteSpace;
Object.defineProperty(KEN.TextField.prototype, "whiteSpace",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._whiteSpace;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._whiteSpace = value;
        this._dom.style["whiteSpace"] = this._whiteSpace;
    }
});

/**
* Get and set the text-overflow CSS property of the text.
* @name KEN.TextField#textOverflow
* @type {string}
*/
KEN.TextField.prototype.textOverflow;
Object.defineProperty(KEN.TextField.prototype, "textOverflow",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._textOverflow;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._textOverflow = value;
        this._dom.style["textOverflow"] = this._textOverflow;
    }
});

/**
 * Get and set the editable status for the textfield.<br>
 * When editable is set to true the textfield is transformed into a textarea field.<br>
 * Important: the editable status must be set after the textfield add into a container.
 * @name KEN.TextField#editable
 * @type {boolean}
 */
KEN.TextField.prototype.editable;
Object.defineProperty(KEN.TextField.prototype, "editable",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._editable;
    },

    /** @this {KEN.TextField} */
    set: function(value)
    {
        var bool = Boolean(value);

        if(this._editable === bool)
        {
            return;
        }

        this._editable = bool;

        if(this._editable === false)
        {
            this._dom.removeEventListener("click", this._clickBind, this !== null && this !== undefined);

            this._viewer["keyboard"].removeBinding(this._editableKeyBinding);
            this._editableKeyBinding = null;

            this["pointer"]["enabled"] = true;
            this._dom.style["cursor"] = "text";
        }
        else
        {
            this._dom.addEventListener("click", this._clickBind, this !== null && this !== undefined);

            this._editableKeyBinding = new KEN.KeyBinding([13, 27], this._destroyInput, null, null, null, this);
            this._viewer["keyboard"].addBinding(this._editableKeyBinding);

            this._dom.style["cursor"] = "default";
        }
    }
});

/**
* Get the loaded status of the TextField.
* @name KEN.TextField#loaded
* @readonly
* @type {boolean}
*/
KEN.TextField.prototype.loaded;
Object.defineProperty(KEN.TextField.prototype, "loaded",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        return this._loaded;
    }
});

/**
* Get the onLoadComplete {@link KEN.EventDispatcher}.
* @name KEN.TextField#onLoadComplete
* @readonly
* @type {KEN.EventDispatcher}
*/
KEN.TextField.prototype.onLoadComplete;
Object.defineProperty(KEN.TextField.prototype, "onLoadComplete",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        if(this._onLoadComplete === null)
        {
            this._onLoadComplete = new KEN.EventDispatcher(this);
        }

        return this._onLoadComplete;
    }
});

/**
* Get the onValueChange {@link KEN.EventDispatcher}.
* @name KEN.TextField#onValueChange
* @readonly
* @type {KEN.EventDispatcher}
*/
KEN.TextField.prototype.onValueChange;
Object.defineProperty(KEN.TextField.prototype, "onValueChange",
{
    /** @this {KEN.TextField} */
    get: function()
    {
        if(this._onValueChange === null)
        {
            this._onValueChange = new KEN.EventDispatcher(this);
        }

        return this._onValueChange;
    }
});



/**
 * A button with three states with out, over and down.
 *
 * @constructor KEN.Button
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @param {ButtonConfig=} config - The button config.
 * @extends {KEN.DisplayObjectContainer}
 *
 * @todo  Add tween for properties
 * @todo  Ability to set image size to the defined width/height/padding/margin of the button
 */
KEN.Button = function(viewer, config)
{
    /**
     * Button configuration object.
     * @name KEN.Button#_config
     * @type {?ButtonConfig}
     * @private
     */
    this._config = config || null;

    /**
     * Object that handles the button skins.
     * @name KEN.Button#_skins
     * @type {Object}
     * @private
     */
    this._skins = {};

    /**
     * Current skin name.
     * @name KEN.Button#_skin
     * @type {string}
     * @private
     */
    this._skin = "";

    /**
     * Current state of the button.<br>
     * Available states are in {link KEN.Button.states}.
     * @type {string}
     * @private
     */
    this._state = "";

    /**
     * Name of the default skin.
     * @name  KEN.Button#_defaultSkin
     * @type {string}
     * @private
     */
    this._defaultSkin = "";

    /**
     * Button image component.
     * @name  KEN.Button#_image
     * @type {KEN.Image}
     * @private
     */
    this._image = null;

    /**
     * Button label component.
     * @name  KEN.Button#_label
     * @type {KEN.TextField}
     * @private
     */
    this._label = null;

    /**
     * Is this button is on auto width?
     * @name KEN.Button#_autoWidth
     * @type {boolean}
     * @private
     */
    this._autoWidth = false;

    /**
     * Is this button is on auto height?
     * @name KEN.Button#_autoHeight
     * @type {boolean}
     * @private
     */
    this._autoHeight = false;

    /**
     * The number of items to load.
     * @name  KEN.Button#_itemToLoad
     * @type {number}
     * @private
     */
    //this._itemsToLoad = 0;

    /**
     * Item that are loaded.
     * @name  KEN.Button#_itemToLoad
     * @type {number}
     * @private
     */
    this._itemsLoaded = 0;

    /**
     * Is this button loaded?
     * @name  KEN.Button#_loaded
     * @type {boolean}
     * @private
     */
    this._loaded = false;

    KEN.DisplayObjectContainer.call(this, viewer, null, "Button");
};

KEN.Button.prototype = Object.create(KEN.DisplayObjectContainer.prototype);
KEN.Button.prototype.constructor = KEN.Button;

/**
 * Button possible states
 * @name  KEN.Button.states
 * @type {Object}
 * @property {string} OUT
 * @property {string} OVER
 * @property {string} DOWN
 * @const
 */
KEN.Button.states =
{
    OUT: "out",
    OVER: "over",
    DOWN: "down"
};

/**
 * Boot sequence.
 * @method KEN.Button#_boot
 * @private
 */
KEN.Button.prototype._boot = function()
{
    KEN.DisplayObjectContainer.prototype._boot.call(this);

    this._state = KEN.Button.states.OUT;

    this._image = new KEN.Image(this._viewer);
    this._image["onLoadComplete"].add(this._itemLoadComplete, this);
    this._image["onResize"].add(this._itemResizeHandler, this);
    this.addChild(this._image);

    this._label = new KEN.TextField(this._viewer);
    this._label["onLoadComplete"].add(this._itemLoadComplete, this);
    this._label["onResize"].add(this._itemResizeHandler, this);
    this._label["autoWidth"] = true;
    this._label["autoHeight"] = true;
    this.addChild(this._label);

    this["pointer"]["enabled"] = true;
    this["pointer"]["cursor"] = KEN.Pointer.cursors.POINTER;
    this["pointer"]["onEnter"].add(this._mouseEnterHandler, this);
    this["pointer"]["onLeave"].add(this._mouseLeaveHandler, this);
    this["pointer"]["onPressStart"].add(this._pressStartHandler, this);
    this["pointer"]["onPressEnd"].add(this._pressEndHandler, this);

    this._viewer["display"].register(this);
    this._notifyReady();
    this._applyPending(false);

    this._viewer["i18n"]["onLocaleChangeComplete"].add(this._localeChangeCompleteHandler, this);

    this.load(this._config);
};

/**
 * Handler for mouse enter.
 * @method KEN.Button#_mouseEnterHandler
 * @private
 */
KEN.Button.prototype._mouseEnterHandler = function()
{
    this._applyState(KEN.Button.states.OVER);
};

/**
 * Handler for mouse leave.
 * @method KEN.Button#_mouseLeaveHandler
 * @private
 */
KEN.Button.prototype._mouseLeaveHandler = function()
{
    this._applyState(KEN.Button.states.OUT);
};

/**
 * Handler for mouse down.
 * @method KEN.Button#_mouseDownHandler
 * @private
 */
KEN.Button.prototype._pressStartHandler = function()
{
    this._applyState(KEN.Button.states.DOWN);
};

/**
 * Handler for mouse up.
 * @method KEN.Button#_mouseUpHandler
 * @private
 */
KEN.Button.prototype._pressEndHandler = function()
{
    this._applyState(KEN.Button.states.OVER);
};

/**
 * Handler for localeChangeComplete.
 * @method KEN.Button#_localeChangeCompleteHandler
 * @private
 */
KEN.Button.prototype._localeChangeCompleteHandler = function()
{
    this._applyState(this._state);
};

/**
 * Image or Label load complete callback.
 * @method KEN.Button._imageLoadComplete
 * @private
 */
KEN.Button.prototype._itemLoadComplete = function(event)
{
    this.log("_itemLoadComplete "+event["emitter"]["className"]);
    this._itemsLoaded++;

    //if(this._itemsLoaded === this._itemsToLoad)
    if(this._itemsLoaded === 2)
    {
        this._allItemsLoaded();
    }
};

/**
 * This method is called after all items are loaded. (image and label).
 * @method KEN.Button#_allItemsLoaded
 * @private
 */
KEN.Button.prototype._allItemsLoaded = function()
{
    this.log("_allItemsLoaded");
    this._updateLayout();
    this._updateAutoSize();
    this._loaded = true;
};

/**
 * Event handler for items resize.
 * @method KEN.Button#_itemResizeHandler
 * @private
 */
KEN.Button.prototype._itemResizeHandler = function()
{
    this._updateLayout();
    this._updateAutoSize();
};

/**
 * Apply a skin to the button.
 * @method  KEN.Button#_applySkin
 * @private
 * @param {string} name - The of the skin you want to apply.
 */
KEN.Button.prototype._applySkin = function(name)
{
    this._skin = name;

    this._applyState(this._state);
};

/**
 * Apply a specified state of the current skin.
 * @method  KEN.Button._applyState
 * @private
 * @param  {string} state - The name of the state you want to apply (listed on KEN.Button.states)
 */
KEN.Button.prototype._applyState = function(state)
{
    //The button is not loaded the time to apply its skin and load its ressources
    this._loaded = false;

    //Set the current state (out, over, down)
    this._state = state;

    //Get the current skin
    var skin = this._skins[this._skin];

    //Reset the load count
    this._itemsLoaded = 0;
    //this._itemsToLoad = 0;

    var hasImage = skin.hasImage(this._state);

    // if(hasImage === true)
    // {
    //     this._itemsToLoad ++;
    // }

    //var hasLabel = skin.hasLabel(this._state);
    //if(hasLabel === true)
    // {
    //     this._itemsToLoad ++;
    // }

    // var width = skin.getProperty("width", state);
    // var height = skin.getProperty("height", state);

    // if(width !== this["width"])
    // {
    //     this["width"] = width;
    // }

    // if(height !== this["height"])
    // {
    //     this["height"] = height;
    // }

    this["background"] = /** @type {string} */ (skin.getProperty("background", this._state));
    this["borderStyle"] = /** @type {string} */ (skin.getProperty("borderStyle", this._state));
    this["borderColor"] = /** @type {string} */ (skin.getProperty("borderColor", this._state));
    this["borderRadius"] = /** @type {number} */ (skin.getProperty("borderRadius", this._state));
    this["borderWidth"] = /** @type {number} */ (skin.getProperty("borderWidth", this._state));

    this._autoWidth = /** @type {boolean} */ (skin.getProperty("autoWidth", this._state));
    this._autoHeight = /** @type {boolean} */ (skin.getProperty("autoHeight", this._state));

    var label = /** @type {(string|TextFieldConfig)} */ (skin.getProperty("label", this._state)); //@todo !!!
    if(typeof label !== "undefined")
    {
        this._label.load(label);
    }

    // Image =================================

    if(hasImage === true)
    {
        this._image.load(/** @type {(string|ImageConfig)} */ (skin.getProperty("image", this._state)));
    }
    else
    {
        // this._image.load(null);
    }

    // if(hasImage === false && hasLabel === false)
    // {
    //     this._allItemsLoaded();
    // }
};

/**
 * Apply the layout of the button skin elements.
 * @method  KEN.Button.prototype#_updateLayout
 * @private
 */
KEN.Button.prototype._updateLayout = function()
{
    this.log("_updateLayout");

    var skin = this._skins[this._skin];
    var align = skin.getProperty("align", this._state);
    var padding = skin.getProperty("padding", this._state);
    var spacing = skin.getProperty("spacing", this._state);
    var f = skin.getProperty("first", this._state);
    var first, second;

    if(f === "label")
    {
        first = this._label;
        second = this._image;
    }
    else
    {
        first = this._image;
        second = this._label;
    }

    switch(align)
    {
        case "left":
            first["left"] = padding;
            first["verticalCenter"] = true;
            second["left"] = first["left"] + spacing + first["pixelWidth"];
            second["verticalCenter"] = true;
            break;

        case "right":
            first["right"] = padding;
            first["verticalCenter"] = true;
            second["right"] = first["right"] + spacing + first["pixelWidth"];
            second["verticalCenter"] = true;
            break;

        case "top":
            first["top"] = padding;
            first["horizontalCenter"] = true;
            second["top"] = first["top"] + first["pixelHeight"] + spacing;
            second["horizontalCenter"] = true;
            break;

        case "bottom":
            first["bottom"] = padding;
            first["horizontalCenter"] = true;
            second["bottom"] = first["bottom"] + spacing + first["pixelHeight"];
            second["horizontalCenter"] = true;
            break;

        default:
            //center
            first["horizontalCenter"] = true;
            first["verticalCenter"] = true;
            second["horizontalCenter"] = true;
            second["verticalCenter"] = true;
    }

};

/**
 * Update auto sizes, ajust width and height if auto size is enabled.
 * @method  KEN.Button#_updateAutoSize
 * @private
 */
KEN.Button.prototype._updateAutoSize = function()
{

    this.log("_updateAutoSize");

    if(this._autoWidth === false && this._autoHeight === false)
    {
        return;
    }

    var skin = this._skins[this._skin];
    var padding = /** @type {number} */ (skin.getProperty("padding", this._state));

    if(this._autoWidth === true)
    {
        var width = this["pixelWidth"];
        var xMin = Math.min(this._label.x, this._image.x);
        var xMax = Math.max(this._label.x + this._label["pixelWidth"], this._image.x + this._image["pixelWidth"]);

        this._width = (xMax - xMin) + padding * 2 + this._borderWidth * 2;
        this._unitWidth = "px";
        this._dom.style["width"] = this._width+"px";

        if(width !== this["pixelWidth"])
        {
            this._notifyResize({ property: "autoWidth" });
        }
    }

    if(this._autoHeight === true)
    {
        var height = this["pixelHeight"];
        var yMin = Math.min(this._label.y, this._image.y);
        var yMax = Math.max(this._label.y + this._label["pixelHeight"], this._image.y + this._image["pixelHeight"]);

        this._height = (yMax - yMin) + padding * 2 + this._borderWidth * 2;
        this._unitHeight = "px";
        this._dom.style["height"] = this._height+"px";

        if(height !== this["pixelHeight"])
        {
            this._notifyResize({ property: "autoHeight" });
        }
    }
};

/**
 * Parse a Button configuration
 * @method KEN.Button#_parseConfig
 * @private
 * @param  {(ButtonConfig|KEN.ButtonSkin)} config - The configuration to parse.
 */
KEN.Button.prototype._parseConfig = function(config)
{
    if(typeof config !== "undefined" && config !== null)
    {
        //If there is an array of skins, add them
        if(KEN.Utils.isArrayOf(config["skins"], "ButtonSkin") === true)
        {
            for(var i = 0, ii = config["skins"].length; i < ii; i++)
            {
                this.addSkin(config["skins"][i]);
            }
        }
        else
        {
            //convert skins object definition into KEN.ButtonSkin objects
            if(typeof config["skins"] === "object" && config["skins"].length > 0)
            {
                var skin;
                for(var j = 0, jj = config["skins"].length; j < jj; j++)
                {
                    skin = new KEN.ButtonSkin(config["skins"][j]["name"], config["skins"][j].states);
                    this.addSkin(skin);
                }
            }
        }
        //If there is a single skin in config, add it
        if(KEN.Utils.isTypeOf(config["skin"], "ButtonSkin"))
        {
            this.addSkin(config["skin"]);
        }
        else
        {
            //convert skin object definition into KEN.ButtonSkin
            if(typeof config["skin"] === "object")
            {
                var singleSkin = new KEN.ButtonSkin(config["skin"]["name"], config["skin"].states);
                this.addSkin(singleSkin);
            }
        }

        if(KEN.Utils.isTypeOf(config["default"], "string") === true && this.hasSkin(config["default"]) === true)
        {
            this._defaultSkin = config["default"];
        }
    }

    //If no skin found, add the default skin
    var skins = this._skins || {};
    if(Object.keys(skins).length === 0)
    {
        var defaultSkin = new KEN.ButtonSkin("default");
        this.addSkin(defaultSkin);
        // this._skins["default"] = new KEN.ButtonSkin("default");
    }

    //If no skin have been chosen pick the first one
    if(this._defaultSkin === "")
    {
        this._defaultSkin = this._skins[Object.keys(skins)[0]]["name"];
    }
};

/**
 * Destroy image method.
 * @method KEN.Button#_destroyImage
 * @private
 */
KEN.Button.prototype._destroyImage = function()
{
    if(this._image !== null)
    {
        this._image["onLoadComplete"].remove(this._itemLoadComplete, this);
        this._image["onResize"].remove(this._itemResizeHandler, this);

        this.removeChild(this._image, true);
        this._image = null;
    }
};

/**
 * Destroy label method.
 * @method KEN.Button#_destroyLabel
 * @private
 */
KEN.Button.prototype._destroyLabel = function()
{
    if(this._label !== null)
    {
        this._label["onLoadComplete"].remove(this._itemLoadComplete, this);
        this._label["onResize"].remove(this._itemResizeHandler, this);

        this.removeChild(this._label, true);
        this._label = null;
    }
};

/**
 * Load a button configuration.
 * @method  KEN.Button#load
 * @param  {(ButtonConfig|KEN.ButtonSkin)} config - The button configuration to load.
 */
KEN.Button.prototype.load = function(config)
{
    this._parseConfig(config);
    this._applySkin(this._defaultSkin);
};

/**
 * Add a skin to the button
 * @method  KEN.Button#addSkin
 * @param {KEN.ButtonSkin} skin - The button skin you want to add to this button.
 * @param {boolean=} setup - Does the skin you add should be defined as the new current skin.
 */
KEN.Button.prototype.addSkin = function(skin, setup)
{
    if(KEN.Utils.isTypeOf(skin, "ButtonSkin") === false)
    {
        throw "KEN.Button: Invalid button skin!";
    }

    skin.setDefaultFromState(KEN.Button.states.OUT);
    this._skins[skin["name"]] = skin;

    if(setup === true)
    {
        this._applySkin(skin["name"]);
    }
};

/**
 * Set the button skin
 * @method KEN.Button#setSkin
 * @param {(string|KEN.ButtonSkin)} value - Either an existing skin name or an existing or a new {@link KEN.ButtonSkin}
 */
KEN.Button.prototype.setSkin = function(value)
{
    if(typeof value === "string" && KEN.Utils.isTypeOf(this._skins[value], "ButtonSkin") === true)
    {
        this._applySkin(value);
    }
    else if(KEN.Utils.isTypeOf(value, "ButtonSkin") === true)
    {
        if(this._skins[value["name"]] === value)
        {
            this._applySkin(value["name"]);
        }
        else if(typeof this._skins[value["name"]] === "undefined" || this._skins[value["name"]] === null)
        {
            this.addSkin(/** @type {KEN.ButtonSkin} */ (value), true);
        }
    }
};

/**
 * Does the button has a specified skin ?
 * @param  {string}  name - The name of the skin you want to check.
 * @return {boolean} Returns true if the button have a skin with asked name.
 */
KEN.Button.prototype.hasSkin = function(name)
{
    return (typeof this._skins[name] !== "undefined");
};

/**
 * Update the skin display, use this method if you change the skin and you need to update it.
 * @method  KEN.Button#updateSkin
 */
KEN.Button.prototype.updateSkin = function()
{
    this._skins[this._skin].setDefaultFromState(KEN.Button.states.OUT);
    this._applySkin(this._skin);
};

/**
 * Destroy method.
 * @method KEN.Button#destroy
 */
KEN.Button.prototype.destroy = function()
{
    this._viewer["i18n"]["onLocaleChangeComplete"].remove(this._localeChangeCompleteHandler, this);

    if(typeof this._skins !== "undefined" && this._skins.length > 0)
    {
        for(var i in this._skins)
        {
            if(this._skins.hasOwnProperty(i))
            {
                this._skins[i].destroy();
            }
        }
    }
    this._skins = {};

    this._destroyImage();

    this._destroyLabel();

    KEN.DisplayObjectContainer.prototype.destroy.call(this);
};

/**
 * Get the skins list.
 * @name  KEN.Button#skins
 * @readonly
 * @type {Object}
 */
KEN.Button.prototype.skins;
Object.defineProperty(KEN.Button.prototype, "skins",
{
    /** @this {KEN.Button} */
    get: function()
    {
        return this._skins;
    }
});

/**
 * Get and set the current skin.
 * @name  KEN.Button#skin
 * @type {KEN.ButtonSkin}
 */
KEN.Button.prototype.skin;
Object.defineProperty(KEN.Button.prototype, "skin",
{
    /** @this {KEN.Button} */
    get: function()
    {
        return this._skins[this._skin];
    },

    /** @this {KEN.Button} */
    set: function(value)
    {
        this.setSkin(value);
    }
});

/**
* Get and set the flag for auto size on width.
* @name KEN.Button#autoWidth
* @type {boolean}
*/
KEN.Button.prototype.autoWidth;
Object.defineProperty(KEN.Button.prototype, "autoWidth",
{
    /** @this {KEN.Button} */
    get: function()
    {
        return this._autoWidth;
    },

    /** @this {KEN.Button} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._autoWidth = value;

        this._updateAutoSize();
    }
});

/**
* Get and set the flag for auto size on height.
* @name KEN.Button#autoHeight
* @type {boolean}
*/
KEN.Button.prototype.autoHeight;
Object.defineProperty(KEN.Button.prototype, "autoHeight",
{
    /** @this {KEN.Button} */
    get: function()
    {
        return this._autoHeight;
    },

    /** @this {KEN.Button} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._autoHeight = value;

        this._updateAutoSize();
    }
});

/**
 * This class describe a button skin.
 * @constructor KEN.ButtonSkin
 * @param {string=} name - The name of this button skin.
 * @param {Object=} states - An object that describe the different states.
 * @extends {KEN.BaseObject}
 */
KEN.ButtonSkin = function(name, states)
{
    /**
     * Button skin name.
     * @name KEN.ButtonSkin#_config
     * @type {string}
     * @private
     */
    this._name = name || "";

    /**
     * Default skin state.
     * @name KEN.ButtonSkin#_defaultState
     * @type {ButtonSkinStateConfig}
     * @private
     */
    this._defaultState = /** @type {ButtonSkinStateConfig} */ (KEN.Utils.extendSimpleObject(KEN.ButtonSkin.DEFAULT_STATE, {}));

    /**
     * List of skin states.
     * @name KEN.ButtonSkin#_states
     * @type {Object<ButtonSkinStateConfig>}
     * @private
     */
    this._states = /** @type {Object<ButtonSkinStateConfig>} */ (KEN.Utils.extendSimpleObject((states || {}), {"out": {}, "over": {}, "down": {}}));

    KEN.BaseObject.call(this, "ButtonSkin");
};

KEN.ButtonSkin.prototype = Object.create(KEN.BaseObject.prototype);
KEN.ButtonSkin.prototype.constructor = KEN.ButtonSkin;

/**
 * This is the empty Skin state for image
 * @name  KEN.ButtonSkin.EMPTY_STATE_IMAGE
 * @type {ImageConfig}
 * @const
 */
KEN.ButtonSkin.EMPTY_STATE_IMAGE =
{
    key: "",
    url: "",
    i18n: false,
    keepRatio: true,
    maximized: false,
    alpha: 1
};

/**
 * This is the empty Skin state for label
 * @name  KEN.ButtonSkin.EMPTY_STATE_LABEL
 * @type {TextFieldConfig}
 * @const
 */
KEN.ButtonSkin.EMPTY_STATE_LABEL =
{
    value: "",
    i18n: false,
    color: "",
    fontFamily: "",
    fontWeight: ""
};

/**
 * This is the empty Skin state
 * @name  KEN.ButtonSkin.EMPTY_STATE
 * @type {ButtonSkinStateConfig}
 * @const
 */
KEN.ButtonSkin.EMPTY_STATE =
{
    name: "",
    background: "",
    borderStyle: "solid",
    borderColor: "",
    borderRadius: 0,
    borderWidth: 0,
    autoWidth: true,
    autoHeight: true,
    align: "center",
    padding: 0,
    spacing: 0,
    first: "image",

    image: /** @type {ImageConfig} */ (KEN.ButtonSkin.EMPTY_STATE_IMAGE),

    label: /** @type {TextFieldConfig} */ (KEN.ButtonSkin.EMPTY_STATE_LABEL)
};

/**
 * This is the empty Skin state for image
 * @name  KEN.ButtonSkin.DEFAULT_STATE_IMAGE
 * @type {ImageConfig}
 * @const
 */
KEN.ButtonSkin.DEFAULT_STATE_IMAGE =
{
    key: "",
    url: "",
    i18n: false,
    keepRatio: true,
    maximized: false,
    alpha: 1
};

/**
 * This is the empty Skin state for label
 * @name  KEN.ButtonSkin.DEFAULT_STATE_LABEL
 * @type {TextFieldConfig}
 * @const
 */
KEN.ButtonSkin.DEFAULT_STATE_LABEL =
{
    value: "Button",
    i18n: false,
    color: "",
    fontFamily: "",
    fontWeight: ""
};

/**
 * This is the default Skin
 * @name  KEN.ButtonSkin.DEFAULT_STATE
 * @type {ButtonSkinStateConfig}
 * @const
 */
KEN.ButtonSkin.DEFAULT_STATE =
{
    name: "default",
    background: "#eee",
    borderStyle: "solid",
    borderColor: "#555",
    borderRadius: 5,
    borderWidth: 2,
    autoWidth: true,
    autoHeight: true,
    align: "left",
    padding: 5,
    spacing: 0,
    first: "image",

    image: /** @type {ImageConfig} */ (KEN.ButtonSkin.DEFAULT_STATE_IMAGE),

    label: /** @type {TextFieldConfig} */ (KEN.ButtonSkin.DEFAULT_STATE_LABEL)
};

/**
 * Set the default skin from a declared state, by default the default skin state will be "out".
 * @method KEN.ButtonSkin#setDefaultFromState
 * @param {string} name - The name of the state that you want to be the default one.
 */
KEN.ButtonSkin.prototype.setDefaultFromState = function(name)
{
    if(typeof this._states[name] !== "undefined")
    {
        //this._defaultState = KEN.Utils.extendSimpleObject(KEN.ButtonSkin.EMPTY_STATE, this._states[name]);
        //this._defaultState = KEN.Utils.extendSimpleObject(this._defaultState, this._states[name]);
        this._defaultState = this._states[name];
    }
};

/**
 * Static method to validate a {@link KEN.ButtonSkin}
 * @method  KEN.ButtonSkin.isValid
 * @static
 * @param  {KEN.ButtonSkin} skin
 * @return {boolean} Returns true if the button skin is valid.
 */
KEN.ButtonSkin.isValid = function(skin)
{
    // @todo This is WIP obviously
    if(skin)
    {
        return true;
    }

    return false;
};

/**
 * Get a property of a specified state.
 * @method KEN.ButtonSkin#getProperty
 * @param  {string} property - The property name you want to get (eg: "borderColor")
 * @param  {string} state - For which state you want the property ? (out, ouver or down)
 * @return {*} Returns the property you asked for, if the property doesn't exist on the requested state, this will return a default value.
 */
KEN.ButtonSkin.prototype.getProperty = function(property, state)
{
    var result = KEN.Utils.getObjectProperty(this._states, state+"."+property,
                        KEN.Utils.getObjectProperty(this._defaultState, property,
                            KEN.Utils.getObjectProperty(KEN.ButtonSkin.EMPTY_STATE, property)));

    if(typeof result === "object")
    {
        result = KEN.Utils.extendSimpleObject(this._defaultState[property], /** @type {Object} */ (result));
    }

    return result;
};

/**
 * Know if a skin state has an image?
 * @method  KEN.ButtonSkin#hasImage
 * @param  {string} state - For which state you want to know if there is an image ? (out, ouver or down)
 * @return {boolean} Returns true if the specified state has an image
 */
KEN.ButtonSkin.prototype.hasImage = function(state)
{
    var image = this.getProperty("image", state);
    return (typeof image !== "undefined" && (typeof image["url"] === "string" && image["url"] !== ""));
};

/**
 * Know if a skin state has a label?
 * @method  KEN.ButtonSkin#hasLabel
 * @param  {string} state - For which state you want to know if there is a label ? (out, ouver or down)
 * @return {boolean} Returns true if the specified state has a label
 */
KEN.ButtonSkin.prototype.hasLabel = function(state)
{
    var label = this.getProperty("label", state);
    return (typeof label !== "undefined" && (typeof label["value"] === "string" && label["value"] !== ""));
};

/**
 * Get the name of this skin.
 * @name KEN.ButtonSkin#name
 * @type {string}
 */
KEN.ButtonSkin.prototype.name;
Object.defineProperty(KEN.ButtonSkin.prototype, "name",
{
    /** @this {KEN.ButtonSkin} */
    get: function()
    {
        return this._name;
    }
});

/**
 * Get and set the default state of this skin.
 * @name KEN.ButtonSkin#default
 * @type {ButtonSkinStateConfig}
 */
KEN.ButtonSkin.prototype.default;
Object.defineProperty(KEN.ButtonSkin.prototype, "default",
{
    /** @this {KEN.ButtonSkin} */
    get: function()
    {
        return this._defaultState;
    },

    /** @this {KEN.ButtonSkin} */
    set: function(value)
    {
        this._defaultState = value;
    }
});

/**
 * Get and set the "out" state of this skin.
 * @name KEN.ButtonSkin#out
 * @type {ButtonSkinStateConfig}
 */
KEN.ButtonSkin.prototype.out;
Object.defineProperty(KEN.ButtonSkin.prototype, "out",
{
    /** @this {KEN.ButtonSkin} */
    get: function()
    {
        return this._states["out"];
    },

    /** @this {KEN.ButtonSkin} */
    set: function(value)
    {
        this._states["out"] = value;
    }
});

/**
 * Get and set the "over" state of this skin.
 * @name KEN.ButtonSkin#over
 * @type {ButtonSkinStateConfig}
 */
KEN.ButtonSkin.prototype.over;
Object.defineProperty(KEN.ButtonSkin.prototype, "over",
{
    /** @this {KEN.ButtonSkin} */
    get: function()
    {
        return this._states["over"];
    },

    /** @this {KEN.ButtonSkin} */
    set: function(value)
    {
        this._states["over"] = value;
    }
});

/**
 * Get and set the "down" state of this skin.
 * @name KEN.ButtonSkin#down
 * @type {ButtonSkinStateConfig}
 */
KEN.ButtonSkin.prototype.down;
Object.defineProperty(KEN.ButtonSkin.prototype, "down",
{
    /** @this {KEN.ButtonSkin} */
    get: function()
    {
        return this._states["down"];
    },

    /** @this {KEN.ButtonSkin} */
    set: function(value)
    {
        this._states["down"] = value;
    }
});


/**
 * Canvas display object.
 * @constructor KEN.Canvas
 * @param {KEN.Viewer} viewer - The {@link KEN.Viewer} reference.
 * @extends {KEN.DisplayObject}
 */
KEN.Canvas = function(viewer)
{
    KEN.DisplayObject.call(this, viewer, document.createElement("canvas"), "Canvas");
};

KEN.Canvas.prototype = Object.create(KEN.DisplayObject.prototype);
KEN.Canvas.prototype.constructor = KEN.Canvas;

/**
 * Boot sequence.
 * @method KEN.Canvas#_boot
 * @private
 */
KEN.Canvas.prototype._boot = function()
{
    KEN.DisplayObject.prototype._boot.call(this);

    this._viewer["display"].register(this);
    this._notifyReady();
    this._applyPending(false);
};

/**
 * Get the context for 2D.
 * @name KEN.Canvas#context2D
 * @type {CanvasRenderingContext2D}
 * @readonly
 */
KEN.Canvas.prototype.context2D;
Object.defineProperty(KEN.Canvas.prototype, "context2D", 
{
    /** @this {KEN.Canvas} */
    get: function()
    {
        return this._dom.getContext("2d");
    }
});

/**
 * Get the webGl context for 3D.
 * @name KEN.Canvas#context3D
 * @type {WebGLRenderingContext}
 * @readonly
 */
KEN.Canvas.prototype.context3D;
Object.defineProperty(KEN.Canvas.prototype, "context3D", 
{
    /** @this {KEN.Canvas} */
    get: function()
    {
        return this._dom.getContext("webgl");
    }
});

/**
 * Get the canvas DOM element
 * @name KEN.Canvas#element
 * @type {HTMLCanvasElement}
 * @readonly
 */
KEN.Canvas.prototype.element;
Object.defineProperty(KEN.Canvas.prototype, "element", 
{
    /** @this {KEN.Canvas} */
    get: function()
    {
        return this._dom;
    }
});


/**
 * Display object that contains a html video tag.<br>
 * <br>
 * Mobile limitations :<br>
 * - Can't play a video without user touch interaction, so we can't do smooth multiquality.
 *
 * @constructor KEN.VideoHTML5
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @param {string} key - The video file id reference.
 * @param {?(string|KEN.VideoQuality|Array<(string|KEN.VideoQuality)>)=} config - Either a {@link KEN.VideoQuality} or a String URL, or an array of strings or {@link KEN.VideoQuality} if multiquality.
 * @param {string=} qualityMode - The default quality mode.
 * @extends {KEN.DisplayObject}
 *
 * @todo  Define a config object for videos, maybe a class like VideoConfig to describe this porperly.
 * @todo  Make it work with several sources if the user wants to pass a mp4 + webm + ogg for example.
 * @todo  Deal with speeds.
 * @todo  Add subtitles management with <track> and VTT/TTML(EBU-TT-D) files: http://html5doctor.com/video-subtitling-and-webvtt/
 *
 */
KEN.VideoHTML5 = function(viewer, key, config, qualityMode)
{
    /**
     * The viewer reference.
     * @name KEN.VideoHTML5#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The video identifier.
     * @name KEN.VideoHTML5#_key
     * @type {string}
     * @private
     */
    this._key = key;

    /**
     * {@link KEN.VideoQuality} for this video, it can be temporarily a string into the constructor.
     * @name KEN.VideoHTML5#_config
     * @type {?(string|KEN.VideoQuality|Array<(string|KEN.VideoQuality)>)}
     * @private
     */
    this._config = config || null;

    /**
     * Array of {@link KEN.VideoQuality}.
     * @name  KEN.VideoHTML5#_qualities
     * @type {Array<KEN.VideoQuality>}
     * @private
     */
    this._qualities = null;

    /**
     * Default quality mode, it can be either "auto" or "manual", modes are listed by KEN.VideoQualityMode constant.
     * @name KEN.VideoHTML5#_defaultQualityMode
     * @type {string}
     * @private
     */
    this._defaultQualityMode = qualityMode || KEN.VideoQualityMode.AUTO;

    /**
     * Current Quality mode.
     * @name  KEN.VideoHTML5#_qualityMode
     * @type {string}
     * @private
     */
    this._qualityMode = "";

    /**
     * Array of videos objects thaht handle the dom and some stats about each videos.
     * @name KEN.VideoHTML5#_videos
     * @type {Array<Object>}
     * @private
     */
    this._videos = null;

    /**
     * The index of the requested video (if -1 no video is requested).
     * @name  KEN.VideoHTML5#_requestIndex
     * @type {number}
     * @private
     */
    this._requestIndex = -1;

    /**
     * The index of the current video (if -1 no video is selected as the current one).
     * @name  KEN.VideoHTML5#_currentIndex
     * @type {number}
     * @private
     */
    this._currentIndex = -1;

    /**
     * Timer that handler all times event when a video quality request is done.
     * @name  KEN.VideoHTML5#_requestTimer
     * @type {KEN.Timer}
     * @private
     */
    this._requestTimer = null;

    /**
     * Do the video quality change should be forced ? This var keep a reference to forceRequest between the diffent functions of callbacks chain.
     * @name  KEN.VideoHTML5#_forceRequest
     * @type {boolean}
     * @private
     */
    this._forceRequest = false;

    /**
     * The time is milliseconds the requested video is seeked above the current time and wait to be synched.<br>
     * This delay ensure that the requested video have a minimum time to load before being synched.
     * @name  KEN.VideoHTML5#_syncTime
     * @type {number}
     * @private
     */
    this._syncTime = 6000;

    /**
     * The time is milliseconds the requested video is considered as a failure.
     * @name  KEN.VideoHTML5#_timeoutTime
     * @type {number}
     * @private
     */
    this._timeoutTime = 20000;

    /**
     * Timer that handler all times loop that check if we have to change quality (up or down).
     * @name  KEN.VideoHTML5#_autoQualityTimer
     * @type {KEN.Timer}
     * @private
     */
    this._autoQualityTimer = null;

    /**
     * Does the video loop?
     * @name  KEN.VideoHTML5#_loop
     * @type {boolean}
     * @private
     */
    this._loop = false;

    /**
     * The volume of the video.
     * @name  KEN.VideoHTML5#_volume
     * @type {number}
     * @private
     */
    this._volume = 1;

    /**
     * Is the video volume is muted?
     * @name  KEN.VideoHTML5#_muted
     * @type {boolean}
     * @private
     */
    this._muted = false;

    /**
     * Private reference to the previous volume before mute.
     * @name  KEN.VideoHTML5#_mutedVolume
     * @type {number}
     * @private
     */
    this._mutedVolume = 0;

     /**
     * Does the video have received its metaData?
     * @name  KEN.VideoHTML5#_metaDataLoaded
     * @type {boolean}
     * @private
     */
    this._metaDataLoaded = false;

    /**
     * On load start event dispatcher.
     * @name  KEN.VideoHTML5#_onLoadStart
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onLoadStart = null;

    /**
     * On loaded metadata event dispatcher.
     * @name  KEN.VideoHTML5#_onLoadedMetaData
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onLoadedMetaData = null;

    /**
     * On loaded data event dispatcher.
     * @name  KEN.VideoHTML5#_onLoadedData
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onLoadedData = null;

    /**
     * On progress event dispatcher.
     * @name  KEN.VideoHTML5#_onProgress
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onProgress = null;

    /**
     * On duration change event dispatcher.
     * @name  KEN.VideoHTML5#_onDurationChange
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onDurationChange = null;

    /**
     * On can play event dispatcher.
     * @name  KEN.VideoHTML5#_onCanPlay
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onCanPlay = null;

    /**
     * On can play through event dispatcher.
     * @name  KEN.VideoHTML5#_onCanPlayThrough
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onCanPlayThrough = null;

    /**
     * On play event dispatcher.
     * @name  KEN.VideoHTML5#_onPlay
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPlay = null;

    /**
     * On pause event dispatcher.
     * @name  KEN.VideoHTML5#_onPause
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * On time update event dispatcher.
     * @name  KEN.VideoHTML5#_onTimeUpdate
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onTimeUpdate = null;

    /**
     * On volume change event dispatcher.
     * @name  KEN.VideoHTML5#_onVolumeChange
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onVolumeChange = null;

    /**
     * On seeked event dispatcher.
     * @name  KEN.VideoHTML5#_onSeeked
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onSeeked = null;

    /**
     * On ended event dispatcher.
     * @name  KEN.VideoHTML5#_onEnded
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onEnded = null;

    /**
     * On error event dispatcher.
     * @name  KEN.VideoHTML5#_onError
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onError = null;

    /**
     * On mute event dispatcher.
     * @name  KEN.VideoHTML5#_onMute
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onMute = null;

    /**
     * On unmute event dispatcher.
     * @name  KEN.VideoHTML5#_onUnmute
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onUnmute = null;

    /**
     * On qualityRequest event dispatcher.
     * @name  KEN.VideoHTML5#_onQualityRequest
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onQualityRequest = null;

    /**
     * On qualityChange event dispatcher.
     * @name  KEN.VideoHTML5#_onQualityChange
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onQualityChange = null;

    /**
     * On qualityAbort event dispatcher.
     * @name  KEN.VideoHTML5#_onQualityAbort
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onQualityAbort = null;

    /**
     * On qualties loaded event dispatcher.
     * @name  KEN.VideoHTML5#_onQualitiesLoaded
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onQualitiesLoaded = null;

    /**
     * On qualityModeChange event dispatcher.
     * @name  KEN.VideoHTML5#_onQualityModeChange
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onQualityModeChange = null;

    /**
     * Playing status of the video.
     * @name  KEN.VideoHTML5#_playing
     * @type {boolean}
     * @private
     */
    this._playing = false;

    /**
     * Boolean flag to know if can play is already received.
     * @name KEN.VideoHTML5#_canPlay
     * @type {boolean}
     * @private
     */
    this._canPlay = false;

    /**
     * Number of play action on this video.
     * @name  KEN.VideoHTML5#_playCount
     * @type {number}
     * @private
     */
    this._playCount = 0;

    /**
     * Number of the video ended.
     * @name  KEN.VideoHTML5#_endCount
     * @type {number}
     * @private
     */
    this._endCount = 0;

    /**
     * Event handler for request error binded to this.
     * @name KEN.VideoHTML5#_onRequestErrorBind
     * @type {Function}
     * @private
     */
    this._onRequestErrorBind = null;

    /**
     * Event handler for request load start binded to this.
     * @name KEN.VideoHTML5#_onRequestLoadStartBind
     * @type {Function}
     * @private
     */
    this._onRequestLoadStartBind = null;

    /**
     * Event handler for request loaded metadata binded to this.
     * @name KEN.VideoHTML5#_onRequestLoadedMetaDataBind
     * @type {Function}
     * @private
     */
    this._onRequestLoadedMetaDataBind = null;

    /**
     * Event handler for request loaded data binded to this.
     * @name KEN.VideoHTML5#_onRequestLoadedDataBind
     * @type {Function}
     * @private
     */
    this._onRequestLoadedDataBind = null;

    /**
     * Event handler for request can play (before seek) binded to this.
     * @name KEN.VideoHTML5#_onRequestCanPlayBeforeSeekBind
     * @type {Function}
     * @private
     */
    this._onRequestCanPlayBeforeSeekBind = null;

    /**
     * Event handler for request seeked binded to this.
     * @name KEN.VideoHTML5#_onRequestSeekedBind
     * @type {Function}
     * @private
     */
    this._onRequestSeekedBind = null;

    /**
     * Event handler for request can play (after seek) binded to this.
     * @name KEN.VideoHTML5#_onRequestCanPlayAfterSeekBind
     * @type {Function}
     * @private
     */
    this._onRequestCanPlayAfterSeekBind = null;

    /**
     * Event handler for request seeked (while synch) binded to this.
     * @name KEN.VideoHTML5#_onRequestSeekedWhileSyncBind
     * @type {Function}
     * @private
     */
    this._onRequestSeekedWhileSyncBind = null;

    /**
     * Event handler for current video load start binded to this.
     * @name KEN.VideoHTML5#_onLoadStartBind
     * @type {Function}
     * @private
     */
    this._onLoadStartBind = null;

    /**
     * Event handler for current video loaded meta data binded to this.
     * @name KEN.VideoHTML5#_onLoadedMetaDataBind
     * @type {Function}
     * @private
     */
    this._onLoadedMetaDataBind = null;

    /**
     * Event handler for current video loaded data binded to this.
     * @name KEN.VideoHTML5#_onLoadedDataBind
     * @type {Function}
     * @private
     */
    this._onLoadedDataBind = null;

    /**
     * Event handler for current video progress binded to this.
     * @name KEN.VideoHTML5#_onProgressBind
     * @type {Function}
     * @private
     */
    this._onProgressBind = null;

    /**
     * Event handler for current video duration change binded to this.
     * @name KEN.VideoHTML5#_onDurationChangeBind
     * @type {Function}
     * @private
     */
    this._onDurationChangeBind = null;

    /**
     * Event handler for current video can play binded to this.
     * @name KEN.VideoHTML5#_onCanPlayBind
     * @type {Function}
     * @private
     */
    this._onCanPlayBind = null;

    /**
     * Event handler for current video can play throught binded to this.
     * @name KEN.VideoHTML5#_onCanPlayThroughBind
     * @type {Function}
     * @private
     */
    this._onCanPlayThroughBind = null;

    /**
     * Event handler for current video play binded to this.
     * @name KEN.VideoHTML5#_onPlayBind
     * @type {Function}
     * @private
     */
    this._onPlayBind = null;

    /**
     * Event handler for current video pause binded to this.
     * @name KEN.VideoHTML5#_onPauseBind
     * @type {Function}
     * @private
     */
    this._onPauseBind = null;

    /**
     * Event handler for current video time update binded to this.
     * @name KEN.VideoHTML5#_onTimeUpdateBind
     * @type {Function}
     * @private
     */
    this._onTimeUpdateBind = null;

    /**
     * Event handler for current video volume change binded to this.
     * @name KEN.VideoHTML5#_onVolumeChangeBind
     * @type {Function}
     * @private
     */
    this._onVolumeChangeBind = null;

    /**
     * Event handler for current video seeked binded to this.
     * @name KEN.VideoHTML5#_onSeekedBind
     * @type {Function}
     * @private
     */
    this._onSeekedBind = null;

    /**
     * Event handler for current video ended binded to this.
     * @name KEN.VideoHTML5#_onEndedBind
     * @type {Function}
     * @private
     */
    this._onEndedBind = null;

    /**
     * Event handler for current video error binded to this.
     * @name KEN.VideoHTML5#_onErrorBind
     * @type {Function}
     * @private
     */
    this._onErrorBind = null;

    KEN.DisplayObject.call(this, viewer, null, "VideoHTML5");
};

KEN.VideoHTML5.prototype = Object.create(KEN.DisplayObject.prototype);
KEN.VideoHTML5.prototype.constructor = KEN.VideoHTML5;

/**
 * Boot sequence.
 * @method KEN.VideoHTML5#_boot
 * @private
 */
KEN.VideoHTML5.prototype._boot = function()
{
    KEN.DisplayObject.prototype._boot.call(this);

    //register the uid
    this._uid = this._key;
    this._register();

    this._onRequestErrorBind = this._onRequestError.bind(this);
    this._onRequestLoadStartBind = this._onRequestLoadStart.bind(this);
    this._onRequestLoadedMetaDataBind = this._onRequestLoadedMetaData.bind(this);
    this._onRequestLoadedDataBind = this._onRequestLoadedData.bind(this);
    this._onRequestCanPlayBeforeSeekBind = this._onRequestCanPlayBeforeSeek.bind(this);
    this._onRequestSeekedBind = this._onRequestSeeked.bind(this);
    this._onRequestCanPlayAfterSeekBind = this._onRequestCanPlayAfterSeek.bind(this);
    this._onRequestSeekedWhileSyncBind = this._onRequestSeekedWhileSync.bind(this);

    this._onLoadStartBind = this._onLoadStartHandler.bind(this);
    this._onDurationChangeBind = this._onDurationChangeHandler.bind(this);
    this._onLoadedMetaDataBind = this._onLoadedMetaDataHandler.bind(this);
    this._onLoadedDataBind = this._onLoadedDataHandler.bind(this);
    this._onProgressBind = this._onProgressHandler.bind(this);
    this._onCanPlayBind = this._onCanPlayHandler.bind(this);
    this._onCanPlayThroughBind = this._onCanPlayThroughHandler.bind(this);
    this._onPlayBind = this._onPlayHandler.bind(this);
    this._onPauseBind = this._onPauseHandler.bind(this);
    this._onTimeUpdateBind = this._onTimeUpdateHandler.bind(this);
    this._onVolumeChangeBind = this._onVolumeChangeHandler.bind(this);
    this._onSeekedBind = this._onSeekedHandler.bind(this);
    this._onEndedBind = this._onEndedHandler.bind(this);
    this._onErrorBind = this._onErrorHandler.bind(this);

    this._requestTimer = this._viewer["clock"].create(false);

    this._autoQualityTimer = this._viewer["clock"].create(false);
    this._autoQualityTimer.loop(500, this._autoQualityTimerLoop, this);

    //Listen to the main volume change to adapt the video volume accordingly.
    this._viewer["audio"]["onVolumeChange"].add(this._mainVolumeChangeHandler, this);

    //Listen to the enabled state of the sound manager.
    this._viewer["audio"]["onDisable"].add(this._disableSoundHandler, this);

    //force the creation of "onQualitiesLoaded" event dispatcher and memorize it's data
    this._onQualitiesLoaded = new KEN.EventDispatcher(this, true);

    if(this._config !== null)
    {
        this.load(this._config);
    }

    this._viewer["display"].register(this);
    this._notifyReady();
    this._applyPending(false);
};

/**
 * Parse the video configuration object.
 * @method KEN.VideoHTML5#_parseConfig
 * @private
 * @param  {?(string|KEN.VideoQuality|Array<(string|KEN.VideoQuality)>)} config - The config object to parse.
 * @return {Array<KEN.VideoQuality>} Returns the array of {@link KEN.VideoQuality}.
 */
KEN.VideoHTML5.prototype._parseConfig = function(config)
{
    if(config !== null)
    {
        if(KEN.Utils.isTypeOf(config, "string") === true)
        {
            config = [config];
        }
        else if(KEN.Utils.isTypeOf(config, "VideoQuality") === true)
        {
            config = [config];
        }

        if(KEN.Utils.isArrayOf(config, "string") === true)
        {
            this._qualities = this._createQualitiesFromURLs(/** @type {Array<string>} */ (config));
        }
        else if(KEN.Utils.isArrayOf(config, "VideoQuality") === true)
        {
            this._qualities = /** @type {Array<KEN.VideoQuality>} */ (config);
        }
    }

    if(this._onQualitiesLoaded !== null)
    {
        this._onQualitiesLoaded.dispatch(this._qualities);
    }

    return this._qualities;
};

/**
 * Notify that the dispay object has been resized.<br>
 * This method ovverrides the {@link KEN.DisplayObject} method.
 * @method  KEN.VideoHTML5#_notifyResize
 * @private
 * @param  {PropertyToUpdate} data - The data contains the property that have changed.
 */
KEN.VideoHTML5.prototype._notifyResize = function(data)
{
    var currentVideo = this._getCurrentVideo();

    if(currentVideo !== null && currentVideo["element"] !== null)
    {
        currentVideo["element"].setAttribute("width", this["pixelWidth"]);
        currentVideo["element"].setAttribute("height", this["pixelHeight"]);
    }

    KEN.DisplayObject.prototype._notifyResize.call(this, data);
};

/**
 * Create the array of {@link KEN.VideoQuality} from an array of URLs (strings).
 * @method KEN.VideoHTML5#_createQualitiesFromURLs
 * @private
 * @param  {Array<string>} urls - Array of URLS (strings) to convert to array of {@link KEN.VideoQuality}.
 * @param {boolean=} checkURL - Does the function have to check url validity?
 * @return {Array<KEN.VideoQuality>} Returns the array of {@link KEN.VideoQuality}.
 */
KEN.VideoHTML5.prototype._createQualitiesFromURLs = function(urls, checkURL)
{
    var qualities = [];
    var quality;

    for(var i = 0, ii = urls.length; i < ii; i++)
    {
        if(checkURL === true && KEN.URL.isValid(urls[i]) === false)
        {
            throw "KEN.VideoHTML5: URL "+urls[i]+" is invalid";
        }

        quality = new KEN.VideoQuality(urls[i]);
        qualities.push(quality);
    }

    return qualities;
};

/**
 * Get the index of a {@link KEN.VideoQuality} that is in the _videoQualities array.
 * @method  KEN.VideoHTML5#_indexOfQuality
 * @private
 * @param  {KEN.VideoQuality} quality - The quality you need to get its index.
 * @return {number} Returns the index of the quality if found, -1 if not found.
 */
KEN.VideoHTML5.prototype._indexOfQuality = function(quality)
{
    var q;
    for(var i = 0, ii = this._qualities.length; i < ii; i++)
    {
        q = this._qualities[i];

        if(q === quality)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Get the index of a video object that is in the _videos array.
 * @method  KEN.VideoHTML5#_indexOfVideo
 * @private
 * @param  {Object} video - The video object you need to get its index.
 * @return {number} Returns the index of the video object if found, -1 if not found.
 */
KEN.VideoHTML5.prototype._indexOfVideo = function(video)
{
    var v;
    for(var i = 0, ii = this._videos.length; i < ii; i++)
    {
        v = this._videos[i];

        if(v === video)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Get a video object at a specified index.
 * @method  KEN.VideoHTML5#_getVideoAt
 * @private
 * @param  {number} index - The index of the video you want to get.
 * @return {?Object} Returns the video object or null if not found.
 */
KEN.VideoHTML5.prototype._getVideoAt = function(index)
{
    if(this._videos === null)
    {
        return null;
    }

    var video = this._videos[index];

    if(video !== null && typeof video !== "undefined")
    {
        return video;
    }

    return null;
};

/**
 * Get the video object for the requested video.
 * @method KEN.VideoHTML5#_getRequestedVideo
 * @private
 * @return {Object} Video object for the requested video.
 */
KEN.VideoHTML5.prototype._getRequestedVideo = function()
{
    return this._getVideoAt(this._requestIndex);
};

/**
 * Get the video object for the current video.
 * @method KEN.VideoHTML5#_getCurrentVideo
 * @private
 * @return {Object} Video object for the current video.
 */
KEN.VideoHTML5.prototype._getCurrentVideo = function()
{
    return this._getVideoAt(this._currentIndex);
};

/**
 * Get a property of the video element of the current video object.
 * @method  KEN.VideoHTML5#_getCurrentVideoElementProperty
 * @param  {string} property - The property you want to get from the current video element.
 * @param  {*} defaultReturnValue - The default return value if the video object or its element is null.
 * @return {*} Return the requested property value or the default one if necessary.
 * @private
 */
KEN.VideoHTML5.prototype._getCurrentVideoElementProperty = function(property, defaultReturnValue)
{
    var video = this._getCurrentVideo();

    if(video !== null && video["element"] !== null)
    {
        return video["element"][property];
    }

    return defaultReturnValue;
};

/**
 * Create placeholders objects for videos and theirs attributes.
 * @method KEN.VideoHTML5#_createVideoObjects
 * @private
 * @param  {number} count - Number of video objects to create.
 * @return {Array} Returns the populated videos array.
 */
KEN.VideoHTML5.prototype._createVideoObjects = function(count)
{
    var videos = [];
    var video;

    for (var i = 0, ii = count; i < ii; i++)
    {
        video =
        {
            index: i,
            element: null,
            buffer: null,
            played: null,

            requestCount: 0,
            currentCount: 0,
            abortCount: 0, //Number of times this video has been requested and aborted
            leaveCount: 0, //Number of times this video has been leaved for bandwidth issues

            lastTimeStamp: 0
        };

        videos[i] = video;
    }

    this._videos = videos;

    return videos;
};

/**
 * Populate a video object at a specified index with an element <video> and a buffer/played {@link KEN.VideoTimeRanges} managers.
 * @method  KEN.VideoHTML5#_createVideoAt
 * @private
 * @param  {number} index - The index to create the video in the _videos array.
 * @return {Object} Returns the populated video object.
 */
KEN.VideoHTML5.prototype._createVideoAt = function(index)
{
    //Create a video tag and get the quality
    var element = document.createElement("video");
    element.setAttribute("webkit-playsinline", "webkit-playsinline");
    element.setAttribute("width", this["pixelWidth"]);
    element.setAttribute("height", this["pixelHeight"]);
    element["volume"] = 0;
    element.crossOrigin = "anonymous";
    element["id"] = "KEN-VideoHTML5-" + this._uid + "-" + index;

    var buffer = new KEN.VideoTimeRanges(element, "buffered");
    var played = new KEN.VideoTimeRanges(element, "played");

    //Update the video object with the element and fresh buffer and played
    var video = this._videos[index];
    video["element"] = element;
    video["buffer"] = buffer;
    video["played"] = played;
    video.lastTimeStamp = 0;

    return video;
};

/**
 * Create the source tag into the video tag.
 * @method KEN.VideoHTML5#_createSourceTags
 * @private
 * @param {Object} video - Video object to add the quality to.
 * @param {KEN.VideoQuality} quality - The quality video source to attach to the video element.
 * @return {Object} The video object that contains the HTML5 Video Element in which the source is append to.
 */
KEN.VideoHTML5.prototype._createSourceTags = function(video, quality)
{
    var source = document.createElement("source");
    source.addEventListener("error", this._onRequestErrorBind, false);
    source.src = quality["url"];
    source["type"] = quality["mimeType"];

    video["element"].appendChild(source);

    return video;
};

/**
 * Destroy a video object.
 * @method KEN.VideoHTML5#_destroyVideo
 * @private
 * @param {Object} video - The video object to destroy.
 */
KEN.VideoHTML5.prototype._destroyVideo = function(video)
{
    var index = this._indexOfVideo(video);

    if(index !== -1)
    {
        this._destroyVideoAt(index);
    }
};

/**
 * Destroy a video object at a specified index, wiil look at the video object into _videos array then detoy it.
 * @method KEN.VideoHTML5#_destroyVideoAt
 * @private
 * @param {number} index - The index of the video object to destroy.
 */
KEN.VideoHTML5.prototype._destroyVideoAt = function(index)
{
    if(index !== -1)
    {
        this.log("_destroyVideoAt "+index);

        var video = this._videos[index];
        var element = video["element"];

        if(typeof element !== "undefined" && element !== null)
        {
            this._uninstallEvents(element);
            element.pause();
            element.src = "";

            var source;
            for(var i = 0, ii = element["children"].length; i < ii; i++)
            {
                source = element["children"][i];
                source.removeEventListener("error", this._onRequestErrorBind, false);
                source.src = "";

                element.removeChild(source);
                source = null;
            }

            element.load();

            if(element.parentNode === this._dom)
            {
                this._dom.removeChild(element);
            }
        }

        element = null;
        video["element"] = null;

        if(video["buffer"] !== null)
        {
            video["buffer"].destroy();
            video["buffer"] = null;
        }

        if(video["played"] !== null)
        {
            video["played"].destroy();
            video["played"] = null;
        }
    }
};

/**
 * Set the request index.<br>
 * A video quality change request starts here!
 * @method KEN.VideoHTML5#_setRequestIndex
 * @private
 * @param {number} index - The index of the video quality that is requested.
 * @param {boolean=} force - Do we have to force the request? Used in downgrade quality, we skip the synch delay to have a minimal interruption of playback.
 */
KEN.VideoHTML5.prototype._setRequestIndex = function(index, force)
{
    this._forceRequest = force || false;
    this.log("Requesting index: "+index+", force: "+this._forceRequest);

    //If a request is already being proccessed clear it
    if(this._requestIndex !== -1 && this._requestIndex !== index)
    {
        this._clearRequestedVideo();
    }

    var alreadyRequested = index === this._requestIndex ? true : false;

    //Assign the new request index
    this._requestIndex = index;

    if(this._onQualityRequest !== null)
    {
        this._onQualityRequest.dispatch(index);
    }

    //If this request is alredy being processed or it matches the current video, return!
    if(index === this._currentIndex || alreadyRequested === true)
    {
        return;
    }

    //Create a video tag and get the quality
    var requestedVideo = this._createVideoAt(this._requestIndex);
    requestedVideo.requestCount++;

    //Get the requested quality
    var quality = this._qualities[this._requestIndex];

    //If there is a current video
    if(this._currentIndex > -1)
    {
        //Add listener to begins transition between qualities
        requestedVideo["element"].addEventListener("loadstart", this._onRequestLoadStartBind, false);
        requestedVideo["element"].addEventListener("error", this._onRequestErrorBind, false);
    }

    //Create source tags according to quality
    this._createSourceTags(requestedVideo, quality);
    //Load!
    requestedVideo["element"].load();

    //If there's no current video, this is the first request, assign the current video directly
    if(this._currentIndex === -1)
    {
        this.log("No current video, set directly the current index");
        this._setCurrentIndex(index);
    }
    else
    {
        //Start a timer to estimate if it is a failure ...
        this._requestTimer.add(this._timeoutTime, this._requestTimeOutHandler, this);
        this._requestTimer.start();
    }
};

/**
 * Event handler for loadstart, binded on a requested video element.
 * @method KEN.VideoHTML5#_onRequestLoadStart
 * @private
 */
KEN.VideoHTML5.prototype._onRequestLoadStart = function()
{
    var element = this._getRequestedVideo().element;

    this.log("_onRequestLoadStart [readyState: "+element.readyState+"]");
    element.removeEventListener("loadstart", this._onRequestLoadStartBind, false);
    element.addEventListener("loadedmetadata", this._onRequestLoadedMetaDataBind, false);
};

/**
 * Event handler for loadedmetadata, binded on a requested video element.
 * @method KEN.VideoHTML5#_onRequestLoadedMetaData
 * @private
 */
KEN.VideoHTML5.prototype._onRequestLoadedMetaData = function()
{
    var element = this._getRequestedVideo().element;

    this.log("_onRequestLoadedMetaData [readyState: "+element.readyState+"]");
    element.removeEventListener("loadedmetadata", this._onRequestLoadedMetaDataBind, false);
    element.addEventListener("loadeddata", this._onRequestLoadedDataBind, false);
};

/**
 * Event handler for loadeddata, binded on a requested video element.
 * @method KEN.VideoHTML5#_onRequestLoadedData
 * @private
 */
KEN.VideoHTML5.prototype._onRequestLoadedData = function()
{
    var element = this._getRequestedVideo().element;

    this.log("_onRequestLoadedData [readyState: "+element.readyState+"]");
    element.removeEventListener("loadeddata", this._onRequestLoadedDataBind, false);

    if(KEN.Device.desktop === true)
    {
        element.addEventListener("play", this._onRequestCanPlayBeforeSeekBind, false);
        element.play();
    }
    else
    {
        //For mobile no sync, we are not able to play without user interaction
        this._setCurrentIndex(this._requestIndex, true);
    }
};

/**
 * Event handler for canplay, binded on a requested video element.
 * @method KEN.VideoHTML5#_onRequestCanPlayBeforeSeek
 * @private
 */
KEN.VideoHTML5.prototype._onRequestCanPlayBeforeSeek = function()
{
    var element = this._getRequestedVideo().element;

    this.log("_onRequestCanPlayBeforeSeek [readyState: "+element.readyState+"]");
    element.pause();
    element.removeEventListener("play", this._onRequestCanPlayBeforeSeekBind, false);
    element.addEventListener("seeked", this._onRequestSeekedBind, false);

    var currentTime = this["currentTime"];

    //If the video is already playing, start buffering the next video quality some seconds after the current time.
    if(this._playing === true && this._forceRequest === false)
    {
        element["currentTime"] = currentTime + (this._syncTime / 1000);
    }
    else
    {
        element["currentTime"] = currentTime;
    }
};

/**
 * Event handler for seeked, binded on a requested video element.
 * @method KEN.VideoHTML5#_onRequestSeeked
 * @private
 */
KEN.VideoHTML5.prototype._onRequestSeeked = function()
{
    var element = this._getRequestedVideo().element;

    this.log("_onRequestSeeked [readyState: "+element.readyState+"]");
    element.removeEventListener("seeked", this._onRequestSeekedBind, false);

    if(element.readyState === 4)
    {
        element.removeEventListener("error", this._onRequestErrorBind, false);
        this._requestWaitSync();
    }
    else
    {
        element.addEventListener("canplay", this._onRequestCanPlayAfterSeekBind, false);
    }
};

/**
 * Event handler for canplay (after a seek), binded on a requested video element.
 * @method KEN.VideoHTML5#_onRequestCanPlayAfterSeek
 * @private
 */
KEN.VideoHTML5.prototype._onRequestCanPlayAfterSeek = function()
{
    var element = this._getRequestedVideo().element;

    this.log("_onRequestCanPlayAfterSeek [readyState: "+element.readyState+"]");

    //Clean events listeners on element
    element.removeEventListener("canplay", this._onRequestCanPlayAfterSeekBind, false);
    element.removeEventListener("error", this._onRequestErrorBind, false);

    this._requestWaitSync();
};

/**
 * Triggers the waiting process of two videos to be synched.
 * @method KEN.VideoHTML5#_requestWaitSync
 * @private
 */
KEN.VideoHTML5.prototype._requestWaitSync = function()
{
    //If the current video is seeked, re init the request (abort then retry)
    var currentVideo = this._getCurrentVideo();
    if(currentVideo !== null && currentVideo["element"] !== null && this._forceRequest === false)
    {
        this.log("Current video listen to seek, wait both video to sync");
        currentVideo["element"].addEventListener("seeked", this._onRequestSeekedWhileSyncBind, false);
        this._requestTimer.loop(10, this._videoSyncTimerLoop, this);
    }

    //Clean error event listener on requested source
    var element = this._getRequestedVideo().element;
    var source;
    for(var i = 0, ii = element["children"].length; i < ii; i++)
    {
        source = element["children"][i];
        source.removeEventListener("error", this._onRequestErrorBind, false);
    }

    if(this._forceRequest === true)
    {
        this._setCurrentIndex(this._requestIndex);
    }
};

/**
 * Event handler for seeked on video while its being synched, binded on a requested video element.<br>
 * if a seeked event occurs while sync, this abort the request and retry with the new current time of the video.
 * @method  KEN.VideoHTML5#_onRequestSeekedWhileSync
 * @private
 */
KEN.VideoHTML5.prototype._onRequestSeekedWhileSync = function()
{
    this.log("_onRequestSeekedWhileSync "+this["currentTime"]);

    var requestIndex = this._requestIndex;
    this._abortRequest(false);
    this._setRequestIndex(requestIndex);
};

/**
 * This is the timer loop handler that check if two videos are synched each other.<br>
 * If sync is ok, sets the requested video as the current one.
 * @method KEN.VideoHTML5#_videoSyncTimerLoop
 * @private
 */
KEN.VideoHTML5.prototype._videoSyncTimerLoop = function()
{
    this.log("_videoSyncTimerLoop "+this._requestIndex);

    var video = this._getRequestedVideo();

    if(video !== null && this["currentTime"] >= video["element"]["currentTime"] && this["currentTime"] < (video["element"]["currentTime"] + 0.05))
    {
        this._setCurrentIndex(this._requestIndex);
    }
};

/**
 * Event handler for the timeout timer. Abort the video raquest if the timeout contdown is reached.
 * @method KEN.VideoHTML5#_requestTimeOutHandler
 * @private
 */
KEN.VideoHTML5.prototype._requestTimeOutHandler = function()
{
    this.log("_requestTimeOutHandler");
    this._abortRequest(true);
};

/**
 * Event handler for error, binded on a requested video element.
 * @method KEN.VideoHTML5#_onRequestError
 * @private
 */
KEN.VideoHTML5.prototype._onRequestError = function(event)
{
    this.log("_onRequestError");
    this.log(event);
    this._abortRequest(true);
};

/**
 * Sets the current video index.<br>
 * This is the end of the video quality request process! Congratulations!
 * @method  KEN.VideoHTML5#_setCurrentIndex
 * @private
 * @param {number} index - The index of the video to be consider as the current one.
 * @param {boolean=} sync - Does the new video have to be time synched with the previous video time?
 */
KEN.VideoHTML5.prototype._setCurrentIndex = function(index, sync)
{
    if(index === this._currentIndex)
    {
        return;
    }

    // Remove all video tags from our container div
    this._dom.innerHTML = "";

    //Get the requested video
    var requestedVideo = this._getRequestedVideo();

    // Resume playback if it was alredy playing
    if(this._playing === true)
    {
        requestedVideo["element"].play();
    }

    //Update the volume of the requested video
    this._updateVolume(requestedVideo);

    //Get the current video and clean some events listener (seek while sync), and destroy video tag.
    var videoToBeRemoved = this._getCurrentVideo();

    // Index switch
    this._requestIndex = -1;
    this._currentIndex = index;

    // Update current video reference
    var currentVideo = this._getCurrentVideo();
    currentVideo.currentCount++;

    //Restore current time on mobile
    if(sync === true && videoToBeRemoved !== null)
    {
        currentVideo["element"]["currentTime"] = videoToBeRemoved["element"]["currentTime"];
    }

    //Install the current video events
    this._installEvents(currentVideo["element"]);

    //Add video to the DOM
    this._dom.appendChild(currentVideo["element"]);


    if(videoToBeRemoved !== null && videoToBeRemoved["element"] !== null)
    {
        videoToBeRemoved["element"].removeEventListener("seeked", this._onRequestSeekedWhileSyncBind, false);
        this._destroyVideo(videoToBeRemoved);
    }

    //Clear the request timer
    this._requestTimer.stop(true);

    if(this._onQualityChange !== null)
    {
        this._onQualityChange.dispatch(this._currentIndex);
    }

    if(this._qualityMode === "")
    {
        this._setQualityMode(this._defaultQualityMode);
    }
};

/**
 * Event handler for the auto quality timer loop that checks if we have to upgrade or downgrade the quality.
 * @method KEN.VideoHTML5#_autoQualityTimerLoop
 * @private
 */
KEN.VideoHTML5.prototype._autoQualityTimerLoop = function()
{
    this.log("Auto quality timer loop");

    //If there is a pending request, return
    if(this._playing === false || this._requestIndex !== -1)
    {
        return;
    }

    if(this._shouldAutoQualityDowngrade() === true)
    {
        this._downgradeAutoQuality();
        return;
    }

    if(this._shouldAutoQualityUpgrade() === true)
    {
        this._upgradeAutoQuality();
        return;
    }
};

/**
 * Algo that check if we should upgrade the video quality.
 * @method  KEN.VideoHTML5#_shouldAutoQualityUpgrade
 * @private
 * @return {boolean} Returns true if we should upgrade the video quality, false if not.
 */
KEN.VideoHTML5.prototype._shouldAutoQualityUpgrade = function()
{
    var currentVideo = this._getCurrentVideo();

    if(currentVideo !== null && currentVideo["buffer"] !== null)
    {
        if(currentVideo["buffer"].isInRanges(currentVideo["element"]["currentTime"], this._syncTime / 1000))
        {
            return true;
        }
    }

    return false;
};

/**
 * Algo that check if we should downgrade the video quality.
 * @method  KEN.VideoHTML5#_shouldAutoQualityDowngrade
 * @private
 * @return {boolean} Returns true if we should downgrade the video quality, false if not.
 */
KEN.VideoHTML5.prototype._shouldAutoQualityDowngrade = function()
{
    var currentVideo = this._getCurrentVideo();
    var time = currentVideo["element"]["currentTime"];

    if(currentVideo["element"]["playing"] === false)
    {
        return false;
    }

    if(time === currentVideo.lastTimeStamp)
    {
        currentVideo.lastTimeStamp = 0;
        return true;
    }
    else
    {
        currentVideo.lastTimeStamp = time;
    }

    return false;
};

/**
 * Upgrade the video quality, triggered by the _autoQualityTimerLoop Timer handler.<br>
 * This part of code decide what is the next quality index to request for a quality upgrade.
 * @method KEN.VideoHTML5#_upgradeAutoQuality
 * @private
 */
KEN.VideoHTML5.prototype._upgradeAutoQuality = function()
{
    //If we are not already to the max quality
    if(this._currentIndex !== this._qualities.length - 1)
    {
        var nextIndex = this._currentIndex + 1;

        if(this._videos[nextIndex].abortCount === 0 && this._videos[nextIndex].leaveCount === 0)
        {
            this.log("AutoQuality upgrade quality");
            this._setRequestIndex(nextIndex);
        }
        else
        {
            this.log("AutoQuality do not attempt to load an already aborted video");
        }
    }
};

/**
 * Downgrade the video quality, triggered by the _autoQualityTimerLoop Timer handler.<br>
 * This part of code decide what is the next quality index to request for a quality downgrade.
 * @method KEN.VideoHTML5#_downgradeAutoQuality
 * @private
 */
KEN.VideoHTML5.prototype._downgradeAutoQuality = function()
{
    this.log("AutoQuality downgrade quality");

    var currentVideo = this._getCurrentVideo();
    currentVideo.leaveCount++;

    if(this._currentIndex - 1 >= 0)
    {
        this._setRequestIndex(this._currentIndex - 1, true);
    }
    else
    {
        this.log("Can't downgrade video quality anymore!");
    }

};

/**
 * Sets the quality mode.
 * @method  KEN.VideoHTML5#_setQualityMode
 * @private
 * @param {string} mode - Quality mode to be set.
 */
KEN.VideoHTML5.prototype._setQualityMode = function(mode)
{
    if(KEN.Device.desktop === false)
    {
        mode = KEN.VideoQualityMode.MANUAL;
        this.warn("Quality mode force to manual, you are not on desktop");
    }

    if(this._qualityMode === mode)
    {
        return;
    }

    if(mode === KEN.VideoQualityMode.AUTO || mode === KEN.VideoQualityMode.MANUAL)
    {
        this._qualityMode = mode;

        //Stop quality related timer anyway
        this._autoQualityTimer.stop(false);

        //If mode auto add and start a fresh timer
        if(this._qualityMode === KEN.VideoQualityMode.AUTO)
        {
            this._autoQualityTimer.start();
        }

        if(this._onQualityModeChange !== null)
        {
            this._onQualityModeChange.dispatch(this._qualityMode);
        }
    }
};

/**
 * Abort a requested video for any reason.
 * @method  KEN.VideoHTML5#_abortRequest
 * @private
 * @param  {boolean} count - Does the aborted property of the video object have to be increased?
 */
KEN.VideoHTML5.prototype._abortRequest = function(count)
{
    var requestedVideo = this._getRequestedVideo();

    if(requestedVideo === null)
    {
        return;
    }

    //Increase the aborted count for this video
    if(count === true)
    {
        requestedVideo.abortCount++;
    }

    //Clear the requested video
    this._clearRequestedVideo();

    //Stop the timer, clear all its events
    this._requestTimer.stop(true);

    if(this._onQualityAbort !== null)
    {
        this._onQualityAbort.dispatch();
    }
};

/**
 * Clear the virequested video from its event, detroy the video element etc ...
 * @method KEN.VideoHTML5#_clearRequestedVideo
 * @private
 */
KEN.VideoHTML5.prototype._clearRequestedVideo = function()
{
    var video = this._getRequestedVideo();
    var element;

    if(video !== null)
    {
        //Remove all listeners used for the requested video
        element = video["element"];
        element.removeEventListener("loadstart", this._onRequestLoadStartBind, false);
        element.removeEventListener("loadedmetadata", this._onRequestLoadedMetaDataBind, false);
        element.removeEventListener("loadeddata", this._onRequestLoadedDataBind, false);
        element.removeEventListener("play", this._onRequestCanPlayBeforeSeekBind, false);
        element.removeEventListener("seeked", this._onRequestSeekedBind, false);
        element.removeEventListener("canplay", this._onRequestCanPlayAfterSeekBind, false);
        element.removeEventListener("error", this._onRequestErrorBind, false);

        //Destroy the requested video
        this._destroyVideo(video);

        //Set the request index to -1, so no video is considered as requested
        this._requestIndex = -1;
    }
};

/**
 * Handles the main volume change, update the volume factor to the video volume.
 * @method KEN.VideoHTML5#_mainVolumeChangeHandler
 * @private
 */
KEN.VideoHTML5.prototype._mainVolumeChangeHandler = function()
{
    this._updateVolume();
};

/**
 * Apply the main volume factor to the video volume.
 * @method KEN.VideoHTML5#_updateVolume
 * @param {Object=} video - The video you want to update the volume, if undefined it will update the currentVideo
 * @private
 */
KEN.VideoHTML5.prototype._updateVolume = function(video)
{
    var v = video || this._getCurrentVideo();

    if(v !== null && v["element"] !== null && this._viewer["audio"]["enabled"] === true)
    {
        v["element"]["volume"] = this._volume * this._viewer["audio"]["volume"];
    }
};

/**
 * Handles the disable status of the sound manager.
 * @method KEN.VideoHTML5#_disableSoundHandler
 * @private
 */
KEN.VideoHTML5.prototype._disableSoundHandler = function()
{
    var v = this._getCurrentVideo();

    if(v !== null && v["element"] !== null && this._viewer["audio"]["enabled"] === false)
    {
        v["element"]["volume"] = 0;
    }
};

/**
 * Bind native events handler for the current video.
 * @method KEN.VideoHTML5#_installEvents
 * @private
 * @param {HTMLVideoElement} element - The video element to bind events on.
 */
KEN.VideoHTML5.prototype._installEvents = function(element)
{
    element.addEventListener("loadstart", this._onLoadStartBind, false);
    element.addEventListener("durationchange", this._onDurationChangeBind, false);
    element.addEventListener("loadedmetadata", this._onLoadedMetaDataBind, false);
    element.addEventListener("loadeddata", this._onLoadedDataBind, false);
    element.addEventListener("progress", this._onProgressBind, false);
    element.addEventListener("canplay", this._onCanPlayBind, false);
    element.addEventListener("canplaythrough", this._onCanPlayThroughBind, false);
    element.addEventListener("play", this._onPlayBind, false);
    element.addEventListener("pause", this._onPauseBind, false);
    element.addEventListener("timeupdate", this._onTimeUpdateBind, false);
    element.addEventListener("volumechange", this._onVolumeChangeBind, false);
    element.addEventListener("seeked", this._onSeekedBind, false);
    element.addEventListener("ended", this._onEndedBind, false);
    element.addEventListener("error", this._onErrorBind, false);
};

/**
 * Unbind events handler for video.
 * @method KEN.VideoHTML5#_uninstallEvents
 * @private
 * @param {HTMLVideoElement} element - The video element to unbind events on.
 */
KEN.VideoHTML5.prototype._uninstallEvents = function(element)
{
    element.removeEventListener("loadstart", this._onLoadStartBind, false);
    element.removeEventListener("durationchange", this._onDurationChangeBind, false);
    element.removeEventListener("loadedmetadata", this._onLoadedMetaDataBind, false);
    element.removeEventListener("loadeddata", this._onLoadedDataBind, false);
    element.removeEventListener("progress", this._onProgressBind, false);
    element.removeEventListener("canplay", this._onCanPlayBind, false);
    element.removeEventListener("canplaythrough", this._onCanPlayThroughBind, false);
    element.removeEventListener("play", this._onPlayBind, false);
    element.removeEventListener("pause", this._onPauseBind, false);
    element.removeEventListener("timeupdate", this._onTimeUpdateBind, false);
    element.removeEventListener("volumechange", this._onVolumeChangeBind, false);
    element.removeEventListener("seeked", this._onSeekedBind, false);
    element.removeEventListener("ended", this._onEndedBind, false);
    element.removeEventListener("error", this._onErrorBind, false);

    //Request specific
    element.removeEventListener("error", this._onRequestErrorBind, false);
};

/**
 * Private event handler for loadStart.
 * @method  KEN.VideoHTML5#_onLoadStartHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoHTML5.prototype._onLoadStartHandler = function(event)
{
    var element = this._getCurrentVideo().element;
    this.log("onLoadStart [readyState: "+element.readyState+"]");

    if(this._onLoadStart !== null)
    {
        this._onLoadStart.dispatch(event);
    }
};

/**
 * Private event handler for durationChange.
 * @method  KEN.VideoHTML5#_onDurationChangeHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoHTML5.prototype._onDurationChangeHandler = function(event)
{
    var element = this._getCurrentVideo().element;
    this.log("onDurationChange [readyState: "+element.readyState+"]");

    //@firefox - FF disptach durationchange twice on readystate 1 & 4
    //I will not dispatch this event if readystate is 4 !
    if(this._onDurationChange !== null && element.readyState === 1)
    {
        this._onDurationChange.dispatch(event);
    }
};

/**
 * Private event handler for loadedMetaData.
 * @method  KEN.VideoHTML5#_onLoadedMetaDataHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoHTML5.prototype._onLoadedMetaDataHandler = function(event)
{
    var element = this._getCurrentVideo().element;

    this.log("onLoadedMetaData [readyState: "+element.readyState+"]");

    this._metaDataLoaded = true;

    if(this._onLoadedMetaData !== null)
    {
        this._onLoadedMetaData.dispatch(event);
    }
};

/**
 * Private event handler for loadedData.
 * @method  KEN.VideoHTML5#_onLoadedDataHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoHTML5.prototype._onLoadedDataHandler = function(event)
{
    var element = this._getCurrentVideo().element;

    this.log("onLoadedData [readyState: "+element.readyState+"]");

    if(this._onLoadedData !== null)
    {
        this._onLoadedData.dispatch(event);
    }
};

/**
 * Private event handler for progress.
 * @method  KEN.VideoHTML5#_onProgressHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoHTML5.prototype._onProgressHandler = function(event)
{
    //var element = this._getCurrentVideo().element;
    //this.log("onProgress [readyState: "+element.readyState+"]");

    if(this._onProgress !== null)
    {
        this._onProgress.dispatch(event);
    }
};

/**
 * Private event handler for canPlay.
 * @method  KEN.VideoHTML5#_onCanPlayHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoHTML5.prototype._onCanPlayHandler = function(event)
{
    var element = this._getCurrentVideo().element;
    this.log("onCanPlay [readyState: "+element.readyState+"]");

    this._canPlay = true;

    if(this._onCanPlay !== null)
    {
        this._onCanPlay.dispatch(event);
    }
};

/**
 * Private event handler for canPlayThrough.
 * @method  KEN.VideoHTML5#_onCanPlayThroughHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoHTML5.prototype._onCanPlayThroughHandler = function(event)
{
    var element = this._getCurrentVideo().element;
    this.log("onCanPlayThrough [readyState: "+element.readyState+"]");

    this._canPlay = true;

    if(this._onCanPlayThrough !== null)
    {
        this._onCanPlayThrough.dispatch(event);
    }
};

/**
 * Private event handler for play.
 * @method  KEN.VideoHTML5#_onPlayHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoHTML5.prototype._onPlayHandler = function(event)
{
    var element = this._getCurrentVideo().element;
    this.log("onPlay [readyState: "+element.readyState+"]");

    if(this._onPlay !== null)
    {
        this._onPlay.dispatch(event);
    }
};

/**
 * Private event handler for pause.
 * @method  KEN.VideoHTML5#_onPauseHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoHTML5.prototype._onPauseHandler = function(event)
{
    var element = this._getCurrentVideo().element;
    this.log("onPause [readyState: "+element.readyState+"]");

    this._playing = false;

    if(this._onPause !== null)
    {
        this._onPause.dispatch(event);
    }
};

/**
 * Private event handler for timeUpdate.
 * @method  KEN.VideoHTML5#_onTimeUpdateHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoHTML5.prototype._onTimeUpdateHandler = function(event)
{
    //var element = this._getCurrentVideo().element;
    //this.log("onTimeUpdate [readyState: "+element.readyState+"]");

    if(this._onTimeUpdate !== null)
    {
        this._onTimeUpdate.dispatch(event);
    }
};

/**
 * Private event handler for volumeChange.
 * @method  KEN.VideoHTML5#_onVolumeChangeHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoHTML5.prototype._onVolumeChangeHandler = function(event)
{
    var element = this._getCurrentVideo().element;
    this.log("onVolumeChange [readyState: "+element.readyState+"]");

    //I do not dispatch the volume change if readyState is 0.
    //because I set the volume at 0 when I create the video element, it is not usefull to dispatch this internal volume change ?
    if(this._onVolumeChange !== null && element.readyState !== 0)
    {
        this._onVolumeChange.dispatch(event);
    }
};

/**
 * Private event handler for seeked.
 * @method  KEN.VideoHTML5#_onSeekedHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoHTML5.prototype._onSeekedHandler = function(event)
{
    var element = this._getCurrentVideo().element;
    this.log("onSeeked [readyState: "+element.readyState+"]");

    this._canPlay = false;

    if(this._onSeeked !== null)
    {
        this._onSeeked.dispatch(event);
    }
};

/**
 * Private event handler for ended.
 * @method  KEN.VideoHTML5#_onEndedHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoHTML5.prototype._onEndedHandler = function(event)
{
    var element = this._getCurrentVideo().element;
    this.log("onEnded [readyState: "+element.readyState+"]");

    this._playing = false;
    this._dom["currentTime"] = 0;
    this._endCount++;

    if(this._loop === true)
    {
        this.play(0);
    }

    if(this._onEnded !== null)
    {
        this._onEnded.dispatch(event);
    }
};

/**
 * Private event handler for error.
 * @method  KEN.VideoHTML5#_onErrorHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoHTML5.prototype._onErrorHandler = function(event)
{
    var element = this._getCurrentVideo().element;
    this.log("onError [readyState: "+element.readyState+"]");

    if(this._onError !== null)
    {
        this._onError.dispatch(event);
    }
};

/**
 * Load a config or a video url to the source.
 * @method KEN.VideoHTML5#load
 * @param {?(string|KEN.VideoQuality|Array<(string|KEN.VideoQuality)>)} config - An url to load, or an array of urls or an array ok {@link KEN.VideoQuality}.
 */
KEN.VideoHTML5.prototype.load = function(config)
{
    //parse the config in parameters
    this._parseConfig(config);

    if(this._qualities === null || this._qualities.length === 0)
    {
        throw "KEN.VideoHTML5.load: Can't create video with no qualities set!";
    }

    //Create place holders for videos
    this._createVideoObjects(this._qualities.length);

    //Request the first quality of the quality array
    this._setRequestIndex(0);
};

/**
 * Plays the video.
 * @method  KEN.VideoHTML5#play
 * @param {number=} time - Time you want to start the playback.
 * @param {boolean=} loop - Does the video have to loop at the end of the duration?
 */
KEN.VideoHTML5.prototype.play = function(time, loop)
{
    this["currentTime"] = time;
    this["loop"] = loop;

    var currentVideo = this._getCurrentVideo();

    if(currentVideo !== null && currentVideo["element"] !== null)
    {
        currentVideo["element"].play();
        this._playing = true;
        this._playCount++;
    }
};

/**
 * Pauses the video.
 * @method  KEN.VideoHTML5#pause
 */
KEN.VideoHTML5.prototype.pause = function()
{
    var currentVideo = this._getCurrentVideo();

    if(currentVideo !== null && currentVideo["element"] !== null)
    {
        currentVideo["element"].pause();
        this._playing = false;
    }
};

/**
 * Stop the video the video (pause it and set time to 0).
 * @method  KEN.VideoHTML5#stop
 */
KEN.VideoHTML5.prototype.stop = function()
{
    var currentVideo = this._getCurrentVideo();

    if(currentVideo !== null && currentVideo["element"] !== null)
    {
        currentVideo["element"].pause();
        currentVideo["element"]["currentTime"] = 0;
        this._playing = false;
    }
};

/**
 * Toggles the playback status, if play toggle to pause and vice versa.
 * @method  KEN.VideoHTML5#togglePlayback
 */
KEN.VideoHTML5.prototype.togglePlayback = function()
{
    if(this._playing === true || this._viewer["audio"]["enabled"] === false)
    {
        this.pause();
    }
    else
    {
        this.play();
    }
};

/**
 * Mute the video sound.
 * @method  KEN.VideoHTML5#mute
 */
KEN.VideoHTML5.prototype.mute = function()
{
    if(this._muted === true || this._viewer["audio"]["enabled"] === false)
    {
        return;
    }

    this._muted = true;
    this._mutedVolume = this._volume;

    this._volume = 0;
    this._updateVolume();

    if(this._onMute !== null)
    {
        this._onMute.dispatch();
    }
};

/**
 * Unute the video sound.
 * @method  KEN.VideoHTML5#unmute
 * @param {number=} volume - The volume to be restored on unmute.
 */
KEN.VideoHTML5.prototype.unmute = function(volume)
{
    if(this._muted === false)
    {
        return;
    }

    var v = (typeof volume === "number") ? volume : this._mutedVolume;

    this._muted = false;
    this._volume = KEN.Math.clamp(v, 0, 1);
    this._updateVolume();

    if(this._onUnmute !== null)
    {
        this._onUnmute.dispatch();
    }
};


/**
 * Destroy method.
 * @method KEN.VideoHTML5#destroy
 */
KEN.VideoHTML5.prototype.destroy = function()
{
    this._clearRequestedVideo();

    this._requestTimer.destroy();
    this._requestTimer = null;

    this._autoQualityTimer.destroy();
    this._autoQualityTimer = null;

    if(this._onLoadStart !== null)
    {
        this._onLoadStart.destroy();
        this._onLoadStart = null;
    }

    if(this._onLoadedMetaData !== null)
    {
        this._onLoadedMetaData.destroy();
        this._onLoadedMetaData = null;
    }

    if(this._onLoadedData !== null)
    {
        this._onLoadedData.destroy();
        this._onLoadedData = null;
    }

    if(this._onProgress !== null)
    {
        this._onProgress.destroy();
        this._onProgress = null;
    }

    if(this._onDurationChange !== null)
    {
        this._onDurationChange.destroy();
        this._onDurationChange = null;
    }

    if(this._onCanPlay !== null)
    {
        this._onCanPlay.destroy();
        this._onCanPlay = null;
    }

    if(this._onCanPlayThrough !== null)
    {
        this._onCanPlayThrough.destroy();
        this._onCanPlayThrough = null;
    }

    if(this._onPlay !== null)
    {
        this._onPlay.destroy();
        this._onPlay = null;
    }

    if(this._onPause !== null)
    {
        this._onPause.destroy();
        this._onPause = null;
    }

    if(this._onTimeUpdate !== null)
    {
        this._onTimeUpdate.destroy();
        this._onTimeUpdate = null;
    }

    if(this._onVolumeChange !== null)
    {
        this._onVolumeChange.destroy();
        this._onVolumeChange = null;
    }

    if(this._onSeeked !== null)
    {
        this._onSeeked.destroy();
        this._onSeeked = null;
    }

    if(this._onEnded !== null)
    {
        this._onEnded.destroy();
        this._onEnded = null;
    }

    if(this._onError !== null)
    {
        this._onError.destroy();
        this._onError = null;
    }

    if(this._onMute !== null)
    {
        this._onMute.destroy();
        this._onMute = null;
    }

    if(this._onUnmute !== null)
    {
        this._onUnmute.destroy();
        this._onUnmute = null;
    }

    if(this._onQualityRequest !== null)
    {
        this._onQualityRequest.destroy();
        this._onQualityRequest = null;
    }

    if(this._onQualityChange !== null)
    {
        this._onQualityChange.destroy();
        this._onQualityChange = null;
    }

    if(this._onQualityAbort !== null)
    {
        this._onQualityAbort.destroy();
        this._onQualityAbort = null;
    }

    if(this._onQualityModeChange !== null)
    {
        this._onQualityModeChange.destroy();
        this._onQualityModeChange = null;
    }

    if(this._onQualitiesLoaded !== null)
    {
        this._onQualitiesLoaded.destroy();
        this._onQualitiesLoaded = null;
    }

    //destroy all videos
    for(var i = 0, ii = this._videos.length; i < ii; i++)
    {
        this._destroyVideoAt(i);
    }

    // Nullify event listeners binded to this!
    this._onRequestErrorBind = null;
    this._onRequestLoadStartBind = null;
    this._onRequestLoadedMetaDataBind = null;
    this._onRequestLoadedDataBind = null;
    this._onRequestCanPlayBeforeSeekBind = null;
    this._onRequestSeekedBind = null;
    this._onRequestCanPlayAfterSeekBind = null;
    this._onRequestSeekedWhileSyncBind = null;

    this._onLoadStartBind = null;
    this._onLoadedMetaDataBind = null;
    this._onLoadedDataBind = null;
    this._onProgressBind = null;
    this._onDurationChangeBind = null;
    this._onCanPlayBind = null;
    this._onCanPlayThroughBind = null;
    this._onPlayBind = null;
    this._onPauseBind = null;
    this._onTimeUpdateBind = null;
    this._onVolumeChangeBind = null;
    this._onSeekedBind = null;
    this._onEndedBind = null;
    this._onErrorBind = null;

    //Unbind main volume event
    this._viewer["audio"]["onVolumeChange"].remove(this._mainVolumeChangeHandler, this);

    this._viewer["audio"]["onDisable"].remove(this._disableSoundHandler, this);

    this._config = null;

    this._qualities = null;

    this._videos = null;

    KEN.DisplayObject.prototype.destroy.call(this);
};


/**
 * Get and set the quality index of the video.
 * @name KEN.VideoHTML5#quality
 * @type {(number|KEN.VideoQuality)}
 */
KEN.VideoHTML5.prototype.quality;
Object.defineProperty(KEN.VideoHTML5.prototype, "quality",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._qualities[this._currentIndex];
    },

    /** @this {KEN.VideoHTML5} */
    set: function(value)
    {
        if(typeof value === "number" && value >= 0 && value < this._qualities.length)
        {
            this._setQualityMode(KEN.VideoQualityMode.MANUAL);
            this._setRequestIndex(value);
        }
        else if(KEN.Utils.isTypeOf(value, "VideoQuality") === true)
        {
            var i = this._indexOfQuality(value);

            if(i !== -1)
            {
                this._setQualityMode(KEN.VideoQualityMode.MANUAL);
                this._setRequestIndex(i);
            }
            else
            {
                throw "Unknown quality";
            }
        }
        else
        {
            throw "Video quality "+value+" out of bounds";
        }
    }
});

/**
 * Get and set the quality mode.<br>
 * Available quality mode are listed in KEN.VideoQualityMode const.
 * @name  KEN.VideoHTML5#qualityMode
 * @type {string}
 */
KEN.VideoHTML5.prototype.qualityMode;
Object.defineProperty(KEN.VideoHTML5.prototype, "qualityMode",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._qualityMode;
    },

    /** @this {KEN.VideoHTML5} */
    set: function(value)
    {
        if(value === KEN.VideoQualityMode.AUTO || value === KEN.VideoQualityMode.MANUAL)
        {
            this._setQualityMode(value);
        }
    }
});

/**
 * Get the quality array.
 * @name  KEN.VideoHTML5#qualities
 * @readonly
 * @type {Array<KEN.VideoQuality>}
 */
KEN.VideoHTML5.prototype.qualities;
Object.defineProperty(KEN.VideoHTML5.prototype, "qualities",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._qualities;
    }
});

/**
 * Get the requested quality index, returns -1 if no request is being processed.
 * @name  KEN.VideoHTML5#requestIndex
 * @readonly
 * @type {number}
 */
KEN.VideoHTML5.prototype.requestIndex;
Object.defineProperty(KEN.VideoHTML5.prototype, "requestIndex",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._requestIndex;
    }
});

/**
 * Get the current quality index, returns -1 if no current is playing.
 * @name  KEN.VideoHTML5#currentIndex
 * @readonly
 * @type {number}
 */
KEN.VideoHTML5.prototype.currentIndex;
Object.defineProperty(KEN.VideoHTML5.prototype, "currentIndex",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._currentIndex;
    }
});

/**
 * Get the video object array.
 * @name  KEN.VideoHTML5#videos
 * @readonly
 * @type {Array<Object>}
 */
KEN.VideoHTML5.prototype.videos;
Object.defineProperty(KEN.VideoHTML5.prototype, "videos",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._videos;
    }
});

/**
 * Get the html element of the current video.
 * @name KEN.VideoHTML5#element
 * @readonly
 * @type {?HTMLVideoElement}
 */
KEN.VideoHTML5.prototype.element;
Object.defineProperty(KEN.VideoHTML5.prototype, "element",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        var currentVideo = this._getCurrentVideo();

        if(currentVideo !== null && currentVideo["element"] !== null)
        {
            return currentVideo["element"];
        }

        return null;
    }
});

/**
 * Get the {@link KEN.VideoTimeRanges} of the video for buffered ranges.
 * @name KEN.VideoHTML5#buffer
 * @readonly
 * @type {?KEN.VideoTimeRanges}
 */
KEN.VideoHTML5.prototype.buffer;
Object.defineProperty(KEN.VideoHTML5.prototype, "buffer",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        var currentVideo = this._getCurrentVideo();

        if(currentVideo !== null && currentVideo["buffer"] !== null)
        {
            return currentVideo["buffer"];
        }

        return null;
    }
});

/**
 * Get the {@link KEN.VideoTimeRanges} of the video for played ranges.
 * @name KEN.VideoHTML5#played
 * @readonly
 * @type {?KEN.VideoTimeRanges}
 */
KEN.VideoHTML5.prototype.played;
Object.defineProperty(KEN.VideoHTML5.prototype, "played",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        var currentVideo = this._getCurrentVideo();

        if(currentVideo !== null && currentVideo["played"] !== null)
        {
            return currentVideo["played"];
        }

        return null;
    }
});

/**
 * Get the original width of the video source.
 * @name KEN.VideoHTML5#originalWidth
 * @readonly
 * @type {number}
 */
KEN.VideoHTML5.prototype.originalWidth;
Object.defineProperty(KEN.VideoHTML5.prototype, "originalWidth",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._getCurrentVideoElementProperty("videoWidth", 0);
    }
});

/**
 * Get the original height of the video source.
 * @name KEN.VideoHTML5#originalHeight
 * @readonly
 * @type {number}
 */
KEN.VideoHTML5.prototype.originalHeight;
Object.defineProperty(KEN.VideoHTML5.prototype, "originalHeight",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._getCurrentVideoElementProperty("videoHeight", 0);
    }
});

/**
 * Get and set the currentTime  of the video.
 * @name KEN.VideoHTML5#currentTime
 * @type {number}
 */
KEN.VideoHTML5.prototype.currentTime;
Object.defineProperty(KEN.VideoHTML5.prototype, "currentTime",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._getCurrentVideoElementProperty("currentTime", 0);
    },

    /** @this {KEN.VideoHTML5} */
    set: function(value)
    {
        if(typeof value === "number") // && value < this["duration"]) //@todo see if we can put video currentTime in pending if no metadata received ?
        {
            var currentVideo = this._getCurrentVideo();

            if(currentVideo !== null && currentVideo["element"] !== null)
            {
                currentVideo["element"]["currentTime"] = value;
            }
        }
    }
});

/**
 * Get and set the currentTime  of the video in milliseconds.
 * @name KEN.VideoHTML5#currentTimeMS
 * @type {number}
 */
KEN.VideoHTML5.prototype.currentTimeMS;
Object.defineProperty(KEN.VideoHTML5.prototype, "currentTimeMS",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this["currentTime"] * 1000;
    },

    /** @this {KEN.VideoHTML5} */
    set: function(value)
    {
        this["currentTime"] = value / 1000;
    }
});

/**
 * Get the remainingTime of the video.
 * @name KEN.VideoHTML5#remainingTime
 * @type {number}
 */
KEN.VideoHTML5.prototype.remainingTime;
Object.defineProperty(KEN.VideoHTML5.prototype, "remainingTime",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this["duration"] - this["currentTime"];
    }
});

/**
 * Get the duration of the video in seconds.
 * @name KEN.VideoHTML5#duration
 * @readonly
 * @type {number}
 */
KEN.VideoHTML5.prototype.duration;
Object.defineProperty(KEN.VideoHTML5.prototype, "duration",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._getCurrentVideoElementProperty("duration", 0);
    }
});

/**
 * Get the duration of the video in milli seconds.
 * @name KEN.VideoHTML5#durationMS
 * @readonly
 * @type {number}
 */
KEN.VideoHTML5.prototype.durationMS;
Object.defineProperty(KEN.VideoHTML5.prototype, "durationMS",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return Math.round(this["duration"] * 1000);
    }
});

/**
 * Get the playing status of the video.
 * @name KEN.VideoHTML5#playing
 * @readonly
 * @type {boolean}
 */
KEN.VideoHTML5.prototype.playing;
Object.defineProperty(KEN.VideoHTML5.prototype, "playing",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._playing;
    }
});

/**
 * Get the number of play action of the video.
 * @name KEN.VideoHTML5#playCount
 * @readonly
 * @type {boolean}
 */
KEN.VideoHTML5.prototype.playCount;
Object.defineProperty(KEN.VideoHTML5.prototype, "playCount",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._playCount;
    }
});

/**
 * Get the canPlay status of the video.
 * @name KEN.VideoHTML5#canPlay
 * @readonly
 * @type {boolean}
 */
KEN.VideoHTML5.prototype.canPlay;
Object.defineProperty(KEN.VideoHTML5.prototype, "canPlay",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._canPlay;
    }
});

/**
 * Get the number of the video ends.
 * @name KEN.VideoHTML5#endCount
 * @readonly
 * @type {boolean}
 */
KEN.VideoHTML5.prototype.endCount;
Object.defineProperty(KEN.VideoHTML5.prototype, "endCount",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._endCount;
    }
});

/**
 * Get the metaDataLoaded status of the video.
 * @name KEN.VideoHTML5#metaDataLoaded
 * @readonly
 * @type {boolean}
 */
KEN.VideoHTML5.prototype.metaDataLoaded;
Object.defineProperty(KEN.VideoHTML5.prototype, "metaDataLoaded",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._metaDataLoaded;
    }
});

/**
 * Get and set the loop status of the video.
 * @name KEN.VideoHTML5#loop
 * @type {boolean}
 */
KEN.VideoHTML5.prototype.loop;
Object.defineProperty(KEN.VideoHTML5.prototype, "loop",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._loop;
    },

    /** @this {KEN.VideoHTML5} */
    set: function(value)
    {
        if(typeof value === "boolean")
        {
            this._loop = value;
        }
    }
});

/**
 * Get and set the volume of the video.
 * Set a volume unmute the video
 * @name KEN.VideoHTML5#volume
 * @type {number}
 */
KEN.VideoHTML5.prototype.volume;
Object.defineProperty(KEN.VideoHTML5.prototype, "volume",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._volume;
    },

    /** @this {KEN.VideoHTML5} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._volume = KEN.Math.clamp(value, 0, 1);
            this._muted = false;
            this._updateVolume();
        }
    }
});

/**
 * Get and set the muet status of the video.
 * @name KEN.VideoHTML5#muted
 * @type {boolean}
 */
KEN.VideoHTML5.prototype.muted;
Object.defineProperty(KEN.VideoHTML5.prototype, "muted",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        return this._muted;
    },

    /** @this {KEN.VideoHTML5} */
    set: function(value)
    {
        if(Boolean(value) === true)
        {
            this.mute();
        }
        else
        {
            this.unmute();
        }
    }
});

/**
 * Get the "onLoadStart" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onLoadStart
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onLoadStart;
Object.defineProperty(KEN.VideoHTML5.prototype, "onLoadStart",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onLoadStart === null)
        {
            this._onLoadStart = new KEN.EventDispatcher(this);
        }

        return this._onLoadStart;
    }
});

/**
 * Get the "onLoadedMetaData" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onLoadedMetaData
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onLoadedMetaData;
Object.defineProperty(KEN.VideoHTML5.prototype, "onLoadedMetaData",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onLoadedMetaData === null)
        {
            this._onLoadedMetaData = new KEN.EventDispatcher(this);
        }

        return this._onLoadedMetaData;
    }
});

/**
 * Get the "onLoadedData" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onLoadedData
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onLoadedData;
Object.defineProperty(KEN.VideoHTML5.prototype, "onLoadedData",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onLoadedData === null)
        {
            this._onLoadedData = new KEN.EventDispatcher(this);
        }

        return this._onLoadedData;
    }
});

/**
 * Get the "onProgress" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onProgress
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onProgress;
Object.defineProperty(KEN.VideoHTML5.prototype, "onProgress",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onProgress === null)
        {
            this._onProgress = new KEN.EventDispatcher(this);
        }

        return this._onProgress;
    }
});

/**
 * Get the "onDurationChange" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onDurationChange
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onDurationChange;
Object.defineProperty(KEN.VideoHTML5.prototype, "onDurationChange",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onDurationChange === null)
        {
            this._onDurationChange = new KEN.EventDispatcher(this);
        }

        return this._onDurationChange;
    }
});

/**
 * Get the "onCanPlay" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onCanPlay
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onCanPlay;
Object.defineProperty(KEN.VideoHTML5.prototype, "onCanPlay",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onCanPlay === null)
        {
            this._onCanPlay = new KEN.EventDispatcher(this);
        }

        return this._onCanPlay;
    }
});

/**
 * Get the "onCanPlayThrough" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onCanPlayThrough
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onCanPlayThrough;
Object.defineProperty(KEN.VideoHTML5.prototype, "onCanPlayThrough",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onCanPlayThrough === null)
        {
            this._onCanPlayThrough = new KEN.EventDispatcher(this);
        }

        return this._onCanPlayThrough;
    }
});

/**
 * Get the "onPlay" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onPlay
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onPlay;
Object.defineProperty(KEN.VideoHTML5.prototype, "onPlay",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onPlay === null)
        {
            this._onPlay = new KEN.EventDispatcher(this);
        }

        return this._onPlay;
    }
});

/**
 * Get the "onPause" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onPause
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onPause;
Object.defineProperty(KEN.VideoHTML5.prototype, "onPause",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onPause === null)
        {
            this._onPause = new KEN.EventDispatcher(this);
        }

        return this._onPause;
    }
});

/**
 * Get the "onTimeUpdate" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onTimeUpdate
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onTimeUpdate;
Object.defineProperty(KEN.VideoHTML5.prototype, "onTimeUpdate",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onTimeUpdate === null)
        {
            this._onTimeUpdate = new KEN.EventDispatcher(this);
        }

        return this._onTimeUpdate;
    }
});

/**
 * Get the "onVolumeChange" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onVolumeChange
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onVolumeChange;
Object.defineProperty(KEN.VideoHTML5.prototype, "onVolumeChange",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onVolumeChange === null)
        {
            this._onVolumeChange = new KEN.EventDispatcher(this);
        }

        return this._onVolumeChange;
    }
});

/**
 * Get the "onSeeked" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onSeeked
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onSeeked;
Object.defineProperty(KEN.VideoHTML5.prototype, "onSeeked",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onSeeked === null)
        {
            this._onSeeked = new KEN.EventDispatcher(this);
        }

        return this._onSeeked;
    }
});

/**
 * Get the "onEnded" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onEnded
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onEnded;
Object.defineProperty(KEN.VideoHTML5.prototype, "onEnded",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onEnded === null)
        {
            this._onEnded = new KEN.EventDispatcher(this);
        }

        return this._onEnded;
    }
});

/**
 * Get the "onError" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onError
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onError;
Object.defineProperty(KEN.VideoHTML5.prototype, "onError",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onError === null)
        {
            this._onError = new KEN.EventDispatcher(this);
        }

        return this._onError;
    }
});

/**
 * Get the "onMute" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onMute
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onMute;
Object.defineProperty(KEN.VideoHTML5.prototype, "onMute",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onMute === null)
        {
            this._onMute = new KEN.EventDispatcher(this);
        }

        return this._onMute;
    }
});

/**
 * Get the "onUnmute" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onUnmute
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onUnmute;
Object.defineProperty(KEN.VideoHTML5.prototype, "onUnmute",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onUnmute === null)
        {
            this._onUnmute = new KEN.EventDispatcher(this);
        }

        return this._onUnmute;
    }
});

/**
 * Get the "onQualityRequest" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onQualityRequest
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onQualityRequest;
Object.defineProperty(KEN.VideoHTML5.prototype, "onQualityRequest",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onQualityRequest === null)
        {
            this._onQualityRequest = new KEN.EventDispatcher(this);
        }

        return this._onQualityRequest;
    }
});

/**
 * Get the "onQualityChange" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onQualityChange
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onQualityChange;
Object.defineProperty(KEN.VideoHTML5.prototype, "onQualityChange",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onQualityChange === null)
        {
            this._onQualityChange = new KEN.EventDispatcher(this);
        }

        return this._onQualityChange;
    }
});

/**
 * Get the "onQualityAbort" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onQualityAbort
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onQualityAbort;
Object.defineProperty(KEN.VideoHTML5.prototype, "onQualityAbort",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onQualityAbort === null)
        {
            this._onQualityAbort = new KEN.EventDispatcher(this);
        }

        return this._onQualityAbort;
    }
});

/**
 * Get the "onQualityModeChange" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onQualityModeChange
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onQualityModeChange;
Object.defineProperty(KEN.VideoHTML5.prototype, "onQualityModeChange",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onQualityModeChange === null)
        {
            this._onQualityModeChange = new KEN.EventDispatcher(this);
        }

        return this._onQualityModeChange;
    }
});

/**
 * Get the "onQualitiesLoaded" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoHTML5#onQualitiesLoaded
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoHTML5.prototype.onQualitiesLoaded;
Object.defineProperty(KEN.VideoHTML5.prototype, "onQualitiesLoaded",
{
    /** @this {KEN.VideoHTML5} */
    get: function()
    {
        if(this._onQualitiesLoaded === null)
        {
            this._onQualitiesLoaded = new KEN.EventDispatcher(this, true);
        }

        return this._onQualitiesLoaded;
    }
});


/**
 * MPEG-DASH video controller.
 *
 * @constructor KEN.VideoDash
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @param {string} key - The video file id reference.
 * @param {?(string|KEN.VideoQuality|Array<(string|KEN.VideoQuality)>)=} config - Either a {@link KEN.VideoQuality} or a string URL.
 * @param {string=} qualityMode - The default quality mode.
 * @extends {KEN.DisplayObject}
 *
 * @todo  ability to call the QualityAbort event.
 * @todo  add protection controller and protection key controller to be able to manage external secured streams as WideVine etc...
 */
KEN.VideoDash = function(viewer, key, config, qualityMode)
{
    /**
     * The viewer reference.
     * @name KEN.VideoDash#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The video identifier.
     * @name KEN.VideoDash#_key
     * @type {string}
     * @private
     */
    this._key = key;

    /**
     * {@link KEN.VideoQuality} for this video, it can be temporarily a string into the constructor.
     * @name KEN.VideoDash#_config
     * @type {?(string|KEN.VideoQuality|Array<(string|KEN.VideoQuality)>)}
     * @private
     */
    this._config = config || null;

    /**
     * The manifest URL.
     * @name KEN.VideoDash#_manifestUrl
     * @type {string}
     * @private
     */
    this._manifestUrl = "";

    /**
     * Array of {@link KEN.VideoQuality}.
     * @name  KEN.VideoDash#_qualities
     * @type {Array<KEN.VideoQuality>}
     * @private
     */
    this._qualities = null;

    /**
     * The index of the current quality (if -1 no video is selected as the current one).
     * @name  KEN.Video#_currentQuality
     * @type {number}
     * @private
     */
    // this._currentQuality = -1;

    /**
     * First quality is initialized?
     * @name  KEN.VideoDash#_qualityInitialized
     * @type {boolean}
     * @private
     */
    // this._qualityInitialized = false;

    /**
     * Default quality mode, it can be either "auto" or "manual", modes are listed by KEN.VideoQualityMode constants.
     * @name KEN.VideoDash#_defaultQualityMode
     * @type {string}
     * @private
     */
    this._defaultQualityMode = qualityMode || KEN.VideoQualityMode.AUTO;

    /**
     * Current Quality mode.
     * @name  KEN.VideoDash#_qualityMode
     * @type {string}
     * @private
     */
    this._qualityMode = "";

    /**
     * Video object that handle the dom and some stats about the video.
     * @name KEN.VideoDash#_video
     * @type {Object}
     * @private
     */
    this._video = null;

    /**
     * Does the video loop?
     * @name  KEN.VideoDash#_loop
     * @type {boolean}
     * @private
     */
    this._loop = false;

    /**
     * The volume of the video.
     * @name  KEN.VideoDash#_volume
     * @type {number}
     * @private
     */
    this._volume = 1;

    /**
     * Is the video volume is muted?
     * @name  KEN.VideoDash#_muted
     * @type {boolean}
     * @private
     */
    this._muted = false;

    /**
     * Private reference to the previous volume before mute.
     * @name  KEN.VideoDash#_mutedVolume
     * @type {number}
     * @private
     */
    this._mutedVolume = 0;

     /**
     * Does the video have received its metaData?
     * @name  KEN.VideoDash#_metaDataLoaded
     * @type {boolean}
     * @private
     */
    this._metaDataLoaded = false;

    /**
     * The dash.js Media Player library.<br>
     * The dash.js library must be loaded prior to the video instanciation!
     * @name  KEN.VideoDash#_dashMediaPlayer
     * @type {dashjs.MediaPlayer}
     * @private
     */
    this._dashMediaPlayer = null;

    /**
     * The dash stream info object.
     * @name  KEN.VideoDash#_streamInfo
     * @type {StreamInfo}
     * @private
     */
    this._streamInfo = null;

    /**
     * The current index for video.
     * @name KEN.VideoDash#_currentIndex
     * @type {number}
     * @private
     */
    this._currentVideoIndex = 0;

    /**
     * The current pending index for video.
     * @name KEN.VideoDash#_currentPendingIndex
     * @type {number}
     * @private
     */
    this._currentVideoPendingIndex = 0;

    /**
     * The current index for audio.
     * @name KEN.VideoDash#_currentIndex
     * @type {number}
     * @private
     */
    this._currentAudioIndex = 0;

    /**
     * The current pending index for audio.
     * @name KEN.VideoDash#_currentPendingIndex
     * @type {number}
     * @private
     */
    this._currentAudioPendingIndex = 0;

    /**
     * The dash media player video metrics object.
     * @name  KEN.VideoDash#_playerVideoMetrics
     * @type {Object}
     * @private
     */
    this._playerVideoMetrics = null;

    /**
     * The dash media player audio metrics object.
     * @name  KEN.VideoDash#_playerAudioMetrics
     * @type {Object}
     * @private
     */
    this._playerAudioMetrics = null;

    /**
     * The dash stream metrics object.
     * @name  KEN.VideoDash#_dashMetrics
     * @type {DashMetrics}
     * @private
     */
    this._dashMetrics = null;

    /**
     * The monitoring object.
     * @name  KEN.VideoDash#_monitoring
     * @type {Object}
     * @private
     */
    this._monitoring = null;

    /**
     * Playing status of the video.
     * @name  KEN.VideoDash#_playing
     * @type {boolean}
     * @private
     */
    this._playing = false;

    /**
     * Boolean flag to know if can play is already received.
     * @name KEN.VideoDash#_canPlay
     * @type {boolean}
     * @private
     */
    this._canPlay = false;

    /**
     * Number of play action on this video.
     * @name  KEN.VideoDash#_playCount
     * @type {number}
     * @private
     */
    this._playCount = 0;

    /**
     * Number of the video ended.
     * @name  KEN.VideoDash#_endCount
     * @type {number}
     * @private
     */
    this._endCount = 0;

    /**
     * On load start event dispatcher.
     * @name  KEN.VideoDash#_onLoadStart
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onLoadStart = null;

    /**
     * On loaded metadata event dispatcher.
     * @name  KEN.VideoDash#_onLoadedMetaData
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onLoadedMetaData = null;

    /**
     * On loaded data event dispatcher.
     * @name  KEN.VideoDash#_onLoadedData
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onLoadedData = null;

    /**
     * On progress event dispatcher.
     * @name  KEN.VideoDash#_onProgress
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onProgress = null;

    /**
     * On duration change event dispatcher.
     * @name  KEN.VideoDash#_onDurationChange
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onDurationChange = null;

    /**
     * On can play event dispatcher.
     * @name  KEN.VideoDash#_onCanPlay
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onCanPlay = null;

    /**
     * On can play through event dispatcher.
     * @name  KEN.VideoDash#_onCanPlayThrough
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onCanPlayThrough = null;

    /**
     * On play event dispatcher.
     * @name  KEN.VideoDash#_onPlay
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPlay = null;

    /**
     * On pause event dispatcher.
     * @name  KEN.VideoDash#_onPause
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * On time update event dispatcher.
     * @name  KEN.VideoDash#_onTimeUpdate
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onTimeUpdate = null;

    /**
     * On volume change event dispatcher.
     * @name  KEN.VideoDash#_onVolumeChange
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onVolumeChange = null;

    /**
     * On seeked event dispatcher.
     * @name  KEN.VideoDash#_onSeeked
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onSeeked = null;

    /**
     * On ended event dispatcher.
     * @name  KEN.VideoDash#_onEnded
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onEnded = null;

    /**
     * On error event dispatcher.
     * @name  KEN.VideoDash#_onError
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onError = null;

    /**
     * On mute event dispatcher.
     * @name  KEN.VideoDash#_onMute
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onMute = null;

    /**
     * On unmute event dispatcher.
     * @name  KEN.VideoDash#_onUnmute
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onUnmute = null;

    /**
     * On qualityRequest event dispatcher.
     * @name  KEN.VideoDash#_onQualityRequest
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onQualityRequest = null;

    /**
     * On qualityChange event dispatcher.
     * @name  KEN.VideoDash#_onQualityChange
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onQualityChange = null;

    /**
     * On qualityAbort event dispatcher.
     * @name  KEN.VideoDash#_onQualityAbort
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onQualityAbort = null;

    /**
     * On qualties loaded event dispatcher.
     * @name  KEN.VideoDash#_onQualitiesLoaded
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onQualitiesLoaded = null;

    /**
     * On qualityModeChange event dispatcher.
     * @name  KEN.VideoDash#_onQualityModeChange
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onQualityModeChange = null;

    /**
     * On metrics changed event dispatcher.
     * @name  KEN.VideoDash#_onMetricsChanged
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onMetricsChanged = null;

    /**
     * Event handler for current video load start binded to this.
     * @name KEN.VideoDash#_onLoadStartBind
     * @type {Function}
     * @private
     */
    this._onLoadStartBind = null;

    /**
     * Event handler for current video loaded meta data binded to this.
     * @name KEN.VideoDash#_onLoadedMetaDataBind
     * @type {Function}
     * @private
     */
    this._onLoadedMetaDataBind = null;

    /**
     * Event handler for current video loaded data binded to this.
     * @name KEN.VideoDash#_onLoadedDataBind
     * @type {Function}
     * @private
     */
    this._onLoadedDataBind = null;

    /**
     * Event handler for current video progress binded to this.
     * @name KEN.VideoDash#_onProgressBind
     * @type {Function}
     * @private
     */
    this._onProgressBind = null;

    /**
     * Event handler for current video duration change binded to this.
     * @name KEN.VideoDash#_onDurationChangeBind
     * @type {Function}
     * @private
     */
    this._onDurationChangeBind = null;

    /**
     * Event handler for current video can play binded to this.
     * @name KEN.VideoDash#_onCanPlayBind
     * @type {Function}
     * @private
     */
    this._onCanPlayBind = null;

    /**
     * Event handler for current video can play throught binded to this.
     * @name KEN.VideoDash#_onCanPlayThroughBind
     * @type {Function}
     * @private
     */
    this._onCanPlayThroughBind = null;

    /**
     * Event handler for current video play binded to this.
     * @name KEN.VideoDash#_onPlayBind
     * @type {Function}
     * @private
     */
    this._onPlayBind = null;

    /**
     * Event handler for current video pause binded to this.
     * @name KEN.VideoDash#_onPauseBind
     * @type {Function}
     * @private
     */
    this._onPauseBind = null;

    /**
     * Event handler for current video time update binded to this.
     * @name KEN.VideoDash#_onTimeUpdateBind
     * @type {Function}
     * @private
     */
    this._onTimeUpdateBind = null;

    /**
     * Event handler for current video volume change binded to this.
     * @name KEN.VideoDash#_onVolumeChangeBind
     * @type {Function}
     * @private
     */
    this._onVolumeChangeBind = null;

    /**
     * Event handler for current video seeked binded to this.
     * @name KEN.VideoDash#_onSeekedBind
     * @type {Function}
     * @private
     */
    this._onSeekedBind = null;

    /**
     * Event handler for current video ended binded to this.
     * @name KEN.VideoDash#_onEndedBind
     * @type {Function}
     * @private
     */
    this._onEndedBind = null;

    /**
     * Event handler for current video error binded to this.
     * @name KEN.VideoDash#_onErrorBind
     * @type {Function}
     * @private
     */
    this._onErrorBind = null;

    /**
     * Event handler for current video quality request binded to this.
     * @name  KEN.VideoDash#_onQualityRequestBind
     * @type {Function}
     * @private
     */
    this._onQualityRequestBind = null;

    /**
     * Event handler for current video quality change binded to this.
     * @name  KEN.VideoDash#_onQualityChangeBind
     * @type {Function}
     * @private
     */
    this._onQualityChangeBind = null;

    /**
     * Event handler for current video quality change aborted binded to this.
     * @name  KEN.VideoDash#_onQualityAbortBind
     * @type {Function}
     * @private
     */
    //this._onQualityAbortBind = null;

    /**
     * Event handler for stream switch completed.
     * @name  KEN.VideoDash#_onSwitchCompletedBind
     * @type {Function}
     * @private
     */
    this._onSwitchCompletedBind = null;

    /**
     * Event handler for metrics changed.
     * @name  KEN.VideoDash#_onMetricsChangedBind
     * @type {Function}
     * @private
     */
    this._onMetricsChangedBind = null;

    KEN.DisplayObject.call(this, viewer, null, "VideoDash");
};

KEN.VideoDash.prototype = Object.create(KEN.DisplayObject.prototype);
KEN.VideoDash.prototype.constructor = KEN.VideoDash;

/**
 * Media types list.
 * @name KEN.VideoDash.mediaType
 * @type {Object}
 * @const
 */
KEN.VideoDash.mediaType = {};

/**
 * @name KEN.VideoDash.mediaType.VIDEO
 * @type {string}
 * @const
 */
KEN.VideoDash.mediaType.VIDEO = "video";

/**
 * @name KEN.VideoDash.mediaType.AUDIO
 * @type {string}
 * @const
 */
KEN.VideoDash.mediaType.AUDIO = "audio";

/**
 * Boot sequence.
 * @method KEN.VideoDash#_boot
 * @private
 */
KEN.VideoDash.prototype._boot = function()
{
    KEN.DisplayObject.prototype._boot.call(this);

    if (typeof dashjs === "undefined")
    {
        throw "KEN.VideoDash._boot: Can't create MPEG-DASH video stream without dash.js Media Player.";
    }

    //register the uid
    this._uid = this._key;
    this._register();

    this._onLoadStartBind = this._onLoadStartHandler.bind(this);
    this._onDurationChangeBind = this._onDurationChangeHandler.bind(this);
    this._onLoadedMetaDataBind = this._onLoadedMetaDataHandler.bind(this);
    this._onLoadedDataBind = this._onLoadedDataHandler.bind(this);
    this._onProgressBind = this._onProgressHandler.bind(this);
    this._onCanPlayBind = this._onCanPlayHandler.bind(this);
    this._onCanPlayThroughBind = this._onCanPlayThroughHandler.bind(this);
    this._onPlayBind = this._onPlayHandler.bind(this);
    this._onPauseBind = this._onPauseHandler.bind(this);
    this._onTimeUpdateBind = this._onTimeUpdateHandler.bind(this);
    this._onVolumeChangeBind = this._onVolumeChangeHandler.bind(this);
    this._onSeekedBind = this._onSeekedHandler.bind(this);
    this._onEndedBind = this._onEndedHandler.bind(this);
    this._onErrorBind = this._onErrorHandler.bind(this);
    this._onQualityRequestBind = this._onQualityRequestHandler.bind(this);
    this._onQualityChangeBind = this._onQualityChangeHandler.bind(this);
    //this._onQualityAbortBind = this._onQualityAbortHandler.bind(this);

    // DASH specific
    this._onSwitchCompletedBind = this._onSwitchCompletedHandler.bind(this);
    this._onMetricsChangedBind = this._onMetricsChangedHandler.bind(this);

    //Listen to the main volume change to adapt the video volume accordingly.
    this._viewer["audio"]["onVolumeChange"].add(this._mainVolumeChangeHandler, this);

    //Listen to the enabled state of the sound manager.
    this._viewer["audio"]["onDisable"].add(this._disableSoundHandler, this);

    //force the creation of "onQualitiesLoaded" event dispatcher and memorize it's data
    this._onQualitiesLoaded = new KEN.EventDispatcher(this, true);

    if(this._config !== null)
    {
        this.load(this._config);
    }

    this._viewer["display"].register(this);
    this._notifyReady();
    this._applyPending(false);
};

/**
 * Parse the video configuration object.
 * @method KEN.VideoDash#_parseConfig
 * @private
 * @param  {?(string|KEN.VideoQuality|Array<(string|KEN.VideoQuality)>)} config - The config object to parse.
 * @return {string} Returns the manifest url for DASH.
 */
KEN.VideoDash.prototype._parseConfig = function(config)
{
    if(config !== null)
    {
        if(KEN.Utils.isTypeOf(config, "string") === true)
        {
            config = [config];
        }
        else if(KEN.Utils.isTypeOf(config, "VideoQuality") === true)
        {
            config = [config];
        }

        if(KEN.Utils.isArrayOf(config, "string") === true)
        {
            this._manifestUrl = config[0];
        }
        else if(KEN.Utils.isArrayOf(config, "VideoQuality") === true)
        {
            this._manifestUrl = config[0]["url"];
        }
    }

    return this._manifestUrl;
};

/**
 * Notify that the dispay object has been resized.<br>
 * This method ovverrides the {@link KEN.DisplayObject} method.
 * @method  KEN.VideoDash#_notifyResize
 * @private
 * @param  {PropertyToUpdate} data - The data contains the property that have changed.
 */
KEN.VideoDash.prototype._notifyResize = function(data)
{
    var video = this._video;

    if(video !== null && video["element"] !== null)
    {
        video["element"].setAttribute("width", this["pixelWidth"]);
        video["element"].setAttribute("height", this["pixelHeight"]);
    }

    KEN.DisplayObject.prototype._notifyResize.call(this, data);
};

/**
 * Create placeholders objects for videos and theirs attributes.
 * @method KEN.VideoDash#_createVideoObject
 * @private
 * @return {Object} Returns the populated videos array.
 */
KEN.VideoDash.prototype._createVideoObject = function()
{
    var video =
    {
        index: 0,
        element: null,
        buffer: null,
        played: null
    };

    this._video = video;

    return video;
};

/**
 * Populate a video object with an element <video> and a buffer/played {@link KEN.VideoTimeRanges} managers.
 * @method  KEN.VideoDash#_createVideoTag
 * @private
 * @return {Object} Returns the populated video object.
 */
KEN.VideoDash.prototype._createVideoTag = function()
{
    //Create a video tag and get the quality
    var element = document.createElement("video");
    element.setAttribute("webkit-playsinline", "webkit-playsinline");
    element.setAttribute("width", this["pixelWidth"]);
    element.setAttribute("height", this["pixelHeight"]);
    element["volume"] = 0;
    element.crossOrigin = "anonymous";
    element["id"] = "KEN-VideoDash-" + this._uid;

    var buffer = new KEN.VideoTimeRanges(element, "buffered");
    var played = new KEN.VideoTimeRanges(element, "played");

    //Update the video object with the element and fresh buffer and played
    var video = this._video;
    video["element"] = element;
    video["buffer"] = buffer;
    video["played"] = played;
    video.lastTimeStamp = 0;

    return video;
};

/**
 * Get a property of the video element of the current video object.
 * @method  KEN.VideoDash#_getCurrentVideoElementProperty
 * @param  {string} property - The property you want to get from the current video element.
 * @param  {*} defaultReturnValue - The default return value if the video object or its element is null.
 * @return {*} Return the requested property value or the default one if necessary.
 * @private
 */
KEN.VideoDash.prototype._getCurrentVideoElementProperty = function(property, defaultReturnValue)
{
    var video = this._video;

    if(video !== null && video["element"] !== null)
    {
        return video["element"][property];
    }

    return defaultReturnValue;
};

/**
 * Create instance of the dash.js Media Player.
 * @method KEN.VideoDash#_instanciateDashMediaPlayer
 * @private
 */
KEN.VideoDash.prototype._initDashMediaPlayer = function()
{
    // create the Media Player
    this._dashMediaPlayer = dashjs.MediaPlayer().create();
    //deactivate logs
    this._dashMediaPlayer.getDebug().setLogToBrowserConsole(false);
    //init media player
    this._dashMediaPlayer.initialize();
    // playback is paused on start
    this._dashMediaPlayer.setAutoPlay(false);
    // add video tag element and video source file
    this._dashMediaPlayer.attachView(this._video["element"]);
    this._dashMediaPlayer.attachSource(this._manifestUrl);

    //add events if element and source are defined
    if(this._dashMediaPlayer.isReady() === true)
    {
        this._installEvents();

        this._addVideoToDom();
    }

    if(this._qualityMode === "")
    {
        this._setQualityMode(this._defaultQualityMode);
    }
};

/**
 * Add video element to the DOM.
 * @method KEN.VideoDash#_addVideoToDom
 * @private
 */
KEN.VideoDash.prototype._addVideoToDom = function()
{
    // Remove video tag from our container div
    this._dom.innerHTML = "";

    this._dom.appendChild(this._video["element"]);
};

/**
 * Bind native events handler for the current video.
 * @method KEN.VideoDash#_installEvents
 * @private
 */
KEN.VideoDash.prototype._installEvents = function()
{
    this._dashMediaPlayer.on(dashjs.MediaPlayer["events"]["CAN_PLAY"], this._onCanPlayBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer["events"]["ERROR"], this._onErrorBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer["events"]["PLAYBACK_ENDED"], this._onEndedBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer["events"]["PLAYBACK_ERROR"], this._onErrorBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer["events"]["PLAYBACK_METADATA_LOADED"], this._onLoadedMetaDataBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer["events"]["PLAYBACK_PAUSED"], this._onPauseBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer["events"]["PLAYBACK_PROGRESS"], this._onProgressBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer["events"]["PLAYBACK_SEEKED"], this._onSeekedBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer["events"]["PLAYBACK_STARTED"], this._onPlayBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer["events"]["PLAYBACK_TIME_UPDATED"], this._onTimeUpdateBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer["events"]["QUALITY_CHANGE_RENDERED"], this._onQualityChangeBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer["events"]["QUALITY_CHANGE_REQUESTED"], this._onQualityRequestBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer["events"]["STREAM_INITIALIZED"], this._onLoadStartBind);

    this._dashMediaPlayer.on(dashjs.MediaPlayer["events"]["PERIOD_SWITCH_COMPLETED"], this._onSwitchCompletedBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer["events"]["METRIC_CHANGED"], this._onMetricsChangedBind);

    this._video["element"].addEventListener("loadeddata", this._onLoadedDataBind, false);
    this._video["element"].addEventListener("durationchange", this._onDurationChangeBind, false);
    this._video["element"].addEventListener("canplaythrough", this._onCanPlayThroughBind, false);
    this._video["element"].addEventListener("volumechange", this._onVolumeChangeBind, false);
};

/**
 * Unbind events handler for video.
 * @method KEN.VideoDash#_uninstallEvents
 * @private
 */
KEN.VideoDash.prototype._uninstallEvents = function()
{
    this._dashMediaPlayer.off(dashjs.MediaPlayer["events"]["CAN_PLAY"], this._onCanPlayBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer["events"]["ERROR"], this._onErrorBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer["events"]["PLAYBACK_ENDED"], this._onEndedBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer["events"]["PLAYBACK_ERROR"], this._onErrorBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer["events"]["PLAYBACK_METADATA_LOADED"], this._onLoadedMetaDataBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer["events"]["PLAYBACK_PAUSED"], this._onPauseBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer["events"]["PLAYBACK_PROGRESS"], this._onProgressBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer["events"]["PLAYBACK_SEEKED"], this._onSeekedBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer["events"]["PLAYBACK_STARTED"], this._onPlayBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer["events"]["PLAYBACK_TIME_UPDATED"], this._onTimeUpdateBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer["events"]["QUALITY_CHANGE_RENDERED"], this._onQualityChangeBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer["events"]["QUALITY_CHANGE_REQUESTED"], this._onQualityRequestBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer["events"]["STREAM_INITIALIZED"], this._onLoadStartBind);

    this._dashMediaPlayer.off(dashjs.MediaPlayer["events"]["PERIOD_SWITCH_COMPLETED"], this._onSwitchCompletedBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer["events"]["METRIC_CHANGED"], this._onMetricsChangedBind);

    this._video["element"].removeEventListener("loadeddata", this._onLoadedDataBind, false);
    this._video["element"].removeEventListener("durationchange", this._onDurationChangeBind, false);
    this._video["element"].removeEventListener("canplaythrough", this._onCanPlayThroughBind, false);
    this._video["element"].removeEventListener("volumechange", this._onVolumeChangeBind, false);
};

/**
 * Private event handler for loadStart.
 * @method  KEN.VideoDash#_onLoadStartHandler
 * @param  {Event} event - The native video event.
 * @private
 */
KEN.VideoDash.prototype._onLoadStartHandler = function(event)
{
    var element = this._video["element"];
    this.log("onLoadStart [readyState: "+element.readyState+"]");

    //populate qualities array with the MPEG-DASH bitrates info list
    this._createQualitiesFromBitrateInfoList(this._manifestUrl, this._dashMediaPlayer.getBitrateInfoListFor(KEN.VideoDash.mediaType.VIDEO));

    if(this._onLoadStart !== null)
    {
        this._onLoadStart.dispatch(event);
    }
};

/**
 * Create a qualities array from the bitrates info list.
 * @method KEN.VideoDash#_createQualitiesFromBitrateInfoList
 * @param  {string} url - The manifest url.
 * @param  {Array<BitrateInfo>} bitrates - The bitrates array.
 * @param  {boolean=} checkURL - URL must be checked?
 * @return {Array<KEN.VideoQuality>} The qualities array.
 * @private
 */
KEN.VideoDash.prototype._createQualitiesFromBitrateInfoList = function(url, bitrates, checkURL)
{
    var qualities = [];
    var quality;

    if(bitrates !== null)
    {
        for(var i = 0, ii = bitrates.length; i < ii; i++)
        {
            if(checkURL === true && KEN.URL.isValid(url) === false)
            {
                throw "KEN.Video: URL "+url+" is invalid";
            }

            quality = new KEN.VideoQuality(url);
            quality["id"] = bitrates[i].qualityIndex;
            quality["bitrate"] = bitrates[i]["bitrate"];
            quality["width"] = bitrates[i]["width"];
            quality["height"] = bitrates[i]["height"];

            qualities.push(quality);
        }

        this._qualities = /** @type {Array<KEN.VideoQuality>} */ (qualities);

        if(this._onQualitiesLoaded !== null)
        {
            this._onQualitiesLoaded.dispatch(qualities);
        }
    }
    else
    {
        this.destroy();
    }

    return qualities;
};

/**
 * Get the index of a {@link KEN.VideoQuality} that is in the _videoQualities array.
 * @method  KEN.VideoDash#_indexOfQuality
 * @private
 * @param  {KEN.VideoQuality} quality - The quality you need to get its index.
 * @return {number} Returns the index of the quality if found, -1 if not found.
 */
KEN.VideoDash.prototype._indexOfQuality = function(quality)
{
    var q;
    for(var i = 0, ii = this._qualities.length; i < ii; i++)
    {
        q = this._qualities[i];

        if(q === quality)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Private event handler for period switch completed.
 * @method  KEN.VideoDash#_onSwitchCompletedHandler
 * @param  {SwitchEvents} event - The dash.js media player event.
 * @private
 */
KEN.VideoDash.prototype._onSwitchCompletedHandler = function(event)
{
    var element = this._video["element"];
    this.log("_onSwitchCompleted [readyState: "+element.readyState+"]");

    this._streamInfo = /** @type {StreamInfo} */ (event.toStreamInfo);
};

/**
 * Private event handler for mertics changed.
 * @method  KEN.VideoDash#_onMetricsChangedHandler
 * @param  {MetricChangedEvents} event - The dash.js media player event.
 * @private
 */
KEN.VideoDash.prototype._onMetricsChangedHandler = function(event)
{
    var element = this._video["element"];
    this.log("_onMetricsChangedHandler [readyState: "+element.readyState+"]");

    if(this._playerVideoMetrics === null)
    {
        this._playerVideoMetrics = this._dashMediaPlayer.getMetricsFor(KEN.VideoDash.mediaType.VIDEO);
    }

    if(this._playerAudioMetrics === null)
    {
        this._playerAudioMetrics = this._dashMediaPlayer.getMetricsFor(KEN.VideoDash.mediaType.AUDIO);
    }

    if(this._dashMetrics === null)
    {
        this._dashMetrics = this._dashMediaPlayer.getDashMetrics();
    }

    //set the current quality index
    // if (this._playerVideoMetrics !== null && this._dashMetrics !== null)
    // {
    //     var repSwitch = /** @type {RepresentationSwitch} */ (this._dashMetrics.getCurrentRepresentationSwitch(this._playerVideoMetrics));
    //     if (repSwitch !== null)
    //     {
    //         this._currentQuality = this._dashMetrics.getIndexForRepresentation(repSwitch.to, this._streamInfo["index"]);
    //         if(this._qualityInitialized === false)
    //         {
    //             this._setRequestQuality(this._currentQuality);
    //             this._qualityInitialized = true;
    //         }
    //     }
    // }

    if(this._onMetricsChanged !== null)
    {
        var metrics;

        if (event.mediaType === KEN.VideoDash.mediaType.VIDEO)
        {
            metrics = this._getMetricsFor(KEN.VideoDash.mediaType.VIDEO, this._playerVideoMetrics, this._dashMetrics);
            if (metrics)
            {
                this._monitoring =
                {
                    "videoBitrate": metrics["bitrate"],
                    "videoIndex": metrics["index"],
                    "videoPendingIndex": metrics.pendingIndex,
                    "videoMaxIndex": metrics.maxIndex,
                    "videoBufferLength": metrics.bufferLength,
                    "videoDroppedFrames": metrics.droppedFrames
                    //"videoRequestsQueue": metrics.requestsQueue
                };
            }
        }

        if (event.mediaType === KEN.VideoDash.mediaType.AUDIO)
        {
            metrics = this._getMetricsFor(KEN.VideoDash.mediaType.AUDIO, this._playerAudioMetrics, this._dashMetrics);
            if (metrics)
            {
                this._monitoring =
                {
                    "audioBitrate": metrics["bitrate"],
                    "audioIndex": metrics["index"],
                    "audioPendingIndex": metrics.pendingIndex,
                    "audioMaxIndex": metrics.maxIndex,
                    "audioBufferLength": metrics.bufferLength,
                    "audioDroppedFrames": metrics.droppedFrames
                    //"audioRequestsQueue": metrics.requestsQueue
                };
            }
        }

        this._onMetricsChanged.dispatch(event);
    }
};


/**
 * Prepare a metrics object for video/audio data.
 * @method  KEN.VideoDash#_getMetricsFor
 * @param {string} type - The video or audio type.
 * @param {Object} metrics - The player video or audio metrics.
 * @param {DashMetrics} dashMetrics - The dash stream video or audio metrics.
 * @return {?Object} The monitoring object
 * @private
 */
KEN.VideoDash.prototype._getMetricsFor = function(type, metrics, dashMetrics)
{
    if (metrics !== null && dashMetrics !== null)
    {
        var streamIndex = this._streamInfo["index"];
        var repSwitch, maxIndex, bufferLevel, droppedFramesMetrics, bitrate, index, pendingIndex, bufferLength, droppedFrames; //httpRequests requestsQueue pendingValue

        repSwitch = /** @type {RepresentationSwitch} */ (dashMetrics.getCurrentRepresentationSwitch(metrics));
        if (repSwitch !== null)
        {
            // index = dashMetrics.getIndexForRepresentation(repSwitch.to, streamIndex);
            bitrate = Math.round(dashMetrics.getBandwidthForRepresentation(repSwitch.to, streamIndex) / 1000);
        }
        if (isNaN(bitrate) || bitrate === undefined)
        {
            bitrate = 0;
        }

        if(type === KEN.VideoDash.mediaType.VIDEO)
        {
            index = this._currentVideoIndex + 1;
            pendingIndex = this._currentVideoPendingIndex + 1;
        }
        else if(type === KEN.VideoDash.mediaType.AUDIO)
        {
            index = this._currentAudioIndex + 1;
            pendingIndex = this._currentAudioPendingIndex + 1;
        }

        if (isNaN(index) || index === undefined)
        {
            index = 0;
        }
        if (isNaN(pendingIndex) || pendingIndex === undefined)
        {
            pendingIndex = 0;
        }

        maxIndex = dashMetrics.getMaxIndexForBufferType(type, streamIndex);
        if (isNaN(maxIndex) || maxIndex === undefined)
        {
            maxIndex = 0;
        }

        bufferLevel = dashMetrics.getCurrentBufferLevel(metrics);
        if (bufferLevel !== null)
        {
            bufferLength = bufferLevel.toPrecision(5);
        }
        if (isNaN(bufferLength) || bufferLength === undefined)
        {
            bufferLength = 0;
        }

        //httpRequests = dashMetrics.getHttpRequests(metrics);

        droppedFramesMetrics = /** @type {DroppedFrames} */ (dashMetrics.getCurrentDroppedFrames(metrics));
        if (droppedFramesMetrics !== null)
        {
            droppedFrames = droppedFramesMetrics.droppedFrames;
        }

        //pendingValue = this._dashMediaPlayer.getQualityFor(type);

        //requestsQueue = dashMetrics.getRequestsQueue(metrics);

        var result =
        {
            bitrate: bitrate,
            index: index,
            pendingIndex: pendingIndex,
            maxIndex: maxIndex,
            bufferLength: bufferLength,
            droppedFrames: droppedFrames
            //requestsQueue: requestsQueue
        };

        return result;
    }

    return null;
};

/**
 * Private event handler for quality change.
 * @method  KEN.VideoDash#_onQualityChangeHandler
 * @private
 * @param  {QualityEvents} event - The dash.js media player event.
 */
KEN.VideoDash.prototype._onQualityChangeHandler = function(event)
{
    var element = this._video["element"];
    this.log("onQualityChange [readyState: "+element.readyState+"]");

    if(event.mediaType === KEN.VideoDash.mediaType.AUDIO)
    {
        this._currentAudioIndex = event.newQuality;
        this._currentAudioPendingIndex = event.newQuality;
    }
    else if(event.mediaType === KEN.VideoDash.mediaType.VIDEO)
    {
        this._currentVideoIndex = event.newQuality;
        this._currentVideoPendingIndex = event.newQuality;

        if(this._onQualityChange !== null)
        {
            this._onQualityChange.dispatch(this._currentVideoPendingIndex);
        }
    }
};

/**
 * Private event handler for quality request.
 * @method  KEN.VideoDash#_onQualityRequestHandler
 * @private
 * @param  {QualityEvents} event - The dash.js media player event.
 */
KEN.VideoDash.prototype._onQualityRequestHandler = function(event)
{
    var element = this._video["element"];
    this.log("onQualityRequest [readyState: "+element.readyState+"]");

    if(event.mediaType === KEN.VideoDash.mediaType.AUDIO)
    {
        this._currentAudioIndex = event.oldQuality;
        this._currentAudioPendingIndex = event.newQuality;
    }
    else if(event.mediaType === KEN.VideoDash.mediaType.VIDEO)
    {
        this._currentVideoIndex = event.oldQuality;
        this._currentVideoPendingIndex = event.newQuality;

        if(this._onQualityRequest !== null)
        {
            this._onQualityRequest.dispatch(this._currentVideoPendingIndex);
        }
    }
};

/**
 * Private event handler for quality request aborted.
 * @method  KEN.VideoDash#_onQualityAbortHandler
 * @private
 * @param  {Event} event - The dash.js media player event.
 */
// KEN.VideoDash.prototype._onQualityAbortHandler = function(event)
// {
//     var element = this._video["element"];
//     this.log("onQualityAbort [readyState: "+element.readyState+"]");

//     if(this._onQualityAbort !== null)
//     {
//         this._onQualityAbort.dispatch(this._video["requestIndex"]);
//     }
// };

/**
 * Private event handler for durationChange.
 * @method  KEN.VideoDash#_onDurationChangeHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoDash.prototype._onDurationChangeHandler = function(event)
{
    var element = this._video["element"];
    this.log("onDurationChange [readyState: "+element.readyState+"]");

    //@firefox - FF disptach durationchange twice on readystate 1 & 4
    //I will not dispatch this event if readystate is 4 !
    if(this._onDurationChange !== null && element.readyState === 1)
    {
        this._onDurationChange.dispatch(event);
    }
};

/**
 * Private event handler for loadedMetaData.
 * @method  KEN.VideoDash#_onLoadedMetaDataHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoDash.prototype._onLoadedMetaDataHandler = function(event)
{
    var element = this._video["element"];
    this.log("onLoadedMetaData [readyState: "+element.readyState+"]");

    this._metaDataLoaded = true;

    if(this._onLoadedMetaData !== null)
    {
        this._onLoadedMetaData.dispatch(event);
    }
};

/**
 * Private event handler for loadedData.
 * @method  KEN.VideoDash#_onLoadedDataHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoDash.prototype._onLoadedDataHandler = function(event)
{
    var element = this._video["element"];
    this.log("onLoadedData [readyState: "+element.readyState+"]");

    if(this._onLoadedData !== null)
    {
        this._onLoadedData.dispatch(event);
    }
};

/**
 * Private event handler for progress.
 * @method  KEN.VideoDash#_onProgressHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoDash.prototype._onProgressHandler = function(event)
{
    //var element = this._video["element"];
    //this.log("onProgress [readyState: "+element.readyState+"]");

    if(this._onProgress !== null)
    {
        this._onProgress.dispatch(event);
    }
};

/**
 * Private event handler for canPlay.
 * @method  KEN.VideoDash#_onCanPlayHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoDash.prototype._onCanPlayHandler = function(event)
{
    var element = this._video["element"];
    this.log("onCanPlay [readyState: "+element.readyState+"]");

    this._canPlay = true;

    if(this._onCanPlay !== null)
    {
        this._onCanPlay.dispatch(event);
    }
};

/**
 * Private event handler for canPlayThrough.
 * @method  KEN.VideoDash#_onCanPlayThroughHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoDash.prototype._onCanPlayThroughHandler = function(event)
{
    var element = this._video["element"];
    this.log("onCanPlayThrough [readyState: "+element.readyState+"]");

    this._canPlay = true;

    if(this._onCanPlayThrough !== null)
    {
        this._onCanPlayThrough.dispatch(event);
    }
};

/**
 * Private event handler for play.
 * @method  KEN.VideoDash#_onPlayHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoDash.prototype._onPlayHandler = function(event)
{
    var element = this._video["element"];
    this.log("onPlay [readyState: "+element.readyState+"]");

    if(this._onPlay !== null)
    {
        this._onPlay.dispatch(event);
    }
};

/**
 * Private event handler for pause.
 * @method  KEN.VideoDash#_onPauseHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoDash.prototype._onPauseHandler = function(event)
{
    var element = this._video["element"];
    this.log("onPause [readyState: "+element.readyState+"]");

    this._playing = false;

    if(this._onPause !== null)
    {
        this._onPause.dispatch(event);
    }
};

/**
 * Private event handler for timeUpdate.
 * @method  KEN.VideoDash#_onTimeUpdateHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoDash.prototype._onTimeUpdateHandler = function(event)
{
    //var element = this._video["element"];
    //this.log("onTimeUpdate [readyState: "+element.readyState+"]");

    if(this._onTimeUpdate !== null)
    {
        this._onTimeUpdate.dispatch(event);
    }
};

/**
 * Private event handler for volumeChange.
 * @method  KEN.VideoDash#_onVolumeChangeHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoDash.prototype._onVolumeChangeHandler = function(event)
{
    var element = this._video["element"];
    this.log("onVolumeChange [readyState: "+element.readyState+"]");

    //I do not dispatch the volume change if readyState is 0.
    //because I set the volume at 0 when I create the video element, it is not usefull to dispatch this internal volume change ?
    if(this._onVolumeChange !== null && element.readyState !== 0)
    {
        this._onVolumeChange.dispatch(event);
    }
};

/**
 * Private event handler for seeked.
 * @method  KEN.VideoDash#_onSeekedHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoDash.prototype._onSeekedHandler = function(event)
{
    var element = this._video["element"];
    this.log("onSeeked [readyState: "+element.readyState+"]");

    this._canPlay = false;

    if(this._onSeeked !== null)
    {
        this._onSeeked.dispatch(event);
    }
};

/**
 * Private event handler for ended.
 * @method  KEN.VideoDash#_onEndedHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoDash.prototype._onEndedHandler = function(event)
{
    var element = this._video["element"];
    this.log("onEnded [readyState: "+element.readyState+"]");

    this._playing = false;
    //this._dom["currentTime"] = 0;
    this._endCount++;

    if(this._loop === true)
    {
        this.play();
    }

    if(this._onEnded !== null)
    {
        this._onEnded.dispatch(event);
    }
};

/**
 * Private event handler for error.
 * @method  KEN.VideoDash#_onErrorHandler
 * @private
 * @param  {Event} event - The native video event.
 */
KEN.VideoDash.prototype._onErrorHandler = function(event)
{
    var element = this._video["element"];
    this.log("onError [readyState: "+element.readyState+"]");

    if(this._onError !== null)
    {
        this._onError.dispatch(event);
    }
};

/**
 * Destroy a video object at a specified index, wiil look at the video object into _videos array then detoy it.
 * @method KEN.VideoDash#_destroyVideo
 * @private
 */
KEN.VideoDash.prototype._destroyVideo = function()
{
    this.log("_destroyVideo");

    if(this._dashMediaPlayer !== null && this._dashMediaPlayer.isReady() === true)
    {
        this._uninstallEvents();

        this._dashMediaPlayer.pause();
        this._dashMediaPlayer.reset();
    }

    var video = this._video;
    var element = video["element"];

    if(typeof element !== "undefined" && element !== null)
    {
        if(element.parentNode === this._dom)
        {
            this._dom.removeChild(element);
        }
    }

    element = null;
    video["element"] = null;

    if(video["buffer"] !== null)
    {
        video["buffer"].destroy();
        video["buffer"] = null;
    }

    if(video["played"] !== null)
    {
        video["played"].destroy();
        video["played"] = null;
    }

    video = null;
};

/**
 * Handles the disable status of the sound manager.
 * @method KEN.VideoDash#_disableSoundHandler
 * @private
 */
KEN.VideoDash.prototype._disableSoundHandler = function()
{
    var v = this._video;

    if(v !== null && v["element"] !== null && this._viewer["audio"]["enabled"] === false)
    {
        this._dashMediaPlayer.setVolume(0);
    }
};

/**
 * Handles the main volume change, update the volume factor to the video volume.
 * @method KEN.VideoDash#_mainVolumeChangeHandler
 * @private
 */
KEN.VideoDash.prototype._mainVolumeChangeHandler = function()
{
    this._updateVolume();
};

/**
 * Apply the main volume factor to the video volume.
 * @method KEN.VideoDash#_updateVolume
 * @private
 */
KEN.VideoDash.prototype._updateVolume = function()
{
    var v = this._video;

    if(v !== null && v["element"] !== null && this._viewer["audio"]["enabled"] === true)
    {
        this._dashMediaPlayer.setVolume(this._volume * this._viewer["audio"]["volume"]);
        if(this._muted === true)
        {
            this._dashMediaPlayer.setMute(true);
        }
        else
        {
            this._dashMediaPlayer.setMute(false);
        }
    }
};

/**
 * Apply the requested quality index.
 * @method KEN.VideoDash#_setRequestQuality
 * @param {number} index - The quality index.
 * @private
 */
KEN.VideoDash.prototype._setRequestQuality = function(index)
{
    this._currentVideoPendingIndex = index;

    if(this._streamInfo !== null && this._dashMediaPlayer !== null && this._dashMediaPlayer.isReady() === true && this._dashMetrics !== null)
    {
        var streamIndex = this._streamInfo["index"];
        var maxVideoIndex = this._dashMetrics.getMaxIndexForBufferType(KEN.VideoDash.mediaType.VIDEO, streamIndex);
        var maxAudioIndex = this._dashMetrics.getMaxIndexForBufferType(KEN.VideoDash.mediaType.AUDIO, streamIndex);

        var newVideoIndex = index,
        newAudioIndex = index;

        // zero based indexes
        if (newVideoIndex >= maxVideoIndex)
        {
            newVideoIndex = maxVideoIndex - 1;
        }
        if (newVideoIndex < 0)
        {
            newVideoIndex = 0;
        }
        if (newAudioIndex >= maxAudioIndex)
        {
            newAudioIndex = maxAudioIndex - 1;
        }
        if (newAudioIndex < 0)
        {
            newAudioIndex = 0;
        }

        this._dashMediaPlayer.setQualityFor(KEN.VideoDash.mediaType.VIDEO, newVideoIndex);
        this._dashMediaPlayer.setQualityFor(KEN.VideoDash.mediaType.AUDIO, newAudioIndex);
    }

    // Update the volume for the requested video
    this._updateVolume();
};

/**
 * Sets the quality mode.<br>
 * This activate or deactivate the adaptative bitrate switching for video and audio (ABR).
 * @method  KEN.VideoDash#_setQualityMode
 * @private
 * @param {string} mode - Quality mode to be set.
 */
KEN.VideoDash.prototype._setQualityMode = function(mode)
{
    if(this._qualityMode === mode)
    {
        return;
    }

    if(mode === KEN.VideoQualityMode.AUTO || mode === KEN.VideoQualityMode.MANUAL)
    {
        this._qualityMode = mode;

        if(this._dashMediaPlayer !== null && this._dashMediaPlayer.isReady() === true)
        {
            if(mode === KEN.VideoQualityMode.MANUAL)
            {
                this._dashMediaPlayer.setAutoSwitchQualityFor(KEN.VideoDash.mediaType.VIDEO, false);
                this._dashMediaPlayer.setAutoSwitchQualityFor(KEN.VideoDash.mediaType.AUDIO, false);
            }
            else
            {
                this._dashMediaPlayer.setAutoSwitchQualityFor(KEN.VideoDash.mediaType.VIDEO, true);
                this._dashMediaPlayer.setAutoSwitchQualityFor(KEN.VideoDash.mediaType.AUDIO, true);
            }
        }

        if(this._onQualityModeChange !== null)
        {
            this._onQualityModeChange.dispatch(this._qualityMode);
        }
    }
};

/**
 * Load a config or a video url to the source.
 * @method KEN.VideoDash#load
 * @param {?(string|KEN.VideoQuality|Array<(string|KEN.VideoQuality)>)} config - The {@link KEN.VideoQuality} or the url string to load.
 */
KEN.VideoDash.prototype.load = function(config)
{
    //parse the config in parameters
    this._parseConfig(config);

    if(this._manifestUrl === "")
    {
        throw "KEN.VideoDash : Can't create video with no manifest!";
    }

    //Create place holders for video and video element
    this._createVideoObject();
    this._createVideoTag();

    this._initDashMediaPlayer();
};

/**
 * Plays the video.
 * @method  KEN.VideoDash#play
 * @param {number=} time - Current video time to start playback.
 * @param {boolean=} loop - Media must be looped?
 */
KEN.VideoDash.prototype.play = function(time, loop)
{
    this["currentTime"] = time;
    this["loop"] = loop;

    if(this._dashMediaPlayer !== null && this._dashMediaPlayer.isReady() === true)
    {
        this._dashMediaPlayer.play();
        this._playing = true;
        this._playCount++;
    }
};

/**
 * Pauses the video.
 * @method  KEN.VideoDash#pause
 */
KEN.VideoDash.prototype.pause = function()
{
    if(this._dashMediaPlayer !== null && this._dashMediaPlayer.isReady() === true)
    {
        this._dashMediaPlayer.pause();
        this._playing = false;
    }
};

/**
 * Stop the video the video (pause it and set time to 0).
 * @method  KEN.VideoDash#stop
 */
KEN.VideoDash.prototype.stop = function()
{
    if(this._dashMediaPlayer !== null && this._dashMediaPlayer.isReady() === true)
    {
        this._dashMediaPlayer.pause();
        this._dashMediaPlayer.seek(0);
        this._video["element"]["currentTime"] = 0;
        this._playing = false;
    }
};

/**
 * Toggles the playback status, if play toggle to pause and vice versa.
 * @method  KEN.VideoDash#togglePlayback
 */
KEN.VideoDash.prototype.togglePlayback = function()
{
    if(this._playing === true || this._viewer["audio"]["enabled"] === false)
    {
        this.pause();
    }
    else
    {
        this.play();
    }
};

/**
 * Mute the video sound.
 * @method  KEN.VideoDash#mute
 */
KEN.VideoDash.prototype.mute = function()
{
    if(this._muted === true || this._viewer["audio"]["enabled"] === false)
    {
        return;
    }

    this._muted = true;
    this._mutedVolume = this._volume;

    this._volume = 0;
    this._updateVolume();

    if(this._onMute !== null)
    {
        this._onMute.dispatch();
    }
};

/**
 * Unmute the video sound.
 * @method  KEN.VideoDash#unmute
 * @param {number=} volume - The volume to be restored on unmute.
 */
KEN.VideoDash.prototype.unmute = function(volume)
{
    if(this._muted === false)
    {
        return;
    }

    var v = (typeof volume === "number") ? volume : this._mutedVolume;

    this._muted = false;
    this._volume = KEN.Math.clamp(v, 0, 1);
    this._updateVolume();

    if(this._onUnmute !== null)
    {
        this._onUnmute.dispatch();
    }
};

/**
 * Enable/Disable the buffer-occupancy-based (BOLA) ABR rule set.<br>
 * BOLA white paper: http://arxiv.org/abs/1601.06748.
 * @method  KEN.VideoDash#enableBufferOccupancyABR
 * @param {boolean} bool - Is the BOLA rule set is activated?
 */
KEN.VideoDash.prototype.enableBufferOccupancyABR = function(bool)
{
    if(this._dashMediaPlayer !== null && this._dashMediaPlayer.isReady() === true)
    {
        this._dashMediaPlayer.enableBufferOccupancyABR(bool);
    }
};

/**
 * Destroy method.
 * @method KEN.VideoDash#destroy
 */
KEN.VideoDash.prototype.destroy = function()
{
    this._destroyVideo();

    if(this._onLoadStart !== null)
    {
        this._onLoadStart.destroy();
        this._onLoadStart = null;
    }

    if(this._onLoadedMetaData !== null)
    {
        this._onLoadedMetaData.destroy();
        this._onLoadedMetaData = null;
    }

    if(this._onLoadedData !== null)
    {
        this._onLoadedData.destroy();
        this._onLoadedData = null;
    }

    if(this._onProgress !== null)
    {
        this._onProgress.destroy();
        this._onProgress = null;
    }

    if(this._onDurationChange !== null)
    {
        this._onDurationChange.destroy();
        this._onDurationChange = null;
    }

    if(this._onCanPlay !== null)
    {
        this._onCanPlay.destroy();
        this._onCanPlay = null;
    }

    if(this._onCanPlayThrough !== null)
    {
        this._onCanPlayThrough.destroy();
        this._onCanPlayThrough = null;
    }

    if(this._onPlay !== null)
    {
        this._onPlay.destroy();
        this._onPlay = null;
    }

    if(this._onPause !== null)
    {
        this._onPause.destroy();
        this._onPause = null;
    }

    if(this._onTimeUpdate !== null)
    {
        this._onTimeUpdate.destroy();
        this._onTimeUpdate = null;
    }

    if(this._onVolumeChange !== null)
    {
        this._onVolumeChange.destroy();
        this._onVolumeChange = null;
    }

    if(this._onSeeked !== null)
    {
        this._onSeeked.destroy();
        this._onSeeked = null;
    }

    if(this._onEnded !== null)
    {
        this._onEnded.destroy();
        this._onEnded = null;
    }

    if(this._onError !== null)
    {
        this._onError.destroy();
        this._onError = null;
    }

    if(this._onQualityRequest !== null)
    {
        this._onQualityRequest.destroy();
        this._onQualityRequest = null;
    }

    if(this._onQualityChange !== null)
    {
        this._onQualityChange.destroy();
        this._onQualityChange = null;
    }

    if(this._onQualityAbort !== null)
    {
        this._onQualityAbort.destroy();
        this._onQualityAbort = null;
    }

    if(this._onQualitiesLoaded !== null)
    {
        this._onQualitiesLoaded.destroy();
        this._onQualitiesLoaded = null;
    }

    if(this._onQualityModeChange !== null)
    {
        this._onQualityModeChange.destroy();
        this._onQualityModeChange = null;
    }

    if(this._onMetricsChanged !== null)
    {
        this._onMetricsChanged.destroy();
        this._onMetricsChanged = null;
    }

    this._onLoadStartBind = null;
    this._onLoadedMetaDataBind = null;
    this._onLoadedDataBind = null;
    this._onProgressBind = null;
    this._onDurationChangeBind = null;
    this._onCanPlayBind = null;
    this._onCanPlayThroughBind = null;
    this._onPlayBind = null;
    this._onPauseBind = null;
    this._onTimeUpdateBind = null;
    this._onVolumeChangeBind = null;
    this._onSeekedBind = null;
    this._onEndedBind = null;
    this._onErrorBind = null;
    this._onQualityRequestBind = null;
    this._onQualityChangeBind = null;
    //this._onQualityAbortBind = null;
    this._onMetricsChangedBind = null;

    //Unbind main volume event
    this._viewer["audio"]["onVolumeChange"].remove(this._mainVolumeChangeHandler, this);

    this._viewer["audio"]["onDisable"].remove(this._disableSoundHandler, this);

    this._dashMediaPlayer = null;
    this._playerVideoMetrics = null;
    this._playerAudioMetrics = null;
    this._dashMetrics = null;

    this._monitoring = null;
    this._streamInfo = null;

    this._config = null;

    this._qualities = null;

    this._video = null;

    KEN.DisplayObject.prototype.destroy.call(this);
};

/**
 * Get the monitoring object related to the video.
 * @name KEN.VideoDash#monitoring
 * @type {Object}
 */
KEN.VideoDash.prototype.monitoring;
Object.defineProperty(KEN.VideoDash.prototype, "monitoring",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._monitoring;
    }
});

/**
 * Get and set the quality index of the video.
 * @name KEN.VideoDash#quality
 * @type {(number|KEN.VideoQuality)}
 */
KEN.VideoDash.prototype.quality;
Object.defineProperty(KEN.VideoDash.prototype, "quality",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._qualities[this._currentVideoIndex];
    },

    /** @this {KEN.VideoDash} */
    set: function(value)
    {
        if(typeof value === "number" && value >= 0 && value < this._qualities.length)
        {
            this._setQualityMode(KEN.VideoQualityMode.MANUAL);
            this._setRequestQuality(value);
        }
        else if(KEN.Utils.isTypeOf(value, "VideoQuality") === true)
        {
            var i = this._indexOfQuality(value);

            if(i !== -1)
            {
                this._setQualityMode(KEN.VideoQualityMode.MANUAL);
                this._setRequestQuality(i);
            }
            else
            {
                throw "Unknown quality";
            }
        }
        else
        {
            throw "Video quality "+value+" out of bounds";
        }
    }
});

/**
 * Get and set the quality mode.<br>
 * Available quality mode are listed in KEN.VideoQualityMode const.
 * @name  KEN.VideoDash#qualityMode
 * @type {string}
 */
KEN.VideoDash.prototype.qualityMode;
Object.defineProperty(KEN.VideoDash.prototype, "qualityMode",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._qualityMode;
    },

    /** @this {KEN.VideoDash} */
    set: function(value)
    {
        if(value === KEN.VideoQualityMode.AUTO || value === KEN.VideoQualityMode.MANUAL)
        {
            this._setQualityMode(value);
        }
    }
});

/**
 * Get the quality array.
 * @name  KEN.VideoDash#qualities
 * @readonly
 * @type {Array<KEN.VideoQuality>}
 */
KEN.VideoDash.prototype.qualities;
Object.defineProperty(KEN.VideoDash.prototype, "qualities",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._qualities;
    }
});

/**
 * Get the requested quality index, returns -1 if no request is being processed.
 * @name  KEN.VideoDash#requestIndex
 * @readonly
 * @type {number}
 */
KEN.VideoDash.prototype.requestIndex;
Object.defineProperty(KEN.VideoDash.prototype, "requestIndex",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._currentVideoPendingIndex;
    }
});

/**
 * Get the current quality index, returns -1 if no current is playing.
 * @name  KEN.VideoDash#currentIndex
 * @readonly
 * @type {number}
 */
KEN.VideoDash.prototype.currentIndex;
Object.defineProperty(KEN.VideoDash.prototype, "currentIndex",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._currentVideoIndex;
    }
});

/**
 * Get the video object array.
 * @name  KEN.VideoDash#video
 * @readonly
 * @type {Object}
 */
KEN.VideoDash.prototype.video;
Object.defineProperty(KEN.VideoDash.prototype, "video",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._video;
    }
});

/**
 * Get the html element of the current video.
 * @name KEN.VideoDash#element
 * @readonly
 * @type {?HTMLVideoElement}
 */
KEN.VideoDash.prototype.element;
Object.defineProperty(KEN.VideoDash.prototype, "element",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        var video = this._video;

        if(video !== null && video["element"] !== null)
        {
            return video["element"];
        }

        return null;
    }
});

/**
 * Get the {@link KEN.VideoTimeRanges} of the video for buffered ranges.
 * @name KEN.VideoDash#buffer
 * @readonly
 * @type {?KEN.VideoTimeRanges}
 */
KEN.VideoDash.prototype.buffer;
Object.defineProperty(KEN.VideoDash.prototype, "buffer",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        var video = this._video;

        if(video !== null && video["buffer"] !== null)
        {
            return video["buffer"];
        }

        return null;
    }
});

/**
 * Get the {@link KEN.VideoTimeRanges} of the video for played ranges.
 * @name KEN.VideoDash#played
 * @readonly
 * @type {?KEN.VideoTimeRanges}
 */
KEN.VideoDash.prototype.played;
Object.defineProperty(KEN.VideoDash.prototype, "played",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        var video = this._video;

        if(video !== null && video["played"] !== null)
        {
            return video["played"];
        }

        return null;
    }
});

/**
 * Get the original width of the video source.
 * @name KEN.VideoDash#originalWidth
 * @readonly
 * @type {number}
 */
KEN.VideoDash.prototype.originalWidth;
Object.defineProperty(KEN.VideoDash.prototype, "originalWidth",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._getCurrentVideoElementProperty("videoWidth", 0);
    }
});

/**
 * Get the original height of the video source.
 * @name KEN.VideoDash#originalHeight
 * @readonly
 * @type {number}
 */
KEN.VideoDash.prototype.originalHeight;
Object.defineProperty(KEN.VideoDash.prototype, "originalHeight",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._getCurrentVideoElementProperty("videoHeight", 0);
    }
});

/**
 * Get and set the currentTime  of the video.
 * @name KEN.VideoDash#currentTime
 * @type {number}
 */
KEN.VideoDash.prototype.currentTime;
Object.defineProperty(KEN.VideoDash.prototype, "currentTime",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._dashMediaPlayer.time();
    },

    /** @this {KEN.VideoDash} */
    set: function(value)
    {
        if(typeof value === "number") // && value < this["duration"]) //@todo see if we can put video currentTime in pending if no metadata received ?
        {
            this._dashMediaPlayer.seek(value);
        }
    }
});

/**
 * Get and set the currentTime  of the video in milliseconds.
 * @name KEN.VideoDash#currentTimeMS
 * @type {number}
 */
KEN.VideoDash.prototype.currentTimeMS;
Object.defineProperty(KEN.VideoDash.prototype, "currentTimeMS",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this["currentTime"] * 1000;
    },

    /** @this {KEN.VideoDash} */
    set: function(value)
    {
        this["currentTime"] = value / 1000;
    }
});

/**
 * Get the remainingTime of the video.
 * @name KEN.VideoDash#remainingTime
 * @type {number}
 */
KEN.VideoDash.prototype.remainingTime;
Object.defineProperty(KEN.VideoDash.prototype, "remainingTime",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this["duration"] - this["currentTime"];
    }
});

/**
 * Get the duration of the video in seconds.
 * @name KEN.VideoDash#duration
 * @readonly
 * @type {number}
 */
KEN.VideoDash.prototype.duration;
Object.defineProperty(KEN.VideoDash.prototype, "duration",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._dashMediaPlayer.duration();
    }
});

/**
 * Get the duration of the video in milli seconds.
 * @name KEN.VideoDash#durationMS
 * @readonly
 * @type {number}
 */
KEN.VideoDash.prototype.durationMS;
Object.defineProperty(KEN.VideoDash.prototype, "durationMS",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return Math.round(this["duration"] * 1000);
    }
});

/**
 * Get the playing status of the video.
 * @name KEN.VideoDash#playing
 * @readonly
 * @type {boolean}
 */
KEN.VideoDash.prototype.playing;
Object.defineProperty(KEN.VideoDash.prototype, "playing",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._playing;
    }
});

/**
 * Get the number of play action of the video.
 * @name KEN.VideoDash#playCount
 * @readonly
 * @type {boolean}
 */
KEN.VideoDash.prototype.playCount;
Object.defineProperty(KEN.VideoDash.prototype, "playCount",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._playCount;
    }
});

/**
 * Get the canPlay status of the video.
 * @name KEN.VideoDash#canPlay
 * @readonly
 * @type {boolean}
 */
KEN.VideoDash.prototype.canPlay;
Object.defineProperty(KEN.VideoDash.prototype, "canPlay",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._canPlay;
    }
});

/**
 * Get the number of the video ends.
 * @name KEN.VideoDash#endCount
 * @readonly
 * @type {boolean}
 */
KEN.VideoDash.prototype.endCount;
Object.defineProperty(KEN.VideoDash.prototype, "endCount",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._endCount;
    }
});

/**
 * Get the metaDataLoaded status of the video.
 * @name KEN.VideoDash#metaDataLoaded
 * @readonly
 * @type {boolean}
 */
KEN.VideoDash.prototype.metaDataLoaded;
Object.defineProperty(KEN.VideoDash.prototype, "metaDataLoaded",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._metaDataLoaded;
    }
});

/**
 * Get and set the loop status of the video.
 * @name KEN.VideoDash#loop
 * @type {boolean}
 */
KEN.VideoDash.prototype.loop;
Object.defineProperty(KEN.VideoDash.prototype, "loop",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._loop;
    },

    /** @this {KEN.VideoDash} */
    set: function(value)
    {
        if(typeof value === "boolean")
        {
            this._loop = value;
        }
    }
});

/**
 * Get and set the volume of the video.
 * Set a volume unmute the video
 * @name KEN.VideoDash#volume
 * @type {number}
 */
KEN.VideoDash.prototype.volume;
Object.defineProperty(KEN.VideoDash.prototype, "volume",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._volume;
    },

    /** @this {KEN.VideoDash} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._volume = KEN.Math.clamp(value, 0, 1);
            this._muted = false;
            this._updateVolume();
        }
    }
});

/**
 * Get and set the mute status of the video.
 * @name KEN.VideoDash#muted
 * @type {boolean}
 */
KEN.VideoDash.prototype.muted;
Object.defineProperty(KEN.VideoDash.prototype, "muted",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        return this._muted;
    },

    /** @this {KEN.VideoDash} */
    set: function(value)
    {
        if(Boolean(value) === true)
        {
            this.mute();
        }
        else
        {
            this.unmute();
        }
    }
});

/**
 * Get the "onLoadStart" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onLoadStart
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onLoadStart;
Object.defineProperty(KEN.VideoDash.prototype, "onLoadStart",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onLoadStart === null)
        {
            this._onLoadStart = new KEN.EventDispatcher(this);
        }

        return this._onLoadStart;
    }
});

/**
 * Get the "onLoadedMetaData" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onLoadedMetaData
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onLoadedMetaData;
Object.defineProperty(KEN.VideoDash.prototype, "onLoadedMetaData",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onLoadedMetaData === null)
        {
            this._onLoadedMetaData = new KEN.EventDispatcher(this);
        }

        return this._onLoadedMetaData;
    }
});

/**
 * Get the "onLoadedData" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onLoadedData
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onLoadedData;
Object.defineProperty(KEN.VideoDash.prototype, "onLoadedData",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onLoadedData === null)
        {
            this._onLoadedData = new KEN.EventDispatcher(this);
        }

        return this._onLoadedData;
    }
});

/**
 * Get the "onProgress" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onProgress
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onProgress;
Object.defineProperty(KEN.VideoDash.prototype, "onProgress",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onProgress === null)
        {
            this._onProgress = new KEN.EventDispatcher(this);
        }

        return this._onProgress;
    }
});

/**
 * Get the "onDurationChange" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onDurationChange
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onDurationChange;
Object.defineProperty(KEN.VideoDash.prototype, "onDurationChange",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onDurationChange === null)
        {
            this._onDurationChange = new KEN.EventDispatcher(this);
        }

        return this._onDurationChange;
    }
});

/**
 * Get the "onCanPlay" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onCanPlay
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onCanPlay;
Object.defineProperty(KEN.VideoDash.prototype, "onCanPlay",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onCanPlay === null)
        {
            this._onCanPlay = new KEN.EventDispatcher(this);
        }

        return this._onCanPlay;
    }
});

/**
 * Get the "onCanPlayThrough" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onCanPlayThrough
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onCanPlayThrough;
Object.defineProperty(KEN.VideoDash.prototype, "onCanPlayThrough",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onCanPlayThrough === null)
        {
            this._onCanPlayThrough = new KEN.EventDispatcher(this);
        }

        return this._onCanPlayThrough;
    }
});

/**
 * Get the "onPlay" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onPlay
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onPlay;
Object.defineProperty(KEN.VideoDash.prototype, "onPlay",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onPlay === null)
        {
            this._onPlay = new KEN.EventDispatcher(this);
        }

        return this._onPlay;
    }
});

/**
 * Get the "onPause" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onPause
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onPause;
Object.defineProperty(KEN.VideoDash.prototype, "onPause",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onPause === null)
        {
            this._onPause = new KEN.EventDispatcher(this);
        }

        return this._onPause;
    }
});

/**
 * Get the "onTimeUpdate" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onTimeUpdate
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onTimeUpdate;
Object.defineProperty(KEN.VideoDash.prototype, "onTimeUpdate",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onTimeUpdate === null)
        {
            this._onTimeUpdate = new KEN.EventDispatcher(this);
        }

        return this._onTimeUpdate;
    }
});

/**
 * Get the "onVolumeChange" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onVolumeChange
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onVolumeChange;
Object.defineProperty(KEN.VideoDash.prototype, "onVolumeChange",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onVolumeChange === null)
        {
            this._onVolumeChange = new KEN.EventDispatcher(this);
        }

        return this._onVolumeChange;
    }
});

/**
 * Get the "onSeeked" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onSeeked
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onSeeked;
Object.defineProperty(KEN.VideoDash.prototype, "onSeeked",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onSeeked === null)
        {
            this._onSeeked = new KEN.EventDispatcher(this);
        }

        return this._onSeeked;
    }
});

/**
 * Get the "onEnded" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onEnded
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onEnded;
Object.defineProperty(KEN.VideoDash.prototype, "onEnded",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onEnded === null)
        {
            this._onEnded = new KEN.EventDispatcher(this);
        }

        return this._onEnded;
    }
});

/**
 * Get the "onError" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onError
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onError;
Object.defineProperty(KEN.VideoDash.prototype, "onError",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onError === null)
        {
            this._onError = new KEN.EventDispatcher(this);
        }

        return this._onError;
    }
});

/**
 * Get the "onQualityRequest" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onQualityRequest
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onQualityRequest;
Object.defineProperty(KEN.VideoDash.prototype, "onQualityRequest",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onQualityRequest === null)
        {
            this._onQualityRequest = new KEN.EventDispatcher(this);
        }

        return this._onQualityRequest;
    }
});

/**
 * Get the "onQualityChange" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onQualityChange
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onQualityChange;
Object.defineProperty(KEN.VideoDash.prototype, "onQualityChange",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onQualityChange === null)
        {
            this._onQualityChange = new KEN.EventDispatcher(this);
        }

        return this._onQualityChange;
    }
});

/**
 * Get the "onQualityAbort" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onQualityAbort
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onQualityAbort;
Object.defineProperty(KEN.VideoDash.prototype, "onQualityAbort",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onQualityAbort === null)
        {
            this._onQualityAbort = new KEN.EventDispatcher(this);
        }

        return this._onQualityAbort;
    }
});

/**
 * Get the "onMetricsChanged" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onMetricChanged
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onMetricsChanged;
Object.defineProperty(KEN.VideoDash.prototype, "onMetricsChanged",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onMetricsChanged === null)
        {
            this._onMetricsChanged = new KEN.EventDispatcher(this);
        }

        return this._onMetricsChanged;
    }
});

/**
 * Get the "onQualitiesLoaded" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onQualitiesLoaded
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onQualitiesLoaded;
Object.defineProperty(KEN.VideoDash.prototype, "onQualitiesLoaded",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onQualitiesLoaded === null)
        {
            this._onQualitiesLoaded = new KEN.EventDispatcher(this, true);
        }

        return this._onQualitiesLoaded;
    }
});

/**
 * Get the "onQualityModeChange" event {@link KEN.EventDispatcher} of the video.
 * @name KEN.VideoDash#onQualityModeChange
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.VideoDash.prototype.onQualityModeChange;
Object.defineProperty(KEN.VideoDash.prototype, "onQualityModeChange",
{
    /** @this {KEN.VideoDash} */
    get: function()
    {
        if(this._onQualityModeChange === null)
        {
            this._onQualityModeChange = new KEN.EventDispatcher(this);
        }

        return this._onQualityModeChange;
    }
});


/**
 * This object describe the video time ranges.
 * 
 * @constructor KEN.VideoTimeRanges
 * @param {Element|HTMLVideoElement} element - The HTMLVideoElement that handle the ranges.
 * @param {string} property - The property of the video element that handles ranges (can be "buffered" or "played").
 * @extends {KEN.BaseObject}
 */
KEN.VideoTimeRanges = function(element, property)
{
    /**
     * The HTMLVideoElement associated to this buffer object.
     * @name KEN.VideoTimeRanges#_element
     * @type {Element|HTMLVideoElement}
     * @private
     */
    this._element = element;

    /**
     * The property that handles the time ranges on the video element.
     * @name  KEN.VideoTimeRanges#_property
     * @type {string}
     * @private
     */
    this._property = property;

    KEN.BaseObject.call(this, "VideoTimeRanges");
};

KEN.VideoTimeRanges.prototype = Object.create(KEN.BaseObject.prototype);
KEN.VideoTimeRanges.prototype.constructor = KEN.VideoTimeRanges;

/**
 * Get a time range from it's index.
 * @method KEN.VideoTimeRanges#getTimeRange
 * @param  {number} index - The index of the asked range.
 * @return {Object} Returns an object that contains the start and the end value of the asked range.
 */
KEN.VideoTimeRanges.prototype.getTimeRange = function(index)
{

    var ranges = this._element[this._property];

    if(this.length === 0)
    {
        this.warn("No available range for now");
        return null;
    }

    if(index > this.length - 1)
    {
        this.warn("Time range out of bounds, returning the last available range");
        return this.getTimeRange(this.length - 1);
    }
    else if(index < 0)
    {
        this.warn("Time range out of bounds, returning the first available range");
        return this.getTimeRange(0);
    }

    var _start = ranges.start(index);
    var _end = ranges.end(index);

    return { "start": _start, "end": _end };
};

/**
 * Know if a given point in time is in any ranges.
 * @method KEN.VideoTimeRanges#isInRanges
 * @param  {number} time - The time of your request.
 * @param {number} duration - The duration of your requested range.
 * @return {boolean} Returns true if you requested range exists.
 */
KEN.VideoTimeRanges.prototype.isInRanges = function(time, duration)
{

    if(typeof duration !== "number")
    {
        duration = 0;
    }

    var ranges = this._element[this._property];
    var start, end;  
    var i = this.length;

    while(i--)
    {
        start = ranges.start(i);
        end = ranges.end(i);

        if(time >= start && (time + duration) <= end)
        {
            return true;
        }
    }

    return false;
};

/**
 * Get the length of time ranges.
 * @name KEN.VideoTimeRanges#length
 * @readonly
 * @type {number}
 */
KEN.VideoTimeRanges.prototype.length;
Object.defineProperty(KEN.VideoTimeRanges.prototype, "length", 
{
    /** @this {KEN.VideoTimeRanges} */
    get: function()
    {
        return this._element[this._property].length;
    }
});

/**
 * Get the complete status of ranges, return true if there is a unique range that covers the entire media.
 * @name KEN.VideoTimeRanges#complete
 * @readonly
 * @type {boolean}
 */
// Object.defineProperty(KEN.VideoTimeRanges.prototype, "complete", 
// {
//     get: function()
//     {
//         var range = this.getTimeRange(0);
//         return (range.start === 0 && range.end === this._video["duration"]);
//     }
// });


/**
 * This object describe a video quality preset.
 * @constructor KEN.VideoQuality
 * @param {string} url - The url of the video source for this video quality preset.
 * @extends {KEN.BaseObject}
 */
KEN.VideoQuality = function(url)
{
     /**
     * The name of the quality.
     * @name  KEN.VideoQuality#_id
     * @type {string|number}
     * @private
     */
    this._id = "";

    /**
     * The url of the video.
     * @name  KEN.VideoQuality#_url
     * @type {string}
     * @private
     */
    this._url = url || "";

    /**
     * The type of the video quality.
     * @name  KEN.VideoQuality#_mimeType
     * @type {string}
     * @private
     */
    this._mimeType = "";

    /**
     * The name of the video quality.
     * @name  KEN.VideoQuality#_name
     * @type {string}
     * @private
     */
    this._name = "";

    /**
     * The framerate of the video quality.
     * @name  KEN.VideoQuality#_framerate
     * @type {number}
     * @private
     */
    this._framerate = 0;

    /**
     * The bitrate of the video quality.
     * @name  KEN.VideoQuality#_bitrate
     * @type {number}
     * @private
     */
    this._bitrate = 0;

    /**
     * The width of the video quality.
     * @name  KEN.VideoQuality#_width
     * @type {number}
     * @private
     */
    this._width = 0;

    /**
     * The height of the video quality.
     * @name  KEN.VideoQuality#_height
     * @type {number}
     * @private
     */
    this._height = 0;

    /**
     * The speed of the video quality.<br>
     * (1 is foward, -1 is backward, 2 is two times faster, ...).
     * @name  KEN.VideoQuality#_speed
     * @type {number}
     * @private
     */
    this._speed = 1;


    KEN.BaseObject.call(this, "VideoQuality");
};

KEN.VideoQuality.prototype = Object.create(KEN.BaseObject.prototype);
KEN.VideoQuality.prototype.constructor = KEN.VideoQuality;

/**
 * Get the MIME type of a video quality preset from it's url.
 * @name  KEN.VideoQuality#mimeTypeFromURL
 * @param  {string} url - The video preset url.
 * @return {string} The MIME type of the video preset.
 */
KEN.VideoQuality.mimeTypeFromURL = function(url)
{
    var types = ["mp4", "webm", "ogg"];
    var parsedURL = KEN.URL.parse(url);
    
    if(parsedURL["extension"] !== "" && types.indexOf(parsedURL["extension"]) !== -1)
    {
        return "video/" + parsedURL["extension"];
    }

    var streamingTypes = ["mpd"];
    if(parsedURL["extension"] !== "" && streamingTypes.indexOf(parsedURL["extension"]) !== -1)
    {
        return "application/dash+xml";
    }

    return "";
};

/**
 * Get and set the video quality preset ID.
 * @name KEN.VideoQuality#id
 * @type {string|number}
 * @readonly
 */
KEN.VideoQuality.prototype.id;
Object.defineProperty(KEN.VideoQuality.prototype, "id", 
{
    /** @this {KEN.VideoQuality} */
    get: function()
    {
        return this._id;
    }, 

    /** @this {KEN.VideoQuality} */
    set: function(value)
    {
        if(typeof value === "number" || typeof value === "string")
        {
            this._id = value;
        }
    }
});

/**
 * Get the video quality preset url.
 * @name KEN.VideoQuality#url
 * @type {string}
 * @readonly
 */
KEN.VideoQuality.prototype.url;
Object.defineProperty(KEN.VideoQuality.prototype, "url", 
{
    /** @this {KEN.VideoQuality} */
    get: function()
    {
        return this._url;
    }, 

    /** @this {KEN.VideoQuality} */
    set: function(value)
    {
        if(typeof value === "string")
        {
            this._url = value;
        }
    }
});

/**
 * Get the video quality preset MIME type.
 * @name KEN.VideoQuality#mimeType
 * @type {string}
 * @readonly
 */
KEN.VideoQuality.prototype.mimeType;
Object.defineProperty(KEN.VideoQuality.prototype, "mimeType", 
{
    /** @this {KEN.VideoQuality} */
    get: function()
    {
        if(this._mimeType !== "")
        {
            return this._mimeType;
        }
        else if(this._url !== "")
        {
            this._mimeType = KEN.VideoQuality.mimeTypeFromURL(this._url);
        }

        return this._mimeType;
    }
});

/**
 * Get the video quality preset name.
 * @name KEN.VideoQuality#name
 * @type {string}
 * @readonly
 */
KEN.VideoQuality.prototype.name;
Object.defineProperty(KEN.VideoQuality.prototype, "name", 
{
    /** @this {KEN.VideoQuality} */
    get: function()
    {
        return this._name;
    },

    /** @this {KEN.VideoQuality} */
    set: function(value)
    {
        if(typeof value === "string")
        {
            this._name = value;
        }
    }
});

/**
 * Get the video quality preset framerate.
 * @name KEN.VideoQuality#framerate
 * @type {number}
 * @readonly
 */
KEN.VideoQuality.prototype.framerate;
Object.defineProperty(KEN.VideoQuality.prototype, "framerate", 
{
    /** @this {KEN.VideoQuality} */
    get: function()
    {
        return this._framerate;
    }
});

/**
 * Get and set the video quality preset bitrate.
 * @name KEN.VideoQuality#bitrate
 * @type {number}
 * @readonly
 */
KEN.VideoQuality.prototype.bitrate;
Object.defineProperty(KEN.VideoQuality.prototype, "bitrate", 
{
    /** @this {KEN.VideoQuality} */
    get: function()
    {
        return this._bitrate;
    },

    /** @this {KEN.VideoQuality} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._bitrate = value;
        }
    }
});

/**
 * Get and set the video quality preset width.
 * @name KEN.VideoQuality#width
 * @type {number}
 * @readonly
 */
KEN.VideoQuality.prototype.width;
Object.defineProperty(KEN.VideoQuality.prototype, "width", 
{
    /** @this {KEN.VideoQuality} */
    get: function()
    {
        return this._width;
    },

    /** @this {KEN.VideoQuality} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._width = value;
        }
    }
});

/**
 * Get and set the video quality preset height.
 * @name KEN.VideoQuality#height
 * @type {number}
 * @readonly
 */
KEN.VideoQuality.prototype.height;
Object.defineProperty(KEN.VideoQuality.prototype, "height", 
{
    /** @this {KEN.VideoQuality} */
    get: function()
    {
        return this._height;
    },

    /** @this {KEN.VideoQuality} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._height = value;
        }
    }
});

/**
 * Get the video quality preset speed.
 * @name KEN.VideoQuality#speed
 * @type {number}
 * @readonly
 */
KEN.VideoQuality.prototype.speed;
Object.defineProperty(KEN.VideoQuality.prototype, "speed", 
{
    /** @this {KEN.VideoQuality} */
    get: function()
    {
        return this._speed;
    }
});


/**
 * Namespace for video quality mode const
 * @namespace {Object} KEN.VideoQualityMode
 */
KEN.VideoQualityMode = {};

/**
 * @name KEN.VideoQualityMode.AUTO
 * @type {string}
 * @const
 */
KEN.VideoQualityMode.AUTO = "auto";

/**
 * @name KEN.VideoQualityMode.MANUAL
 * @type {string}
 * @const
 */
KEN.VideoQualityMode.MANUAL = "manual";

/**
 * Namespace for video format const.
 * @namespace {Object} KEN.VideoFormat
 */
KEN.VideoFormat = {};

/**
 * @name KEN.VideoFormat.DASH
 * @type {string}
 * @const
 */
KEN.VideoFormat.DASH = "dash";

/**
 * @name KEN.VideoFormat.HTML5
 * @type {string}
 * @const
 */
KEN.VideoFormat.HTML5 = "html5";

/**
 * @name KEN.VideoFormat.UNKNOWN
 * @type {string}
 * @const
 */
KEN.VideoFormat.UNKNOWN = "unknown";

/**
 * Animation manager, handles animations for the {@link KEN.Sprite} display class.
 * @constructor KEN.AnimationManager
 * @param {KEN.Sprite} sprite - The Sprite attached to this animation manager.
 * @extends {KEN.BaseObject}
 */
KEN.AnimationManager = function(sprite)
{
    /**
     * The Sprite attached to this AnimationManager.
     * @name  KEN.AnimationManager#_sprite
     * @type {KEN.Sprite}
     * @private
     */
    this._sprite = sprite;

    /**
     * The Object that handles all animation declarations.
     * @name  KEN.AnimationManager#_anims
     * @type {Object<string,KEN.Animation>}
     * @private
     */
    this._anims = {};

    /**
     * Reference to the curretn animation sequence.
     * @name  KEN.AnimationManager#_currentAnimation
     * @type {KEN.Animation}
     * @private
     */
    this._currentAnimation = null;

    /**
     * List of pending actions.<br>
     * some action are placed here if the Sprite is not loaded.
     * @name  KEN.AnimationManager#_pending
     * @type {Array<AnimationConfiguration>}
     * @private
     */
    this._pending = [];

    KEN.BaseObject.call(this, "AnimationManager");

    this._boot();
};

KEN.AnimationManager.prototype = Object.create(KEN.BaseObject.prototype);
KEN.AnimationManager.prototype.constructor = KEN.AnimationManager;

/**
 * Boot sequence.
 * @method KEN.AnimationManager#_boot
 * @private
 */
KEN.AnimationManager.prototype._boot = function()
{
    if(this._sprite["loaded"] === false)
    {
        this._sprite["onLoadComplete"].addOnce(this._spriteLoadComplete, this);
    }
};

/**
 * Apply pending animation declaration on sprite load complete.
 * @method KEN.AnimationManager#_spriteLoadComplete
 * @private
 */
KEN.AnimationManager.prototype._spriteLoadComplete = function()
{
    this.log("_spriteLoadComplete");

    var method, args;
    for(var i = 0, ii = this._pending.length; i < ii; i++)
    {
        method = this._pending[i].method;
        args = this._pending[i].args;
        KEN.AnimationManager.prototype[method].apply(this, args);
    }

    this._pending = [];
};

/**
 * Add an animation sequence to this sprite.
 * @param {string} name - The name of your animation sequence.
 * @param {number} start - The starting frame index of the full frames array.
 * @param {number} end - The end frame index of the full frame array.
 * @param {number} frameRate - The frame rate of this animation (default: 60)
 * @param {boolean} loop - Does the animation have to loop? (default: false)
 */
KEN.AnimationManager.prototype.add = function(name, start, end, frameRate, loop)
{
    if(this._sprite["loaded"] === false)
    {
        this._pending.push({
            method: "add",
            args: arguments
        });

        return;
    }

    this.log("add");

    if(typeof name !== "string")
    {
        name = "default";
    }

    start = parseInt(start, 10);
    end = parseInt(end, 10);

    var frames = this._sprite["frames"];
    if(typeof start !== "number" || isNaN(start) === true || start < 0 || start >= frames.length)
    {
        start = 0;
    }
    if(typeof end !== "number" || isNaN(end) === true || end < 0 || end >= frames.length)
    {
        end = frames.length;
    }

    frameRate = frameRate || 60;
    loop = (typeof loop === "undefined") ? false : Boolean(loop);

    var selectedFrames = frames.slice(start, end);

    this._anims[name] = new KEN.Animation(this._sprite, name, selectedFrames, frameRate);

    this._currentAnimation = this._anims[name];
};

/**
 * Play the curretn animation or a specified animation.<br>
 * If the Sprite is not loaded, kepp this method call in pending.
 * @method  KEN.AnimationManager#play
 * @param  {string=} animation - The animation name you want to play.
 * @param  {boolean=} loop - Does the animation should loop?
 * @param  {number=} index - The index of the animation to play
 */
KEN.AnimationManager.prototype.play = function(animation, loop, index)
{
    if(this._sprite["loaded"] === false)
    {
        this._pending.push({
            method: "play",
            args: arguments
        });

        return;
    }

    var anim = this._currentAnimation;

    if(typeof animation === "string" && animation !== null)
    {
        anim = this.get(animation);
    }

    if(anim !== null)
    {
        anim.play(loop, index);
    }

    //@todo play should also resume the current paused animation ?
};

/**
 * Pause the animation.
 * @method  KEN.AnimationManager#pause
 * @param  {number=} index - The frame index on which to pause to animation. Default will be the current frame.
 */
KEN.AnimationManager.prototype.pause = function(index)
{
    var anim = this._currentAnimation;

    if(anim !== null)
    {
        anim.pause(index);
    }
};

/**
 * Resume the animation.
 * @method  KEN.AnimationManager#resume
 * @param  {number=} index - The frame index on which to pause to animation. Default will be the current frame.
 */
KEN.AnimationManager.prototype.resume = function(index)
{
    var anim = this._currentAnimation;

    if(anim !== null)
    {
        anim.resume(index);
    }
};

/**
 * Stops the current animation, reset it to its first frame.
 * @method  KEN.AnimationManager#stop
 */
KEN.AnimationManager.prototype.stop = function()
{
    var anim = this._currentAnimation;

    if(anim !== null)
    {
        anim.stop();
    }
};


/**
 * Get an animation by its name.
 * @method  KEN.AnimationManager#get
 * @param  {string} name - The name of the animation you want to get.
 * @return {KEN.Animation} Returns the asked animation if exists, null if not.
 */
KEN.AnimationManager.prototype.get = function(name)
{
    if(KEN.Utils.isTypeOf(this._anims[name], "Animation") === true)
    {
        return this._anims[name];
    }

    return null;
};

/**
 * Internal update method.<br>
 * Main purpose is to update the current animation.
 * @method KEN.AnimationManager#update
 */
KEN.AnimationManager.prototype.update = function()
{
    if(this._currentAnimation !== null)
    {
        this._currentAnimation.update();
    }
};

/**
 * Destroy method
 * @method KEN.AnimationManager#destroy
 */
KEN.AnimationManager.prototype.destroy = function()
{
    for(var name in this._anims)
    {
        this._anims[name].destroy();
        this._anims[name] = null;
    }

    this._sprite = null;
    this._anims = null;
    this._currentAnimation = null;
    this._pending = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get and set the current animation.
 * @name KEN.AnimationManager#currentAnimation
 * @type {KEN.Animation}
 */
KEN.AnimationManager.prototype.currentAnimation;
Object.defineProperty(KEN.AnimationManager.prototype, "currentAnimation",
{
    /** @this {KEN.AnimationManager} */
    get: function()
    {
        return this._currentAnimation;
    },

    /** @this {KEN.AnimationManager} */
    set: function(animation)
    {
        if(KEN.Utils.isTypeOf(animation, "Animation") === true)
        {
            this._currentAnimation = animation;
        }
    }
});


/**
 * Animation for Sprites.
 * @constructor KEN.Animation
 * @param {KEN.Sprite} sprite - The Sprite that is animated.
 * @param {string} name - Name of the animation.
 * @param {Array} frames - The frames taht compose this animation.
 * @param {number} [frameRate=60] - Frame rate of this animation (default: 60)
 * @extends {KEN.BaseObject}
 *
 * @todo Work on trimmed textures
 */
KEN.Animation = function(sprite, name, frames, frameRate)
{
    /**
     * The sprite attached to this animation.
     * @name  KEN.Animation#_sprite
     * @type {KEN.Sprite}
     * @private
     */
    this._sprite = sprite;

    /**
     * Name of the animation.
     * @name  KEN.Animation#_name
     * @type {string}
     * @private
     */
    this._name = name;

    /**
     * Array of frames that compose this animation
     * @name  KEN.Animation#_frames
     * @type {Array<Object>}
     * @private
     */
    this._frames = frames || [];

    /**
     * The index of the current frame.
     * @name  KEN.Animation#_frameIndex
     * @type {number}
     * @private
     */
    this._frameIndex = 0;

    /**
     * Frame rate of this animation, this is the number of frames per second. (default = 60)
     * @name  KEN.Animation#_frameRate
     * @type {number}
     * @private
     */
    this._frameRate = frameRate || 60;

    /**
     * Does this animation loop?
     * @name  KEN.Animation#_loop
     * @type {boolean}
     * @private
     */
    this._loop = false;

    /**
     * The number of times this animation has looped.
     * @name  KEN.Animation#_loopCount
     * @type {number}
     * @private
     */
    this._loopCount = 0;

    /**
     * The delay in milliseconds between two frames.
     * @name  KEN.Animation#_delay
     * @type {number}
     * @private
     */
    this._delay = 1000 / frameRate;

    /**
     * The time of the last frame.
     * @name  KEN.Animation#_timeLastFrame
     * @type {number}
     * @private
     */
    this._timeLastFrame = 0;

    /**
     * The time of the next frame.
     * @name  KEN.Animation#_timeNextFrame
     * @type {number}
     * @private
     */
    this._timeNextFrame = 0;

    /**
     * The time between the current time and the next frame.
     * @name  KEN.Animation#_frameDiff
     * @type {number}
     * @private
     */
    this._frameDiff = 0;

    /**
     * The number of frames to skip when laag occurs.
     * @name  KEN.Animation#_frameSkip
     * @type {number}
     * @private
     */
    this._frameSkip = 1;

    /**
     * Is this animation is currently playing?
     * @name  KEN.Animation#_playing
     * @type {boolean}
     * @private
     */
    this._playing = false;

    /**
     * Is this animation is currently paused?
     * @name  KEN.Animation#_paused
     * @type {boolean}
     * @private
     */
    this._paused = false;

    /**
     * Is this animation is complete?
     * @name  KEN.Animation#_complete
     * @type {boolean}
     * @private
     */
    this._complete = false;

    /**
     * On play event dispatcher.
     * @name  KEN.Animation#_onPlay
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onPlay = null;

    /**
     * On pause event dispatcher.
     * @name  KEN.Animation#_onPause
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * On resume event dispatcher.
     * @name  KEN.Animation#_onResume
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onResume = null;

    /**
     * On loop event dispatcher.
     * @name  KEN.Animation#_onLoop
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onLoop = null;

    /**
     * On stop event dispatcher.
     * @name  KEN.Animation#_onStop
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onStop = null;

    /**
     * On complete event dispatcher.
     * @name  KEN.Animation#_onComplete
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onComplete = null;

    KEN.BaseObject.call(this, "Animation");
};

KEN.Animation.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Animation.prototype.constructor = KEN.Animation;

/**
 * Internal method to notify when animation is complete.
 * @method  KEN.Animation#_notifyComplete
 * @private
 */
KEN.Animation.prototype._notifyComplete = function()
{
    this._setFrameIndex(this._frames.length - 1);

    this._playing = false;
    this._complete = true;
    this._paused = false;

    if(this._onComplete !== null)
    {
        this._onComplete.dispatch();
    }
};

/**
 * Internal method to set the frame index of the animation and update the sprite display.
 * @method  KEN.Animation#_setFrameIndex
 * @private
 * @param {number=} [index=0] - The frame index to set.
 */
KEN.Animation.prototype._setFrameIndex = function(index)
{
    this._frameIndex = (typeof index === "number" && index >= 0 && index < this._frames.length) ? index : 0;
    this._sprite["frame"] = this._frames[this._frameIndex]["frame"];
};

/**
 * Play this animation.
 * @method  KEN.Animation#play
 * @param {boolean=} loop - Does the animation have to loop on complete?
 * @param {number=} index - the index to play at
 */
KEN.Animation.prototype.play = function(loop, index)
{
    if(typeof loop === "boolean")
    {
        this._loop = loop;
    }

    this._playing = true;
    this._complete = false;
    this._paused = false;
    this._loopCount = 0;

    var time = this._sprite["viewer"]["clock"]["time"];
    this._timeLastFrame = time;
    this._timeNextFrame = time + this._delay;

    this._setFrameIndex(index); //Default will be 0 :)

    this._sprite["animations"]["currentAnimation"] = this;

    if(this._onPlay !== null)
    {
        this._onPlay.dispatch();
    }
};

/**
 * Pause the animation.
 * @method  KEN.Animation#pause
 * @param  {number} [index] - The frame index on which to pause the animation. Default will be the current frame.
 */
KEN.Animation.prototype.pause = function(index)
{
    if(this._paused === true)
    {
        return;
    }

    this._paused = true;

    if(typeof index === "number")
    {
        this._setFrameIndex(index);
    }

    if(this._onPause !== null)
    {
        this._onPause.dispatch();
    }
};

/**
 * Resume the animation
 * @method KEN.Animation#resume
 * @param  {number} [index] - The frame index on which to resume the animation. Default will be the current frame.
 */
KEN.Animation.prototype.resume = function(index)
{
    if(this._paused === false)
    {
        return;
    }

    this._paused = false;

    if(typeof index === "number")
    {
        this._setFrameIndex(index);
    }

    if(this._playing)
    {
        this._timeNextFrame = this._sprite["viewer"]["clock"]["time"] + this._delay;
    }

    if(this._onResume !== null)
    {
        this._onResume.dispatch();
    }
};

/**
 * Stops the animation, reset it to the first frame.
 * @method  KEN.Animation#stop
 */
KEN.Animation.prototype.stop = function()
{
    this._playing = false;
    this._complete = true;
    this._paused = false;

    this._setFrameIndex(0);

    if(this._onStop !== null)
    {
        this._onStop.dispatch();
    }
};

/**
 * Update loop that will be called by the DisplayList through Sprite & AnimationManager update
 * @method KEN.Animation#update
 */
KEN.Animation.prototype.update = function()
{
    if (this._paused === true)
    {
        return;
    }

    var time = this._sprite["viewer"]["clock"]["time"];

    if (this._playing === true && time >= this._timeNextFrame)
    {
        this._frameSkip = 1;
        this._frameDiff = time - this._timeNextFrame;
        this._timeLastFrame = time;

        if (this._frameDiff > this._delay)
        {
            this._frameSkip = Math.floor(this._frameDiff / this._delay);
            this._frameDiff -= (this._frameSkip * this._delay);
        }

        this._timeNextFrame = time + (this._delay - this._frameDiff);

        var frameIndex = this._frameIndex + this._frameSkip;

        if (frameIndex >= this._frames.length)
        {
            if (this._loop === true)
            {
                frameIndex %= this._frames.length;
                this._loopCount++;

                if(this._onLoop !== null)
                {
                    this._onLoop.dispatch();
                }

                this._setFrameIndex(frameIndex);
            }
            else
            {
                this._notifyComplete();
            }
        }
        else
        {
            this._setFrameIndex(frameIndex);
        }
    }
};

/**
 * Destroy method
 * @method KEN.Animation#destroy
 */
KEN.Animation.prototype.destroy = function()
{
    this._sprite = null;
    this._frames = null;

    if(this._onPlay !== null)
    {
        this._onPlay.destroy();
        this._onPlay = null;
    }

    if(this._onPause !== null)
    {
        this._onPause.destroy();
        this._onPause = null;
    }

    if(this._onResume !== null)
    {
        this._onResume.destroy();
        this._onResume = null;
    }

    if(this._onComplete !== null)
    {
        this._onComplete.destroy();
        this._onComplete = null;
    }

    if(this._onLoop !== null)
    {
        this._onLoop.destroy();
        this._onLoop = null;
    }

    if(this._onStop !== null)
    {
        this._onStop.destroy();
        this._onStop = null;
    }

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
* Get the name of the Animation.
* @name KEN.Animation#name
* @readonly
* @type {string}
*/
KEN.Animation.prototype.name;
Object.defineProperty(KEN.Animation.prototype, "name",
{
    /** @this {KEN.Animation} */
    get: function()
    {
        return this._name;
    }
});

/**
* Get the frames array of the Animation.
* @name KEN.Animation#frames
* @readonly
* @type {Array<Object>}
*/
KEN.Animation.prototype.frames;
Object.defineProperty(KEN.Animation.prototype, "frames",
{
    /** @this {KEN.Animation} */
    get: function()
    {
        return this._frames;
    }
});

/**
* Get the current frame index of the Animation.
* @name KEN.Animation#frameIndex
* @readonly
* @type {number}
*/
KEN.Animation.prototype.frameIndex;
Object.defineProperty(KEN.Animation.prototype, "frameIndex",
{
    /** @this {KEN.Animation} */
    get: function()
    {
        return this._frameIndex;
    }
});

/**
* Get the frame rate of the Animation.
* @name KEN.Animation#frameRate
* @readonly
* @type {string}
*/
KEN.Animation.prototype.frameRate;
Object.defineProperty(KEN.Animation.prototype, "frameRate",
{
    /** @this {KEN.Animation} */
    get: function()
    {
        return this._frameRate;
    },

    /** @this {KEN.Animation} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        this._frameRate = value;
        this._delay = 1000 / this._frameRate;
    }
});

/**
* Get and set the loop flag of the Animation.
* @name KEN.Animation#loop
* @type {boolean}
*/
KEN.Animation.prototype.loop;
Object.defineProperty(KEN.Animation.prototype, "loop",
{
    /** @this {KEN.Animation} */
    get: function()
    {
        return this._loop;
    },

    /** @this {KEN.Animation} */
    set: function(value)
    {
        this._loop = Boolean(value);
    }
});

/**
* Get the loop count of the Animation.
* @name KEN.Animation#loopCount
* @readonly
* @type {boolean}
*/
KEN.Animation.prototype.loopCount;
Object.defineProperty(KEN.Animation.prototype, "loopCount",
{
    /** @this {KEN.Animation} */
    get: function()
    {
        return this._loopCount;
    }
});


/**
* Get the playing status of the Animation.
* @name KEN.Animation#playing
* @readonly
* @type {boolean}
*/
KEN.Animation.prototype.playing;
Object.defineProperty(KEN.Animation.prototype, "playing",
{
    /** @this {KEN.Animation} */
    get: function()
    {
        return this._playing;
    }
});

/**
* Get the paused status of the Animation.
* @name KEN.Animation#paused
* @type {boolean}
*/
KEN.Animation.prototype.paused;
Object.defineProperty(KEN.Animation.prototype, "paused",
{
    /** @this {KEN.Animation} */
    get: function()
    {
        return this._paused;
    },

    /** @this {KEN.Animation} */
    set: function(value)
    {
        if(Boolean(value) === true)
        {
            this.pause();
        }
        else
        {
            this.resume();
        }
    }
});

/**
* Get the complete status of the Animation.
* @name KEN.Animation#complete
* @readonly
* @type {boolean}
*/
KEN.Animation.prototype.complete;
Object.defineProperty(KEN.Animation.prototype, "complete",
{
    /** @this {KEN.Animation} */
    get: function()
    {
        return this._complete;
    }
});

/**
* Get the onPlay {@link KEN.EventDispatcher}.
* @name KEN.Animation#onPlay
* @readonly
* @type {KEN.EventDispatcher}
*/
KEN.Animation.prototype.onPlay;
Object.defineProperty(KEN.Animation.prototype, "onPlay",
{
    /** @this {KEN.Animation} */
    get: function()
    {
        if(this._onPlay === null)
        {
            this._onPlay = new KEN.EventDispatcher(this);
        }

        return this._onPlay;
    }
});

/**
* Get the onPause {@link KEN.EventDispatcher}.
* @name KEN.Animation#onPause
* @readonly
* @type {KEN.EventDispatcher}
*/
KEN.Animation.prototype.onPause;
Object.defineProperty(KEN.Animation.prototype, "onPause",
{
    /** @this {KEN.Animation} */
    get: function()
    {
        if(this._onPause === null)
        {
            this._onPause = new KEN.EventDispatcher(this);
        }

        return this._onPause;
    }
});

/**
* Get the onResume {@link KEN.EventDispatcher}.
* @name KEN.Animation#onResume
* @readonly
* @type {KEN.EventDispatcher}
*/
KEN.Animation.prototype.onResume;
Object.defineProperty(KEN.Animation.prototype, "onResume",
{
    /** @this {KEN.Animation} */
    get: function()
    {
        if(this._onResume === null)
        {
            this._onResume = new KEN.EventDispatcher(this);
        }

        return this._onResume;
    }
});

/**
* Get the onLoop {@link KEN.EventDispatcher}.
* @name KEN.Animation#onLoop
* @readonly
* @type {KEN.EventDispatcher}
*/
KEN.Animation.prototype.onLoop;
Object.defineProperty(KEN.Animation.prototype, "onLoop",
{
    /** @this {KEN.Animation} */
    get: function()
    {
        if(this._onLoop === null)
        {
            this._onLoop = new KEN.EventDispatcher(this);
        }

        return this._onLoop;
    }
});

/**
* Get the onComplete {@link KEN.EventDispatcher}.
* @name KEN.Animation#onComplete
* @readonly
* @type {KEN.EventDispatcher}
*/
KEN.Animation.prototype.onComplete;
Object.defineProperty(KEN.Animation.prototype, "onComplete",
{
    /** @this {KEN.Animation} */
    get: function()
    {
        if(this._onComplete === null)
        {
            this._onComplete = new KEN.EventDispatcher(this);
        }

        return this._onComplete;
    }
});

/**
* Get the onStop {@link KEN.EventDispatcher}.
* @name KEN.Animation#onStop
* @readonly
* @type {KEN.EventDispatcher}
*/
KEN.Animation.prototype.onStop;
Object.defineProperty(KEN.Animation.prototype, "onStop",
{
    /** @this {KEN.Animation} */
    get: function()
    {
        if(this._onStop === null)
        {
            this._onStop = new KEN.EventDispatcher(this);
        }

        return this._onStop;
    }
});


/**
 * Cache manager for loaded objects.
 *
 * @constructor KEN.Cache
 * @param {KEN.Viewer} viewer - The {@link KEN.Viewer} reference.
 */
KEN.Cache = function(viewer)
{
    /**
     * The viewer reference.
     * @name KEN.Cache#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The list of json.
     * @name KEN.Cache#_json
     * @type {KEN.Map}
     * @private
     */
    this._json = new KEN.Map();

    /**
     * The list of xml.
     * @name KEN.Cache#_xml
     * @type {KEN.Map}
     * @private
     */
    this._xml = new KEN.Map();

    /**
     * The list of images.
     * @name KEN.Cache#_images
     * @type {KEN.Map}
     * @private
     */
    this._images = new KEN.Map();

    /**
     * The list of sounds.
     * @name KEN.Cache#_sounds
     * @type {KEN.Map}
     * @private
     */
    this._sounds = new KEN.Map();

    /**
     * The current key increment used to generate keys.
     * @name KEN.Cache#_keyIncrement
     * @type {number}
     * @private
     */
    this._keyIncrement = 0;
};

/**
 * Default prefix for generated keys
 * @name KEN.PluginEngine._PREFIX
 * @type {string}
 * @const
 * @private
 */
KEN.Cache._PREFIX = "ken-cache";

/**
 * Const that list different types of cache.
 * @name  KEN.Cache.types
 * @type {Object}
 * @const
 */
KEN.Cache.types = {};

/**
 * @name KEN.Cache.types.JSON
 * @type {string}
 * @const
 */
KEN.Cache.types.JSON = "json";

/**
 * @name KEN.Cache.types.XML
 * @type {string}
 * @const
 */
KEN.Cache.types.XML = "xml";

/**
 * @name KEN.Cache.types.IMAGE
 * @type {string}
 * @const
 */
KEN.Cache.types.IMAGE = "image";

/**
 * @name KEN.Cache.types.SOUND
 * @type {string}
 * @const
 */
KEN.Cache.types.SOUND = "sound";

/**
 * List of reserved keys for specific cache.
 * @name KEN.PluginEngine.reserved
 * @type {Object}
 * @const
 */
KEN.Cache.reserved = {};

/**
 * @name KEN.Cache.reserved.COMMON
 * @type {Array<string>}
 * @const
 */
KEN.Cache.reserved.COMMON = ["ken"];

/**
 * @name KEN.Cache.reserved.JSON
 * @type {Array<string>}
 * @const
 */
KEN.Cache.reserved.JSON = ["tour.config"].concat(KEN.Cache.reserved.COMMON);

/**
 * @name KEN.Cache.reserved.XML
 * @type {Array<string>}
 * @const
 */
KEN.Cache.reserved.XML = [].concat(KEN.Cache.reserved.COMMON);

/**
 * @name KEN.Cache.reserved.IMAGE
 * @type {Array<string>}
 * @const
 */
KEN.Cache.reserved.IMAGE = [].concat(KEN.Cache.reserved.COMMON);

/**
 * @name KEN.Cache.reserved.SOUND
 * @type {Array<string>}
 * @const
 */
KEN.Cache.reserved.SOUND = [].concat(KEN.Cache.reserved.COMMON);

/**
 * Get a cache map from a type that is listed on KEN.Cache.types
 * @method KEN.Cache._getCacheByType
 * @param  {string} type - The type of cache you want to get.
 * @return {?KEN.Map} Returns the {@link KEN.Map} associated to the required type of cache.
 * @private
 */
KEN.Cache.prototype._getCacheByType = function(type)
{
    var cache = null;

    switch(type)
    {
        case KEN.Cache.types.JSON:
            cache = this._json;
            break;

        case KEN.Cache.types.XML:
            cache = this._xml;
            break;

        case KEN.Cache.types.IMAGE:
            cache = this._images;
            break;

        case KEN.Cache.types.SOUND:
            cache = this._sounds;
            break;
    }

    return cache;
};

/**
 * Get a reserved key array from a type that is listed on KEN.Cache.types
 * @method KEN.Cache._getReservedByType
 * @param  {string} type - The type of reserved key you want to get.
 * @return {?Array<string>} Returns the reserved key array associated to the required type of cache.
 * @private
 */
KEN.Cache.prototype._getReservedByType = function(type)
{
    var reserved = null;

    switch(type)
    {
        case KEN.Cache.types.JSON:
            reserved = KEN.Cache.reserved.JSON;
            break;

        case KEN.Cache.types.XML:
            reserved = KEN.Cache.reserved.XML;
            break;

        case KEN.Cache.types.IMAGE:
            reserved = KEN.Cache.reserved.IMAGE;
            break;

        case KEN.Cache.types.SOUND:
            reserved = KEN.Cache.reserved.SOUND;
            break;
    }

    return reserved;
};

/**
 * Generate a key for a specific cache.
 * @method KEN.Cache#_generateKey
 * @param  {string} type - In which cache type the key should be valid?
 * @param  {string} prefix - Custom key prefix.
 * @return {string} Returns a generated cache key.
 * @private
 */
KEN.Cache.prototype._generateKey = function(type, prefix)
{
    var cache = this._getCacheByType(type);

    var p = prefix || KEN.Cache._PREFIX;
    var key = p+"-"+this._keyIncrement;

    this._keyIncrement++;

    if(cache.has(key) === false && this._isReserved(type, key) === false)
    {
        return key;
    }
    else
    {
        return this._generateKey(type, prefix);
    }
};

/**
 * Check if a reserved key has been already added into cache.
 * @method KEN.Cache#_isReservedAlreadyUsed
 * @param {string} type - The type of cache you want to check.
 * @param {string} key - The cache key to search for.
 * @return {boolean} Return true if the key is reserved and it is already registered
 * @private
 */
KEN.Cache.prototype._isReservedAlreadyUsed = function(type, key)
{
    var cache = this._getCacheByType(type);
    var reserved = this._getReservedByType(type);

    return (this._isReserved(type, key) === true && cache.has(key) === true);
};

/**
 * Check if a key is reserved for a given type of cache.
 * @param  {string} type - The type of cache you want to check.
 * @param  {string} key - The key you want to check
 * @return {boolean} Return true if the key is a reserved one for the type of cache
 * @private
 */
KEN.Cache.prototype._isReserved = function(type, key)
{
    var reserved = this._getReservedByType(type);

    if(reserved !== null)
    {
        return reserved.indexOf(key.toLowerCase()) !== -1;
    }

    return false;
};

/**
 * Is a cache has something associated to a key?
 * @method KEN.Cache#has
 * @param {string} type - The type of cache you want to check.
 * @param {string} key - The key to search for.
 * @return {boolean} Returns true if found, false if not.
 */
KEN.Cache.prototype.has = function(type, key)
{
    var cache = this._getCacheByType(type);

    if(cache !== null)
    {
        return cache.has(key);
    }

    return false;
};

/**
 * Get the file associated to a key in a specific cache.
 * @method KEN.Cache#get
 * @param {string} type - The type of cache you want to use.
 * @param {string} key - The key to search for.
 * @return {?KEN.File} Returns the {@link KEN.File} object if found, null if not found.
 */
KEN.Cache.prototype.get = function(type, key)
{
    if(this.has(type, key) === true)
    {
        var cache = this._getCacheByType(type);

        if(cache !== null)
        {
            return cache.get(key);
        }
    }

    return null;
};

/**
 * Add a file to a specific cache.
 * @method KEN.Cache#add
 * @param {string} type - The type of cache you want to use.
 * @param {string} key - The key for the file.
 * @param {KEN.File} file - The {@link KEN.File} object you want to add.
 * @return {boolean} Returns true if the addition is complete, false if not.
 */
KEN.Cache.prototype.add = function(type, key, file)
{
    if(typeof key !== "string" || key === "" || this._isReservedAlreadyUsed(type, key) === true)
    {
        key = this._generateKey(type, type+"-cache");
    }

    if(this.has(key, type) === false)
    {
        var cache = this._getCacheByType(type);

        if(cache !== null)
        {
            cache.set(key, file);
            return true;
        }
    }

    return false;
};

/**
 * Remove a {@link KEN.File} from a specific cache.
 * @method KEN.Cache#remove
 * @param {string} type - The type of cache you want to remove the file from.
 * @param {string} key - The key associated to the file you want to remove.
 * @return {boolean} Returns true if the deletion is complete, false if not.
 */
KEN.Cache.prototype.remove = function(type, key)
{
    if(this.has(type, key) === true)
    {
        var cache = this._getCacheByType(type);

        if(cache !== null)
        {
            cache.delete(key);
            return true;
        }
    }

    return false;
};

/**
 * Destroy sequence.
 * @method KEN.Cache#destroy
 */
KEN.Cache.prototype.destroy = function()
{
    this._viewer = null;
    this._json = null;
    this._images = null;
    this._sounds = null;
};

/**
 * File object description.<br>
 * Used in {@link KEN.Loader}
 *
 * @constructor KEN.File
 */
KEN.File = function()
{

};

/**
 * The key of the file.
 * @name KEN.File#key
 * @type {string}
 */
KEN.File.prototype.key = "";

/**
 * The url of the file.
 * @name KEN.File#url
 * @type {string}
 */
KEN.File.prototype.url = "";

/**
 * The type of the file.
 * @name KEN.File#type
 * @type {string}
 */
KEN.File.prototype.type = "";

/**
 * The file data.
 * @name KEN.File#data
 * @type {Object|string}
 */
KEN.File.prototype.data = null;

/**
 * The XMLHttpRequest response.
 * @name KEN.File#xhr
 * @type {Object}
 */
KEN.File.prototype.xhr = null;

/**
 * The loading satatus of the file.
 * @name KEN.File#loading
 * @type {boolean}
 */
KEN.File.prototype.loading = false;

/**
 * File is loaded?
 * @name KEN.File#loaded
 * @type {boolean}
 */
KEN.File.prototype.loaded = false;

/**
 * The error text of the file.
 * @name KEN.File#error
 * @type {string}
 */
KEN.File.prototype.error = "";

KEN.File.prototype.constructor = KEN.File;
/**
 * This class have several methods to load assets and put them in cache.
 * @constructor KEN.Loader
 * @param {KEN.Viewer} viewer - {@link KEN.Viewer} reference.
 * @extends {KEN.BaseObject}
 *
 * @todo  Clean callback and context from file like in jsonLoadComplete, this cause JS keep reference to viewer when destroyed.
 */
KEN.Loader = function(viewer)
{
    /**
     * The viewer reference. 
     * @name KEN.Loader#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    KEN.BaseObject.call(this, "Loader");
};

KEN.Loader.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Loader.prototype.constructor = KEN.Loader;

/**
 * Load a json file.
 * @method KEN.Loader#json
 * @param  {string} key - The key for the json file.               
 * @param  {string} url - URL of the file.           
 * @param  {Function} onCompleteCallback - The callback function called when file is completed.
 * @param  {Object} onCompleteContext - The callback context when file is completed.
 * @param  {Function=} onErrorCallback - The callback function called on file error.
 * @param  {Object=} onErrorContext - The callback context for file error.
 */
KEN.Loader.prototype.json = function(key, url, onCompleteCallback, onCompleteContext, onErrorCallback, onErrorContext)
{
    var file = new KEN.File();
    file["type"] = "json";
    file["key"] = key;
    file["url"] = url;
    file.onCompleteCallback = onCompleteCallback;
    file.onCompleteContext = onCompleteContext;
    file.onErrorCallback = onErrorCallback;
    file.onErrorContext = onErrorContext;

    this._xhr(file, "text", this._jsonLoadComplete, this._jsonLoadError);
};

/**
 * Internal method called when a json file is completed.
 * @method KEN.Loader#_jsonLoadComplete
 * @private
 * @param {KEN.File} file - The {@link KEN.File} corresponding to the json file.
 * @param {XMLHttpRequest} xhr - The XMLHttpRequest response.
 */
KEN.Loader.prototype._jsonLoadComplete = function(file, xhr)
{
    if (xhr.responseText)
    {
        file["data"] = Object(JSON.parse(xhr.responseText));

        if (this._viewer["cache"].has(KEN.Cache.types.JSON, file["key"]) === false)
        {
            this._viewer["cache"].add(KEN.Cache.types.JSON, file["key"], file);
        }
        else
        {
            this.log("KEN.Loader.json : JSON file already exists");
        }

        if (typeof file.onCompleteCallback === "function" && file.onCompleteContext !== null)
        {
            var callback = file.onCompleteCallback;
            var context = file.onCompleteContext;

            file.onCompleteCallback = null;
            file.onCompleteContext = null;
            file.onErrorCallback = null;
            file.onErrorContext = null;

            callback.call(context, file);
        }
    }
    else
    {
        throw "KEN.Loader.json : JSON file empty ?";
    }
};

/**
 * Internal method called when the load of a json file return error.
 * @method KEN.Loader#_jsonLoadError
 * @private
 * @param {KEN.File} file - The {@link KEN.File} corresponding to the json file.
 * @param {XMLHttpRequest} xhr - The XMLHttpRequest response.
 */
KEN.Loader.prototype._jsonLoadError = function(file, xhr)
{
    if (xhr.responseText)
    {
        if (typeof file.onErrorCallback === "function" && file.onErrorContext !== null)
        {
            var callback = file.onErrorCallback;
            var context = file.onErrorContext;

            file.onCompleteCallback = null;
            file.onCompleteContext = null;
            file.onErrorCallback = null;
            file.onErrorContext = null;

            callback.call(context, file);
        }
    }
    else
    {
        throw "KEN.Loader.json : JSON file empty ?";
    }
};

/**
 * Load a xml file.
 * @method KEN.Loader#xml
 * @param  {string} key - The key for the xml file.               
 * @param  {string} url - URL of the file.           
 * @param  {Function} onCompleteCallback - The callback function called when file is completed.
 * @param  {Object} onCompleteContext - The callback context when file is completed.
 * @param  {Function} onErrorCallback - The callback function called on file error.
 * @param  {Object} onErrorContext - The callback context for file error.
 */
KEN.Loader.prototype.xml = function(key, url, onCompleteCallback, onCompleteContext, onErrorCallback, onErrorContext)
{
    var file = new KEN.File();
    file["type"] = "xml";
    file["key"] = key;
    file["url"] = url;
    file.onCompleteCallback = onCompleteCallback;
    file.onCompleteContext = onCompleteContext;
    file.onErrorCallback = onCompleteCallback;
    file.onErrorContext = onErrorContext;

    this._xhr(file, "document", this._xmlLoadComplete, this._xmlLoadError);
};

/**
 * Internal method called when a xml file is completed.
 * @method KEN.Loader#_xmlLoadComplete
 * @private
 * @param {KEN.File} file - The {@link KEN.File} corresponding to the xml file.
 * @param {XMLHttpRequest} xhr - The XMLHttpRequest response.
 */
KEN.Loader.prototype._xmlLoadComplete = function(file, xhr)
{
    if (xhr.responseXML)
    {
        file["data"] = xhr.responseXML;

        if (this._viewer["cache"].has(KEN.Cache.types.XML, file["key"]) === false)
        {
            this._viewer["cache"].add(KEN.Cache.types.XML, file["key"], file);
        }
        else
        {
            this.log("KEN.Loader.xml : XML file already exists");
        }

        if (typeof file.onCompleteCallback === "function" && file.onCompleteContext !== null)
        {
            var callback = file.onCompleteCallback;
            var context = file.onCompleteContext;

            file.onCompleteCallback = null;
            file.onCompleteContext = null;
            file.onErrorCallback = null;
            file.onErrorContext = null;

            callback.call(context, file);
        }
    }
    else
    {
        throw "KEN.Loader.xml : XML file empty ?";
    }
};

/**
 * Internal method called when the load of a xml file return error.
 * @method KEN.Loader#_xmlLoadError
 * @private
 * @param {KEN.File} file - The {@link KEN.File} corresponding to the xml file.
 * @param {XMLHttpRequest} xhr - The XMLHttpRequest response.
 */
KEN.Loader.prototype._xmlLoadError = function(file, xhr)
{
    if (xhr.responseXML)
    {
        if (typeof file.onErrorCallback === "function" && file.onErrorContext !== null)
        {
            var callback = file.onErrorCallback;
            var context = file.onErrorContext;

            file.onCompleteCallback = null;
            file.onCompleteContext = null;
            file.onErrorCallback = null;
            file.onErrorContext = null;

            callback.call(context, file);
        }
    }
    else
    {
        throw "KEN.Loader.xml : JSON file empty ?";
    }
};

/**
 * Load a sound file.
 * @method KEN.Loader#sound
 * @param  {string} key - The key for the sound file.
 * @param  {string} url - The url of the sound file.
 * @param  {Function} onCompleteCallback - The callback function called when file is completed.
 * @param  {Object} onCompleteContext - The callback context when file is completed.
 */
KEN.Loader.prototype.sound = function(key, url, onCompleteCallback, onCompleteContext)
{
    var file = new KEN.File();
    file["type"] = "sound";
    file["key"] = key;
    file["url"] = url;
    file.onCompleteCallback = onCompleteCallback;
    file.onCompleteContext = onCompleteContext;

    if (this._viewer["audio"]["useWebAudio"] === true)
    {
        this._xhr(file, "arraybuffer", this._soundLoadComplete);
    }
    else if (this._viewer["audio"]["useAudioTag"] === true)
    {
        this._loadAudioTag(file, this._soundLoadComplete, this);
    }
};

/**
 * Internal method called when a sound file is completed and use the WebAudio API.
 * @method KEN.Loader#_soundLoadComplete
 * @private
 * @param {KEN.File} file - The {@link KEN.File} corresponding to the sound file.
 * @param {XMLHttpRequest=} xhr - The XMLHttpRequest response.
 */
KEN.Loader.prototype._soundLoadComplete = function(file, xhr)
{

    if (this._viewer["audio"]["useWebAudio"] === true && typeof xhr !== "undefined")
    {
        file["data"] = xhr.response;
    }

    this._viewer["cache"].add(KEN.Cache.types.SOUND, file["key"], file);

    if (typeof file.onCompleteCallback === "function" && file.onCompleteContext !== null)
    {
        file.onCompleteCallback.call(file.onCompleteContext, file);
    }
};

/**
 * Internal method called when a sound file is completed and use the AudioTag.
 * @method KEN.Loader#_loadAudioTag
 * @private
 * @param {KEN.File} file - The {@link KEN.File} corresponding to the sound file.
 * @param {Function} callback - The callback function called when file is completed.
 * @param  {Object} context - The callback context when file is completed.
 */
KEN.Loader.prototype._loadAudioTag = function(file, callback, context)
{
    // Populate Audio tag data
    file["data"] = new Audio();
    // file["data"]["name"] = file["key"];

    file["data"]["preload"] = "auto";
    file["data"].src = file["url"]; //this.transformUrl(file["url"], file);

    var canPlayEvent = "canplaythrough";
    var canPlayThroughEvent = function()
    {
        file["data"].removeEventListener(canPlayEvent, canPlayThroughEvent, false);
        file["data"].onerror = null;

        if (typeof callback === "function")
        {
            callback.call(context, file);
        }
    };
    file["data"].onerror = function()
    {
        file["data"].removeEventListener(canPlayEvent, canPlayThroughEvent, false);
        file["data"].onerror = null;
        throw "KEN.Loader._loadAudioTag : Could not load " + file.url;
    };

    if (typeof file["data"].oncanplaythrough === "undefined")
    {
        canPlayEvent = "canplay";
    }
    file["data"].addEventListener(canPlayEvent, canPlayThroughEvent, false);
    file["data"].load();
};

/**
 * Internal method to load data from XMLHttpRequest.
 * @method KEN.Loader#_xhr
 * @private
 * @param {KEN.File} file - The {@link KEN.File} corresponding to the file to load.
 * @param {string} type - The type of the object to load.
 * @param {Function} onComplete - The callback function called when file is completed.
 * @param {Function=} onError - The callback function for error during the load.
 * @param {Function=} onProgress - The callback function for the progress of the load.         
 */
KEN.Loader.prototype._xhr = function(file, type, onComplete, onError, onProgress)
{
    file.loading = true;

    var xhr = new XMLHttpRequest();
    xhr.open("GET", file["url"], true);
    xhr.responseType = type;

    var length = 0;

    var _this = this;

    /** @this {XMLHttpRequest} */
    xhr.onreadystatechange = function()
    {
        if (xhr.readyState === XMLHttpRequest.DONE)
        {
            if (xhr.status === 200 || xhr.status === 0)
            {
                this.onreadystatechange = null;

                if (typeof onComplete === "function")
                {
                    file["loaded"] = true;
                    onComplete.call(_this, file, xhr);
                }
            }
            else
            {
                throw "KEN.Loader._xhr : Could not load " + file.url;
            }
        }
        else if (xhr.readyState === XMLHttpRequest.LOADING)
        {
            if (onProgress !== null && typeof onProgress !== "undefined")
            {
                if (length === 0)
                {
                    length = xhr.getResponseHeader("Content-Length");
                }

                if (typeof onProgress !== "undefined")
                {
                    onProgress(
                    {
                        "total": length,
                        "loaded": xhr.responseText.length
                    });
                }
            }
        }
        else if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED)
        {
            if (onProgress !== null && typeof onProgress !== "undefined")
            {
                length = xhr.getResponseHeader("Content-Length");
            }
        }

    };

    xhr.onerror = function()
    {
        if (typeof onError === "function")
        {
            onError.call(_this, file, xhr);
        }
    };

    xhr.send();
};

/**
 * Load an image file.
 * @method KEN.Loader#image
 * @param  {string} key - The key for the image file.
 * @param  {string} url - The url of the image file.
 * @param  {Function} callback - The callback function called when file is completed.
 * @param  {Object} context - The callback context when file is completed.
 */
KEN.Loader.prototype.image = function(key, url, callback, context)
{
    var file = new KEN.File();
    file["type"] = "image";
    file["key"] = key;
    file["url"] = url;
    file["data"] = new Image();

    file["data"].crossOrigin = "anonymous";

    var _this = this;

    file["data"].onload = function()
    {
        file["data"].onload = null;
        file["data"].onerror = null;

        file.loading = false;
        file["loaded"] = true;

        _this._viewer["cache"].add(KEN.Cache.types.IMAGE, file["key"], file);
        callback.call(context, file);

        _this = null;
    };

    file["data"].onerror = function()
    {
        file["data"].onload = null;
        file["data"].onerror = null;

        throw "ERROR : KEN.Loader.image, failed to load image key : " + key + " at url " + url;
    };

    file["data"].src = file["url"];
    file.loading = true;
};

/**
 * Load a script file.
 * @method KEN.Loader#script
 * @param  {string} url - The url of the js file.
 * @param  {Function} callback - The callback function called when file is completed.
 * @param  {Object} context - The callback context when file is completed.
 */
KEN.Loader.prototype.script = function(url, callback, context)
{
    var head = document.getElementsByTagName("head")[0];
    var scripts = head.getElementsByTagName("script");

    //Check if a script is not already in the head of the document
    for (var i = 0, ii = scripts.length; i < ii; i++)
    {
        if (scripts[i].src === url)
        {
            this.warn("Attempt to load an already loaded script!");
            callback.call(context);
            return;
        }
    }

    var script = document.createElement("script");
    script["type"] = "text/javascript";

    script.onload = function()
    {
        script.onload = null;
        callback.call(context);
    };

    script.src = url;
    head.appendChild(script);
};

/**
 * Load a CSS file.
 * @method KEN.Loader#css
 * @param  {string} url - The url of the CSS file.
 * @param  {Function} callback - The callback function called when file is completed.
 * @param  {Object} context - The callback context when file is completed.
 */
KEN.Loader.prototype.css = function(url, callback, context)
{
    var css = document.createElement("link");
    css["type"] = "text/css";
    css.rel = "stylesheet";

    if (typeof callback !== "undefined" && typeof context !== "undefined")
    {
        css.onload = function()
        {
            css.onload = null;
            callback.call(context);
        };
    }

    css.href = url;
    document.getElementsByTagName("head")[0].appendChild(css);
};

/**
 * Destroy sequence.
 * @method KEN.Loader#destroy
 */
KEN.Loader.prototype.destroy = function()
{
    this._viewer = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Manager for the dependencies (scripts).
 *
 * @constructor  KEN.DependencyManager
 * @param {KEN.Viewer} viewer - Reference to the KEN.Viewer.
 * @extends {KEN.BaseObject}
 */
KEN.DependencyManager = function(viewer)
{
    /**
     * Viewer reference.
     * @name KEN.DependencyManager#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Number of dependencies.
     * @name KEN.DependencyManager#_dependenciesCounter
     * @type {number}
     * @private
     */
    this._dependenciesCounter = 0;

    /**
     * Number of loaded dependencies.
     * @name KEN.DependencyManager#_dependenciesLoaded
     * @type {number}
     * @private
     */
    this._dependenciesLoaded = 0;

    /**
     * On all dependencies scripts loaded event dispatcher.
     * @name  KEN.DependencyManager#_onAllScriptsLoaded
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onAllScriptsLoaded = null;

    KEN.BaseObject.call(this, "DependencyManager");
};

KEN.DependencyManager.prototype = Object.create(KEN.BaseObject.prototype);
KEN.DependencyManager.prototype.constructor = KEN.DependencyManager;

/**
 * Add dependency data.
 * @method KEN.DependencyManager#add
 * @param {Object} config - The configuration data.
 */
KEN.DependencyManager.prototype.add = function(config)
{
    if(typeof config === "undefined")
    {
        return;
    }

    if(typeof config["url"] === "string")
    {
        this._dependenciesCounter++;
        this._viewer["load"].script(config["url"], this._scriptLoadComplete, this);
    }
};

/**
 * Internal callback when a dependency script is loaded.
 * @method KEN.DependencyManager#_scriptLoadComplete
 * @private
 */
KEN.DependencyManager.prototype._scriptLoadComplete = function()
{
    this._dependenciesLoaded++;

    this._allScriptsLoaded();
};

/**
 * All dependencies are loaded?
 * @method KEN.DependencyManager#_allScriptsLoaded
 * @private
 */
KEN.DependencyManager.prototype._allScriptsLoaded = function()
{
    if ((this._dependenciesCounter - this._dependenciesLoaded) === 0)
    {
        console.log("DependencyManager : all scripts loaded");

        if(this._onAllScriptsLoaded !== null)
        {
            this._onAllScriptsLoaded.dispatch();
        }
    }
};

/**
 * Destroy method.
 * @method KEN.DependencyManager#destroy
 */
KEN.DependencyManager.prototype.destroy = function()
{
    this._viewer = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
* Get the number of dependencies.
* @name KEN.DependencyManager#dependencies
* @type {number}
*/
KEN.DependencyManager.prototype.dependencies;
Object.defineProperty(KEN.DependencyManager.prototype, "dependencies",
{
    /** @this {KEN.DependencyManager} */
    get: function()
    {
        return this._dependenciesCounter;
    }
});

/**
 * Get the "onAllDependenciesComplete" {@link KEN.EventDispatcher} of the DependencyManager.
 * @name KEN.DependencyManager#onAllScriptsLoaded
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.DependencyManager.prototype.onAllScriptsLoaded;
Object.defineProperty(KEN.DependencyManager.prototype, "onAllScriptsLoaded",
{
    /** @this {KEN.DependencyManager} */
    get: function()
    {
        if(this._onAllScriptsLoaded === null)
        {
            this._onAllScriptsLoaded = new KEN.EventDispatcher(this);
        }

        return this._onAllScriptsLoaded;
    }
});


/**
 * Handle the time.
 * @constructor KEN.Clock
 * @param {KEN.Viewer} viewer - The {@link KEN.Viewer} reference.
 * @extends {KEN.BaseObject}
 */
KEN.Clock = function(viewer)
{
    /**
     * The viewer reference.
     * @name KEN.Clock#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The current time.
     * @name KEN.Timer#_time
     * @type {number}
     * @private
     */
    this._time = 0;

    /**
     * Time from raf
     * @name KEN.Clock#_rafTime
     * @type {number}
     * @private
     */
    this._rafTime = 0;

    /**
     * Started time.
     * @name KEN.Timer#_started
     * @type {number}
     * @private
     */
    this._started = 0;

    /**
     * The {KEN.Timer} list.
     * @name KEN.Timer#_timers
     * @type {Array<KEN.Timer>}
     * @private
     */
    this._timers = null;

    KEN.BaseObject.call(this, "Clock");

    this._boot();
};

KEN.Clock.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Clock.prototype.constructor = KEN.Clock;

/**
 * Boot sequence.
 * @name KEN.Clock#_boot
 * @private
 */
KEN.Clock.prototype._boot = function()
{
    this._started = Date.now();
    this._time = Date.now();
    this._timers = [];
};

/**
 * Returns the timer identifier.
 * @name KEN.Clock#_indexOfTimer
 * @param  {KEN.Timer} timer - The timer to search for.
 * @return {number} Returns the {KEN.Timer} identifier into the list of timers, if not, returns -1.
 * @private
 */
KEN.Clock.prototype._indexOfTimer = function(timer)
{
    if(this._timers === null)
    {
        return -1;
    }

    var t;
    for ( var i = 0, ii = this._timers.length; i < ii; i++ )
    {
        t = this._timers[i];

        if(t === timer)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Internal handler for timer destroy.
 * @name KEN.Clock#_onTimerDestroy
 * @param  {KEN.Event} event - The event.
 * @private
 */
KEN.Clock.prototype._onTimerDestroy = function(event)
{
    var timer = /** @type {KEN.Timer} */ (event["emitter"]);
    var index = this._indexOfTimer(timer);

    if(index !== -1)
    {
        this._timers.splice(index, 1);
    }
};

/**
 * Create a {KEN.Timer} for the clock.
 * @name KEN.Clock#create
 * @param  {boolean} autoDestroy - The timer must be destroyed once completed?
 * @return {KEN.Timer} The created {@link KEN.Timer}.
 */
KEN.Clock.prototype.create = function(autoDestroy)
{
    var timer = new KEN.Timer(this._viewer, autoDestroy);
    return this.add(timer);
};

/**
 * Add a {@link KEN.Timer} to the clock.
 * @name KEN.Clock#add
 * @param {KEN.Timer} timer - The {KEN.Timer} to add.
 * @return {KEN.Timer} The added {@link KEN.Timer}.
 */
KEN.Clock.prototype.add = function(timer)
{
    this._timers.push(timer);
    timer["onDestroy"].add(this._onTimerDestroy, this);
    return timer;
};

/**
 * Update clock on the main loop.
 * @name KEN.Clock#update
 * @param  {number} time - Time in ms
 */
KEN.Clock.prototype.update = function(time)
{
    this._rafTime = time;

    //Current TimeStamp
    this._time = Date.now();

    for(var i = 0, ii = this._timers.length; i < ii; i++)
    {
        this._timers[i].update(this._time);
    }
};

/**
 * Destroy method.
 * @method KEN.Clock#destroy
 */
KEN.Clock.prototype.destroy = function()
{
    this._viewer = null;

    var i = this._timers.length;
    while(i--)
    {
        this._timers[i].destroy();
    }

    this._timers = null;
};

/**
 * Get the time value.
 * @name KEN.Clock#time
 * @readonly
 * @type {number}
 */
KEN.Clock.prototype.time;
Object.defineProperty(KEN.Clock.prototype, "time",
{
    /** @this {KEN.Clock} */
    get: function()
    {
        return this._time;
    }
});


/**
 * Timer utility that work with {@link KEN.Clock}.
 * @constructor KEN.Timer
 * @param {KEN.Viewer} viewer - The {@link KEN.Viewer} reference.
 * @param {boolean} autoDestroy - Does the timer will autodestroy on time complete?
 * @extends {KEN.BaseObject}
 */
KEN.Timer = function(viewer, autoDestroy)
{
    /**
     * The viewer reference.
     * @name KEN.Timer#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Must be destoyed when time complete?
     * @name KEN.Timer#_viewer
     * @type {boolean}
     * @private
     */
    this._autoDestroy = (typeof autoDestroy !== "undefined") ? autoDestroy : true;

    /**
     * The start time.
     * @name KEN.Timer#_startTime
     * @type {number}
     * @private
     */
    this._startTime = 0;

    /**
     * Is timer running?
     * @name KEN.Timer#_running
     * @type {boolean}
     * @private
     */
    this._running = false;

    /**
     * The time when paused.
     * @name KEN.Timer#_pauseTime
     * @type {number}
     * @private
     */
    this._pauseTime = 0;

    /**
     * The number of pauses.
     * @name KEN.Timer#_pauseTotal
     * @type {number}
     * @private
     */
    this._pauseTotal = 0;

    /**
     * Is timer paused?
     * @name KEN.Timer#_paused
     * @type {boolean}
     * @private
     */
    this._paused = false;

    /**
     * The current time.
     * @name KEN.Timer#_now
     * @type {number}
     * @private
     */
    this._now = 0;

    /**
     * The clock tick.
     * @name KEN.Timer#_tick
     * @type {number}
     * @private
     */
    this._tick = 0;

    /**
     * Is timer expired?
     * @name KEN.Timer#_expired
     * @type {boolean}
     * @private
     */
    this._expired = false;

    /**
     * The list of events.
     * @name KEN.Timer#_events
     * @type {Array<KEN.TimerEvent>}
     * @private
     */
    this._events = null;

     /**
     * Internal reference to the onStart {@link KEN.EventDispatcher}.
     * @name KEN.Timer#_onStart
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onStart = null;

     /**
     * Internal reference to the onPause {@link KEN.EventDispatcher}.
     * @name KEN.Timer#_onPause
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * Internal reference to the onResume {@link KEN.EventDispatcher}.
     * @name KEN.Timer#_onResume
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onResume = null;

     /**
     * Internal reference to the onStop {@link KEN.EventDispatcher}.
     * @name KEN.Timer#_onStop
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onStop = null;

    /**
     * Internal reference to the onComplete {@link KEN.EventDispatcher}.
     * @name KEN.Timer#_onComplete
     * @type {?KEN.EventDispatcher}
     * @private
     */
    this._onComplete = null;

    KEN.BaseObject.call(this, "Timer");

    this._boot();
};

KEN.Timer.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Timer.prototype.constructor = KEN.Timer;

/**
 * Boot sequence.
 * @method KEN.Timer#_boot
 * @private
 */
KEN.Timer.prototype._boot = function()
{
    this._events = [];
    this._now = Date.now();
};

/**
 * Update events.
 * @method KEN.Timer#_updateEvents
 * @param  {number} baseTime - The reference time.
 * @private
 */
KEN.Timer.prototype._updateEvents = function(baseTime)
{
    for(var i = 0; i < this._events.length; i++)
    {
        var event = this._events[i];

        if (event.pendingDelete === false)
        {
            // Work out how long there would have been from when the game paused until the events next tick
            var t = event.tick - baseTime;

            if (t < 0)
            {
                t = 0;
            }

            // Add the difference on to the time now
            event.tick = this._now + t;
        }
    }

    var d = this._nextTick - baseTime;

    if (d < 0)
    {
        this._nextTick = this._now;
    }
    else
    {
        this._nextTick = this._now + d;
    }
};

/**
 * Sort events list to get the next event.
 * @method KEN.Timer#_sort
 * @private
 */
KEN.Timer.prototype._sort = function()
{
    if (this._events.length > 0)
    {
        this._events.sort(this._sortCompare);
        this._nextTick = this._events[0].tick;
    }
};

/**
 * Sort comparison for events.
 * @param  {KEN.TimerEvent} a - First event to compare.
 * @param  {KEN.TimerEvent} b - Second event to compare.
 * @return {number} Returns 1 if bigger, -1 if lower, 0 if equal.
 * @private
 */
KEN.Timer.prototype._sortCompare = function (a, b)
{
    if (a.tick < b.tick)
    {
        return -1;
    }
    else if (a.tick > b.tick)
    {
        return 1;
    }

    return 0;
};

/**
 * Clear pending events.
 * @method KEN.Timer#_clearPendingEvents
 * @private
 */
KEN.Timer.prototype._clearPendingEvents = function ()
{
    var count = this._events.length;

    while (count--)
    {
        if (this._events[count].pendingDelete === true)
        {
            this._events.splice(count, 1);
        }
    }
};

/**
 * Create an event in the timer.
 * @method KEN.Timer#create
 * @param {number} delay - The delay to call the event.
 * @param {boolean} loop - Must be looped?
 * @param {number} repeatCount - Number of repetition.
 * @param {Function} callback - The callback function.
 * @param {Object} callbackContext - The context for the callback function.
 * @param {Array<*>} args - List of arguments.
 * @return {KEN.TimerEvent} Returns the created event.
 */
KEN.Timer.prototype.create = function(delay, loop, repeatCount, callback, callbackContext, args)
{

    delay = Math.round(delay);

    var tick = delay;

    if (this._now === 0)
    {
        tick += this._viewer["clock"]["time"];
    }
    else
    {
        tick += this._now;
    }

    var event = new KEN.TimerEvent(this, delay, tick, repeatCount, loop, callback, callbackContext, args);

    this._events.push(event);

    this._sort();

    this._expired = false;

    return event;
};

/**
 * Add an event in the timer
 * @method KEN.Timer#add
 * @param {number} delay - The delay to call the event.
 * @param {Function} callback - The callback function.
 * @param {Object} callbackContext - The context for the callback function.
 * @return {KEN.TimerEvent} Returns the created event.
 */
KEN.Timer.prototype.add = function(delay, callback, callbackContext)
{
    return this.create(delay, false, 0, callback, callbackContext, Array.prototype.splice.call(arguments, 3));
};

/**
 * Repeat an event in the timer.
 * @method KEN.Timer#repeat
 * @param {number} delay - The delay to call the event.
 * @param {number} repeatCount - The number of repetition.
 * @param {Function} callback - The callback function.
 * @param {Object}   callbackContext - The context for the callback function.
 * @return {KEN.TimerEvent} Returns the created event.
 */
KEN.Timer.prototype.repeat = function(delay, repeatCount, callback, callbackContext)
{
    return this.create(delay, false, repeatCount, callback, callbackContext, Array.prototype.splice.call(arguments, 4));
};

/**
 * Loop an event in the timer.
 * @method KEN.Timer#loop
 * @param {number} delay - The delay to call the event.
 * @param {Function} callback - The callback function.
 * @param {Object} callbackContext - The context for the callback function.
 * @return {KEN.TimerEvent} Returns the created event.
 */
KEN.Timer.prototype.loop = function(delay, callback, callbackContext)
{
    return this.create(delay, true, 0, callback, callbackContext, Array.prototype.splice.call(arguments, 3));
};

/**
 * Remove an event from the timer.
 * @method KEN.Timer#remove
 * @param {KEN.TimerEvent} event - The event to remove.
 * @return {boolean} Returns true if event has been removed, if not, returns false.
 */
KEN.Timer.prototype.remove = function(event)
{
    for (var i = 0; i < this._events.length; i++)
    {
        if (this._events[i] === event)
        {
            this._events[i].pendingDelete = true;
            return true;
        }
    }

    return false;
};

/**
 * Start the timer.
 * @method KEN.Timer#start
 */
KEN.Timer.prototype.start = function()
{
    if(this._running === true)
    {
        return;
    }

    this._startTime = this._viewer["clock"]["time"];
    this._running = true;

    var event;
    for (var i = 0; i < this._events.length; i++)
    {
        event = this._events[i];
        event.tick = event.delay + this._startTime;
    }

    if(this._onStart !== null)
    {
        this._onStart.dispatch();
    }
};

/**
 * Stop the timer.
 * @method KEN.Timer#stop
 * @param {boolean} clear - Clear the events list.
 */
KEN.Timer.prototype.stop = function(clear)
{
    this._running = false;

    if (clear === true || typeof clear === "undefined")
    {
        this._events.length = 0;
    }

    if(this._onStop !== null)
    {
        this._onStop.dispatch();
    }
};

/**
 * Pause the timer.
 * @method KEN.Timer#pause
 */
KEN.Timer.prototype.pause = function()
{
    if (this._running === false || this._paused === true)
    {
        return;
    }

    this._pauseTime = this._viewer["clock"]["time"];
    this._paused = true;

    if(this._onPause !== null)
    {
        this._onPause.dispatch();
    }
};

/**
 * Resume the timer.
 * @method KEN.Timer#resume
 */
KEN.Timer.prototype.resume = function()
{
    if (this._paused === false)
    {
        return;
    }

    var now = this._viewer["clock"]["time"];
    this._pauseTotal += now - this._now;

    this._now = now;
    this._updateEvents(this._pauseTime);
    this._paused = false;

    if(this._onResume !== null)
    {
        this._onResume.dispatch();
    }
};

/**
 * Update the timer from the main loop.
 * @method KEN.Timer#update
 * @param {number} time - The current time.
 */
KEN.Timer.prototype.update = function(time)
{
    if(this._paused === true)
    {
        return;
    }

    var elapsed = time - this._now;
    this._now = time;

    //If elapsed time is superior to 1000ms, we can consider that time has been paused by a brower tab change which makes the raf pause.
    if(elapsed > 1000)
    {
        this._updateEvents(time - elapsed);
    }

    this._clearPendingEvents();

    var count = this._events.length;
    var i = 0;
    var markedForDeletion = 0;

    if (this._running === true && this._now >= this._nextTick && count > 0)
    {
        var event;

        while (i < count && this._running === true)
        {
            event = this._events[i];

            if (this._now >= event.tick && event.pendingDelete === false)
            {
                //  (now + delay) - (time difference from last tick to now)
                var newTick = (this._now + event.delay) - (this._now - event.tick);

                if (newTick < 0)
                {
                    newTick = this._now + event.delay;
                }

                if (event["loop"] === true)
                {
                    event.tick = newTick;
                    event.execute();
                }
                else if (event.repeatCount > 0)
                {
                    event.repeatCount--;
                    event.tick = newTick;
                    event.execute();
                }
                else
                {
                    markedForDeletion++;
                    event.pendingDelete = true;
                    event.execute();
                }

                i++;
            }
            else
            {
                break;
            }
        }

        //  Are there any events left?
        if (this._events.length > markedForDeletion)
        {
            this._sort();
        }
        else
        {
            this._expired = true;
            this._running = false;

            if(this._onComplete !== null)
            {
                this._onComplete.dispatch();
            }
        }
    }

    if (this._expired && this._autoDestroy)
    {
        this.destroy();
    }

};

/**
 * Destroy method.
 * @method KEN.Timer#destroy
 */
KEN.Timer.prototype.destroy = function()
{
    this._running = false;
    this._events = [];

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the auto destroy value.
 * @name KEN.Timer#autoDestroy
 * @readonly
 * @type {boolean}
 */
KEN.Timer.prototype.autoDestroy;
Object.defineProperty(KEN.Timer.prototype, "autoDestroy",
{
    /** @this {KEN.Timer} */
    get: function()
    {
        return this._autoDestroy;
    }
});

/**
 * Get the running value.
 * @name KEN.Timer#running
 * @readonly
 * @type {boolean}
 */
KEN.Timer.prototype.running;
Object.defineProperty(KEN.Timer.prototype, "running",
{
    /** @this {KEN.Timer} */
    get: function()
    {
        return this._running;
    }
});

/**
 * Get the paused value.
 * @name KEN.Timer#paused
 * @readonly
 * @type {boolean}
 */
KEN.Timer.prototype.paused;
Object.defineProperty(KEN.Timer.prototype, "paused",
{
    /** @this {KEN.Timer} */
    get: function()
    {
        return this._paused;
    }
});

/**
 * Get the "onStart" event {@link KEN.EventDispatcher} of the timer.
 * @name KEN.Timer#onStart
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Timer.prototype.onStart;
Object.defineProperty(KEN.Timer.prototype, "onStart",
{
    /** @this {KEN.Timer} */
    get: function()
    {
        if(this._onStart === null)
        {
            this._onStart = new KEN.EventDispatcher(this);
        }

        return this._onStart;
    }
});

/**
 * Get the "onPause" event {@link KEN.EventDispatcher} of the timer.
 * @name KEN.Timer#onPause
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Timer.prototype.onPause;
Object.defineProperty(KEN.Timer.prototype, "onPause",
{
    /** @this {KEN.Timer} */
    get: function()
    {
        if(this._onPause === null)
        {
            this._onPause = new KEN.EventDispatcher(this);
        }

        return this._onPause;
    }
});

/**
 * Get the "onResume" event {@link KEN.EventDispatcher} of the timer.
 * @name KEN.Timer#onResume
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Timer.prototype.onResume;
Object.defineProperty(KEN.Timer.prototype, "onResume",
{
    /** @this {KEN.Timer} */
    get: function()
    {
        if(this._onResume === null)
        {
            this._onResume = new KEN.EventDispatcher(this);
        }

        return this._onResume;
    }
});

/**
 * Get the "onStop" event {@link KEN.EventDispatcher} of the timer.
 * @name KEN.Timer#onStop
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Timer.prototype.onStop;
Object.defineProperty(KEN.Timer.prototype, "onStop",
{
    /** @this {KEN.Timer} */
    get: function()
    {
        if(this._onStop === null)
        {
            this._onStop = new KEN.EventDispatcher(this);
        }

        return this._onStop;
    }
});

/**
 * Get the "onComplete" event {@link KEN.EventDispatcher} of the timer.
 * @name KEN.Timer#onComplete
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Timer.prototype.onComplete;
Object.defineProperty(KEN.Timer.prototype, "onComplete",
{
    /** @this {KEN.Timer} */
    get: function()
    {
        if(this._onComplete === null)
        {
            this._onComplete = new KEN.EventDispatcher(this);
        }

        return this._onComplete;
    }
});

/**
 * Describe a timer event.
 *
 * @constructor KEN.TimerEvent
 * @param {KEN.Timer} timer - The {@link KEN.Timer} that handle this event.
 * @param {number} delay - Delay in millisenconds.
 * @param {number} tick - The current clock tick.
 * @param {number} repeatCount - The number of time the timer should repeat itself.
 * @param {boolean} loop - Does the timer have to loop?
 * @param {Function} callback - The callback function for this timer timer event complete.
 * @param {Object} callbackContext - The context in which the callback have to be executed.
 * @param {Array<*>} args - The arguments to pass to the callback.
 */
KEN.TimerEvent = function(timer, delay, tick, repeatCount, loop, callback, callbackContext, args)
{

    /**
     * The timer object.
     * @name KEN.TimerEvent#timer 
     * @type {KEN.Timer}
     */
    this.timer = timer;

    /**
     * Delay in millisenconds.
     * @name KEN.TimerEvent#delay 
     * @type {number}
     */
    this.delay = delay;

    /**
     * The current clock tick.
     * @name KEN.TimerEvent#tick 
     * @type {number}
     */
    this.tick = tick;

    /**
     * The number of time the timer should repeat itself.
     * @name KEN.TimerEvent#repeatCount 
     * @type {number}
     */
    this.repeatCount = repeatCount - 1;

    /**
     * Does the timer have to loop?
     * @name KEN.TimerEvent#loop 
     * @type {boolean}
     */
    this["loop"] = loop;

    /**
     * The callback function for this timer event complete.
     * @name KEN.TimerEvent#_callback 
     * @type {Function}
     * @private
     */
    this._callback = callback;

    /**
     * The context in which the callback have to be executed.
     * @name KEN.TimerEvent#_callbackContext 
     * @type {Object}
     * @private
     */
    this._callbackContext = callbackContext;

    /**
     * List of arguments.
     * @name KEN.TimerEvent#_args 
     * @type {Array<*>}
     * @private
     */
    this._args = args;

    /**
     * Must be deleted?
     * @name KEN.TimerEvent#pendingDelete 
     * @type {boolean}
     */
    this.pendingDelete = false;
};

KEN.TimerEvent.prototype.constructor = KEN.TimerEvent;

/**
 * Execute the callback with arguments.
 * @method KEN.TimerEvent#execute
 */
KEN.TimerEvent.prototype.execute = function()
{
    this._callback.apply(this._callbackContext, this._args);
};

/**
 * Timeline
 *
 * @constructor KEN.Timeline
 * @param {KEN.Viewer} viewer - Viewer reference.
 * @param {?Array<KEN.Keyframe>=} keyframes - Array of keyframes for this timeline.
 *
 * @extends {KEN.BaseObject}
 */
KEN.Timeline = function(viewer, keyframes)
{
    /**
     * The viewer reference.
     * @name  KEN.Timeline#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Array of {@link KEN.Keyframe} for this timeline
     * @name  KEN.Timeline#_keyframes
     * @type {Array<KEN.Keyframe>}
     * @private
     */
    this._keyframes = keyframes || [];

    KEN.BaseObject.call(this, "Timeline");
};

KEN.Timeline.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Timeline.prototype.constructor = KEN.Timeline;

/**
 * Check if this Timeline object has keyframes.
 * @method  KEN.Timeline#hasKeyframes
 * @return {boolean}
 */
KEN.Timeline.prototype.hasKeyframes = function()
{
    return (this._keyframes !== null && this._keyframes.length > 0);
};

/**
 * Get an Object containing the previous and the next keyframes indexes from a time.
 * @method  KEN.Timeline#getKeyframesIndexesFromTime
 * @param  {number} time - the time to get the keyframes at
 * @return {TimelineKeyframesPrevNextIndexes} the two keyframes indexes
 */
KEN.Timeline.prototype.getKeyframesIndexesFromTime = function(time)
{
    var previous, next;
    var i = this._keyframes.length - 1;
    var timeIsHigher = false;

    while(i >= 0) 
    {
        timeIsHigher = (time >= this._keyframes[i]["timestamp"]);

        if (timeIsHigher || i === 0) 
        {
            break;
        }

        --i;
    }

    previous = timeIsHigher ? i : null;

    if (previous === null && this._keyframes.length > 0) 
    {
        next = 0;   
    }
    else 
    {
        next = (previous < this._keyframes.length - 1) ? previous + 1 : null;
    }

    var result = {previous: previous, next: next};

    return result;
};

/**
 * Get an Object containing the previous and the next keyframes from a time.
 * @param  {number} time - the time to get the keyframes at
 * @return {TimelineKeyframesPrevNext} the two keyframes object
 */
KEN.Timeline.prototype.getKeyframesFromTime = function(time)
{
    var indexes = this.getKeyframesIndexesFromTime(time);
    var previous = (indexes.previous !== null && KEN.Utils.isTypeOf(this._keyframes[indexes.previous], "Keyframe") === true) ? this._keyframes[indexes.previous] : null;
    var next = (indexes.next !== null && KEN.Utils.isTypeOf(this._keyframes[indexes.next], "Keyframe") === true) ? this._keyframes[indexes.next] : null;

    var result = {previous: previous, next: next};

    return result;
};

/**
 * Pass a time and get a normalized one.
 * @param  {number} time - the time to normalize
 * @return {number} the normalized time
 */
KEN.Timeline.prototype.getNormalizedTime = function(time)
{
    var keyframes = this.getKeyframesFromTime(time);

    if(keyframes.previous === null || keyframes.next === null)
    {
        return 0;
    }
    else
    {
        return (time - keyframes.previous["timestamp"]) / (keyframes.next["timestamp"] - keyframes.previous["timestamp"]);
    }
};

/**
 * Destroy this object.
 */
KEN.Timeline.prototype.destroy = function()
{
    this._viewer = null;
    this._keyframes = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
* Get the keyframes array.
* @name KEN.Timeline#keyframes
* @readonly
* @type {Array} 
*/
KEN.Timeline.prototype.keyframes;
Object.defineProperty(KEN.Timeline.prototype, "keyframes", 
{
    /** @this {KEN.Timeline} */
    get: function()
    {
        return this._keyframes;
    },

    /** @this {KEN.Timeline} */
    set: function(value)
    {
        if(KEN.Utils.isArrayOf(value, "Keyframe"))
        {
            this._keyframes = value;
        }
    }
});

/**
 * A keyframe is a data associated to a timestamp.
 * @constructor KEN.Keyframe
 * @param {number} timestamp - Timestamp of the keyframe.
 * @param {*} data - Data bindd to the keyframe.
 * @extends {KEN.BaseObject}
 */
KEN.Keyframe = function(timestamp, data)
{
    KEN.BaseObject.call(this, "Keyframe");

    /**
     * The timestamp associated to this keyframe.
     * @name  KEN.Keyframe#_timestamp
     * @type {number}
     * @private
     */
    this._timestamp = timestamp;

    /**
     * The data associated to this keyframe.
     * @name KEN.Keyframe#_data
     * @type {*}
     * @private
     */
    this._data = data;
};

KEN.Keyframe.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Keyframe.prototype.constructor = KEN.Keyframe;

/**
 * Get and set the timestamp of keyframe.
 * @name KEN.Keyframe#timestamp
 * @type {number}
 */
KEN.Keyframe.prototype.timestamp;
Object.defineProperty(KEN.Keyframe.prototype, "timestamp", 
{
    /** @this {KEN.Keyframe} */
    get: function()
    {
        return this._timestamp;
    },

    /** @this {KEN.Keyframe} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._timestamp = value;
        }
    }
});





/**
 * Manages the {@link KEN.Tween}.
 * @constructor KEN.TweenManager
 * @param {KEN.Viewer} viewer - The {@link KEN.Viewer} reference.
 * @extends {KEN.BaseObject}
 */
KEN.TweenManager = function(viewer)
{
    /**
     * The viewer reference. 
     * @name KEN.TweenManager#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The list of {KEN.Tween}. 
     * @name KEN.TweenManager#_tweens
     * @type {Array<KEN.Tween>}
     * @private
     */
    this._tweens = [];

    KEN.BaseObject.call(this, "TweenManager");
};

KEN.TweenManager.prototype = Object.create(KEN.BaseObject.prototype);
KEN.TweenManager.prototype.constructor = KEN.TweenManager;

/**
 * Internal handler to destroy a tween.
 * @method KEN.TweenManager#_indexOfTween
 * @param {KEN.Tween} tween - The {KEN.Tween} to look for.
 * @return {number} Returns the tween identifier, if not, returns -1.
 * @private
 */
KEN.TweenManager.prototype._indexOfTween = function(tween)
{
    for ( var i = 0, ii = this._tweens.length; i < ii; i++ )
    {
        if(tween === this._tweens[i])
        {
            return i;
        }
    }

    return -1;
};

/**
 * Internal handler to destroy a tween.
 * @method KEN.TweenManager#_tweenDestroyHandler
 * @param {KEN.Event} event - The event.
 * @private
 */
KEN.TweenManager.prototype._tweenDestroyHandler = function(event)
{
    var tween = /** @type {KEN.Tween} */ (event["emitter"]);
    this.remove(tween);
};

/**
 * Add a tween.
 * @method KEN.TweenManager#add
 * @param {KEN.Tween} tween - The {KEN.Tween} to add.
 */
KEN.TweenManager.prototype.add = function(tween)
{
    this._tweens.push(tween);
    tween["onDestroy"].addOnce(this._tweenDestroyHandler, this);
};

/**
 * Remove a tween.
 * @method KEN.TweenManager#remove
 * @param {KEN.Tween} tween - The {KEN.Tween} to remove.
 */
KEN.TweenManager.prototype.remove = function(tween)
{
    var index = this._indexOfTween(tween);

    if(index !== -1)
    {
        this._tweens.splice(index, 1);
    }
};

/**
 * Update loop.
 * @method KEN.TweenManager#update
 */
KEN.TweenManager.prototype.update = function()
{
    for(var i = 0, ii = this._tweens.length; i < ii; i++)
    {
        this._tweens[i].update();
    }
};

/**
 * Destroy method.
 * @method KEN.TweenManager#destroy
 */
KEN.TweenManager.prototype.destroy = function()
{
    var count = this._tweens.length;
    while(count--)
    {
        this._tweens[count].destroy();
    }

    this._tweens = null;
    this._viewer = null;

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Utility class to interpolate objects values.
 * @constructor KEN.Tween
 * @param {KEN.Viewer} viewer - The {@link KEN.Viewer} reference.
 * @param {Object} object - The object to interpolate its property.
 * @extends {KEN.BaseObject}
 */
KEN.Tween = function(viewer, object)
{
    /**
     * The viewer reference.
     * @name KEN.Tween#_viewer
     * @type {KEN.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The targeted object.
     * @name KEN.Tween#_object
     * @type {Object}
     * @private
     */
    this._object = object;

    /**
     * The tween properties.
     * @name KEN.Tween#_properties
     * @type {Object<string,TweenProperties>}
     * @private
     */
    this._properties = null;

    /**
     * The easing method.
     * @name KEN.Tween#_easing
     * @type {Function}
     * @private
     */
    this._easing = KEN.Easing.LINEAR;

    /**
     * The start time.
     * @name KEN.Tween#_startTime
     * @type {?number}
     * @private
     */
    this._startTime = null;

    /**
     * Is started?
     * @name KEN.Tween#_started
     * @type {boolean}
     * @private
     */
    this._started = false;

    /**
     * Is stopped?
     * @name KEN.Tween#_stopped
     * @type {boolean}
     * @private
     */
    this._stopped = false;

    /**
     * Is completed?
     * @name KEN.Tween#_complete
     * @type {boolean}
     * @private
     */
    this._complete = false;

    /**
     * Tween start event dispatcher.
     * @name  KEN.Tween#_onStart
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onStart = null;

    /**
     * Tween progress event dispatcher.
     * @name  KEN.Tween#_onProgress
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onProgress = null;

    /**
     * Tween complete event dispatcher.
     * @name  KEN.Tween#_onComplete
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onComplete = null;

    /**
     * Tween stop event dispatcher.
     * @name  KEN.Tween#_onStop
     * @type {KEN.EventDispatcher}
     * @private
     */
    this._onStop = null;

    KEN.BaseObject.call(this, "Tween");
};

KEN.Tween.prototype = Object.create(KEN.BaseObject.prototype);
KEN.Tween.prototype.constructor = KEN.Tween;

/**
 * Set the tween properties.
 * @method  KEN.Tween#to
 * @param  {Array|Object} values - Array of values.
 * @param  {number} duration - Duration of the tween.
 * @param  {Function=} easing - Easing value.
 * @return {KEN.Tween} Returns the {KEN.Tween} object.
 */
KEN.Tween.prototype.to = function(values, duration, easing)
{
    if (this._properties === null)
    {
        this._properties = {};
    }

    for (var p in values)
    {
        this._properties[p] = {
            name: p,
            min: null,
            max: values[p],
            duration: typeof duration === "number" ? duration : 0,
            easing: typeof easing === "function" ? easing : null,
            started: false,
            complete: false,
            startTime: null
        };
    }

    return this;
};

/**
 * Start the tween.
 * @method  KEN.Tween#start
 * @return {KEN.Tween} Returns the {KEN.Tween} object.
 */
KEN.Tween.prototype.start = function()
{
    this._startTime = Date.now();
    this._started = true;
    this._stopped = false;
    this._complete = false;

    var prop;
    for (var p in this._properties)
    {
        prop = this._properties[p];
        prop.min = this._object[p];
        prop.max = typeof this._properties[p].max === "string" ? prop.min + parseInt(this._properties[p].max, 10) : prop.max;
        prop.started = true;
        prop.startTime = this._startTime;
    }

    if (this._onStart !== null)
    {
        this._onStart.dispatch();
    }

    return this;
};

/**
 * Stop the tween.
 * @method  KEN.Tween#start
 * @return {KEN.Tween} Returns the {KEN.Tween} object.
 */
KEN.Tween.prototype.stop = function()
{
    this._stopped = true;

    if (this._onStop !== null)
    {
        this._onStop.dispatch();
    }

    return this;
};

/**
 * Update loop.
 * @method  KEN.Tween#update
 */
KEN.Tween.prototype.update = function()
{
    if (this._started === false || this._complete === true || this._stopped === true)
    {
        return;
    }

    var prop;
    var notCompleteCount = 0;
    for (var p in this._properties)
    {
        prop = this._properties[p];

        if (prop["complete"] === false)
        {
            this._updateProperty(prop);
        }

        if (prop["complete"] === false)
        {
            notCompleteCount++;
        }
    }

    if (this._onProgress !== null)
    {
        this._onProgress.dispatch();
    }

    if (notCompleteCount === 0)
    {
        this._complete = true;

        if (this._onComplete !== null)
        {
            this._onComplete.dispatch();
        }
    }
};

/**
 * Update the tween properties.
 * @method  KEN.Tween#_updateProperty
 * @param {Object} prop - The properties object.
 * @private
 */
KEN.Tween.prototype._updateProperty = function(prop)
{
    var currentTime = Date.now();
    var deltaTime = currentTime - prop.startTime;

    prop["complete"] = deltaTime >= prop["duration"];

    if (prop["complete"] === false)
    {
        var easing = prop["easing"] !== null ? prop["easing"] : this._easing;
        var y = easing(deltaTime / prop["duration"]);
        this._object[prop["name"]] = (y * (prop.max - prop.min) + prop.min);
    }
    else
    {
        this._object[prop["name"]] = prop.max;
    }
};

/**
 * Destroy method.
 * @method KEN.Tween#destroy
 */
KEN.Tween.prototype.destroy = function()
{
    this.stop();

    this._viewer = null;

    this._object = null;

    this._properties = null;

    this._easing = null;

    if (this._onStart !== null)
    {
        this._onStart.destroy();
        this._onStart = null;
    }

    if (this._onProgress !== null)
    {
        this._onProgress.destroy();
        this._onProgress = null;
    }

    if (this._onComplete !== null)
    {
        this._onComplete.destroy();
        this._onComplete = null;
    }

    if (this._onStop !== null)
    {
        this._onStop.destroy();
        this._onStop = null;
    }

    KEN.BaseObject.prototype.destroy.call(this);
};

/**
 * Get and set the easing method.
 * @name  KEN.Tween#easing
 * @type {Function}
 */
KEN.Tween.prototype.easing;
Object.defineProperty(KEN.Tween.prototype, "easing",
{
    /** @this {KEN.Tween} */
    get: function()
    {
        return this._easing;
    },

    /** @this {KEN.Tween} */
    set: function(easing)
    {
        if (typeof easing === "function")
        {
            this._easing = easing;
        }
    }
});

/**
 * Get the complete flag value.
 * @name  KEN.Tween#complete
 * @readonly
 * @type {boolean}
 */
KEN.Tween.prototype.complete;
Object.defineProperty(KEN.Tween.prototype, "complete",
{
    /** @this {KEN.Tween} */
    get: function()
    {
        return this._complete;
    }
});

/**
 * Get the onStart {@link KEN.EventDispatcher}
 * @name  KEN.Tween#onStart
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Tween.prototype.onStart;
Object.defineProperty(KEN.Tween.prototype, "onStart",
{
    /** @this {KEN.Tween} */
    get: function()
    {
        if (this._onStart === null)
        {
            this._onStart = new KEN.EventDispatcher(this);
        }

        return this._onStart;
    }
});

/**
 * Get the onProgress {@link KEN.EventDispatcher}
 * @name  KEN.Tween#onProgress
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Tween.prototype.onProgress;
Object.defineProperty(KEN.Tween.prototype, "onProgress",
{
    /** @this {KEN.Tween} */
    get: function()
    {
        if (this._onProgress === null)
        {
            this._onProgress = new KEN.EventDispatcher(this);
        }

        return this._onProgress;
    }
});

/**
 * Get the onComplete {@link KEN.EventDispatcher}
 * @name  KEN.Tween#onComplete
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Tween.prototype.onComplete;
Object.defineProperty(KEN.Tween.prototype, "onComplete",
{
    /** @this {KEN.Tween} */
    get: function()
    {
        if (this._onComplete === null)
        {
            this._onComplete = new KEN.EventDispatcher(this);
        }

        return this._onComplete;
    }
});

/**
 * Get the onStop {@link KEN.EventDispatcher}
 * @name  KEN.Tween#onStop
 * @readonly
 * @type {KEN.EventDispatcher}
 */
KEN.Tween.prototype.onStop;
Object.defineProperty(KEN.Tween.prototype, "onStop",
{
    /** @this {KEN.Tween} */
    get: function()
    {
        if (this._onStop === null)
        {
            this._onStop = new KEN.EventDispatcher(this);
        }

        return this._onStop;
    }
});
/**
 * Namespace to store all easing methods.
 * @name KEN.Easing
 * @type {Object}
 */
KEN.Easing = {};

/**
 * @method KEN.Easing.LINEAR
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
KEN.Easing.LINEAR = function(t)
{
    var y = t;
    return KEN.Math.clamp(y, 0, 1);
};

/**
 * @method KEN.Easing.SINE_IN
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
KEN.Easing.SINE_IN = function(t)
{
    var y = 1.0 + Math.sin(Math.PI / 2.0 * (t - 1.0));
    return KEN.Math.clamp(y, 0, 1);
};

/**
 * @method KEN.Easing.SINE_IN_OUT
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
KEN.Easing.SINE_IN_OUT = function(t)
{
    var y = 0.5 * (1.0 + Math.sin(Math.PI / 2.0 * (2.0 * t - 1.0)));
    return KEN.Math.clamp(y, 0, 1);
};

/**
 * @method KEN.Easing.SINE_OUT
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
KEN.Easing.SINE_OUT = function(t)
{
    var y = Math.sin(Math.PI / 2.0 * t);
    return KEN.Math.clamp(y, 0, 1);
};

/**
 * @method KEN.Easing.QUAD_IN
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
KEN.Easing.QUAD_IN = function(t)
{
    var y = t * t;
    return KEN.Math.clamp(y, 0, 1);
};

/**
 * @method KEN.Easing.QUAD_IN_OUT
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
KEN.Easing.QUAD_IN_OUT = function(t)
{
    var y;
    if (t < 0.5)
    {
        y = 2.0 * t * t;
    }
    else
    {
        y = 1.0 - 2.0 * (t - 1.0) * (t - 1.0);
    }

    return KEN.Math.clamp(y, 0, 1);
};

/**
 * @method KEN.Easing.QUAD_OUT
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
KEN.Easing.QUAD_OUT = function(t)
{
    t = 1.0 - t;
    var y = 1.0 - (t * t);
    return KEN.Math.clamp(y, 0, 1);
};

/**
 * @method KEN.Easing.CUBIC_IN
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
KEN.Easing.CUBIC_IN = function(t)
{
    var y = t * t * t;
    return KEN.Math.clamp(y, 0, 1);
};

/**
 * @method KEN.Easing.CUBIC_IN_OUT
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
KEN.Easing.CUBIC_IN_OUT = function(t)
{
    var y;
    if (t < 0.5)
    {
        y = 4.0 * t * t * t;
    }
    else
    {
        y = 1.0 + 4.0 * (t - 1.0) * (t - 1.0) * (t - 1.0);
    }

    return KEN.Math.clamp(y, 0, 1);
};

/**
 * @method KEN.Easing.CUBIC_OUT
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
KEN.Easing.CUBIC_OUT = function(t)
{
    t = 1.0 - t;
    var y = 1.0 - (t * t * t);
    return KEN.Math.clamp(y, 0, 1);
};

/**
 * @method KEN.Easing.BOUNCE_OUT
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
KEN.Easing.BOUNCE_OUT = function (t)
{

    var y;
    if (t < 1 / 2.75)
    {
        y = 7.5625 * t * t;
    }
    else if (t < 2/2.75)
    {
        t = t - (1.5 / 2.75);
        y = 7.5625 * t * t + 0.75;
    }
    else if (t < 2.5 / 2.75)
    {
        t = t - 2.25 / 2.75;
        y = 7.5625 * t * t + 0.9375;
    }
    else
    {
        t = t - 2.625 / 2.75;
        y = 7.5625 * t * t + 0.984375;
    }
    return KEN.Math.clamp(y, 0, 1);
};

/**
 * @method KEN.Easing.BOUNCE_IN
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
KEN.Easing.BOUNCE_IN = function (t)
{
    return 1.0 - KEN.Easing.BOUNCE_OUT(1-t);
};


/**
 * Global utilities.
 * @namespace  KEN.Utils
 * @type {Object}
 */
KEN.Utils = {};

/**
 * Convert a string value into a size object.
 * @method KEN.Utils.parseSizeString
 * @param {string} value - The string value to convert.
 * @return {Object} A size object with value and unit.
 */
KEN.Utils.parseSizeString = function(value)
{
    var result = { value: null, unit: null };

    if(typeof value === "string")
    {
        var size = parseInt(value, 10);
        if(isNaN(size) === false)
        {
            result["value"] = size;
        }

        if(value.indexOf("%") > -1)
        {
            result.unit = "%";
        }
        else if(value.indexOf("px") > -1)
        {
            result.unit = "px";
        }
    }

    return result;
};

/**
 * TODO. Use for config extend / override.
 * @method KEN.Utils.extendSimpleObject
 * @param  {Object}   from
 * @param  {Object}   to
 * @param  {boolean=} recursive
 * @return {Object}
 */
KEN.Utils.extendSimpleObject = function(from, to, recursive)
{
    var result = {};

    from = (typeof from !== "undefined") ? from : {};
    to = (typeof to !== "undefined") ? to : {};

    for(var f in from)
    {
        if(from.hasOwnProperty(f)) //to guarantee that keys are on the object instance itself
        {
            result[f] = from[f];
        }
    }

    for(var t in to)
    {
        if(to.hasOwnProperty(t)) //to guarantee that keys are on the object instance itself
        {
            if(recursive !== false && from !== null && to[t] !== null && typeof to[t] !== "undefined" && to[t].constructor === Object)
            {
                result[t] = KEN.Utils.extendSimpleObject(from[t], to[t], true);
            }
            else
            {
                result[t] = to[t];
            }
        }
    }

    return result;
};

/**
 * Extend multiple object you pass in arguments, the last overrides the first and so on ...
 * @method  KEN.Utils.extedMultipleObjects
 * @param  {...Object} obj - the objects to merge
 * @return {Object} return the merged objects.
 */
//jscs:disable
KEN.Utils.extendMultipleObjects = function(obj)
{


    var objects = arguments;
    var res = {};

    for(var i = 0, ii = objects.length; i < ii; i++)
    {
        res = KEN.Utils.extendSimpleObject(res, objects[i], true);
    }

    return res;
};
//jscs:enable

/**
 * Is the object a display object? Check the className.
 * @method KEN.Utils.isDisplayObject
 * @param {Object} object - The object to verify.
 * @return {boolean} Returns true if the object is a display object.
 */
KEN.Utils.isDisplayObject = function(object)
{
    if(object !== null && typeof object === "object")
    {
        if(typeof object["className"] === "string" && KEN.DisplayList.types.indexOf(object["className"]) !== -1)
        {
            return true;
        }
    }

    return false;
};

/**
 * Is the className of the object can be verified?
 * @method KEN.Utils.isTypeOf
 * @param {*} object - The object to verify.
 * @param {(string|Array<string>)} className - The className to search for, it can be a string or an array of string if you accept multiple types.
 * @return {boolean} Returns true if the className of the object can be verified.
 */
KEN.Utils.isTypeOf = function(object, className)
{
    if( typeof className === "string" && ((object !== null && typeof object === "object" && typeof object["className"] === "string" && object["className"].toLowerCase() === className.toLowerCase()) || typeof object === className.toLowerCase()))
    {
        return true;
    }
    else if(Array.isArray(className) === true && KEN.Utils.isArrayOf(className, "string") === true)
    {
        for(var i = 0, ii = className.length; i < ii; i++)
        {
            if(KEN.Utils.isTypeOf(object, className[i]) === true)
            {
                return true;
            }
        }
    }

    return false;
};

/**
 * Check the className of an object based on it's path (pointed syntax in string)<br>
 * Very usefull if you have to check a deep property without the knowing if all the parent chain is defined.
 * @method  KEN.Utils.isTypeOfRecursive
 * @param  {Object}  object - The main object that handle the property you want to check.
 * @param  {string}  path - Path to the target you want to check (example : "image.url" on a button skin state)
 * @param  {string}  className - The className you want to check for
 * @return {boolean} Returns true if object is of the asked className, false if not or if it's not found.
 */
KEN.Utils.isTypeOfRecursive = function(object, path, className)
{
    var pathArray = path.split(".");
    var currentObject = object;

    for(var i=0, ii=pathArray.length; i<ii; i++)
    {
        currentObject = currentObject[pathArray[i]];

        if(i === ii-1)
        {
            return KEN.Utils.isTypeOf(currentObject, className);
        }
        else if(typeof currentObject === "undefined")
        {
            return false;
        }
    }

    return false;
};

/**
 * Know if array is an array full of object of a single className (KEN types).
 * @method KEN.Utils.isArrayOf
 * @param  {*} array - The array to test.
 * @param  {string} className - The className to test if this array is exclusvie to this className.
 * @return {boolean} Returns true if the array is full of object with the className in params.
 */
KEN.Utils.isArrayOf = function(array, className)
{
    if(typeof array === "object" && Array.isArray(array) === true)
    {
        for (var i = 0, ii = array.length; i < ii; i++)
        {
            if(KEN.Utils.isTypeOf(array[i], className) === false)
            {
                return false;
            }
        }

        return true;
    }

    return false;
};


/**
 * Get an objet property by its string path in pointed syntax.
 * @method  KEN.Utils.getObjectProperty
 * @param  {Object}  object - The main object that handle the property you want to check.
 * @param  {string}  property - Path to the property you want to get (example : "image.url" on a button skin state)
 * @param  {*=}  defaultReturnValue - The default return value if not found, if not specified the default is undefined
 * @return {*} Returns the property if found, if not found returns your defaultReturnValue or undefined.
 */
KEN.Utils.getObjectProperty = function(object, property, defaultReturnValue)
{
    var pathArray = property.split(".");
    var currentObject = object;

    for(var i=0, ii=pathArray.length; i<ii; i++)
    {
        currentObject = currentObject[pathArray[i]];

        //If current object is undefined, return default value or undefined
        if(typeof currentObject === "undefined")
        {
            return defaultReturnValue;
        }
        //If this is the target item (the last in property path)
        if(i === ii-1)
        {
            return currentObject;
        }
    }

    return defaultReturnValue;
};

/**
 * Sort an array by property.
 * @method KEN.Utils.sortArrayByProperty
 * @param  {Array} array - The array to test.
 * @param  {Object} property - The property to sort.
 * @return {Array} Returns the sorted array.
 */
KEN.Utils.sortArrayByProperty = function (array, property)
{
    property = property.split(".");
    var len = property.length;

    array.sort(function (a, b)
    {
        var i = 0;

        while( i < len )
        {
            a = a[property[i]];
            b = b[property[i]];
            i++;
        }

        if (a < b)
        {
            return -1;
        }
        else if (a > b)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    });

    return array;
};

/**
 * Fill a string from the left
 * @method KEN.Utils.leftFill
 * @param {string} string - String to fill.
 * @param {string|number} fillCharacter - Char or string to fill with.
 * @param {number} length - The length for the output string.
 * @returns {string} The filled string.
 */
KEN.Utils.leftFill = function(string, fillCharacter, length)
{
    var str = String(string);

    while(str.length < length)
    {
        str = fillCharacter+str;
    }

    return str;
};

/**
 * Parse seconds value in hours, minutes and seconds components.
 * @method KEN.Utils.parseTime
 * @param {number} seconds - Seconds to parse.
 * @returns {Object} Parsed values in an object.
 */
KEN.Utils.parseTime = function(seconds)
{
    var time =
    {
        "input": seconds,
        "hours": 0,
        "minutes": 0,
        "seconds": 0
    };

    //If input is not a parsable value, return time with default values
    if(typeof time.input !== "number" || isNaN(time.input))
    {
        return time;
    }

    time.hours = parseInt(time.input / 3600, 10) % 24;
    time.minutes = parseInt(time.input / 60, 10) % 60;
    time.seconds = parseInt(time.input % 60, 10);

    return time;
};

/**
 * Format a timestamp according to a format (eg: H:M:S)<br>
 * H = hours two digits.<br>
 * h = hours no 0 fill.<br>
 * M = minutes two digits.<br>
 * m = minutes no 0 fill.<br>
 * S = seconds two digits.<br>
 * s = seconds no 0 fill.
 * @method KEN.Utils.formatTime
 * @param  {number} time - Timestamp in seconds.
 * @param  {string} format - The out format for time (default "H:M:S").
 * @return {string} Returns the formated time string.
 */
KEN.Utils.formatTime = function(time, format)
{
    var parsed = KEN.Utils.parseTime(time);

    var f = (typeof format === "string") ? format : "H:M:S";

    var h = 0;
    if(f.indexOf("H") !== -1)
    {
        h = 2;
    }
    else if(f.indexOf("h") !== -1)
    {
        h = 1;
    }

    var m = 0;
    if(f.indexOf("M") !== -1)
    {
        m = 2;
    }
    else if(f.indexOf("m") !== -1)
    {
        m = 1;
    }

    var s = 0;
    if(f.indexOf("S") !== -1)
    {
        s = 2;
    }
    else if(f.indexOf("s") !== -1)
    {
        s = 1;
    }

    var result = f.toLowerCase();

    if(h > 0)
    {
        result = result.replace("h", KEN.Utils.leftFill(parsed.hours, 0, h));
    }

    if(m > 0)
    {
        result = result.replace("m", KEN.Utils.leftFill(parsed.minutes, 0, m));
    }

    if(s > 0)
    {
        result = result.replace("s", KEN.Utils.leftFill(parsed.seconds, 0, s));
    }

    return result;
};

/**
 * Get THREE.Spherical object from euler angles with KEN coordinates
 * @method KEN.Utils.toTHREESpherical
 * @param {number} radius radius
 * @param {number} theta theta angle
 * @param {number} phi phi angle
 * @return {THREE.Spherical} spherical object
 */
KEN.Utils.toTHREESpherical = function(radius, theta, phi)
{
    return new THREE.Spherical(radius, Math.PI / 2 - phi, theta);
};

/**
 * Get object with euler angles in KEN coordinates from a THREE.Spherical object
 * @method KEN.Utils.fromTHREESpherical
 * @param {THREE.Spherical} spherical spherical object
 * @return {Object} spherical object
 */
KEN.Utils.fromTHREESpherical = function(spherical)
{
    var result =
    {
        "radius": spherical.radius,
        "theta": spherical.theta,
        "phi": Math.PI / 2 - spherical.phi
    };

    return result;
};

/**
 * Get an array by difference with another array
 * @method KEN.Utils.arrayByDifference
 * @param  {Array} array input array to be filtered
 * @param  {Array} elements elements to be excluded in result array
 * @return {Array} difference array (array - elements)
 */
KEN.Utils.arrayByDifference = function(array, elements)
{
    return array.filter(function(i)
    {
        return elements.indexOf(i) < 0;
    });
};

/**
 * endsWith ES6 implementation
 * @param  {string} str
 * @param  {string} suffix
 * @return {boolean} Ends with suffix?
 */
KEN.Utils.endsWith = function(str, suffix)
{
    if (typeof String.prototype.endsWith !== "function")
    {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }
    return str.endsWith(suffix);
}


/**
 * Dom manager interface.
 * @type {Object}
 * @namespace KEN.Dom
 */
KEN.Dom = {};

/**
 * Get a CSS property.
 * @method KEN.Dom.getCssProperty
 * @param  {Element} dom - DOM element to evaluate.
 * @param  {string} property - The CSS property you want to get.
 * @return {string} Returns the CSS property.
 */
KEN.Dom.getCssProperty = function(dom, property)
{
    //If I want to get the real percent value, I have to temporarly hide the object to have it's true CSS value.
    var display = window.getComputedStyle(dom, null).getPropertyValue("display");
    dom.style["display"] = "none";

    var result = window.getComputedStyle(dom, null).getPropertyValue(property);
    dom.style["display"] = display;

    return result;
};

/**
 * Get the unit width of an element.
 * @method KEN.Dom.getUnitWidth
 * @param  {Element} dom - DOM element to evaluate.
 * @return {string} Returns the unit. Can be px or %.
 */
KEN.Dom.getUnitWidth = function(dom)
{
    var width = KEN.Dom.getCssProperty(dom, "width");
    var unit = "px";

    if(width.indexOf("%") > -1)
    {
        unit = "%";
    }

    if(width.indexOf("px") > -1)
    {
        unit = "px";
    }

    return unit;
};

/**
 * Get the width value of an element.
 * @method KEN.Dom.getValueWidth
 * @param  {Element} dom - DOM element to evaluate.
 * @return {number} Returns the width.
 */
KEN.Dom.getValueWidth = function(dom)
{
    var width = parseInt(KEN.Dom.getCssProperty(dom, "width"), 10);
    return isNaN(width) ? 0 : width;
};


/**
 * Get the unit height of an element.
 * @method KEN.Dom.getUnitHeight
 * @param  {Element} dom - DOM element to evaluate.
 * @return {string} Returns the unit. Can be px or %.
 */
KEN.Dom.getUnitHeight = function(dom)
{
    var height = KEN.Dom.getCssProperty(dom, "height");
    var unit = "px";

    if(height.indexOf("%") > -1)
    {
        unit = "%";
    }

    if(height.indexOf("px") > -1)
    {
        unit = "px";
    }

    return unit;
};

/**
 * Get the height value of an element.
 * @method KEN.Dom.getValueHeight
 * @param  {Element} dom - DOM element to evaluate.
 * @return {number} Returns the height.
 */
KEN.Dom.getValueHeight = function(dom)
{
    var height = parseInt(KEN.Dom.getCssProperty(dom, "height"), 10);
    return isNaN(height) ? 0 : height;
};

/**
 * Verify if a dom element is on document
 * @param  {Element|HTMLElement}  dom - dom element you want to check
 * @return {boolean}     Returns true if the dom element is in document, false if not
 */
KEN.Dom.has = function(dom)
{
    return document.body.contains(dom);
};

/**
 * Is it an HTMLElement?
 * @method KEN.Dom.isHtmlElement
 * @param  {*} dom - DOM element to evaluate.
 * @return {boolean} Returns true if element is an HTMLElement, if not, false.
 */
KEN.Dom.isHtmlElement = function(dom)
{
    return dom instanceof HTMLElement;
};

/**
 * Get mouse offset values for an element.
 * @method KEN.Dom.getMouseEventOffset
 * @param  {Event|MouseEvent|HammerEvent} event - The event.
 * @return {Object} Object which describe the x and y offset values.
 */
KEN.Dom.getMouseEventOffset = function(event) 
{
    var target, rect, offsetX, offsetY;

    // If the event is coming from HammerJS, the native MouseEvent is in srcEvent property
    // HAMMERJS CASE
    if(typeof event.srcEvent === "object" && event.srcEvent.constructor === MouseEvent)
    {
        target = event["target"];
        rect = target.getBoundingClientRect();
        offsetX = event.srcEvent.clientX - rect["left"];
        offsetY = event.srcEvent.clientY - rect["top"];
    }
    //CLASSIC MOUSE EVENT CASE
    else
    {
        target = event.currentTarget || event.srcElement;
        rect = target.getBoundingClientRect();
        offsetX = event.clientX - rect["left"];
        offsetY = event.clientY - rect["top"];
    }

    return { x: offsetX, y: offsetY };
};


/**
 * Describe a Map.
 * @constructor KEN.Map
 *
 * @todo be carreful with 'key' which can be a keyword as "length" !
 */
KEN.Map = function()
{
    /**
     * The number of elements into the Map.
     * @name KEN.Map#_count
     * @type {number}
     * @private
     */
    this._count = 0;

    /**
     * The map object.
     * @name KEN.Map#_map
     * @type {Object}
     * @private
     */
    this._map = {};
};

KEN.Map.prototype.constructor = KEN.Map;

/**
 * Set an element into the Map.
 * @method KEN.Map.set
 * @param {string} key - The key to assign.
 * @param {?} item - The item to add.
 * @return {number|undefined} The size of the Map.
 */
KEN.Map.prototype.set = function(key, item)
{
    if (typeof key === "undefined")
    {
        return undefined;
    }

    if (this._map[key] === undefined)
    {
        this._count++;
    }

    this._map[key] = item;

    return this._count;
};

/**
 * Delete an element into the Map.
 * @method KEN.Map.delete
 * @param {string} key - The key to search for.
 * @return {number|undefined} The size of the Map.
 */
KEN.Map.prototype.delete = function(key)
{
    if (typeof key === "undefined" || this._map[key] === undefined)
    {
        return undefined;
    }

    delete this._map[key];
    return --this._count;
};

/**
 * Get an element of the Map.
 * @method KEN.Map.get
 * @param {string} key - The key to search for.
 * @return {?} The item linked to the key.
 */
KEN.Map.prototype.get = function(key)
{
    return this._map[key];
};

/**
 * The list of the keys.
 * @method KEN.Map.keys
 * @return {Array<String>} The list of all the Map keys.
 */
KEN.Map.prototype.keys = function()
{
    var keys = new KEN.Collection();

    for (var key in this._map)
    {
        keys.add(key);
    }

    return keys.toArray();
};

/**
 * The list of the values.
 * @method KEN.Map.values
 * @return {Array<?>} The list of all the Map values.
 */
KEN.Map.prototype.values = function()
{
    var values = new KEN.Collection();

    for (var key in this._map)
    {
        values.add(this._map[key]);
    }

    return values.toArray();
};

/**
 * The whole content of the Map.
 * @method KEN.Map.entries
 * @return {Array} The complete key-value list of the Map.
 */
KEN.Map.prototype.entries = function()
{
    var entries = new KEN.Collection();

    for (var key in this._map)
    {
        var entry = [];
        entry.push(key);
        entry.push(this._map[key]);
        entries.add(entry);
    }

    return entries.toArray();
};

/**
 * Clear the Map object.
 * @method KEN.Map.clear
 */
KEN.Map.prototype.clear = function()
{
    for (var key in this._map)
    {
        this.delete(key);
    }
};

/**
 * Has an element into the Map?
 * @method KEN.Map.has
 * @param {string} key - The key to search for.
 * @return {boolean} Returns true if an item corresponding to the key is found, if not, returns false.
 */
KEN.Map.prototype.has = function(key)
{
    return (this._count > 0 && this._map[key] !== undefined);
};

/**
 * Get the size of the Map.
 * @name KEN.Map["size"]
 * @type {number}
 * @readonly
 */
KEN.Map.prototype.size;
Object.defineProperty(KEN.Map.prototype, "size",
{
    /** @this {KEN.Map} */
    get: function()
    {
        return this._count;
    }
});


/**
 * Describe a collection of elements.
 * @constructor KEN.Collection
 */
KEN.Collection = function() 
{
    /**
     * The elements list.
     * @name KEN.Collection#_elements
     * @type {Array<*>}
     * @private
     */
    this._elements = [];
};

KEN.Collection.prototype.constructor = KEN.Collection;

/**
 * Add an element of the list.
 * @method KEN.Collection.add
 * @param {*} item - The item to add.
 * @return {number} The size of the elements list.
 */
KEN.Collection.prototype.add = function(item)
{
    this._elements.push(item);
    return this._elements.length;
};

/**
 * Remove an element of the list.
 * @method KEN.Collection.remove
 * @param {*} item - The item to remove.
 */
KEN.Collection.prototype.remove = function(item) 
{
    for(var i = 0, ii = this._elements.length; i < ii; i++)
    {
        if(this._elements[i] === item)
        {
            this._elements.splice(i, 1);
        }
    }
};

/**
 * Get an element of the list.
 * @method KEN.Collection.get
 * @param {number} index - The element index to search for.
 * @return {*} Returns an element.
 */
KEN.Collection.prototype.get = function(index)
{
    return this._elements[index];
};

/**
 * Returns the elements list array.
 * @method KEN.Collection.toArray
 * @return {Array} Returns the elements list.
 */
KEN.Collection.prototype.toArray = function()
{
    return this._elements;
};

/**
 * Get the size of the elements list.
 * @name KEN.Collection["size"]
 * @type {number}
 * @readonly
 */
KEN.Collection.prototype.size;
Object.defineProperty(KEN.Collection.prototype, "size", 
{
    /** @this {KEN.Collection} */
    get: function()
    {
        return this._elements.length;
    }
});


/**
 * Utility for URL.
 * @constructor KEN.URL
 * @param {string=} url - The URL to use.
 * @extends {KEN.BaseObject}
 *
 * @todo  exists method is a POC
 */
KEN.URL = function(url)
{
    /**
     * The full URL.
     * @name KEN.URL#_url
     * @type {string|undefined}
     * @private
     */
    this._url = url;

    /**
     * The protocol of the URL (http or https).
     * @name KEN.URL#_protocol
     * @type {string}
     * @private
     */
    this._protocol = "";

    /**
     * The host for the URL.
     * @name KEN.URL#_host
     * @type {string}
     * @private
     */
    this._host = "";

    /**
     * The port used in the URL.
     * @name KEN.URL#_port
     * @type {string}
     * @private
     */
    this._port = "";

    /**
     * The path of the URL.
     * @name KEN.URL#_path
     * @type {string}
     * @private
     */
    this._path = "";

    /**
     * The query string of the URL.
     * @name KEN.URL#_query
     * @type {string}
     * @private
     */
    this._query = "";

    /**
     * The hash of the URL (slug name in there).
     * @name KEN.URL#_hash
     * @type {string}
     * @private
     */
    this._hash = "";

    /**
     * This object contains hash parameters key / value.
     * @name  KEN.URL#_hashParameters
     * @type {Object}
     * @private
     */
    this._hashParameters = null;

    /**
     * The extension of a file in URL.
     * @name KEN.URL#_extension
     * @type {string}
     * @private
     */
    this._extension = "";

    KEN.BaseObject.call(this, "URL");
};

KEN.URL.prototype = Object.create(KEN.BaseObject.prototype);
KEN.URL.prototype.constructor = KEN.URL;

/**
 * Parse the given URL.
 * @method  KEN.URL.parse
 * @param  {string=} url - The URL to parse.
 * @return {KEN.URL} Returns the a new KEN.URL with parsed data.
 */
KEN.URL.parse = function(url)
{
    var result = new KEN.URL();

    if(typeof url !== "string")
    {
        //throw "KEN.URL : Can't parse an undefined URL!";
        url = window.location.toString();
    }

    result._url = url;

    var a = document.createElement("a");
    a.href = result._url;

    result._protocol = a["protocol"];
    result._host = a.hostname;
    result._port = a["port"];
    result._path = a.pathname;
    result._query = a.search;
    result._hash = a["hash"];
    result._extension = result._path.substr(result._path.lastIndexOf(".") + 1);

    if(result._hash !== "")
    {
        var hash = result._hash.replace("#", "");
        var hashComponents = hash.split("&");

        var parameters = {};
        parameters["slug"] = hashComponents[0];

        for(var i = 1, ii = hashComponents.length; i < ii; i++)
        {
            var item = hashComponents[i].split("=");
            parameters[item[0]] = decodeURIComponent(item[1]);
        }

        result._hashParameters = parameters;
    }

    return result;
};



/**
 * Check if a given url exists.
 * Beware of cross domain, work only on the same domain.
 * @method  KEN.URL.exists
 * @param  {string} url - The URL to test.
 * @param  {Function} success - The callback to call when test is succeed.
 * @param  {Function} fail - The callback to call when test is failed.
 * @param  {Object} context - The context in which to call the callback.
 */
KEN.URL.exists = function(url, success, fail, context)
{
    var xhr = new XMLHttpRequest();
    var exists = false;
    var timeout = null;
    
    /** @this {XMLHttpRequest} */
    xhr.onreadystatechange = function() 
    {
        if(this.readyState === 4)
        {
            if(this.status === 200)
            {
                exists = true;
                clearTimeout(timeout);

                if(typeof success === "function")
                {
                    success.call(context); 
                }
                
            }  
        }
    };

    xhr.onerror = function(event)
    {
        console.log(event);
    };

    xhr.open("HEAD", url);
    xhr.send();

    var timeoutCallback = function()
    {
        if(typeof fail === "function")
        {
            fail.call(context); 
        }
        
    };

    timeout = window.setTimeout(timeoutCallback, 500);
};

/**
 * Check if a URL is valid. 
 * Works only for absolute URLs.
 * @method  KEN.URL.isValid
 * @param  {string} url - The URL to test.
 * @return {boolean} Returns true if URL is valid.
 */
KEN.URL.isValid = function(url)
{
    var urlRegEx = /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[\-;:&=\+\$,\w]+@)?[A-Za-z0-9\.\-]+|(?:www\.|[\-;:&=\+\$,\w]+@)[A-Za-z0-9\.\-]+)((?:\/[\+~%\/\.\w\-]*)?\??(?:[\-\+=&;%@\.\w]*)#?(?:[\.\!\/\\\w]*))?)/;
      
    if(!urlRegEx.test(url)) 
    {
        return false;
    }

    return true;
};

/**
 * Get the full URL.
 * @name KEN.URL#url
 * @readonly
 * @type {string}
 */
KEN.URL.prototype.url;
Object.defineProperty(KEN.URL.prototype, "url", 
{
    /** @this {KEN.URL} */
    get: function()
    {
        return this._url;
    }
});

/**
 * Get the protocol of the URL.
 * @name KEN.URL#protocol
 * @readonly
 * @type {string}
 */
KEN.URL.prototype.protocol;
Object.defineProperty(KEN.URL.prototype, "protocol", 
{
    /** @this {KEN.URL} */
    get: function()
    {
        return this._protocol;
    }
});

/**
 * Get the host of the URL.
 * @name KEN.URL#host
 * @readonly
 * @type {string}
 */
KEN.URL.prototype.host;
Object.defineProperty(KEN.URL.prototype, "host", 
{
    /** @this {KEN.URL} */
    get: function()
    {
        return this._host;
    }
});

/**
 * Get the port of the URL.
 * @name KEN.URL#port
 * @readonly
 * @type {string}
 */
KEN.URL.prototype.port;
Object.defineProperty(KEN.URL.prototype, "port", 
{
    /** @this {KEN.URL} */
    get: function()
    {
        return this._port;
    }
});

/**
 * Get the path of the URL.
 * @name KEN.URL#path
 * @readonly
 * @type {string}
 */
KEN.URL.prototype.path;
Object.defineProperty(KEN.URL.prototype, "path", 
{
    /** @this {KEN.URL} */
    get: function()
    {
        return this._path;
    }
});

/**
 * Get the query of the URL.
 * @name KEN.URL#query
 * @readonly
 * @type {string}
 */
KEN.URL.prototype.query;
Object.defineProperty(KEN.URL.prototype, "query", 
{
    /** @this {KEN.URL} */
    get: function()
    {
        return this._query;
    }
});

/**
 * Get the hash of the URL.
 * @name KEN.URL#hash
 * @readonly
 * @type {string}
 */
KEN.URL.prototype.hash;
Object.defineProperty(KEN.URL.prototype, "hash", 
{
    /** @this {KEN.URL} */
    get: function()
    {
        return this._hash;
    }
});

/**
 * Get the hash parameters of the URL.
 * @name KEN.URL#hashParameters
 * @readonly
 * @type {string}
 */
KEN.URL.prototype.hashParameters;
Object.defineProperty(KEN.URL.prototype, "hashParameters", 
{
    /** @this {KEN.URL} */
    get: function()
    {
        return this._hashParameters;
    }
});

/**
 * Get the extension of the URL.
 * @name KEN.URL#extension
 * @readonly
 * @type {string}
 */
KEN.URL.prototype.extension;
Object.defineProperty(KEN.URL.prototype, "extension", 
{
    /** @this {KEN.URL} */
    get: function()
    {
        return this._extension;
    }
});

/**
 * @namespace KEN.Color
 */
KEN.Color = {};

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.<br>
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 * @method KEN.Color.rgbToHsl
 * @param {number} r - The red color value.
 * @param {number} g - The green color value.
 * @param {number} b - The blue color value.
 * @return {Object} The HSL representation.
 */
KEN.Color.rgbToHsl = function(r, g, b)
{
    r /= 255;
    g /= 255;
    b /= 255;

    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if (max === min)
    {
        h = s = 0; // achromatic
    }
    else
    {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h:h, s:s, l:l };
};

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.<br>
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 * @method KEN.Color.hslToRgb
 * @param {number} h - The hue
 * @param {number} s - The saturation
 * @param {number} l - The lightness
 * @return {Object} The RGB representation
 */
KEN.Color.hslToRgb = function(h, s, l)
{
    var r, g, b;

    if (s === 0)
    {
        r = g = b = l; // achromatic
    }
    else
    {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;

        r = KEN.Color.hueToRgb(p, q, h + 1/3);
        g = KEN.Color.hueToRgb(p, q, h);
        b = KEN.Color.hueToRgb(p, q, h - 1/3);
    }

    return {r: r * 255, g: g * 255, b: b * 255};
};

/**
 * Convert hue to rgb.
 * @method KEN.Color.hueToRgb
 * @param  {number} p
 * @param  {number} q
 * @param  {number} t
 * @return {number}
 */
KEN.Color.hueToRgb = function(p, q, t)
{
    if (t < 0)
    {
        t += 1;
    }
    else if (t > 1)
    {
        t -= 1;
    }
    else if (t < 1 / 6)
    {
        return p + (q - p) * 6 * t;
    }
    else if (t < 1 / 2)
    {
        return q;
    }
    else if (t < 2 / 3)
    {
        return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
};

/**
 * Converts an RGB color value to HSV. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and v in the set [0, 1].
 * @method  KEN.Color.rgbToHsv
 * @param {number} r - The red color value.
 * @param {number} g - The green color value.
 * @param {number} b - The blue color value.
 * @return {Object} The HSV representation.
 */
KEN.Color.rgbToHsv = function(r, g, b)
{
    r /= 255;
    g /= 255;
    b /= 255;

    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if (max === min)
    {
        h = 0; // achromatic
    }
    else
    {
        switch (max)
        {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return {"h": h, "s": s, "v": v};
};

/**
 * Converts an HSV color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.<br>
 * Assumes h, s, and v are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 * @method  KEN.Color.hsvToRgb
 * @param {number} h - The hue
 * @param {number} s - The saturation
 * @param {number} v - The value
 * @return {Object} The RGB representation
 */
KEN.Color.hsvToRgb = function(h, s, v)
{
    var r, g, b;

    var i = Math.floor(h * 6);
    var f = h * 6 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);

    switch (i % 6)
    {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        case 5: r = v; g = p; b = q; break;
    }

    return {"r": r * 255, "g": g * 255, "b": b * 255};
};

/**
 * Convert a color component into hexa value.
 * @method KEN.Color.componentToHex
 * @param  {number} c - The color component to convert.
 * @return {string} The convert componenet into hex string.
 */
KEN.Color.componentToHex = function(c)
{
    var hex = c.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
};

/**
 * Convert rgb values into a css compatible hexadecimal string.
 * @method KEN.Color.regbToHex
 * @param {number} r - Red component.
 * @param {number} g - Green component.
 * @param {number} b - Blue component.
 * @return {string} Returns the hexadecimal string for the color.
 */
KEN.Color.rgbToHex = function(r, g, b)
{
    return "#" + KEN.Color.componentToHex(r) + KEN.Color.componentToHex(g) + KEN.Color.componentToHex(b);
};


/**
 * Convert rgba/rgb string into a four/three components object.
 * @method KEN.Color.fromRgbaString
 * @param {string} rgbaString - rgba/rgb string with format rgba(r,g,b,a)/rgb(r,g,b)
 * @return {Object} The rgb color in four/three components.
 */
KEN.Color.fromRgbaString = function(rgbaString)
{
    var rgba = rgbaString.split("(")[1].split(")")[0];
    var components = rgba.split(",");
    var color = {
        "r": components[0],
        "g": components[1],
        "b": components[2]
    };

    if (components.length > 3)
    {
        color.a = components[3];
    }

    return color;
};


/**
 * Convert hexadecimal color string to rgb components.
 * @method  KEN.Color.hexToRgb
 * @param  {string} hex - hexadecimal color string to convert.
 * @return {Object} The rgb color in three components.
 */
KEN.Color.hexToRgb = function(hex)
{
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function(m, r, g, b)
    {
        return r + r + g + g + b + b;
    });

    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        "r": parseInt(result[1], 16),
        "g": parseInt(result[2], 16),
        "b": parseInt(result[3], 16)
    } : null;
};

/**
 * Convert RGB into YCbCr color space
 * @method  KEN.Color.rgbToYcbcr
 * @param  {Object} color color in RGB space ([0 .. 255])
 * @return {Object} color in YCrCb space (Y,Cr,Cb [0 .. 255])
 */
KEN.Color.rgbToYcbcr = function(color)
{
    var c = new THREE.Vector3(color.r, color.g, color.b);

    //jscs:disable
    var mat = new THREE.Matrix3().set(
         0.299,  0.587, 0.114,
        -0.169, -0.331, 0.500,
         0.500, -0.419, -0.081
    );
    //jscs:enable

    var offset = new THREE.Vector3(0, 128, 128);

    c.applyMatrix3(mat).add(offset);

    return {
        Y: c.x,
        Cr: c.y,
        Cb: c.z
    };
};

/**
 * Convert YCbCr into RGB color space
 * @method  KEN.Color.ycbcrToRgb
 * @param {Object} color color in YCrCb space (Y,Cr,Cb [0 .. 255])
 * @return  {Object} color in RGB space ([0 .. 255])
 */
KEN.Color.ycbcrToRgb = function(color)
{
    var c = new THREE.Vector3(color.Y, color.Cr, color.Cb);

    var offset = new THREE.Vector3(0, -128, -128);

    //jscs:disable
    var mat = new THREE.Matrix3().set(
        1.000,  0.000,  1.400,
        1.000, -0.343, -0.711,
        1.000,  1.765,  0.000
    );
    //jscs:enable

    c.add(offset).applyMatrix3(mat);

    return {
        r: c.x,
        g: c.y,
        b: c.z
    };
};

/**
 * Rotate color in YCbCr color space
 * @method KEN.Color.ycbrcrRotate
 * @param {Object} color YCbCr color
 * @param {number} angle rotation angle (degrees)
 * @return  {Object} YCbCr rotated color
 */
KEN.Color.ycbrcrRotate = function(color, angle)
{
    var theta = KEN.Math.degToRad(angle);
    var c = Math.cos(theta), s = Math.sin(theta);

    return {
        Y: color.Y,
        Cb: color.Cb * c - color.Cr * s,
        Cr: color.Cb * s + color.Cr * c
    };
};

/**
 * Evaluate euclidian distance between two colors
 * @param  {Object} a 1st color in YCrCb colorspace
 * @param  {Object} b 2nd color in YCrCb colorspace
 * @return {number} distance
 */
KEN.Color.distance = function(a, b)
{
    return Math.sqrt((a.Cb - b.Cb) * (a.Cb - b.Cb) + (a.Cr - b.Cr) * (a.Cr - b.Cr));
};


/**
 * ColorRGBA Object
 * @constructor KEN.ColorRGBA
 * @param {number} r - Red channel
 * @param {number} g - Green channel
 * @param {number} b - Blue channel
 * @param {number} a - Alpha channel
 */
KEN.ColorRGBA = function(r, g, b, a)
{
    /**
     * Red channel
     * @name KEN.ColorRGBA#red
     * @type {number}
     */
    this.red = r;

    /**
     * Green channel
     * @name KEN.ColorRGBA#green
     * @type {number}
     */
    this.green = g;

    /**
     * Blue channel
     * @name KEN.ColorRGBA#blue
     * @type {number}
     */
    this.blue = b;

    /**
     * Alpha channel
     * @name KEN.ColorRGBA#alpha
     * @type {number}
     */
    this["alpha"] = a;
};